<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 6 章 面向对象（下） | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 6 章 面向对象（下）</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 6 章 面向对象（下）</h1><div class="post-meta">Jan 6, 2020<span> | </span><span class="category"><a href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Java-8-增强的包装类"><span class="toc-text">6.1 Java 8 增强的包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-处理对象"><span class="toc-text">6.2 处理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-打印对象的-toString-方法"><span class="toc-text">6.2.1 打印对象的 toString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-和-equals-方法"><span class="toc-text">6.2.2 ==和 equals 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-类成员"><span class="toc-text">6.3 类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-理解类成员"><span class="toc-text">6.3.1 理解类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-单例类"><span class="toc-text">6.3.2 单例类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-final-修饰符"><span class="toc-text">6.4 final 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-final-成员变量"><span class="toc-text">6.4.1 final 成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-final-局部变量"><span class="toc-text">6.4.2 final 局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-final-修饰基本类型变量和引用类型变量区别"><span class="toc-text">6.4.3  final 修饰基本类型变量和引用类型变量区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4-可执行-“宏替换”-的-final-变量"><span class="toc-text">6.4.4 可执行 “宏替换” 的 final 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5-final-方法"><span class="toc-text">6.4.5 final 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-6-final-类"><span class="toc-text">6.4.6 final 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-7-不可变类"><span class="toc-text">6.4.7 不可变类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-8-缓存实例的不可变类"><span class="toc-text">6.4.8 缓存实例的不可变类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-抽象类"><span class="toc-text">6.5 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-抽象方法和抽象类"><span class="toc-text">6.5.1 抽象方法和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-抽象类的作用"><span class="toc-text">6.5.2 抽象类的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Java-9-改进的接口"><span class="toc-text">6.6 Java 9 改进的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-接口的概念"><span class="toc-text">6.6.1 接口的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-Java-9-中接口的定义"><span class="toc-text">6.6.2 Java 9 中接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-接口的继承"><span class="toc-text">6.6.3 接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4-使用接口"><span class="toc-text">6.6.4 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5-接口和抽象类"><span class="toc-text">6.6.5 接口和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-6-面向接口编程"><span class="toc-text">6.6.6 面向接口编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-简单工厂模式"><span class="toc-text">1. 简单工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-命令模式"><span class="toc-text">2. 命令模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-内部类"><span class="toc-text">6.7 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-非静态内部类"><span class="toc-text">6.7.1 非静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-静态内部类"><span class="toc-text">6.7.2 静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-3-使用内部类"><span class="toc-text">6.7.3 使用内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-在外部类内部使用内部类"><span class="toc-text">1. 在外部类内部使用内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-在外部类以外使用非静态内部类"><span class="toc-text">2. 在外部类以外使用非静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-在外部类以外使用静态内部类"><span class="toc-text">3. 在外部类以外使用静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-4-局部内部类"><span class="toc-text">6.7.4 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-5-Java-8-改进的匿名内部类"><span class="toc-text">6.7.5 Java 8 改进的匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-Java-8-新增的-Lambda-表达式"><span class="toc-text">6.8 Java 8 新增的 Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-Lambda-表达式入门"><span class="toc-text">6.8.1  Lambda 表达式入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-2-Lambda-表达式与函数式接口"><span class="toc-text">6.8.2 Lambda 表达式与函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-3-方法引用与构造器引用"><span class="toc-text">6.8.3 方法引用与构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-引用类方法"><span class="toc-text">1. 引用类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-引用特定对象的实例方法"><span class="toc-text">2. 引用特定对象的实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-引用某类对象的实例方法"><span class="toc-text">3. 引用某类对象的实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-引用构造器"><span class="toc-text">4. 引用构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-4-Lambda-表达式与匿名内部类的联系和区别"><span class="toc-text">6.8.4 Lambda 表达式与匿名内部类的联系和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Lambda-表达式调用-Arrays-的类方法"><span class="toc-text">使用 Lambda 表达式调用 Arrays 的类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-枚举类"><span class="toc-text">6.9 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-1-手动实现枚举类"><span class="toc-text">6.9.1 手动实现枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-2-枚举类入门"><span class="toc-text">6.9.2 枚举类入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-3-枚举类的成员变量、方法和构造器"><span class="toc-text">6.9.3 枚举类的成员变量、方法和构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-4-实现接口的枚举类"><span class="toc-text">6.9.4 实现接口的枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-5-包含抽象方法的枚举类"><span class="toc-text">6.9.5 包含抽象方法的枚举类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-对象与垃圾回收"><span class="toc-text">6.10 对象与垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-对象在内存中的状态"><span class="toc-text">6.10.1 对象在内存中的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-强制垃圾回收"><span class="toc-text">6.10.2 强制垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-3-finalize-方法"><span class="toc-text">6.10.3 finalize 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-4-对象的软、弱和虚引用"><span class="toc-text">6.10.4 对象的软、弱和虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-修饰符的适用范围"><span class="toc-text">6.11 修饰符的适用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-Java-9-的多版本-JAR-包"><span class="toc-text">6.12 Java 9 的多版本 JAR 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-1-jar-命令详解"><span class="toc-text">6.12.1 jar 命令详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-2-创建可执行的-jar-包"><span class="toc-text">6.12.2 创建可执行的 jar 包</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 6 章 面向对象（下）</p>
<a id="more"></a>
<h2 id="6-1-Java-8-增强的包装类"><a href="#6-1-Java-8-增强的包装类" class="headerlink" title="6.1 Java 8 增强的包装类"></a>6.1 Java 8 增强的包装类</h2><p>Java 是面向对象的编程语言，但它包含 8 种基本数据类型，他们不具备“对象”的特征：没有成员变量、方法可以被调用。所有引用类型的变量都继承了 Object 类，都可当成 Object 类型变量使用。但基本数据类型的变量不可以，如果有个方法需要 Object 类型的参数，但实际需要的值却是 2、3 等数值，这可能比较难处理。</p>
<p>为了解决 8 种基本数据类型的变量不能当成 Object 类型变量使用的问题，Java 提供了包装类的概念，为 8 种基本数据类型分别定义了相应的引用类型。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<p>JDK 1.5 以前，基本类型和包装类之间的转换：</p>
<p><img src="../../images/java/c6/c61_基本类和包装类转换.png" alt=""></p>
<p>JDK 1.5 开始，提供<strong>自动装箱</strong>和<strong>自动拆箱</strong>功能。</p>
<p><strong>自动装箱</strong>， 就是可以把一个基本类型变量直接赋给对应的包装类变量， 或者赋给 Object 变量。</p>
<p>自动拆箱则与之相反，允许直接把包装类对象直接赋给一个对应的基本类型变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoBoxingUnboxing</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 自动装箱，直接把一个基本类型变量赋值给 Integer 对象</span></div><div class="line">        Integer inObj = <span class="number">5</span>;</div><div class="line">        <span class="comment">// 自动装箱，直接把一个 boolean 类型变量赋值给一个 Object 类型变量</span></div><div class="line">        Object boolObj = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 自动拆箱，直接把一个 Integer 对象赋给 int 类型的变量</span></div><div class="line">        <span class="keyword">int</span> it = inObj;</div><div class="line">        <span class="keyword">if</span>(boolObj <span class="keyword">instanceof</span> Boolean)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">boolean</span> b = (Boolean)boolObj;</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本类和字符串转换</p>
<p><img src="../../images/java/c6/c61_基本类和字符串转换.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Primitive2String</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String intStr = <span class="string">"123"</span>;</div><div class="line">        <span class="comment">// 字符串转int</span></div><div class="line">        <span class="keyword">int</span> it1 = Integer.parseInt(intStr);</div><div class="line">        <span class="keyword">int</span> it2 = Integer.valueOf(intStr);</div><div class="line">        System.out.println(it2);</div><div class="line">        String floatStr = <span class="string">"4.56"</span>;</div><div class="line">        <span class="comment">// 字符串转float</span></div><div class="line">        <span class="keyword">float</span> ft1 = Float.parseFloat(floatStr);</div><div class="line">        <span class="keyword">float</span> ft2 = Float.valueOf(floatStr);</div><div class="line">        System.out.println(ft2);</div><div class="line"></div><div class="line">        <span class="comment">// float转string</span></div><div class="line">        String ftStr = String.valueOf(<span class="number">2.345f</span>);</div><div class="line">        <span class="comment">// double转string</span></div><div class="line">        String dbStr = String.valueOf(<span class="number">3.345</span>);</div><div class="line">        <span class="comment">// boolean转String</span></div><div class="line">        String boolStr = String.valueOf(<span class="keyword">true</span>);</div><div class="line">        System.out.println(boolStr.toUpperCase());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperClassCompare</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 虽然包装类型变量是引用数据类型，但包装类的实例可以与数值类型的值进行比较</span></div><div class="line">        Integer a = Integer.valueOf(<span class="number">6</span>);</div><div class="line">        System.out.println(<span class="string">"6的包装类实例是否大于5.0："</span> + (a &gt; <span class="number">5.0</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 两个包装类的实例进行比较的情况比较复杂，因为包装类的实例实际上是引用类型，只有两个包装类的引用</span></div><div class="line">        <span class="comment">// 指向同一个对象时才会返回 true</span></div><div class="line">        System.out.println(<span class="string">"比较两个包装类的实例是否想等："</span> + (Integer.valueOf(<span class="number">2</span>) == Integer.valueOf(<span class="number">2</span>)));</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"比较两个包装类的实例是否想等(127)："</span> + (Integer.valueOf(<span class="number">127</span>) == Integer.valueOf(<span class="number">127</span>)));</div><div class="line">        System.out.println(<span class="string">"比较两个包装类的实例是否想等(128)："</span> + (Integer.valueOf(<span class="number">128</span>) == Integer.valueOf(<span class="number">128</span>)));</div><div class="line">        <span class="comment">// 结果不同和 Integer 的设计有关，Integer 把 -128~127 之间的整数自动装箱成 Integer 实例， 并放入了一个名为 cache 的数组中缓存起来</span></div><div class="line">        <span class="comment">// 不在 -128~127之间的整数自动装箱为Integer时，系统会新建一个Integer实例</span></div><div class="line"></div><div class="line">        <span class="comment">// Java7 为所有的包装类都提供了一个静态的 compare 方法，用于比较两个基本类型的大小</span></div><div class="line">        System.out.println(<span class="string">"========================包装类静态compare方法========================"</span>);</div><div class="line">        System.out.println(Boolean.compare(<span class="keyword">true</span>, <span class="keyword">false</span>));</div><div class="line">        System.out.println(Boolean.compare(<span class="keyword">false</span>, <span class="keyword">false</span>));</div><div class="line"></div><div class="line">        System.out.println(Double.compare(<span class="number">3.14</span>, <span class="number">3.15</span>));</div><div class="line">        System.out.println(Double.compare(<span class="number">3.14</span>, <span class="number">3.14</span>));</div><div class="line"></div><div class="line">        <span class="comment">// Character 提供了很多字符相关的工具方法，详见 API</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsignedTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> b = -<span class="number">3</span>;</div><div class="line">        System.out.println(<span class="string">"byte 类型的 -3 对应的无符号整数："</span> + Byte.toUnsignedInt(b));</div><div class="line">        System.out.println(<span class="string">"指定使用 16 进制解析无符号整数："</span> + Integer.parseUnsignedInt(<span class="string">"ab"</span>, <span class="number">16</span>));</div><div class="line">        <span class="comment">// 将 -12 转换为无符号 int 型，然后转换为十六进制的字符串</span></div><div class="line">        System.out.println(Integer.toUnsignedString(-<span class="number">12</span>, <span class="number">16</span>));</div><div class="line">        System.out.println(Integer.divideUnsigned(-<span class="number">2</span>, <span class="number">3</span>));</div><div class="line">        System.out.println(Integer.remainderUnsigned(-<span class="number">2</span>, <span class="number">7</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-2-处理对象"><a href="#6-2-处理对象" class="headerlink" title="6.2 处理对象"></a>6.2 处理对象</h2><h3 id="6-2-1-打印对象的-toString-方法"><a href="#6-2-1-打印对象的-toString-方法" class="headerlink" title="6.2.1 打印对象的 toString 方法"></a>6.2.1 打印对象的 toString 方法</h3><p>Object 类提供的 toString() 方法总是返回该对象实现类的”类名+@+ hashCode “ 值，这个返回值并不能真正实现”自我描述”的功能，因此如果用户需要自定义类能实现”自我描述”的功能，就必须重写 Object 类的toString() 方法。</p>
<h3 id="6-2-2-和-equals-方法"><a href="#6-2-2-和-equals-方法" class="headerlink" title="6.2.2 ==和 equals 方法"></a>6.2.2 ==和 equals 方法</h3><p>​    <code>==</code> 用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不一定要求数据类型严格相同) ，则只要两个变量的值相等，就将返回 true 。</p>
<p>但对于两个引用类型变量，只有它们指向同一个对象时，<code>==</code> 判断才会返回 true，<code>==</code> 不可用于比较类型上没有父子关系的两个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> it = <span class="number">65</span>;</div><div class="line">        <span class="keyword">float</span> fl = <span class="number">65.0f</span>;</div><div class="line">        <span class="comment">// true</span></div><div class="line">        System.out.println(<span class="string">"65和65.0f是否相等？"</span> + (it == fl));</div><div class="line">        <span class="keyword">char</span> ch = <span class="string">'A'</span>;</div><div class="line">        <span class="comment">// true</span></div><div class="line">        System.out.println(<span class="string">"65和'A是否相等？"</span> + (it == ch));</div><div class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</div><div class="line">        <span class="comment">// false</span></div><div class="line">        System.out.println(<span class="string">"str1 和 str2 是否相等？"</span></div><div class="line">            + (str1 == str2));</div><div class="line">        <span class="comment">// true</span></div><div class="line">        System.out.println(<span class="string">"str1 是否 equals str2？"</span></div><div class="line">            + (str1.equals(str2)));</div><div class="line">        <span class="comment">// String 与 EqualTest 类没有继承关系，编译报错</span></div><div class="line">        <span class="comment">// System.out.println("hello" == new EqualTest());</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“hello” 直接量和 new Sting(“hello”) 有什么区别呢？当 Java 程序直接使用形如 “hello” 的字符串直接量( 包括可以在编译时就计算出来的字符串值)时， JVM 将会使用常量池来管理这些字符串；当使用new String(“hello”) 时， JVM 会先使用常量池来管理”hello”直接量，再调用 String 类的构造器来创建一个新的String 对象，新创建的 String 对象被保存在堆内存中。换句话说， new String(“hello”)一共产生了两个字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCompareTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// s1 直接引用常量池中的"疯狂Java"</span></div><div class="line">        String s1 = <span class="string">"疯狂Java"</span>;</div><div class="line">        String s2 = <span class="string">"疯狂"</span>;</div><div class="line">        String s3 = <span class="string">"Java"</span>;</div><div class="line">        <span class="comment">// s4 可以在编译时就确定下来，直接引用常量池</span></div><div class="line">        String s4 = <span class="string">"疯狂"</span> + <span class="string">"Java"</span>;</div><div class="line">        <span class="comment">// 同上</span></div><div class="line">        String s5 = <span class="string">"疯"</span> + <span class="string">"狂"</span> + <span class="string">"Java"</span>;</div><div class="line">        <span class="comment">// 编译时无法确定，不能引用常量池</span></div><div class="line">        String s6 = s2 + s3;</div><div class="line">        <span class="comment">// 使用new调用构造器会创建一个新的String对象</span></div><div class="line">        <span class="comment">// s7引用堆内存中新创建的String对象</span></div><div class="line">        String s7 = <span class="keyword">new</span> String(<span class="string">"疯狂Java"</span>);</div><div class="line">        System.out.println(s1 == s4);</div><div class="line">        System.out.println(s1 == s5);</div><div class="line">        System.out.println(s1 == s6);</div><div class="line">        System.out.println(s1 == s7);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-3-类成员"><a href="#6-3-类成员" class="headerlink" title="6.3 类成员"></a>6.3 类成员</h2><h3 id="6-3-1-理解类成员"><a href="#6-3-1-理解类成员" class="headerlink" title="6.3.1 理解类成员"></a>6.3.1 理解类成员</h3><p>类方法也是类成员的一种，类方法也是属于类的，通常直接使用类作为调用者来调用类方法，但也可以使用对象来调用类方法。与类变量类似，即使使用对象来调用类方法，其效果也与采用类来调用类方法完全一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullAccessStatic</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"static 修饰的类方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        NullAccessStatic nas = <span class="keyword">null</span>;</div><div class="line">        nas.test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译、运行上面程序， 一切正常，程序将打印出” static 修饰的类方法”宇符串，这表明 null 对象可以访问它所属类的类成员。</p>
<p>对 static 关键宇而言，有一条非常重要的规则：类成员( 包括方法、初始化块、内部类和枚举类)不能访问实例成员(包括成员变量、方法、初始化块、内部类和枚举类) 。</p>
<h3 id="6-3-2-单例类"><a href="#6-3-2-单例类" class="headerlink" title="6.3.2 单例类"></a>6.3.2 单例类</h3><p>如果一个类始终只能创建一个实例，则会个类被成为单例类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">// 使用一个类变量来缓存曾经创建的实例</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="comment">// 隐藏构造器</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">// 提供一个静态方法，返回Singleton对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Singleton s1 = Singleton.getInstance();</div><div class="line">        Singleton s2 = Singleton.getInstance();</div><div class="line">        System.out.println(s1 == s2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-4-final-修饰符"><a href="#6-4-final-修饰符" class="headerlink" title="6.4 final 修饰符"></a>6.4 final 修饰符</h2><p>final 关键字可用于修饰类、变量和方法。</p>
<p>final 修饰变量时，表示该变量一旦获得了初始值就不可被改变， final 既可以修饰成员变量( 包括类变量和实例变量)， 也可以修饰局部变量、形参。有的书上介绍说 final 修饰的变量不能被赋值，这种说法是错误的。严格的说法是， final 修饰的变量<strong>不可被改变</strong>， 一旦获得了初始值， 该 final 变量的值就不能被重新赋值。</p>
<h3 id="6-4-1-final-成员变量"><a href="#6-4-1-final-成员变量" class="headerlink" title="6.4.1 final 成员变量"></a>6.4.1 final 成员变量</h3><p>理解成员变量：</p>
<p>成员变量是随类初始化或对象初始化而初始化的。当类初始化时，系统会为该类的类变量分配内存，<strong>并分配默认值</strong>；当创建对象时，系统会为该对象的实例变量分配内存，<strong>并分配默认值</strong>。</p>
<p>也就是说，当执行<strong>静态初始化块</strong>时可以对<strong>类变量</strong>赋初始值；当执行<strong>普通初始化块、构造器</strong>时可对<strong>实例变量</strong>赋初始值。</p>
<p>类变量（static）和实例变量理解 ：</p>
<p><a href="https://blog.csdn.net/caigen0001/article/details/89676253" target="_blank" rel="external">https://blog.csdn.net/caigen0001/article/details/89676253</a></p>
<p>简单的说，有 static 修饰的就是类变量（静态变量）。使用时直接用类调用即可，不用创建对象。</p>
<p>理解 final 修饰的成员变量：</p>
<p>对于 final 修饰的成员变量而言，一旦有了初始值，就不能被重新赋值，如果既没有在定义成员变量时指定初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值将一直是系统默认分配的 0 、’\u0000’ 、false 或 null ， 这些成员变量也就完全失去了存在的意义。因此 Java 语法规定: <strong>final 修饰的成员变量必须由程序员显式地指定初始值。并且不能重新赋值。</strong></p>
<p>例如：如果在初始化块中初始化了 final 的值，那么就不能在构造器中初始化了。</p>
<p>类变量和实例变量赋值：</p>
<ul>
<li>类变量：只能在静态初始化块或者声明该类时指定值</li>
<li>实例变量：只能在非静态初始化块、声明该类或者构造器中指定初始值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实例变量，声明时分配了初始值，合法</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">6</span>;</div><div class="line"><span class="comment">// 实例变量，在普通初始化块中分配了初始值，合法</span></div><div class="line"><span class="keyword">final</span> String str;</div><div class="line">&#123;</div><div class="line">    str = <span class="string">"Hello"</span>;</div><div class="line">    <span class="comment">// 实例变量 a 已经分配初始值，不可重新赋值，不合法</span></div><div class="line">    <span class="comment">// a = 9;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 实例变量，在构造器中分配了初始值，合法</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> c;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalVariableTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// str 已经分配初始值，不可重新赋值，不合法</span></div><div class="line">    <span class="comment">// str = "java";</span></div><div class="line">    c = <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 类变量，在静态初始化块中分配了初始值，合法</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> d;</div><div class="line"><span class="keyword">static</span></div><div class="line">&#123;</div><div class="line">    d = <span class="number">5.6</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实例变量，在声明时、初始化块中、构造器中均没有分配初始值，不合法</span></div><div class="line"><span class="comment">// final char ch;</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFinal</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 普通方法不能为 final 修饰的成员变量（实例变量、类变量）赋值</span></div><div class="line">    <span class="comment">// d = 1.2;</span></div><div class="line">    <span class="comment">// ch = 'a';</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>成员变量包含：实例变量、类变量</li>
<li>成员变量赋值的位置：声明变量时、初始化块（普通、静态块）、构造函数（仅实例变量）</li>
<li>普通成员变量：如果没有赋初始值，系统会给默认值</li>
<li>final 成员变量：Java 规定必须显示指定初始值</li>
</ol>
<p>如果打算在构造器、初始化块中对 final 成员变量进行初始化，则不要在初始化之前直接访问 final 成员变量;但 Java 又允许通过方法来访问 final 成员变量，此时会看到系统将 final 成员变量默认初始化为0(或’\u0000’ 、false 或 null) 。基本上可断定是 Java 设计的一个缺陷，应该避免在 final 变量初始化之前访问它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinaIErrorTest</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义 final 修饰的实例变量 age</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="comment">// 定义普通初始化块，用来初始化 age 的值</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 此时 age 还没有初始化，不可以直接访问成员变量</span></div><div class="line">        <span class="comment">// System.out.println(age);</span></div><div class="line">        <span class="comment">// 此时 age 还没有初始化，但是可以通过方法访问成员变量，值为0</span></div><div class="line">        printAge();</div><div class="line">        age = <span class="number">6</span>;</div><div class="line">        System.out.println(age);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(age);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果去掉 final 修饰，那么上面代码完全没问题。否则会报错。</p>
<h3 id="6-4-2-final-局部变量"><a href="#6-4-2-final-局部变量" class="headerlink" title="6.4.2 final 局部变量"></a>6.4.2 final 局部变量</h3><p>系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。因此使用 final 修饰局部变量时， <strong>既可以在定义时指定默认值，也可以不指定默认值。</strong></p>
<p>如果 final 修饰的局部变量在定义时没有指定默认值，则可以在后面代码中对该 final 变量赋初始值，但只能一次，不能重复赋值; </p>
<p>如果 final 修饰的局部变量在定义时己经指定默认值，则后面代码中不能再对该变量赋值。</p>
<p>因为形参在调用该方法时，由系统根据传入的参数来完成初始化，因此使用 final 修饰的形参不能被赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalLocalVariableTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 不能对 final 形参赋值，非法</span></div><div class="line">        <span class="comment">// a = 5;</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 局部变量，定义时赋初始值</span></div><div class="line">        <span class="keyword">final</span> String str = <span class="string">"hello"</span>;</div><div class="line">        <span class="comment">// 局部变量，str 已经赋值，非法</span></div><div class="line">        <span class="comment">// str = "Java";</span></div><div class="line">        <span class="comment">// 局部变量，定义没有赋初始值</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">double</span> d;</div><div class="line">        <span class="comment">// 局部变量，可以赋值一次</span></div><div class="line">        d = <span class="number">5.6</span>;</div><div class="line">        <span class="comment">// 局部变量，d 已经赋值，非法</span></div><div class="line">        <span class="comment">// d = 3.4;</span></div><div class="line">        <span class="comment">// 普通局部变量，可以多次赋值</span></div><div class="line">        <span class="keyword">double</span> e;</div><div class="line">        e = <span class="number">1</span>;</div><div class="line">        e = <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>系统不会对局部变量赋初始值，所以局部变量必须赋初始值，不管是否有 final</li>
<li>局部变量赋值位置：定义局部变量时、定义之后赋值</li>
<li>final 局部变量和普通局部变量区别：final 局部变量只可以赋值一次</li>
</ol>
<h3 id="6-4-3-final-修饰基本类型变量和引用类型变量区别"><a href="#6-4-3-final-修饰基本类型变量和引用类型变量区别" class="headerlink" title="6.4.3  final 修饰基本类型变量和引用类型变量区别"></a>6.4.3  final 修饰基本类型变量和引用类型变量区别</h3><p>当使用 final 修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用， final 只保证这个引用类型变量所引用的<strong>地址不会改变</strong>， 即一直引用同一个对象，但这个对象完全可以发生改变。</p>
<p><strong>简单的说，final 修饰的应用变量可以改变应用变量的内容，但是不可以重新赋值，改变引用的地址。</strong></p>
<h3 id="6-4-4-可执行-“宏替换”-的-final-变量"><a href="#6-4-4-可执行-“宏替换”-的-final-变量" class="headerlink" title="6.4.4 可执行 “宏替换” 的 final 变量"></a>6.4.4 可执行 “宏替换” 的 final 变量</h3><p>final 修饰符的一个重要用途就是定义”宏变量”。</p>
<p>对一个final 变量来说，不管它是类变量、实例变量，还是局部变量，只要该变量满足三个条件，这个final 变量就不再是一个变量，而是相当于一个直接量。</p>
<ul>
<li>使用 final 修饰符修饰</li>
<li>在<strong>定义</strong>该 final 变量时指定了初始值</li>
<li>该初始值在编译时就被确定下来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 宏变量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">2</span>;</div><div class="line">    <span class="comment">// 宏变量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">double</span> b = <span class="number">1.2</span>/<span class="number">5</span>;</div><div class="line">    <span class="comment">// 宏变量</span></div><div class="line">    <span class="keyword">final</span> String str = <span class="string">"疯狂"</span> + <span class="string">"Java"</span>;</div><div class="line">    <span class="comment">// 宏变量</span></div><div class="line">    <span class="keyword">final</span> String book = <span class="string">"疯狂 Java 讲义："</span> + <span class="number">99.0</span>;</div><div class="line">    <span class="comment">// 调用了方法，无法在编译时确定，所以不是宏变量</span></div><div class="line">    <span class="keyword">final</span> String book2 = <span class="string">"疯狂 Java 讲义："</span> + String.valueOf(<span class="number">99.0</span>);</div><div class="line">    System.out.println(book == <span class="string">"疯狂 Java 讲义：99.0"</span>); <span class="comment">// true</span></div><div class="line">    System.out.println(book2 == <span class="string">"疯狂 Java 讲义：99.0"</span>);<span class="comment">// false</span></div><div class="line">    </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">5</span>;</div><div class="line">    <span class="comment">// 对于程序来说，变量 c 其实根本不存在。实际执行的代码被转换为 println(5)</span></div><div class="line">    System.out.println(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 会使用<strong>常量池</strong>来管理曾经用过的字符串直接量，例如执行 String a = “java”；语句之后，常量池中就会缓存一个字符串”java”；如果程序再次执行String b = “java”；系统将会让 b 直接指向常量池中的”java”字符串，因此 a == b 将会返回 true。</p>
<p>进一步理解 final 宏替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    String s1 = <span class="string">"疯狂Java"</span>;</div><div class="line">    <span class="comment">// 编译时就可以确认，所以 s2 直接引用常量池中已有的"疯狂Java"字符串</span></div><div class="line">    String s2 = <span class="string">"疯狂"</span> + <span class="string">"Java"</span>;</div><div class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></div><div class="line">    String str1 = <span class="string">"疯狂"</span>;</div><div class="line">    String str2 = <span class="string">"Java"</span>;</div><div class="line">    <span class="comment">// str1、str2 只是两个普通变量，编译器不会进行“宏替换”，因此编译器无法在编译时确定 s3 的值</span></div><div class="line">    String s3 = str1 + str2;</div><div class="line">    System.out.println(s1 == s3); <span class="comment">// false</span></div><div class="line">    <span class="comment">// 所以要使得 s1 == s3 只需，str1、str2 用 final 修饰即可</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：对于实例变量，三个地方赋初始值效果一样。但对于 final 实例变量而言，只有在<strong>定义</strong>该变量时指定初始值才会有”宏变量”的效果。final 局部变量也是一样。</p>
<h3 id="6-4-5-final-方法"><a href="#6-4-5-final-方法" class="headerlink" title="6.4.5 final 方法"></a>6.4.5 final 方法</h3><p>final 修饰的方法不可被重写，如果出于某些原因，<strong>不希望子类重写父类的某个方法</strong>，则可以使用 final 修饰该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateFinalMethodTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span>  <span class="title">PrivateFinalMethodTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 合法，只是定义了一个新方法，不是重写父类方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">    <span class="comment">// 非法</span></div><div class="line">    <span class="comment">// public void test2()&#123;&#125;;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于一个 private 方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法。所以如果子类中定义一个与父类 private 方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。</p>
<p>final 修饰发方法，只是不能被重写，但是可以重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalOverload</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">// final 修饰的方法，只是不能被重写，而不是不能被重载。合法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String org)</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-4-6-final-类"><a href="#6-4-6-final-类" class="headerlink" title="6.4.6 final 类"></a>6.4.6 final 类</h3><p>final 修饰的类不可以有子类， 例如 java.1ang.Math 类就是一个 final 类，它不可以有子类。如 Math 类。</p>
<p>当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用 final 修饰这个类。</p>
<h3 id="6-4-7-不可变类"><a href="#6-4-7-不可变类" class="headerlink" title="6.4.7 不可变类"></a>6.4.7 不可变类</h3><p>不可变( immutable ) 类的意思是创建该<strong>类的实例</strong>后， 该实例的实例变量是不可改变的。</p>
<p>Java 提供的8 个包装类和 java.lang.String 类都是不可变类。</p>
<p>创建自定义的不可变类规则：</p>
<ul>
<li>使用 private 和 final 修饰符来修饰该类的成员变量。</li>
<li>提供带参数构造器，用于根据传入参数来初始化类里的成员变量。</li>
<li>仅为该类的成员变量提供 getter 方法，不要为该类的成员变量提供 setter 方法，因为普通方法无法修改final 修饰的成员变量。</li>
<li>如果有必要，重写 Object 类的 hashCode() 和 equals() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 使用 private 和 final 修饰符来修饰该类的成员变量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String detail;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String postCode;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.detail = <span class="string">""</span>;</div><div class="line">        <span class="keyword">this</span>.postCode = <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 提供带参数构造器，用于根据传入参数来初始化类里的成员变量</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String detail, String postCode)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.detail = detail;</div><div class="line">        <span class="keyword">this</span>.postCode = postCode;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 仅为该类的成员变量提供 getter 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDetail</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> detail;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPostCode</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> postCode;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重写 equals() 方法，判断两个对象是否相等</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Address.class)</div><div class="line">        &#123;</div><div class="line">            Address address = (Address)obj;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getDetail().equals(address.getDetail())</div><div class="line">                &amp;&amp; <span class="keyword">this</span>.getPostCode().equals(address.getPostCode()))</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> detail.hashCode() + postCode.hashCode() * <span class="number">31</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：当使用 final 修饰引用类型变量时，仅表示这个引用类型变量不可被重新赋值，但<strong>引用类型变量所指向的对象</strong>依然可改变。所以成员变量和 get 方法需要特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Address address;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Address address)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 设置新对象，防止 Person 类的 address 成员变量被改</span></div><div class="line">        <span class="keyword">this</span>.address = <span class="keyword">new</span> Address(address.getDetail(), address.getPostCode());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 返回新对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Address(address.getDetail(), address.getPostCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-4-8-缓存实例的不可变类"><a href="#6-4-8-缓存实例的不可变类" class="headerlink" title="6.4.8 缓存实例的不可变类"></a>6.4.8 缓存实例的不可变类</h3><p>不可变类的实例状态不可改变，可以很方便地被多个对象所共享。如果程序经常需要使用相同的不可变类实例，则应该考虑缓存这种不可变类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cachelmmutale</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE=<span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cachelmmutale[] cache = <span class="keyword">new</span> Cachelmmutale[MAX_SIZE];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">// 隐藏构造器，使得只能使用 valueOf 方法来创建实例</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cachelmmutale</span><span class="params">(String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cachelmmutale <span class="title">valueOf</span><span class="params">(String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(cache[i] != <span class="keyword">null</span> &amp;&amp; cache[i].getName().equals(name))</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> cache[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(pos == MAX_SIZE)</div><div class="line">        &#123;</div><div class="line">            cache[<span class="number">0</span>] = <span class="keyword">new</span> Cachelmmutale(name);</div><div class="line">            pos = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            cache[pos++] = <span class="keyword">new</span> Cachelmmutale(name);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 走到这里，肯定是新对象，存到了缓存，然后pos+1</span></div><div class="line">        <span class="keyword">return</span> cache[pos - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Cachelmmutale.class)</div><div class="line">        &#123;</div><div class="line">            Cachelmmutale ci = (Cachelmmutale)obj;</div><div class="line">            <span class="keyword">return</span> name.equals(ci.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> name.hashCode();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachelmmutaleTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        Cachelmmutale c1 = Cachelmmutale.valueOf(<span class="string">"hello"</span>);</div><div class="line">        Cachelmmutale c2 = Cachelmmutale.valueOf(<span class="string">"hello"</span>);</div><div class="line">        System.out.println(c1 == c2); <span class="comment">// true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 提供的 java.lang .lnteger 类，采用了与 Cachelmmutale 类相同的处理策略。</p>
<h2 id="6-5-抽象类"><a href="#6-5-抽象类" class="headerlink" title="6.5 抽象类"></a>6.5 抽象类</h2><h3 id="6-5-1-抽象方法和抽象类"><a href="#6-5-1-抽象方法和抽象类" class="headerlink" title="6.5.1 抽象方法和抽象类"></a>6.5.1 抽象方法和抽象类</h3><ul>
<li>抽象方法、抽象类使用 abstract 修饰符来修饰，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，无法 new 出实例。</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接口、枚举）5 种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</li>
<li>含有抽象方法的类（直接定义了一个抽象方法；继承了一个抽象父类，但没有完全实现父类包含的抽象方法；实现了一个接口，但没有完全实现接口包含的抽象方法）只能被定义为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"执行 Shape 的初始化块..."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> String color;</div><div class="line">    <span class="comment">// 定义一个计算周长的抽象方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 定义一个返回形状的抽象方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getType</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 定义构造器，用于被子类调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(String color)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行 Shape 的构造器..."</span>);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义三角形三边</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> a;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> b;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> c;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span><span class="params">(String color, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 调用父类构造器</span></div><div class="line">        <span class="keyword">super</span>(color);</div><div class="line">        <span class="keyword">this</span>.setSides(a,b,c);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSides</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(a &gt;= b+c || b &gt;= a+c || c &gt;= a+b)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"三角形两边之和必须大于第三边"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.a = a;</div><div class="line">        <span class="keyword">this</span>.b = b;</div><div class="line">        <span class="keyword">this</span>.c = c;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a + b + c;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"三角形"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Shape s1 = <span class="keyword">new</span> Triangle(<span class="string">"黑色"</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line">        System.out.println(s1.getType());</div><div class="line">        System.out.println(s1.calPerimeter());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 Triangle 类继承了 Shape 抽象类，并实现了 Shape 类中两个抽象方法，是一个普通类，因此可以创建Triangle 类的实例，可以让一个 Shape 类型的引用变量指向 Triangle 对象。</p>
<p>利用抽象类和抽象方法的优势，可以更好地发挥多态的优势，使得程序更加灵活。</p>
<p>final 和 abstract 永远不能同时使用。static 和 abstract 不能同时修饰某个方法，即没有所谓的类抽象方法。private 和 abstract 不能同时修饰方法。</p>
<h3 id="6-5-2-抽象类的作用"><a href="#6-5-2-抽象类的作用" class="headerlink" title="6.5.2 抽象类的作用"></a>6.5.2 抽象类的作用</h3><p>模板模式：父类的普通方法依赖于一个抽象方法，而抽象方法则推迟到子类中提供实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpeedMeter</span> </span>&#123;</div><div class="line">    <span class="comment">// 转速</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> turnRate;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpeedMeter</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">// 把计算车轮周长的方法定义成抽象方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calGirth</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTurnRate</span><span class="params">(<span class="keyword">double</span> turnRate)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.turnRate = turnRate;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义计算速度的通用算法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 速度等于 周长 * 转速</span></div><div class="line">        <span class="keyword">return</span> calGirth() * turnRate;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarSpeedMeter</span> <span class="keyword">extends</span> <span class="title">SpeedMeter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarSpeedMeter</span><span class="params">(<span class="keyword">double</span> radius)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calGirth</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span>  radius * <span class="number">2</span> * Math.PI;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CarSpeedMeter csm = <span class="keyword">new</span> CarSpeedMeter(<span class="number">0.34</span>);</div><div class="line">        csm.setTurnRate(<span class="number">15</span>);</div><div class="line">        System.out.println(csm.getSpeed());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpeedMeter 类里提供了速度表的通用算法，但一些具体的实现细节则推迟到其子类 CarSpeedMeter 类中实现。这也是一种典型的模板模式。</p>
<p>模板模式规则：</p>
<ul>
<li>抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给子类实现。</li>
<li>父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而必须依赖于其子类的辅助。</li>
</ul>
<h2 id="6-6-Java-9-改进的接口"><a href="#6-6-Java-9-改进的接口" class="headerlink" title="6.6 Java 9 改进的接口"></a>6.6 Java 9 改进的接口</h2><h3 id="6-6-1-接口的概念"><a href="#6-6-1-接口的概念" class="headerlink" title="6.6.1 接口的概念"></a>6.6.1 接口的概念</h3><p>接口是从多个相似类中抽象出来的规范，接口不提供任何实现。接口体现的是规范和实现分离的设计哲学。</p>
<p>让规范和实现分离正是接口的好处，让软件系统的各组件之间面向接口搞合，是一种松藕合的设计。</p>
<h3 id="6-6-2-Java-9-中接口的定义"><a href="#6-6-2-Java-9-中接口的定义" class="headerlink" title="6.6.2 Java 9 中接口的定义"></a>6.6.2 Java 9 中接口的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[修饰符] <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1，父接口2...</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    零个到多个常量定义...</div><div class="line">    零个到多个抽象方法定义...</div><div class="line">    零个到多个内部类、接口、枚举定义...</div><div class="line">    零个到多个私有方法（java9）、默认方法（java8）或类方法（java8）定义...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修饰符可以是 public 或者省略，如果省略则默认采用包权限访问控制符</li>
</ul>
<p>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量(只能是<strong>静态常量</strong>)、方法(只能是抽象实例方法、类方法、默认方法或私有方法)、内部类(包括内部接口、枚举)定义。</p>
<p>私有方法可以使用 static 修饰，也就是说，私有方法既可是类方法，也可是实例方法。</p>
<p>对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static 和 final 两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用 <strong>public static final</strong> 修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。</p>
<p>定义接口里的普通方法时不管是否使用 <strong>public abstract</strong> 修饰符，接口里的普通方法总是使用 public abstract 来修饰。接口里的普通方法不能有方法实现(方法体)；但类方法、默认方法、私有方法都必须有方法实现(方法体〉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Output</span> </span>&#123;</div><div class="line">    <span class="comment">// 接口里定义的成员变量只能是常量</span></div><div class="line">    <span class="keyword">int</span> MAX_CACHE_LINE = <span class="number">50</span>;</div><div class="line">    <span class="comment">// 接口里定义的普通方法只能是 public 的抽象方法</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(String msg)</span></span>;</div><div class="line">    <span class="comment">// 接口中定义默认方法，需要使用 default 修饰</span></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... msgs)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span>(String msg : msgs)</div><div class="line">        &#123;</div><div class="line">            System.out.println(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"默认的test方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 接口中定义类方法，需要使用 static 修饰</span></div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">staticTest</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"接口里的类方法"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 接口中定义私有方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"foo 私有方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 接口中定义私有静态方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"bar 私有静态方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputFieldTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(Output.MAX_CACHE_LINE);</div><div class="line">        <span class="comment">// final 变量不可重新赋值</span></div><div class="line">        <span class="comment">// Output.MAX_CACHE_LINE = 20;</span></div><div class="line">        <span class="comment">// 使用接口调用类方法</span></div><div class="line">        System.out.println(Output.staticTest());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-6-3-接口的继承"><a href="#6-6-3-接口的继承" class="headerlink" title="6.6.3 接口的继承"></a>6.6.3 接口的继承</h3><p>接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。</p>
<h3 id="6-6-4-使用接口"><a href="#6-6-4-使用接口" class="headerlink" title="6.6.4 使用接口"></a>6.6.4 使用接口</h3><ul>
<li>定义变量，也可用于进行强制类型转换</li>
<li>调用接口中定义的常量</li>
<li>被其他类实现</li>
</ul>
<p>实现接口和继承父类类似，一样可以获得所实现接口里定义的常量（成员变量）、方法（包括抽象方法和默认方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1，接口2</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	类体部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法(也就是重写这些抽象方法)；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getProduceTime</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Output</span>, <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String[] printData = <span class="keyword">new</span> String[MAX_CACHE_LINE];</div><div class="line">    <span class="comment">// 用于记录当前需打印的作业数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dataNum = <span class="number">0</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 只要还有作业，就继续打印</span></div><div class="line">        <span class="keyword">while</span> (dataNum &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"打印机打印："</span>+printData[<span class="number">0</span>]);</div><div class="line">            <span class="comment">// 把作业队列整体前移一位，并将剩下的作业数减一</span></div><div class="line">            System.arraycopy(printData,<span class="number">1</span>,printData,<span class="number">0</span>,--dataNum);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String msg)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dataNum &gt;= MAX_CACHE_LINE)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"输出队列已满，添加失败"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 把打印数据添加到队列里，已保存数据的数量加1</span></div><div class="line">            printData[dataNum++] = msg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProduceTime</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">45</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建一个Printer对象，当成Output使用</span></div><div class="line">        Output o = <span class="keyword">new</span> Printer();</div><div class="line">        o.getData(<span class="string">"轻量级Java EE企业应用实战"</span>);</div><div class="line">        o.getData(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">        o.out();</div><div class="line">        o.getData(<span class="string">"疯狂Android讲义"</span>);</div><div class="line">        o.getData(<span class="string">"疯狂Ajax讲义"</span>);</div><div class="line">        o.out();</div><div class="line">        <span class="comment">// 调用Output接口中定义的默认方法</span></div><div class="line">        o.print(<span class="string">"孙悟空"</span>, <span class="string">"猪八戒"</span>, <span class="string">"白骨精"</span>);</div><div class="line">        o.test();</div><div class="line">        <span class="comment">// 创建一个Printer对象，当成Product使用</span></div><div class="line">        Product p = <span class="keyword">new</span> Printer();</div><div class="line">        System.out.println(p.getProduceTime());</div><div class="line">        <span class="comment">// 所有接口类型的引用变量都可以直接赋值给Object类型变量</span></div><div class="line">        Object obj = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-6-5-接口和抽象类"><a href="#6-6-5-接口和抽象类" class="headerlink" title="6.6.5 接口和抽象类"></a>6.6.5 接口和抽象类</h3><ul>
<li>接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</li>
<li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li>
<li>接口里不包含构造器；抽象类里可以包含构造器</li>
<li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li>
<li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。</li>
</ul>
<h3 id="6-6-6-面向接口编程"><a href="#6-6-6-面向接口编程" class="headerlink" title="6.6.6 面向接口编程"></a>6.6.6 面向接口编程</h3><h4 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h4><p>有一个场景：假设程序中有个 Computer 类需要组合一个输出设备，现在有两个选择: 直接让 Computer 类组合一个 Printer ， 或者让 Computer 类组合一个 Output ，那么到底采用哪种方式更好呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Output out;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Output out)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.out = out;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个模拟获取字符串输入的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyIn</span><span class="params">(String msg)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        out.getData(msg);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个模拟打印的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        out.out();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 Computer 类己经完全与 Printer 类分离，只是与 Output 接口稠合。Computer 不再负责创建 Output 对象，系统提供一个 Output 工厂来负责生成 Output 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Output <span class="title">getOutput</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Printer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        OutputFactory of = <span class="keyword">new</span> OutputFactory();</div><div class="line">        Computer c = <span class="keyword">new</span> Computer(of.getOutput());</div><div class="line">        c.keyIn(<span class="string">"轻量级Java EE企业应用实战"</span>);</div><div class="line">        c.keyIn(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">        c.print();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2. 命令模式"></a>2. 命令模式</h4><p>场景: 某个方法需要完成某一个行为， 但这个行为的具体实现无法确定，必须等到执行该方法时才可以确定。具体一点: 假设有个方法需要遍历某个数组的数组元素， 但无法确定在遍历数组元素时如何处理这些元素， 需要在调用该方法时指定具体的处理行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</div><div class="line">    <span class="comment">// 接口里定义的process方法用于封装"处理行为"</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] target)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessArray</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] target, Command cmd)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        cmd.process(target);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ProcessArray pa = <span class="keyword">new</span> ProcessArray();</div><div class="line">        <span class="keyword">int</span>[] target = &#123;<span class="number">3</span>, -<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</div><div class="line">        <span class="comment">// 第一次处理数组，具体行为取决于PrintCommand</span></div><div class="line">        pa.process(target, <span class="keyword">new</span> PrintCommand());</div><div class="line">        System.out.println(<span class="string">"================="</span>);</div><div class="line">        pa.process(target, <span class="keyword">new</span> AddCommand());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] target)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tmp : target)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"迭代输出："</span> + tmp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-7-内部类"><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2><p>内部类作用：</p>
<ul>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内。</li>
<li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员。</li>
<li>匿名内部类适合用于创建那些仅需要使用一次的类。</li>
<li>内部类比外部类可以多使用单个修饰符：private、protected、static</li>
<li>非静态内部类不能拥有静态成员</li>
</ul>
<h3 id="6-7-1-非静态内部类"><a href="#6-7-1-非静态内部类" class="headerlink" title="6.7.1 非静态内部类"></a>6.7.1 非静态内部类</h3><p>外部类的上一级程序单元是包，所以它只有 2 个作用域；同一个包内和任何位置。因此只需2 种访问权限:包访问权限和公开访问权限，正好对应省略访问控制符和public访问控制符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cow</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cow</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cow</span><span class="params">(<span class="keyword">double</span> weight)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个非静态内部类</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CowLeg</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="comment">// 非静态内部类的两个实例变量</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> length;</div><div class="line">        <span class="keyword">private</span> String color;</div><div class="line">        <span class="comment">// 非静态内部类的两个重载的构造器</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CowLeg</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CowLeg</span><span class="params">(<span class="keyword">double</span> length, String color)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">this</span>.length = length;</div><div class="line">            <span class="keyword">this</span>.color = color;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 非静态内部类的实例方法</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            System.out.println(<span class="string">"当前牛的颜色是："</span> + color</div><div class="line">                + <span class="string">",高："</span> + length);</div><div class="line">            <span class="comment">// 直接访问外部类private成员变量</span></div><div class="line">            System.out.println(<span class="string">"本牛腿所在的奶牛重："</span> + weight);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> length;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.length = length;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> color;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.color = color;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        CowLeg cl = <span class="keyword">new</span> CowLeg(<span class="number">1.12</span>, <span class="string">"黑白相间"</span>);</div><div class="line">        cl.info();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Cow cow = <span class="keyword">new</span> Cow(<span class="number">378.9</span>);</div><div class="line">        cow.test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>外部类、内部类实例变量和局部变量的访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscernVariable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String prop = <span class="string">"外部类的实例变量"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InClass</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="keyword">private</span> String prop = <span class="string">"内部类的实例变量"</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            String prop = <span class="string">"局部变量"</span>;</div><div class="line">            System.out.println(<span class="string">"外部类实例变量值："</span> + DiscernVariable.<span class="keyword">this</span>.prop);</div><div class="line">            System.out.println(<span class="string">"内部类实例变量值："</span> + <span class="keyword">this</span>.prop);</div><div class="line">            System.out.println(<span class="string">"局部变量值："</span> + prop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        InClass in = <span class="keyword">new</span> InClass();</div><div class="line">        in.info();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> DiscernVariable().test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据静态成员不能访问非静态成员的规则， 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">In</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 静态成员无法访问非静态成员</span></div><div class="line">        <span class="comment">// new In();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerNoStatic</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="comment">// 非静态成员不能使用静态成员</span></div><div class="line"><span class="comment">//        static</span></div><div class="line"><span class="comment">//        &#123;</span></div><div class="line"><span class="comment">//            System.out.println("========");</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        private static int inProp;</span></div><div class="line"><span class="comment">//        private static void test()&#123;&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-7-2-静态内部类"><a href="#6-7-2-静态内部类" class="headerlink" title="6.7.2 静态内部类"></a>6.7.2 静态内部类</h3><p>静态内部类可以包含静态成员， 也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticlnnerClassTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> prop1 = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> prop2 = <span class="number">9</span>;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="comment">// 静态内部类里可以包含静态成员</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</div><div class="line">        <span class="comment">// 也可以包含非静态成员</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> money;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessOuterProp</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="comment">// 静态内部类不可访问外部类实例变量</span></div><div class="line">            <span class="comment">// System.out.println(prop1);</span></div><div class="line">            System.out.println(prop2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 还允许在接口里定义内部类，接口里定义的内部类默认使用public static 修饰，也就是说， 接口内部类只能是静态内部类。</p>
<h3 id="6-7-3-使用内部类"><a href="#6-7-3-使用内部类" class="headerlink" title="6.7.3 使用内部类"></a>6.7.3 使用内部类</h3><h4 id="1-在外部类内部使用内部类"><a href="#1-在外部类内部使用内部类" class="headerlink" title="1. 在外部类内部使用内部类"></a>1. 在外部类内部使用内部类</h4><p>与平常使用普通类没有太大的区别。只需注意不要在外部类的静态成员中使用非静态内部类。</p>
<h4 id="2-在外部类以外使用非静态内部类"><a href="#2-在外部类以外使用非静态内部类" class="headerlink" title="2. 在外部类以外使用非静态内部类"></a>2. 在外部类以外使用非静态内部类</h4><p>定义内部类时不可用 private，定义格式：OuterClass.InnerClass varName</p>
<p>创建内部类对象：OuterInstance.new InnerConstructor()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Out</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">In</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">In</span><span class="params">(String msg)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            System.out.println(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Createlnnerlnstance</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Out.In in = <span class="keyword">new</span> Out().new In(<span class="string">"测试信息"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当创建一个子类时，子类构造器总会调用父类的构造器，因此在创建非静态内部类的子类时，必须保证让子类构造器可以调用非静态内部类的构造器，调用非静态内部类的构造器时，必须存在一个外部类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Out</span>.<span class="title">In</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">(Out out)</span> </span>&#123;</div><div class="line">        out.<span class="keyword">super</span>(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-在外部类以外使用静态内部类"><a href="#3-在外部类以外使用静态内部类" class="headerlink" title="3. 在外部类以外使用静态内部类"></a>3. 在外部类以外使用静态内部类</h4><p>因为静态内部类是外部类类相关的，因此创建静态内部类对象时无须创建外部类对象。在外部类以外的地方创建静态内部类实例的语法如下:</p>
<p><code>new OuterClass.InnerConstructor()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticOut</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticIn</span></span></div><div class="line"><span class="class">    </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticIn</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            System.out.println(<span class="string">"静态内部类的构造器"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateStaticInnerInstance</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StaticOut.StaticIn in = <span class="keyword">new</span> StaticOut.StaticIn();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比之下，使用静态内部类比使用非静态内部类要简单很多，只要把外部类当成静态内部类的包空间即可。因此当程序需要使用内部类时， 应该优先考虑使用静态内部类。</p>
<h3 id="6-7-4-局部内部类"><a href="#6-7-4-局部内部类" class="headerlink" title="6.7.4 局部内部类"></a>6.7.4 局部内部类</h3><p>如果把一个内部类放在方法里定义，则这个内部类就是一个局部内部类， 局部内部类仅在该方法里有效。由于局部内部类不能在外部类的方法以外的地方使用，因此局部内部类也不能使用访问控制符和 static 修饰符修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义局部内部类</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerBase</span></span></div><div class="line"><span class="class">        </span>&#123;</div><div class="line">            <span class="keyword">int</span> a;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 定义局部内部类的子类</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerSub</span> <span class="keyword">extends</span> <span class="title">InnerBase</span></span></div><div class="line"><span class="class">        </span>&#123;</div><div class="line">            <span class="keyword">int</span> b;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 创建局部内部类的对象</span></div><div class="line">        InnerSub is = <span class="keyword">new</span> InnerSub();</div><div class="line">        is.a = <span class="number">5</span>;</div><div class="line">        is.b = <span class="number">8</span>;</div><div class="line">        System.out.println(<span class="string">"a:"</span> + is.a +<span class="string">",b:"</span> + is.b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>局部内部类走一个非常”鸡肋” 的语法，在实际开发中很少定义局部内部类，这是因为局部内部类的作用域太小了：只能在当前方法中使用。大部分时候，定义一个类之后，当然希望多次复用这个类，但局部内部类无法离开它所在的方法， 因此在实际开发中很少使用局部内部类。</p>
<h3 id="6-7-5-Java-8-改进的匿名内部类"><a href="#6-7-5-Java-8-改进的匿名内部类" class="headerlink" title="6.7.5 Java 8 改进的匿名内部类"></a>6.7.5 Java 8 改进的匿名内部类</h3><p>匿名内部类适合创建那种只需要一次使用的类，例如前面介绍命令模式时所需要的Command 对象。匿名内部类的语法有点奇怪，创建匿名内部类时会立即创建一个该类的实例， 这个类定义立即消失， 匿名内部类不能重复使用。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> 实现接口() | 父类构造器（实参列表）</div><div class="line">&#123;</div><div class="line">	<span class="comment">// 匿名内部类的类体部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匿名内部类必须继承一个父类，或实现一个接口， 但最多只能继承一个父类，或实现一个接口。</p>
<p>匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。</p>
<p>匿名内部类不能定义构造器。可以定义初始化块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Product p)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"购买一个"</span> + p.getName()</div><div class="line">            + <span class="string">"，花掉了"</span> + p.getPrice());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        AnonymousTest ta = <span class="keyword">new</span> AnonymousTest();</div><div class="line">        <span class="comment">// 调用 test 方法时，需要传入一个 Product 参数</span></div><div class="line">        <span class="comment">// 此处传入其匿名实现类的实例</span></div><div class="line">        ta.test(<span class="keyword">new</span> Product() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">567.8</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"AGP显卡"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这个 Product 接口<strong>实现类</strong>需要重复使用， 则应该将该实现类定义成一个独立类；如果这个Product 接口实现类只需一次使用，则可采用上面程序中的方式，定义一个匿名内部类。</p>
<p>如果通过继承父类来创建匿名内部类时， 匿名内部类将拥有和父类相似的构造器，此处的相似指的是拥有相同的形参列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">(String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymouslnner</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Device d)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"购买了一个"</span> + d.getName()</div><div class="line">            + <span class="string">"，花掉了"</span> + d.getPrice());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Anonymouslnner ai = <span class="keyword">new</span> Anonymouslnner();</div><div class="line">        <span class="comment">// 调用有参数的构造器创建Device匿名实现类的对象</span></div><div class="line">        ai.test(<span class="keyword">new</span> Device(<span class="string">"电子示波器"</span>) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">67.8</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 调用无参数的构造器创建 Device 匿名实现类的对象</span></div><div class="line">        Device d = <span class="keyword">new</span> Device() &#123;</div><div class="line">            <span class="comment">// 初始化块</span></div><div class="line">            &#123;</div><div class="line">                System.out.println(<span class="string">"匿名内部类的初始化块..."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">56.2</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 重写父类的实例方法</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></div><div class="line"><span class="function">            </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"键盘"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        ai.test(d);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>被匿名内部类访问的局部变量必须使用 final 修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> age = <span class="number">8</span>;</div><div class="line">        A a = <span class="keyword">new</span> A()</div><div class="line">        &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">            </span>&#123;</div><div class="line">                <span class="comment">// 在Java 8 以前下面语句将提示错误: age 必须使用final 修饰</span></div><div class="line">                <span class="comment">// Java 8开始，自动添加了 final 修饰</span></div><div class="line">                System.out.println(age);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        a.test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-8-Java-8-新增的-Lambda-表达式"><a href="#6-8-Java-8-新增的-Lambda-表达式" class="headerlink" title="6.8 Java 8 新增的 Lambda 表达式"></a>6.8 Java 8 新增的 Lambda 表达式</h2><p>Lambda 表达式支持将代码块作为方法参数， Lambda 表达式允许使用更简洁的代码来创建只有一个抽象方法的接口(这种接口被称为函数式接口)的实例。</p>
<h3 id="6-8-1-Lambda-表达式入门"><a href="#6-8-1-Lambda-表达式入门" class="headerlink" title="6.8.1  Lambda 表达式入门"></a>6.8.1  Lambda 表达式入门</h3><p>使用匿名内部类来改写前面的command 表达式的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ProcessArray pa = <span class="keyword">new</span> ProcessArray();</div><div class="line">        <span class="keyword">int</span>[] target = &#123;<span class="number">3</span>, -<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</div><div class="line">        <span class="comment">// 处理数组，具体处理行为取决于匿名内部类</span></div><div class="line">        pa.process(target, <span class="keyword">new</span> Command() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> tmp : target)</div><div class="line">                &#123;</div><div class="line">                    sum += tmp;</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"数组元素之和："</span>+sum);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 Lambda 改写后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandTest2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ProcessArray pa = <span class="keyword">new</span> ProcessArray();</div><div class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">3</span>, -<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</div><div class="line">        pa.process(array, (<span class="keyword">int</span>[] target)-&gt;&#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> tmp : target)</div><div class="line">            &#123;</div><div class="line">                sum += tmp;</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"数组元素之和："</span> + sum);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda 表达式的几种简化写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaQs</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//System.out.println(e);</span></div><div class="line">        e.taste();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//System.out.println("我正在驾驶：" + f);</span></div><div class="line">        f.fly(<span class="string">"[碧空如洗的晴日]"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable add)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"5与3的和为:"</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LambdaQs lq = <span class="keyword">new</span> LambdaQs();</div><div class="line">        <span class="comment">// Lambda 代码块只有一条语句，可以省略花括号</span></div><div class="line">        lq.eat(() -&gt; System.out.println(<span class="string">"苹果的味道不错！"</span>));</div><div class="line">        <span class="comment">// Lambda 形参只有一个，可以省略圆括号</span></div><div class="line">        lq.drive(weather -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"今天天气是："</span> + weather);</div><div class="line">            System.out.println(<span class="string">"直升机飞行平稳"</span>);</div><div class="line">        &#125;);</div><div class="line">        lq.test((a, b)-&gt; a+b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eat()方法，调用该方法需要一个Eatable 类型的参数，但实际传入的是Lambda 表达式</p>
<p>这说明Lambda 表达式实际上将会被当成一个”任意类型”的对象，到底需要当成何种类型的对象， 这取决于运行环境的需要</p>
<h3 id="6-8-2-Lambda-表达式与函数式接口"><a href="#6-8-2-Lambda-表达式与函数式接口" class="headerlink" title="6.8.2 Lambda 表达式与函数式接口"></a>6.8.2 Lambda 表达式与函数式接口</h3><p>函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法。</p>
<p>由于Lambda 表达式的结果就是被当成对象， 因此程序中完全可以使用Lambda 表达式进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</div><div class="line">    <span class="comment">// Runnable 接口中只包含一个无参数的方法</span></div><div class="line">    <span class="comment">// 下面的Lambda表达式创建了一个Runnable对象</span></div><div class="line">    Runnable r = () -&gt;&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</div><div class="line">        &#123;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Object 不是函数接口</span></div><div class="line"><span class="comment">//    Object obj = () -&gt;&#123;</span></div><div class="line"><span class="comment">//        for(int i=0;i&lt;100;i++)</span></div><div class="line"><span class="comment">//        &#123;</span></div><div class="line"><span class="comment">//            System.out.println();</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//    &#125;;</span></div><div class="line"></div><div class="line">    <span class="comment">// 强转</span></div><div class="line">        Object obj = (Runnable)() -&gt;&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</div><div class="line">        &#123;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上所述，不难发现Lambda 表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例-这种语法避免了匿名内部类的烦琐。</p>
<h3 id="6-8-3-方法引用与构造器引用"><a href="#6-8-3-方法引用与构造器引用" class="headerlink" title="6.8.3 方法引用与构造器引用"></a>6.8.3 方法引用与构造器引用</h3><h4 id="1-引用类方法"><a href="#1-引用类方法" class="headerlink" title="1. 引用类方法"></a>1. 引用类方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter converter1 = from -&gt; Integer.valueOf(from);</div><div class="line"><span class="comment">// 方法引用代替 Lambda 表达式</span></div><div class="line">Converter converter2 = Integer::valueOf;</div></pre></td></tr></table></figure>
<h4 id="2-引用特定对象的实例方法"><a href="#2-引用特定对象的实例方法" class="headerlink" title="2. 引用特定对象的实例方法"></a>2. 引用特定对象的实例方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Converter converter3 = from -&gt; <span class="string">"fkit.org"</span>.indexOf(from);</div><div class="line">Converter converter4 = <span class="string">"fkit.org"</span>::indexOf;</div></pre></td></tr></table></figure>
<h4 id="3-引用某类对象的实例方法"><a href="#3-引用某类对象的实例方法" class="headerlink" title="3. 引用某类对象的实例方法"></a>3. 引用某类对象的实例方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyTest mt = (a,b,c)-&gt; a.substring(b,c);</div><div class="line">MyTest mt1 = String :: substring;</div></pre></td></tr></table></figure>
<h4 id="4-引用构造器"><a href="#4-引用构造器" class="headerlink" title="4. 引用构造器"></a>4. 引用构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">YoutTest yt = (String a) -&gt; <span class="keyword">new</span> JFrame(a);</div><div class="line">YoutTest yt1 = JFrame::<span class="keyword">new</span>;</div></pre></td></tr></table></figure>
<h3 id="6-8-4-Lambda-表达式与匿名内部类的联系和区别"><a href="#6-8-4-Lambda-表达式与匿名内部类的联系和区别" class="headerlink" title="6.8.4 Lambda 表达式与匿名内部类的联系和区别"></a>6.8.4 Lambda 表达式与匿名内部类的联系和区别</h3><ul>
<li>Lambda 表达式与匿名内部类都可以直接访问”effectively final” 的局部变量，以及外部类的成员变量(包括实例变量和类变量〉。</li>
<li>Lambda 表达式创建的对象与匿名内部类生成的对象 都可以直接调用从接口中继承的默认方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Displayable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 定义一个抽象方法和默认方法</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> a + b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaAndlnner</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"疯狂软件教育中心"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        String book = <span class="string">"疯狂Java讲义"</span>;</div><div class="line">        Displayable dis = ()-&gt;&#123;</div><div class="line">            <span class="comment">// 访问“effectively final”的局部变量</span></div><div class="line">            System.out.println(<span class="string">"book 局部变量为："</span> + book);</div><div class="line">            System.out.println(<span class="string">"外部类的age实例变量为："</span>+age);</div><div class="line">            System.out.println(<span class="string">"外部类的name类变量为："</span> + name);</div><div class="line">        &#125;;</div><div class="line">        dis.display();</div><div class="line">        System.out.println(dis.add(<span class="number">3</span>,<span class="number">5</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LambdaAndlnner lambda = <span class="keyword">new</span> LambdaAndlnner();</div><div class="line">        lambda.test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要区别：</p>
<ul>
<li>匿名内部类可以为任意接口创建实例一一不管接口包含多少个抽象方法，只要匿名内部类实现所有的抽象方法即可;但Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例;但Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法;但Lambda 表达式的代码块不允许调用接口中定义的默认方法。</li>
</ul>
<h3 id="使用-Lambda-表达式调用-Arrays-的类方法"><a href="#使用-Lambda-表达式调用-Arrays-的类方法" class="headerlink" title="使用 Lambda 表达式调用 Arrays 的类方法"></a>使用 Lambda 表达式调用 Arrays 的类方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaArrays</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String[] arr1 = <span class="keyword">new</span> String[]&#123;<span class="string">"java"</span>,<span class="string">"fkava"</span>,<span class="string">"fkit"</span>,<span class="string">"ios"</span>,<span class="string">"android"</span>&#125;;</div><div class="line">        Arrays.parallelSort(arr1, (o1,o2) -&gt; o1.length() - o2.length());</div><div class="line">        System.out.println(Arrays.toString(arr1));</div><div class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">25</span>,<span class="number">16</span>,<span class="number">30</span>,<span class="number">18</span>&#125;;</div><div class="line">        Arrays.parallelPrefix(arr2, (left,right)-&gt; left * right);</div><div class="line">        System.out.println(Arrays.toString(arr2));</div><div class="line">        <span class="keyword">long</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</div><div class="line">        Arrays.parallelSetAll(arr3, operand -&gt; operand * <span class="number">5</span>);</div><div class="line">        System.out.println(arr3);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-9-枚举类"><a href="#6-9-枚举类" class="headerlink" title="6.9 枚举类"></a>6.9 枚举类</h2><p>一个类的对象是有限而且固定的，比如季节类，它只有4 个对象:再比如行星类，<br>目前只有8 个对象。这种实例有限而且固定的类，在Java 里被称为枚举类。</p>
<h3 id="6-9-1-手动实现枚举类"><a href="#6-9-1-手动实现枚举类" class="headerlink" title="6.9.1 手动实现枚举类"></a>6.9.1 手动实现枚举类</h3><p>在早期代码中，可能会直接使用简单的静态常量来表示枚举。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEASON_SPRING = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEASON_SUMMER = <span class="number">2</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEASON_FALL = <span class="number">3</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEASON_WINTER = <span class="number">4</span>;</div></pre></td></tr></table></figure>
<p>这样写有如下问题：</p>
<ol>
<li>类型不安全。例如，完全可以把季节当成int来操作</li>
<li>没有命名空间。必须要有 SEASON_ 前缀</li>
<li>打印输出意义不明确</li>
</ol>
<h3 id="6-9-2-枚举类入门"><a href="#6-9-2-枚举类入门" class="headerlink" title="6.9.2 枚举类入门"></a>6.9.2 枚举类入门</h3><p>Java 5 新增 enum 关键字，用于定义枚举类。</p>
<p>枚举类和普通类区别：</p>
<ul>
<li>枚举类可以实现一个或多个接口。枚举类默认继承 Enum 类，而不是 Object 类，因此<strong>枚举类不能显示继承其他父类</strong>。</li>
<li>非抽象的枚举类默认使用 final 修饰，因此枚举类不能派生子类。</li>
<li>枚举类构造器只能使用 private 修饰，如省略系统模式使用 private</li>
<li>枚举类所有实例必须在第一行显示列出，系统自动加 public static final</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</div><div class="line">    <span class="comment">// 在第一行列出 4 个枚举实例</span></div><div class="line">    SPRING,</div><div class="line">    SUMMER,</div><div class="line">    FALL,</div><div class="line">    WINTER;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judge</span><span class="params">(SeasonEnum s)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// switch 语句里可以是枚举值</span></div><div class="line">        <span class="keyword">switch</span> (s)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> SPRING:</div><div class="line">                System.out.println(<span class="string">"春天"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> SUMMER:</div><div class="line">                System.out.println(<span class="string">"夏天"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> FALL:</div><div class="line">                System.out.println(<span class="string">"秋天"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> WINTER:</div><div class="line">                System.out.println(<span class="string">"冬天"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 枚举类默认有 values() 方法，返回所有实例</span></div><div class="line">        <span class="keyword">for</span> (SeasonEnum s : SeasonEnum.values())</div><div class="line">        &#123;</div><div class="line">            System.out.println(s);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 使用枚举类时，EnumClass.variable</span></div><div class="line">        <span class="keyword">new</span> EnumTest().judge(SeasonEnum.SUMMER);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-9-3-枚举类的成员变量、方法和构造器"><a href="#6-9-3-枚举类的成员变量、方法和构造器" class="headerlink" title="6.9.3 枚举类的成员变量、方法和构造器"></a>6.9.3 枚举类的成员变量、方法和构造器</h3><p>枚举类通常应该设计成不可变类，也就是说，它的成员变量值不应该允许改变，这样会更安全，而且代码更加简洁。因此建议将枚举类的成员变量都使用private final 修饰。</p>
<p>如此，则应该在构造器里为这些成员变量指定初始值（或者定义成员变量、初始化块，这两种不常见）。</p>
<p>一旦为枚举类显示定义了带参数构造器，列出枚举值时，必须传入该参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender &#123;</div><div class="line">    <span class="comment">// 此处枚举值必须调用对应构造器创建</span></div><div class="line">    MALE(<span class="string">"男"</span>),</div><div class="line">    FEMALE(<span class="string">"女"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">// 枚举类构造器只能用 private 修饰</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-9-4-实现接口的枚举类"><a href="#6-9-4-实现接口的枚举类" class="headerlink" title="6.9.4 实现接口的枚举类"></a>6.9.4 实现接口的枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenderDesc</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender implements GenderDesc&#123;</div><div class="line">    <span class="comment">// 此处枚举值必须调用对应构造器创建</span></div><div class="line">    <span class="comment">// 花括号部分实际上是一个类体部分</span></div><div class="line">    MALE(<span class="string">"男"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"这个枚举值代表男性"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    FEMALE(<span class="string">"女"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"这个枚举值代表女性"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">// 枚举类构造器只能用 private 修饰</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这样写，所有枚举实例行为全部一样</span></div><div class="line"><span class="comment">//    @Override</span></div><div class="line"><span class="comment">//    public void info() &#123;</span></div><div class="line"><span class="comment">//        System.out.println("这是一个用于定义性别的枚举类");</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>花括号部分实际上就是一个类体部分，在这种情况下，当创建MALE 、FEMALE 枚举值时， 并不是直接创建Gender 枚举类的实例， 而是相当于创建G ender 的匿名子类的实例。因为粗体字括号部分实际上是匿名内部类的类体部分， 所以这个部分的代码语法与前面介绍的匿名内部类语法大致相似，只是它依然是枚举类的匿名内部子类。</p>
<p>问题：枚举类不是用 final 修饰了吗？怎么还能派生子类呢？</p>
<p>回答：并不是所有的枚举类都使用了 final 修饰。非抽象的枚举类才默认使用 final。对于抽象枚举类（只要它包含抽象方法），系统默认使用 abstract 修饰。</p>
<p>编译上面程序，生产了 Gender.class、Gender$1.class和Gender$2.class 三个文件，正好证明 MALE 和 FEMALE 实际上是 Gender 匿名子类的实例，而不是 Gender 类的实例。</p>
<h3 id="6-9-5-包含抽象方法的枚举类"><a href="#6-9-5-包含抽象方法的枚举类" class="headerlink" title="6.9.5 包含抽象方法的枚举类"></a>6.9.5 包含抽象方法的枚举类</h3><p>定义一个枚举类，表示加减乘除，定义一个方法来完成计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">    PLUS</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> x + y;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    MINUS</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> x - y;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    TIMES</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> x * y;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    DIVIDE</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> x / y;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 为枚举类定义一个抽象方法</span></div><div class="line">    <span class="comment">// 这个抽象方法由不同的枚举值提供不同的实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(Operation.PLUS.eval(<span class="number">3</span>, <span class="number">4</span>));</div><div class="line">        System.out.println(Operation.MINUS.eval(<span class="number">3</span>, <span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译上面程序会生产 5 个 class 文件。</p>
<p>枚举类里定义抽象方法时，不能用 abstract 定义枚举类（系统会自动添加）。</p>
<p>枚举类需要显示创建枚举值，不是作为父类，所以定义每个枚举值时，必须为抽象方法提供实现，否则出先编译错误。</p>
<h2 id="6-10-对象与垃圾回收"><a href="#6-10-对象与垃圾回收" class="headerlink" title="6.10 对象与垃圾回收"></a>6.10 对象与垃圾回收</h2><p>当程序创建对象、数组等引用类型实体时，系统都会在堆内存中为之分配一块内存区，对象就保存在这块内存区中，当这块内存不再被任何引用变量引用时，这块内存就变成垃圾，等待垃圾回收机制进行回收。</p>
<ul>
<li>垃圾回收机制只负责回收堆内存中对象，不会回收任何物理资源（例如数据库连接、网络 IO 等资源）。</li>
<li>程序无法精确控制垃圾回收的运行，垃圾回收会在何时的时候进行。</li>
<li><strong>回收任何对象之前，总会先调用它的 finalize() 方法</strong>，该方法可能使对象重新复活（让一个引用变量重新引用该对象）,从而导致取消回收。</li>
</ul>
<h3 id="6-10-1-对象在内存中的状态"><a href="#6-10-1-对象在内存中的状态" class="headerlink" title="6.10.1 对象在内存中的状态"></a>6.10.1 对象在内存中的状态</h3><p>当一个对象在堆内存中运行时，根据他被引用变量所引用的状态，可以把它所处的状态分为如下三种：</p>
<ul>
<li><strong>可达状态</strong>：一个对象被创建后，有一个以上的引用变量引用它。程序可通过引用变量来调用该对象的实例变量和方法。</li>
<li><strong>可恢复状态</strong>：程序中某个对象不再有任何引用变量引用他。通过 finalize()方法可能变回可达状态</li>
<li><strong>不可达状态</strong>：对象与所有引用变量的关联都被切断。且调用 finalize() 方法后依然没有使该对象变成可达状态，那么这个对象将永久性失去引用，变成不可达状态</li>
</ul>
<h3 id="6-10-2-强制垃圾回收"><a href="#6-10-2-强制垃圾回收" class="headerlink" title="6.10.2 强制垃圾回收"></a>6.10.2 强制垃圾回收</h3><p>程序只能控制一个对象何时不再被任何引用变量引用，绝不能控制它何时被回收。</p>
<p>程序无法精确控制 Java 垃圾回收的时机，但依然可以强制系统进行垃圾回收，这种强制只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">new</span> GcTest();</div><div class="line">            <span class="comment">//System.gc();</span></div><div class="line">            Runtime.getRuntime().gc();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"系统正在清理 GcTest 对象的资源..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>指定 <code>-verbose:gc</code> 选项，可以看到每次垃圾回收后的提示信息。</p>
<h3 id="6-10-3-finalize-方法"><a href="#6-10-3-finalize-方法" class="headerlink" title="6.10.3 finalize 方法"></a>6.10.3 finalize 方法</h3><p>特点：</p>
<ol>
<li>永远不要主动调用某个对象的 finalize() 方法</li>
<li>该方法何时被调用具有不确定性</li>
<li>JVM 执行可恢复对象的 finalize() 方法时，可能使该对象或者系统中其他对象重新变成可达状态</li>
<li>执行该方法时出现异常，垃圾回收机制不会报告异常，程序继续执行</li>
</ol>
<h3 id="6-10-4-对象的软、弱和虚引用"><a href="#6-10-4-对象的软、弱和虚引用" class="headerlink" title="6.10.4 对象的软、弱和虚引用"></a>6.10.4 对象的软、弱和虚引用</h3><ol>
<li><p>强引用</p>
</li>
<li><p>软引用</p>
<p>通过 SoftReference 类实现。当一个对象只有软引用时，可能被回收，是否回收得<strong>看系统内存</strong></p>
</li>
<li><p>弱引用</p>
<p>通过 WeakReference 类实现。当一个对象只有弱引用时，<strong>执行垃圾回收时，肯定会被回收</strong></p>
</li>
<li><p>虚引用</p>
<p>通过 PhantomReference 类实现。虚引用完全类似于没有引用。主要用于跟踪对象被垃圾回收的状态。必须和引用队列联合使用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        String str = <span class="keyword">new</span> String(<span class="string">"疯狂 Java 讲义"</span>);</div><div class="line">        WeakReference wr = <span class="keyword">new</span> WeakReference(str);</div><div class="line">        str = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 取出弱引用所引用的对象</span></div><div class="line">        System.out.println(wr.get());</div><div class="line">        <span class="comment">// 强制垃圾回收</span></div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        System.out.println(wr.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str = <span class="keyword">new</span> String(<span class="string">"疯狂 Java 讲义"</span>);</div><div class="line">        <span class="comment">// 创建一个引用队列</span></div><div class="line">        ReferenceQueue rq = <span class="keyword">new</span> ReferenceQueue();</div><div class="line">        <span class="comment">// 创建一个虚引用</span></div><div class="line">        PhantomReference pr = <span class="keyword">new</span> PhantomReference(str, rq);</div><div class="line">        str = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 并不能通过虚引用获取被引用的对象，输出 null</span></div><div class="line">        System.out.println(pr.get());</div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        <span class="comment">// 垃圾回收后，虚引用将被放入引用队列中</span></div><div class="line">        System.out.println(rq.poll() == pr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要使用这些特殊的引用类，就不能保留对对象的强引用:如果保留了对对象的强引用，就会浪费这些引用类所提供的任何好处。</p>
<p>由于垃圾回收的不确定性，当程序希望从软、弱引用中取出被引用的对象时，可能这个对象已经被回收了。如果程序需要使用那个被引用的对象，则必须判断，如果为 null，则必须重新创建该对象。</p>
<h2 id="6-11-修饰符的适用范围"><a href="#6-11-修饰符的适用范围" class="headerlink" title="6.11 修饰符的适用范围"></a>6.11 修饰符的适用范围</h2><table>
<thead>
<tr>
<th></th>
<th>外部类/接口</th>
<th>成员</th>
<th>方法</th>
<th>构造器</th>
<th>初始化</th>
<th>成员</th>
<th>局部</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>protect</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>包访问控制符</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>⚪</td>
<td>√</td>
<td>⚪</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>abstract</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>final</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>static</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>strictfp</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>synchronized</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>native</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transient</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>volatile</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>strictfp 关键宇的含义是 FP-strict ，也就是精确浮点的意思。</p>
<p>native 方法通常采用C 语言来实现。如果某个方法需要利用平台相关特性，或者访问系统硬件等，则可以使用native 修饰该方法，再把该方法交给C 去实现。一旦Java 程序中包含了native 方法，这个程序将失去跨平台的功能。</p>
<p>4 个访问控制符是互斥的，最多只能出现其中之一。</p>
<p>abstract 和 final 永远不能用时使用；</p>
<p>abstract 和 static 不能同时修饰方法，可以同时修饰内部类；</p>
<p>abstract 和 private 不能同时修饰方法，可以同时修饰内部类</p>
<p>private 和 final 同时修饰方法语法是合法的，但是没有意义。</p>
<h2 id="6-12-Java-9-的多版本-JAR-包"><a href="#6-12-Java-9-的多版本-JAR-包" class="headerlink" title="6.12 Java 9 的多版本 JAR 包"></a>6.12 Java 9 的多版本 JAR 包</h2><p>JAR 文件与 ZIP  文件的区别就是在 JAR 文件中默认包含了一个名为META-INF/MANIFEST.MF 的清单文件，这个清单文件是在生成 JAR 文件时由系统自动创建的。</p>
<h3 id="6-12-1-jar-命令详解"><a href="#6-12-1-jar-命令详解" class="headerlink" title="6.12.1 jar 命令详解"></a>6.12.1 jar 命令详解</h3><ol>
<li>创建 jar 文件 jar cvf test.jar -C dist/ .</li>
</ol>
<p>当前路径下的 dist 路径下的全部内容生成一个 test.jar 文件。</p>
<ol>
<li>不适用清单文件 jar cvfM test.jar -C dist/ .</li>
<li>自定义清单文件内容 jar cvfm test.jar a.txt -C dist/ .</li>
<li>查看 jar 包内容 jar tf test.jar &gt; a.txt</li>
<li>查看 jar 包详细内容 jar tvf test.jar</li>
<li>解压缩 jar xvf test.jar</li>
<li>更新 jar 文件 jar uvf test.jar Hello.class</li>
</ol>
<p>更新 test.jar 中的 Hello.class 文件</p>
<ol>
<li>创建多版本 jar 包 jar cvf test.jar -C dist7/ . –release 9 -C dist/ .</li>
</ol>
<p>针对 Java7 编译的所有 class 文件放在 dist7 目录下，9则方法 dist </p>
<h3 id="6-12-2-创建可执行的-jar-包"><a href="#6-12-2-创建可执行的-jar-包" class="headerlink" title="6.12.2 创建可执行的 jar 包"></a>6.12.2 创建可执行的 jar 包</h3><p>对于一个可执行的JAR 包，用户只需要双击它就可以运行程序了。</p>
<p>创建可执行的JAR 包的关键在于:让Javaw 命令知道JAR 包中哪个类是主类。</p>
<p>java cvfe test.jar test.Test test</p>
<p>上面命令把 test 目录下所有文件都压缩到 test.jar 包中，并指定使用 test.Test 类作为程序入口。</p>
<p>java -jar test.jar</p>
<p>javaw test.jar</p>
</div><div class="tags"><a href="/tags/疯狂-Java-讲义/">疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-01-07-疯狂Java讲义/疯狂Java讲义C7.html">第 7 章 Java 基础类库</a><a class="next" href="/2020-01-05-疯狂Java讲义/疯狂Java讲义C5.html">第 5 章 面向对象（上）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加解密技术/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/吉他/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/吉他/" style="font-size: 15px;">吉他</a> <a href="/tags/疯狂-Java-讲义/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>