<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-27T15:20:05.944Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>悟空</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第 5-9 章 Web 中的 Spring</title>
    <link href="http://yoursite.com/2020-12-25-13Spring%E5%9F%BA%E7%A1%80/springmvc.html"/>
    <id>http://yoursite.com/2020-12-25-13Spring%E5%9F%BA%E7%A1%80/springmvc.html</id>
    <published>2020-12-25T14:13:12.000Z</published>
    <updated>2020-12-27T15:20:05.944Z</updated>
    
    <content type="html"><![CDATA[<p>书中的代码是用 Grandle 构建，怎么跑起来是个问题。记录一下采坑过程。</p><a id="more"></a><h2 id="1、构建-Spring-MVC-项目"><a href="#1、构建-Spring-MVC-项目" class="headerlink" title="1、构建 Spring MVC 项目"></a>1、构建 Spring MVC 项目</h2><h3 id="1-1-demo-项目编写"><a href="#1-1-demo-项目编写" class="headerlink" title="1.1 demo 项目编写"></a>1.1 demo 项目编写</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p><img src="../../images/sia/c5/%E6%96%B0%E5%BB%BAgradle%E9%A1%B9%E7%9B%AE.png"></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p><strong>build.gradle</strong></p><pre><code class="json">apply plugin: &#39;eclipse&#39;apply plugin: &#39;war&#39;apply plugin: &#39;eclipse-wtp&#39;// 依赖dependencies &#123;    compile &quot;org.springframework:spring-webmvc:$springVersion&quot;    compile &quot;org.springframework:spring-jdbc:$springVersion&quot;    compile &quot;com.h2database:h2:$h2Version&quot;    compile &quot;org.hibernate:hibernate-validator:$hibernateValidatorVersion&quot;    compile &quot;org.apache.commons:commons-lang3:$commonsLangVersion&quot;    compile &quot;javax.servlet:jstl:$jstlVersion&quot;// jdk 版本高于8时可能需要//    compile &quot;javax.xml.bind:jaxb-api:2.3.0&quot;//    compile &quot;com.sun.xml.bind:jaxb-impl:2.3.0&quot;//    compile &quot;com.sun.xml.bind:jaxb-core:2.3.0&quot;//    compile &quot;javax.activation:activation:1.1.1&quot;    providedCompile &quot;javax.servlet:javax.servlet-api:$servletApiVersion&quot;    providedCompile &quot;javax.servlet.jsp:jsp-api:$jspApiVersion&quot;    providedCompile &quot;javax.el:javax.el-api:$jspElVersion&quot;    testCompile &quot;junit:junit-dep:$junitVersion&quot;    testCompile &quot;org.springframework:spring-test:$springVersion&quot;    testCompile &quot;org.mockito:mockito-core:$mockitoVersion&quot;    testCompile &quot;org.hamcrest:hamcrest-library:$hamcrestVersion&quot;&#125;// 仓库地址repositories &#123;    maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; &#125;&#125;war &#123;    baseName = &#39;spittr&#39;&#125;</code></pre><p><strong>gradle.properties</strong></p><pre><code class="properties">activeMQVersion=5.7.0aspectJVersion=1.7.2commonsLangVersion = 3.1ehcacheVersion=2.7.4ehcacheJCacheVersion=1.4.0-beta1h2Version=1.4.182hamcrestVersion = 1.3hibernateVersion=4.1.6.FinalhibernateEntityManagerVersion=4.0.1.FinalhibernateValidatorVersion = 5.0.1.FinaljspApiVersion = 2.1jspElVersion = 2.2.4jstlVersion = 1.2junitVersion=4.11log4jVersion=1.2.14mockitoVersion=1.9.5servletApiVersion = 3.1.0slf4jVersion = 1.7.5springAMQPVersion=1.0.0.RELEASEspringDataJpaVersion=1.3.2.RELEASEspringSecurityVersion = 3.2.0.RELEASEspringVersion=4.0.7.RELEASEspringWebflowVersion=2.4.1.RELEASEsystemRulesVersion=1.5.0thymeleafVersion = 2.1.3.RELEASEtilesVersion = 3.0.1</code></pre><h4 id="mvc-demo-配置和编写"><a href="#mvc-demo-配置和编写" class="headerlink" title="mvc demo 配置和编写"></a>mvc demo 配置和编写</h4><pre><code class="java">/** * 配置 mvc 的 DispatcherServlet */public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    /**     * 指定配置类     * @return     */    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[]&#123; RootConfig.class &#125;;    &#125;    /**     * 指定配置类     * @return     */    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123; WebConfig.class &#125;;    &#125;    /**     * 指定 DispatcherServlet 处理哪些请求     * @return     */    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123; &quot;/&quot; &#125;;    &#125;&#125;</code></pre><pre><code class="java">/** * 配置包扫描。springboot 一般配置在启动类上 */@Configuration@ComponentScan(basePackages=&#123;&quot;spittr&quot;&#125;,        excludeFilters=&#123;                @ComponentScan.Filter(type= FilterType.ANNOTATION, value= EnableWebMvc.class)        &#125;)public class RootConfig &#123;&#125;</code></pre><pre><code class="java">/** * 定义 DispatcherServlet 应用上下文中的 bean * 包含控制器、视图解析器以及处理器映射等 */@Configuration// 启动 mvc@EnableWebMvc// RootConfig 不是已经配置了吗？这里不需要了吧@ComponentScan(&quot;spittr.web&quot;)public class WebConfig extends WebMvcConfigurerAdapter &#123;    /**     * 配置 JSP 视图解析器     * Spring默认会使用BeanNameViewResolver，这个视图解析器会查找ID与视图名称匹配的bean，     * 并且查找的bean要实现View接口，它以这样的方式来解析视图。     */    @Bean    public ViewResolver viewResolver() &#123;        InternalResourceViewResolver resolver = new InternalResourceViewResolver();        resolver.setPrefix(&quot;/WEB-INF/templates/&quot;);        resolver.setSuffix(&quot;.jsp&quot;);        resolver.setExposeContextBeansAsAttributes(true);        return resolver;    &#125;    /**     * 配置静态资源的处理     * 要求DispatcherServlet将对静态资源的请求转发到Servlet容器中默认的Servlet上，     * 而不是使用DispatcherServlet本身来处理此类请求。     * @param configurer     */    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;        super.configureDefaultServletHandling(configurer);    &#125;&#125;</code></pre><pre><code class="java">@Controllerpublic class HomeController &#123;    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)    public String hone() &#123;        return &quot;home&quot;;    &#125;&#125;</code></pre><pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;&lt;%@ page session=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Spittr&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot;          href=&quot;&lt;c:url value=&quot;/resources/css/style.css&quot;/&gt;&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to Spittr&lt;/h1&gt;&lt;a href=&quot;&lt;c:url value=&quot;/spittles&quot; /&gt;&quot;&gt;Spittles&lt;/a&gt;&lt;a href=&quot;&lt;c:url value=&quot;/spitter/register&quot; /&gt;&quot;&gt;Register&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-2-启动项目"><a href="#1-2-启动项目" class="headerlink" title="1.2 启动项目"></a>1.2 启动项目</h3><h4 id="配置-tomcat"><a href="#配置-tomcat" class="headerlink" title="配置 tomcat"></a>配置 tomcat</h4><p><img src="../../images/sia/c5/tomcat%E9%85%8D%E7%BD%AE1.png"></p><p><img src="../../images/sia/c5/tomcat%E9%85%8D%E7%BD%AE2.png"></p><p>这里有个根路径配置，选完之后自动变了，记得手动修改下</p><p><img src="../../images/sia/c5/tomcat%E9%85%8D%E7%BD%AE3.png"></p><h4 id="启动-tomcat"><a href="#启动-tomcat" class="headerlink" title="启动 tomcat"></a>启动 tomcat</h4><p>如果使用的是高版本 jdk（大于8），可能 404 都看不到，直接报错</p><p><img src="../../images/sia/c5/%E9%AB%98%E7%89%88%E6%9C%ACjdk%E9%97%AE%E9%A2%98.png"></p><p>这个报错的解决方法：</p><ul><li><p>降低 jdk 版本到8</p></li><li><p>增加几个依赖</p><pre><code class="json">// jdk 版本高于8时可能需要compile &quot;javax.xml.bind:jaxb-api:2.3.0&quot;compile &quot;com.sun.xml.bind:jaxb-impl:2.3.0&quot;compile &quot;com.sun.xml.bind:jaxb-core:2.3.0&quot;compile &quot;javax.activation:activation:1.1.1&quot;</code></pre></li></ul><p>再启动，可能会 404，只在 jdk8 上出现这情况。</p><p><img src="../../images/sia/c5/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%BB%93%E6%9E%9C.png"></p><p>如出现上面 404 问题，修改如下配置，全部改为<strong>IntelliJ IDEA</strong>，注意jdk大于8时无需修改，我用jdk12，修改了反而报错：</p><p><img src="../../images/sia/c5/404%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D.png"></p><h3 id="1-3-乱码问题解决"><a href="#1-3-乱码问题解决" class="headerlink" title="1.3 乱码问题解决"></a>1.3 乱码问题解决</h3><p>tomcat 控制台可能乱码、idea 控制台也可能乱码</p><p>idea 相关 vmoptions 全局加 <code>-Dfile.encoding=UTF-8</code>。</p><p>tomcat 启动 vmoptions 也加 <code>-Dfile-encoding=UTF-8</code>。</p><p>tomcat 日志配置文件<code>D:\16_tomcat\apache-tomcat-9.0.41\conf\logging.properties</code> 所有 GBK 替换为 UTF-8。</p><h2 id="2、Spring-MVC-学习"><a href="#2、Spring-MVC-学习" class="headerlink" title="2、Spring MVC 学习"></a>2、Spring MVC 学习</h2><h3 id="2-1-Spring-MVC-基本组成"><a href="#2-1-Spring-MVC-基本组成" class="headerlink" title="2.1 Spring MVC 基本组成"></a>2.1 Spring MVC 基本组成</h3><p><img src="../../images/sia/c5/mvc%E7%BB%84%E6%88%90.png"></p><h3 id="2-2-测试-Controller-的方法"><a href="#2-2-测试-Controller-的方法" class="headerlink" title="2.2 测试 Controller 的方法"></a>2.2 测试 Controller 的方法</h3><h4 id="测试视图是否正确"><a href="#测试视图是否正确" class="headerlink" title="测试视图是否正确"></a>测试视图是否正确</h4><pre><code class="java">package spittr.web;import org.junit.Test;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup;public class HomeControllerTest &#123;    /**     * 测试控制器的方法     * @throws Exception     */    @Test    public void testHomePage() throws Exception &#123;        HomeController controller = new HomeController();        // 搭建 MockMvc        MockMvc mockMvc = standaloneSetup(controller).build();        // 对“/”执行 GET 请求，预期得到 home 视图        mockMvc.perform(get(&quot;/&quot;)).andExpect(view().name(&quot;home&quot;));    &#125;&#125;</code></pre><h4 id="测试-model"><a href="#测试-model" class="headerlink" title="测试 model"></a>测试 model</h4><pre><code class="java">@Testpublic void testSpitte() throws Exception &#123;    Spittle exceptedSpittle = new Spittle(&quot;Hello&quot;, new Date());    SpittleRepository mockRepository = mock(SpittleRepository.class);    when(mockRepository.findOne(1))        .thenReturn(exceptedSpittle);    SpittleController controller = new SpittleController(mockRepository);    MockMvc mockMvc = standaloneSetup(controller)        .setSingleView(new InternalResourceView(&quot;/WEB-INF/views/spittle.jsp&quot;))        .build();    mockMvc.perform(get(&quot;/spittles/1&quot;))        .andExpect(view().name(&quot;spittle&quot;))        .andExpect(model().attributeExists(&quot;spittle&quot;))        .andExpect(model().attribute(&quot;spittle&quot;, exceptedSpittle));&#125;</code></pre><h3 id="2-3-传递模型数据到视图"><a href="#2-3-传递模型数据到视图" class="headerlink" title="2.3 传递模型数据到视图"></a>2.3 传递模型数据到视图</h3><p>把数据塞进 Model 就行，Model 就是一个 map。</p><pre><code class="java">@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) &#123;    // 将 spittle 添加到模型中    model.addAttribute(&quot;spittleList&quot;,                       spittleRepository.findSpittles(Long.MAX_VALUE, 20));    // 返回视图    return &quot;spittles&quot;;&#125;</code></pre><h3 id="2-4-接受请求的输入"><a href="#2-4-接受请求的输入" class="headerlink" title="2.4 接受请求的输入"></a>2.4 接受请求的输入</h3><p><strong>直接从请求参数中拿</strong></p><pre><code class="java">@RequestMapping(value = &quot;/pageList&quot;, method = RequestMethod.GET)public String spittles(@RequestParam(value = &quot;max&quot;, defaultValue = MAX_LONG_AS_STRING) long max,                       @RequestParam(value = &quot;count&quot;, defaultValue = &quot;20&quot;) int count, Model model) &#123;    model.addAttribute(spittleRepository.findSpittles(max, count));    return &quot;spittles&quot;;&#125;</code></pre><p><strong>直接从请求路径中拿</strong></p><pre><code class="java">@RequestMapping(value = &quot;/&#123;spittleId&#125;&quot;, method = RequestMethod.GET)public String spittle(@PathVariable(&quot;spittleId&quot;) long spittleId, Model model) &#123;    model.addAttribute(spittleRepository.findOne(spittleId));    return &quot;spittle&quot;;&#125;</code></pre><h3 id="2-5-处理表单"><a href="#2-5-处理表单" class="headerlink" title="2.5 处理表单"></a>2.5 处理表单</h3><h4 id="注册功能实现"><a href="#注册功能实现" class="headerlink" title="注册功能实现"></a>注册功能实现</h4><p>获取表单参数，校验表单参数，校验通过后重定向到个人主页。</p><p><strong>控制器</strong></p><pre><code class="java">/*** 执行注册* @param spitter* @return*/@RequestMapping(value = &quot;/register&quot;, method = RequestMethod.POST)public String processRegister(@Valid Spitter spitter, Errors errors) &#123;    if (errors.hasErrors()) &#123;        return &quot;registerForm&quot;;    &#125;    // 保存 spitter    spitterRepository.save(spitter);    // 重定向到基本信息页，防止用户重复提交    return &quot;redirect:/spitter/&quot; + spitter.getUsername();&#125;/*** 个人主页* @param username* @param model* @return*/@RequestMapping(value = &quot;/&#123;username&#125;&quot;, method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123;    Spitter spitter = spitterRepository.findByUsername(username);    model.addAttribute(spitter);    return &quot;profile&quot;;&#125;</code></pre><p><strong>页面</strong></p><pre><code class="jsp">&lt;body&gt;    &lt;h1&gt;Register&lt;/h1&gt;    &lt;form method=&quot;POST&quot;&gt;        First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot;/&gt;&lt;br/&gt;        Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot;/&gt;&lt;br/&gt;        Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;        Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><pre><code class="jsp">&lt;body&gt;    &lt;h1&gt;Your Profile&lt;/h1&gt;    &lt;c:out value=&quot;$&#123;spitter.username&#125;&quot;/&gt;&lt;br/&gt;    &lt;c:out value=&quot;$&#123;spitter.firstName&#125;&quot;/&gt;,    &lt;c:out value=&quot;$&#123;spitter.lastName&#125;&quot;/&gt;&lt;/body&gt;</code></pre><p><strong>pojo</strong></p><pre><code class="java">public class Spitter &#123;    private Long id;    @NotNull    @Size(min=2, max = 30)    private String firstName;    @NotNull    @Size(min=2, max = 30)    private String lastName;    @NotNull    @Size(min=5, max = 16)    private String username;    @NotNull    @Size(min=5, max = 25)    private String password;&#125;</code></pre><h2 id="3、渲染-Web-视图"><a href="#3、渲染-Web-视图" class="headerlink" title="3、渲染 Web 视图"></a>3、渲染 Web 视图</h2><ul><li>将模型数据渲染为HTML</li><li>使用JSP视图</li><li>通过tiles定义视图布局</li><li>使用Thymeleaf视图</li></ul><h3 id="3-1-理解视图解析器"><a href="#3-1-理解视图解析器" class="headerlink" title="3.1 理解视图解析器"></a>3.1 理解视图解析器</h3><p>根据 Controller 返回的逻辑视图名，找到真正的物理视图。</p><pre><code class="java">public interface ViewResolver &#123;    View resolveViewName(String viewName, Locale locale) throws Exception;&#125;</code></pre><pre><code class="java">public interface View &#123;    /**     * Render the view given the specified model.     * &lt;p&gt;The first step will be preparing the request: In the JSP case,     * this would mean setting model objects as request attributes.     * The second step will be the actual rendering of the view,     * for example including the JSP via a RequestDispatcher.     * @param model Map with name Strings as keys and corresponding model     * objects as values (Map can also be &#123;@code null&#125; in case of empty model)     * @param request current HTTP request     * @param response HTTP response we are building     * @throws Exception if rendering failed     */    void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;&#125;</code></pre><p>View 的 render 方法把处理结果写入 response，返回浏览器。</p><p>一般来说，我们无需自己实现 ViewResolver，Spring 内置了 13 个视图解析器。</p><p><img src="../../images/sia/c5/spring%E5%86%85%E7%BD%AE%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8.png"></p><h3 id="3-2-创建-JSP-视图"><a href="#3-2-创建-JSP-视图" class="headerlink" title="3.2 创建 JSP 视图"></a>3.2 创建 JSP 视图</h3><h4 id="配置适用于-JSP-的视图解析器"><a href="#配置适用于-JSP-的视图解析器" class="headerlink" title="配置适用于 JSP 的视图解析器"></a>配置适用于 JSP 的视图解析器</h4><p>InternalResourceViewResolver</p><h4 id="使用-Spring-的-JSP-库-表单库"><a href="#使用-Spring-的-JSP-库-表单库" class="headerlink" title="使用 Spring 的 JSP 库-表单库"></a>使用 Spring 的 JSP 库-表单库</h4><p>标签库能够避免在脚本块中直接编写 Java 代码。Spring提供了两个JSP标签库，用来帮助定义Spring MVC Web的视图。其中一个标签库会用来<strong>渲染HTML表单</strong>标签，这些标签可以绑定model中的某个属性。另外一个标签库包含了一些工具类标签，我们随时都可以非常便利地使用它们。</p><p><strong>引入标签库</strong></p><pre><code class="jsp">&lt;%-- 引入Spring表单标签库 --%&gt;&lt;%@ taglib prefix=&quot;sf&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;</code></pre><p><strong>标签一览表</strong></p><p><img src="../../images/sia/c5/spring%E6%A0%87%E7%AD%BE%E5%BA%93.png"></p><p><strong>使用标签</strong></p><p>修改注册页面，进行友好提示。</p><p>直接在表单后面提示。</p><pre><code class="jsp">    &lt;%--  使用spring标签库进行校验提示。每个元素后边提示  --%&gt;    &lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot;&gt;        First Name: &lt;sf:input path=&quot;firstName&quot;/&gt;            &lt;%--展现表单校验错误--%&gt;            &lt;sf:errors path=&quot;firstName&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Last Name: &lt;sf:input path=&quot;lastName&quot;/&gt;            &lt;sf:errors path=&quot;lastName&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Email: &lt;sf:input path=&quot;email&quot; type=&quot;email&quot;/&gt;            &lt;sf:errors path=&quot;email&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Username: &lt;sf:input path=&quot;username&quot;/&gt;            &lt;sf:errors path=&quot;username&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Password: &lt;sf:password path=&quot;password&quot;/&gt;            &lt;sf:errors path=&quot;password&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;    &lt;/sf:form&gt;</code></pre><p><img src="../../images/sia/c5/%E4%BD%BF%E7%94%A8spring%E6%A0%87%E7%AD%BE%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E6%8F%90%E7%A4%BA.png"></p><p>统一提示，方便排版。</p><pre><code class="jsp">    &lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot;&gt;        &lt;sf:errors path=&quot;*&quot; element=&quot;div&quot; cssClass=&quot;error&quot;/&gt;        &lt;sf:label path=&quot;firstName&quot; cssErrorClass=&quot;error&quot;&gt;First Name&lt;/sf:label&gt; :        &lt;sf:input path=&quot;firstName&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;lastName&quot; cssErrorClass=&quot;error&quot;&gt;Last Name&lt;/sf:label&gt; :        &lt;sf:input path=&quot;lastName&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;email&quot; cssErrorClass=&quot;error&quot;&gt;Email&lt;/sf:label&gt; :        &lt;sf:input path=&quot;email&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;username&quot; cssErrorClass=&quot;error&quot;&gt;Username&lt;/sf:label&gt; :        &lt;sf:input path=&quot;username&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;password&quot; cssErrorClass=&quot;error&quot;&gt;Password&lt;/sf:label&gt; :        &lt;sf:input path=&quot;password&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;    &lt;/sf:form&gt;</code></pre><p><img src="../../images/sia/c5/%E6%A0%A1%E9%AA%8C%E9%94%99%E8%AF%AF%E7%BB%9F%E4%B8%80%E6%8F%90%E7%A4%BA.png"></p><h4 id="使用-Spring-的-JSP-库-工具库"><a href="#使用-Spring-的-JSP-库-工具库" class="headerlink" title="使用 Spring 的 JSP 库-工具库"></a>使用 Spring 的 JSP 库-工具库</h4><p><strong>引入标签库</strong></p><pre><code class="jsp">&lt;%--引入Spring工具标签库--%&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</code></pre><p><strong>标签一览表</strong></p><p><img src="../../images/sia/c5/spring%E5%B7%A5%E5%85%B7%E6%A0%87%E7%AD%BE%E4%B8%80%E8%A7%88%E8%A1%A8.png"></p><p><strong>使用标签</strong></p><p>使用<code>&lt;s:message&gt;</code>实现国际化</p><p>配置资源加载器</p><pre><code class="java">@Beanpublic MessageSource messageSource() &#123;    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    messageSource.setBasename(&quot;messages&quot;);    return messageSource;&#125;</code></pre><p>创建资源文件<code>messages.properties</code></p><pre><code class="properties">spittr.welcome=Welcome to Spittr!</code></pre><p>页面使用</p><pre><code class="jsp">&lt;h1&gt;&lt;s:message code=&quot;spittr.welcome&quot;/&gt;&lt;/h1&gt;</code></pre><h3 id="3-3-创建-Apache-Tiles-视图"><a href="#3-3-创建-Apache-Tiles-视图" class="headerlink" title="3.3 创建 Apache Tiles 视图"></a>3.3 创建 Apache Tiles 视图</h3><p>Apache Tiles 布局引擎。</p><p>配置 视图解析器</p><pre><code class="java">    /**     * 配置 TilesConfigurer     * @return     */    @Bean    public TilesConfigurer tilesConfigurer() &#123;        TilesConfigurer tiles = new TilesConfigurer();        // 指定 tile 定义的位置        tiles.setDefinitions(new String[] &#123;                &quot;/WEB-INF/**/tiles.xml&quot;        &#125;);        // 启用刷新功能        tiles.setCheckRefresh(true);        return tiles;    &#125;    /**     * 配置 tile 的视图解析器     * 查找与逻辑视图名称相匹配的 Tile 定义     * @return     */    @Bean    public ViewResolver viewResolver() &#123;        return new TilesViewResolver();    &#125;</code></pre><p>然后配置 tails.xml，然后定义模板在页面中使用即可。这里不再演示了。</p><h3 id="3-4-使用-Thymeleaf"><a href="#3-4-使用-Thymeleaf" class="headerlink" title="3.4 使用 Thymeleaf"></a>3.4 使用 Thymeleaf</h3><p>JSP 模板的问题</p><ol><li>JSP 模板采用 HTML 形式，但是参杂了各种 JSP 标签库的标签，很混乱</li><li>看起来像是 html，但是并不是，未经渲染直接打开是一场视觉灾难</li><li>JSP 规范与 Servlet 规范紧密耦合，只能用在基于 Servlet 的 Web 应用之中，不能作为通用模板，比如格式化 Email</li></ol><h4 id="配置-Thymeleaf-视图解析器"><a href="#配置-Thymeleaf-视图解析器" class="headerlink" title="配置 Thymeleaf 视图解析器"></a>配置 Thymeleaf 视图解析器</h4><ul><li>ThymeleafViewResolver：将逻辑视图名称解析为 Thymeleaf 模板视图</li><li>SpringTemplateEngine：处理模板并渲染结果</li><li>TemplateResolver：加载 Thymeleaf 模板</li></ul><pre><code class="java">    @Bean    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123;        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();        viewResolver.setTemplateEngine(templateEngine);        return viewResolver;    &#125;    @Bean    public SpringTemplateEngine templateEngine(TemplateResolver templateResolver) &#123;        SpringTemplateEngine templateEngine = new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver);        return templateEngine;    &#125;    @Bean    public TemplateResolver templateResolver() &#123;        TemplateResolver templateResolver = new ServletContextTemplateResolver();        templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);        templateResolver.setSuffix(&quot;.html&quot;);        templateResolver.setTemplateMode(&quot;HTML5&quot;);        return templateResolver;    &#125;</code></pre><h4 id="编写模板"><a href="#编写模板" class="headerlink" title="编写模板"></a>编写模板</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;title&gt;Spittr&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;          th:href=&quot;@&#123;/resources/style.css&#125;&quot;/&gt;&lt;/head&gt;&lt;body&gt;    &lt;form method=&quot;post&quot; th:object=&quot;$&#123;spitter&#125;&quot;&gt;        &lt;!--展示错误--&gt;        &lt;div class=&quot;errors&quot; th:if=&quot;$&#123;#fields.hasErrors('*')&#125;">            <ul>                <li th:each="err : $&#123;#fields.errors('*')&#125;" th:text="$&#123;err&#125;">Input is incorrect</li>            </ul>        </div>        <!--FirstName-->        <label th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'">First Name</label>        <input type="text" th:field="*&#123;firstName&#125;" th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'" /><br/>        <!--LastName-->        <label th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'">Last Name</label>        <input type="text" th:field="*&#123;lastName&#125;" th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'" /><br/>        <!--Email-->        <label th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'">Email</label>        <input type="text" th:field="*&#123;email&#125;" th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'" /><br/>        <!--Username-->        <label th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'">Username</label>        <input type="text" th:field="*&#123;username&#125;" th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'" /><br/>        <!--Password-->        <label th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'">Password</label>        <input type="text" th:field="*&#123;password&#125;" th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'" /><br/>        <input type="submit" value="Register" />    </form></body><style>    span.error &#123;        color: red;    &#125;    label.error &#123;        color: red;    &#125;    input.error &#123;        background-color: #ffcccc;    &#125;    div.error &#123;        background-color: #ffcccc;        border: 2px solid red;    &#125;</style></html>```## 4、Spring MVC 配置的替代方案### 4.1 自定义 DispatcherServlet 配置```java/** * 配置 mvc 的 DispatcherServlet */public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    @Override    protected Class<?>[] getRootConfigClasses() &#123;        return new Class[]&#123; RootConfig.class &#125;;    &#125;    @Override    protected Class<?>[] getServletConfigClasses() &#123;        return new Class[]&#123; WebConfig.class &#125;;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123; "/" &#125;;    &#125;    /**     * 配置 multipart 支持     * @param registration     */    @Override    protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;        // registration.setLoadOnStartup();        // registration.setInitParameter();        registration.setMultipartConfig(                new MultipartConfigElement("/tmp/spittr/uploads"));    &#125;&#125;```### 4.2 添加 Servlet 和 Filter继承 WebApplicationInitializer，在 onStartup 中增加相应的内容即可。```javapublic class MyServletInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        // 注册一个自定义的 servlet        ServletRegistration.Dynamic myServlet = servletContext.addServlet("myServlet", MyServlet.class);        // 映射到指定路径        myServlet.addMapping("/custom/**");    &#125;&#125;``````javapublic class MyFilterInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        FilterRegistration.Dynamic myFilter = servletContext.addFilter("myFilter", MyFilter.class);        myFilter.addMappingForUrlPatterns(null, false, "/custom/*");    &#125;&#125;``````java    /**     * 如果自定义 Filter 只映射到 DispatcherServlet 上的话，在这里返回即可。     * @return     */    @Override    protected Filter[] getServletFilters() &#123;        return new Filter[]&#123;new MyFilter()&#125;;    &#125;```## 5、处理文件上传### 5.1 配置 multipart 解析器```java    /**     * 配置 multipart 解析器     * @return     * @throws IOException     */    @Bean    public MultipartResolver multipartResolver() throws IOException &#123;        return new StandardServletMultipartResolver();    &#125;```**配置上传细节参数**```java    @Override    protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;        // registration.setLoadOnStartup();        // registration.setInitParameter();        registration.setMultipartConfig(                /**                 * 文件路径                 * 文件最大容量                 * 文件请求最大容量                 * 不缓存，直接落盘                 */                new MultipartConfigElement("D:/00_tmpdownload/tmp/", 2097152, 4194304, 0));    &#125;```### 5.2 处理 multipart 请求**修改 from 表单**- enctype="multipart/form-data"- type="file" accept="image/jpeg,image/png,image/gif"```html    <!--enctype="multipart/form-data" 告诉浏览器以 multipart 数据形式提交表单-->    <form method="post" th:object="$&#123;spitter&#125;" enctype="multipart/form-data">        <!--展示错误-->        <div class="errors" th:if="$&#123;#fields.hasErrors('*')&#125;">            <ul>                <li th:each="err : $&#123;#fields.errors('*')&#125;" th:text="$&#123;err&#125;">Input is incorrect</li>            </ul>        </div>        <!--FirstName-->        <label th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'">First Name</label>        <input type="text" th:field="*&#123;firstName&#125;" th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'" /><br/>        <!--LastName-->        <label th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'">Last Name</label>        <input type="text" th:field="*&#123;lastName&#125;" th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'" /><br/>        <!--Email-->        <label th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'">Email</label>        <input type="text" th:field="*&#123;email&#125;" th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'" /><br/>        <!--Username-->        <label th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'">Username</label>        <input type="text" th:field="*&#123;username&#125;" th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'" /><br/>        <!--Password-->        <label th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'">Password</label>        <input type="text" th:field="*&#123;password&#125;" th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'" /><br/>        <!--ProfilePicture-->        <label>Profile Picture</label>        <input type="file" name="profilePicture" accept="image/jpeg,image/png,image/gif"/><br/>        <input type="submit" value="Register" />    </form>```**使用 MutipartFile 接口接收图片数据**```java    /**     * 执行注册     * @RequestPart 接收图片     * @param spitter     * @return     */    @RequestMapping(value = "/register", method = RequestMethod.POST)    public String processRegister(@RequestPart("profilePicture") MultipartFile profilePicture,                                  @Valid Spitter spitter, Errors errors) throws IOException &#123;        if (errors.hasErrors()) &#123;            return "registerForm";        &#125;        // 把图片保存到指定位置        profilePicture.transferTo(new File("D:/00_tmpdownload/spittr/" + profilePicture.getOriginalFilename()));        // 保存 spitter        spitterRepository.save(spitter);        // 重定向到基本信息页，防止用户重复提交        return "redirect:/spitter/" + spitter.getUsername();    &#125;```**MultipartFile 接口详情**```javapublic interface MultipartFile &#123;String getName();String getOriginalFilename();String getContentType();boolean isEmpty();long getSize();byte[] getBytes() throws IOException;InputStream getInputStream() throws IOException;void transferTo(File dest) throws IOException, IllegalStateException;&#125;```**也可使用 javax.servlet.http.Part 接口接收**该接口和 MultipartFile 接口类似。但是使用这个接口就不用配置 MultipartResolver 了。你丫不早说。。。**图片上传云端**## 6、在控制器中处理异常Spring 提供了多种方式将异常转换为响应：- 特定的 Spring 异常将会自动映射为指定的 HTTP 状态码- 异常上可以添加 @ResponseStatus 注解，从而将其映射为某一个 HTTP 状态码- 在方法上可以添加 @ExceptionHandler 注解，使其用来处理异常### 6.1 将异常映射为 HTTP 状态码![](../../images/sia/c5/Spring默认异常映射.png)自己映射```java/** * 使用 @ResponseStatus 将异常映射为指定 http 响应码 */@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Spitter Not Found")public class SpitterNotFoundException extends RuntimeException&#123;&#125;```### 6.2 编写异常处理的方法```java    @RequestMapping(value = "/register", method = RequestMethod.POST)    public String processRegister(@RequestPart("profilePicture") MultipartFile profilePicture,                                  @Valid Spitter spitter, Errors errors) throws IOException &#123;        if (errors.hasErrors()) &#123;            return "registerForm";        &#125;        // 把图片保存到指定位置        profilePicture.transferTo(new File("D:/00_tmpdownload/spittr/" + profilePicture.getOriginalFilename()));        try &#123;            // 保存 spitter            spitterRepository.save(spitter);            // 重定向到基本信息页，防止用户重复提交            return "redirect:/spitter/" + spitter.getUsername();        &#125; catch (DuplicateSpitterException e) &#123;            return "error/duplicate";        &#125;    &#125;```这么处理异常导致同一个方法有两条路线，不易测试。异常代码也业务代码混杂。所以我们可以用**ExceptionHandler**注解抽取统一的处理方法```java    /**     * 这个 Controller 中所有的 DuplicateSpitterException 异常都会来这里     * @return     */    @ExceptionHandler(DuplicateSpitterException.class)    public String handleDuplicateSpitter() &#123;        return "error/duplicate";    &#125;```### 6.3 为控制器添加通知任意带有**@ControllerAdvice**注解的类，这个类会包含一个或多个如下类型的方法：- @ExceptionHandler注解标注的方法；- @InitBinder注解标注的方法；- @ModelAttribute注解标注的方法。这些方法作用于整个应用程序所有控制器中带有**@RequestMapping注解**的方法上。例子：定义统一异常处理类```java@ControllerAdvicepublic class AppWideExceptionHandler &#123;    @ExceptionHandler(DuplicateSpitterException.class)    public String handleDuplicateSpitter() &#123;        return "error/duplicate";    &#125;&#125;```## 7、跨重定向请求传递数据### 7.1 通过 URL 模板进行重定向```java// 重定向到基本信息页，防止用户重复提交。而不是返回某个视图// 直接拼接字符串没有转义不安全，// return "redirect:/spitter/" + spitter.getUsername();// 向模型中塞数据，然后在请求中用占位符匹配。没有匹配到的模型数据自动添加查询参数// 结果：spitter/alvin?spitterId=42model.addAttribute("username", spitter.getUsername());model.addAttribute("spitterId", spitter.getId());return "redirect:/spitter/&#123;username&#125;";```通过 URL 只能传递简单数值，如 String 和数字。### 7.2 使用 flash 属性flash属性会一直携带这些数据直到下一次请求，然后才会消失。原理就是重定向前把 Flash 属性复制到回话中，重定向后把 Flash 属性从回话中取出放到新请求的 model 中。![](../../images/sia/c5/flash属性原理.png)```java// 向模型中塞数据，然后在请求中用占位符匹配。没有匹配到的模型数据自动添加查询参数// 结果：spitter/alvin?spitterId=42model.addAttribute("username", spitter.getUsername());model.addAttribute("spitterId", spitter.getId());// 非基础类型，使用 flash 属性。注意此时 RedirectAttributes modelmodel.addFlashAttribute("spitter", spitter);return "redirect:/spitter/&#123;username&#125;";``````java@RequestMapping(value = "/&#123;username&#125;", method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123;    // 上游已经传了 spitter 就不用查询了    if (!model.containsAttribute("spitter")) &#123;        Spitter spitter = spitterRepository.findByUsername(username);        model.addAttribute(spitter);        if (spitter == null) &#123;            throw new SpitterNotFoundException();        &#125;    &#125;    return "profile";&#125;```## 8、使用 Spring Web Flow- 创建回话式的 Web 应用程序- 定义流程状态和行为- 保护 Web 流程Spring Web Flow 是一个 Web 框架，它适用于元素按规定流程运行的程序。**流程与实现分开**。Spring Web Flow 是 Spring MVC 的扩展，它支持开发基于流程的应用程序。它将**流程的定义与****实现流程行为的类和视图分离开来**。### 8.1 在 Spring 中配置 Web Flow#### 装配流程执行器#### 配置流程注册表#### 处理流程请求#### 响应流程请求一切尽在这个 flow.xml 文件中配置：```xml<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:flow="http://www.springframework.org/schema/webflow-config" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/webflow-config    http://www.springframework.org/schema/webflow-config/spring-webflow-config-2.3.xsd   http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.0.xsd">  <context:component-scan base-package="com.sia.pizza.flow" />  <!-- 配置流程执行器 -->  <flow:flow-executor id="flowExecutor" />  <!-- 配置流程注册表。-->  <!-- 从/WEB-INF/flows目录找流程定义；        任何以 -flow.xml 结尾的都认为是流程定义；        所有流程通过ID引用。**所代表的路径就是流程ID-->  <flow:flow-registry id="flowRegistry" base-path="/WEB-INF/flows">     <flow:flow-location-pattern value="/**/*-flow.xml" />     <!--显示声明流程定义文件的位置。此时流程ID从文件名获取，就是springpizza；         或者也可以显示定义ID，如 id="pizza"-->      <!--<flow:flow-location path="/WEB-INF/flows/springpizza.xml" />-->  </flow:flow-registry>  <!--FlowHandlerMapping 处理流程请求。将流程请求发送给Spring Web Flow-->  <bean class="org.springframework.webflow.mvc.servlet.FlowHandlerMapping">    <!-- 装配了注册表，所以知道如何将请求的 URL 匹配到流程上 -->    <property name="flowRegistry" ref="flowRegistry" />  </bean>  <!--   FlowHandlerAdapter 响应流程请求。   是 DispatcherServlet 和 Spring Web Flow 之间的桥梁。  -->  <bean class="org.springframework.webflow.mvc.servlet.FlowHandlerAdapter">    <property name="flowExecutor" ref="flowExecutor" />  </bean></beans>```### 8.2 流程组件- 状态：业务执行逻辑- 转移：通过转移从一个状态到另外一个- 流程数据：流程的当前状况#### 状态Spring Web Flow 定义了五种不同类型的状态。![](../../images/sia/c5/流程的5种状态.png)**视图状态**`<view-state id="welcome" />` 定义了一个 id 和逻辑视图名都为 weblcome 的视图状态。`<view-state id="welcome" view="greeting" />`另外指定视图名。`<view-state id="takePayment" model="flowScope.paymentDetails" />` 当然也可绑定模型数据。**行为状态**视图状态会涉及到流程应用程序的用户，而行为状态则是应用程序自身在执行任务。行为状态一般会触发 Spring 所管理 bean 的一些方法并根据方法调用的执行结果转移到另一个状态。定义行为状态：```xml<action-state id="saveOrder"><evaluate expression="pizzaFlowActions.saveOrder(order)" />    <transition to="thankYou" /></action-state>```**决策状态**用来处理流程的分支情况。决策状态能够在流程执行时产生两个分支。定义决策状态：```xml<decision-state id="checkDeliveryArea"><if test="pizzaFlowActions.checkDeliveryArea(customer.zipCode)"        then="addCustomer"        else="deliveryWarning" /></decision-state>```**子流程状态**一个流程中调用另外一个流程。定义子流程状态：```xml<subflow-state id="order" subflow="pizza/order">    <!--传递订单对象作为子流程的输入--><input name="order" value="order" />    <!--如果子流程的结束状态ID为 orderCreated，那么流程将会转移到名为 payment 的状态-->    <transition on="orderCreated" to="payment" /></subflow-state>```**结束状态**定义流程结束状态：`<end-state id="customerReady" />`- 如果是子流程，执行父流程- 如果设置了 view，渲染视图- 如果都不是，仅仅结束#### 转移处理结束状态之外，其他每个状态至少都需要有一个转移。一个状态可能有多个转移，表示不同路径。- on：触发点- to：转移到- on-exception：异常时**全局转移**```xml<global-transitions><transition on="cancel" to="endState" /></global-transitions>```#### 流程数据**声明变量**流程数据保存在变量中，而变量可以在流程的各个地方进行引用。它能够以多种方式创建。在流程中创建变量的最简单形式是使用`<var>`元素。`<var name="customer" class="com.sia.pizza.domain.Customer"/>`这里，创建了一个新的Customer实例并将其放在名为customer的变量中。这个变量可以在流程的任意状态进行访问。- var：流程作用域- evaluate：作用域通过 name 或 result 属性的前缀指定- set：同上**变量的流程作用域、视图作用域**流程中携带的数据会拥有不同的生命作用域和可见性，这取决于保存数据的变量本身的作用域。Spring Web Flow定义了五种不同作用域。![](../../images/sia/c5/流程数据作用域.png)### 8.3 组合起来：披萨流程#### 定义基本流程![](../../images/sia/c5/披萨订单流程.png)```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <!-- order 变量声明，每次流程开始就新建一个 Order 实例 -->    <var name="order" class="com.sia.pizza.domain.Order"/>        <!-- 顾客子流程状态 -->    <subflow-state id="customer" subflow="pizza/customer">      <!-- 订单作为子流程的输入 -->      <input name="order" value="order"/>      <transition on="customerReady" to="order" />    </subflow-state>        <!-- 订单子流程状态 -->    <subflow-state id="order" subflow="pizza/order">      <input name="order" value="order"/>      <transition on="orderCreated" to="payment" />    </subflow-state>            <!-- 支付子流程状态 -->    <subflow-state id="payment" subflow="pizza/payment">      <input name="order" value="order"/>      <transition on="paymentTaken" to="saveOrder"/>          </subflow-state>    <!-- 保存订单行为状态 -->    <action-state id="saveOrder">        <!-- 执行保存订单行为 -->        <evaluate expression="pizzaFlowActions.saveOrder(order)" />        <transition to="thankYou" />    </action-state>    <!-- 视图状态 -->    <view-state id="thankYou">      <transition to="endState" />    </view-state>                    <!-- 结束状态 -->    <end-state id="endState" />    <!-- 全局转移 -->    <global-transitions>      <transition on="cancel" to="endState" />    </global-transitions></flow>```#### 收集顾客信息![](../../images/sia/c5/识别顾客子流程.png)```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <input name="order" required="true"/>        <!-- 视图状态-欢迎顾客 -->    <view-state id="welcome">        <transition on="phoneEntered" to="lookupCustomer"/>        <transition on="cancel" to="cancel"/>    </view-state>    <!-- 行为状态-查找顾客 -->    <action-state id="lookupCustomer">        <!-- 查找顾客，查询结果设置到订单的顾客属性上 -->        <evaluate result="order.customer" expression=            "pizzaFlowActions.lookupCustomer(requestParameters.phoneNumber)" />        <!-- 未找到顾客，跳转到注册页面 -->        <transition to="registrationForm" on-exception=            "com.sia.pizza.service.CustomerNotFoundException" />        <!-- 找到顾客，直接进入结束流程 -->        <transition to="customerReady" />    </action-state>    <!-- 视图状态-注册新顾客 -->    <view-state id="registrationForm" model="customer" popup="true" >        <on-entry>          <evaluate expression="order.customer.phoneNumber = requestParameters.phoneNumber" />        </on-entry>        <!-- 提交注册 -->        <transition on="submit" to="checkDeliveryArea" />        <transition on="cancel" to="cancel" />    </view-state>    <!-- 决策状态-检查配送区域 -->    <decision-state id="checkDeliveryArea">      <if test="pizzaFlowActions.checkDeliveryArea(order.customer.zipCode)"           then="addCustomer"           else="deliveryWarning"/>    </decision-state>    <!-- 视图状态-配送范围超出警告 -->    <view-state id="deliveryWarning">        <transition on="accept" to="addCustomer" />        <transition on="cancel" to="cancel" />    </view-state>    <!-- 行为状态-新增顾客 -->    <action-state id="addCustomer">        <evaluate expression="pizzaFlowActions.addCustomer(order.customer)" />        <transition to="customerReady" />    </action-state>                <!-- 结束状态-取消 -->    <end-state id="cancel" />    <!-- 结束状态-顾客就绪 -->    <end-state id="customerReady" /></flow>```#### 构建订单```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <input name="order" required="true" />        <!-- 视图状态-订单视图 -->    <view-state id="showOrder">        <!-- 添加披萨 -->        <transition on="createPizza" to="createPizza" />        <!-- 提交订单 -->        <transition on="checkout" to="orderCreated" />        <!-- 取消 -->        <transition on="cancel" to="cancel" />    </view-state>    <!-- 视图状态-添加披萨 -->    <view-state id="createPizza" model="flowScope.pizza">        <on-entry>          <!-- 创建披萨实例，当前流程可见 -->            <set name="flowScope.pizza"               value="new com.sia.pizza.domain.Pizza()" />          <!-- 获取配料列表，当前视图状态可见 -->          <evaluate result="viewScope.toppingsList"               expression="T(com.sia.pizza.domain.Topping).asList()" />        </on-entry>        <transition on="addPizza" to="showOrder">          <evaluate expression="order.addPizza(flowScope.pizza)" />        </transition>        <transition on="cancel" to="showOrder" />    </view-state>    <!-- 结束状态 -->    <end-state id="cancel" />    <end-state id="orderCreated" /></flow>```#### 支付```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <input name="order" required="true"/>    <!-- 视图状态-输入支付信息 -->    <view-state id="takePayment" model="flowScope.paymentDetails">        <on-entry>          <set name="flowScope.paymentDetails"              value="new com.sia.pizza.domain.PaymentDetails()" />          <evaluate result="viewScope.paymentTypeList"              expression="T(com.sia.pizza.domain.PaymentType).asList()" />        </on-entry>        <transition on="paymentSubmitted" to="verifyPayment" />        <transition on="cancel" to="cancel" />    </view-state>    <!-- 行为状态-验证支付信息 -->    <action-state id="verifyPayment">        <evaluate result="order.payment" expression=            "pizzaFlowActions.verifyPayment(flowScope.paymentDetails)" />        <transition to="paymentTaken" />    </action-state>                <!-- End state -->    <end-state id="cancel" />    <end-state id="paymentTaken" /></flow>```### 8.4 保护 Web 流程结合 Spring Security 保护 Spring Web Flow 中的状态、转移甚至整个流程。```xml<view-state id="restricted"><secured attributes="ROLE_ADMIN" match="all"/></view-state>```match:- all：必须全部满足- any：满足一个即可## 9、保护 Web 应用- Spring Security 介绍- 使用 Servlet 规范中的 Filter 保护 Web 应用- 基于数据口和 LDAP 进行认证### 9.1 Spring Security 简介Spring Security 是为基于 Spring 的应用程序提供声明式安全保护的安全性框架。Spring Security 提供了完整的安全性解决方案，它能够在 **Web 请求级别和方法调用级别**处理身份认证和授权。因为基于Spring框架，所以 Spring Security 充分利用了依赖注入（dependency injection，DI）和面向切面的技术。最新版本为 3.2，Spring Security 从两个角度来解决安全性问题。它使用 **Servlet 规范中的 Filter 保护 Web 请求并限制URL级别的访问**。Spring Security 还能够**使用 Spring AOP 保护方法调用**——借助于**对象代理和使用通知**，能够确保只有具备适当权限的用户才能访问安全保护的方法。> 可以实现 Web 请求级别和方法级别的身份认证和授权>> 请求级别基于 Filter 实现；方法级别使用 AOP 实现#### Spring Security 的 11 个模块![](../../images/sia/c5/springsecurity模块.png)至少需要 Core 和 Configuration 两个模块。#### 过滤 Web 请求**在 xml 中配置**Spring Security 借助一系列 Servlet Filter 来提供各种安全性功能。但是我们不用在 web.xml 中配置多个 Filter，只需要配置 **DelegatingFilterProxy** 就行，他会把工作委托给各个自定义 Filter。**DelegatingFilterProxy**  的 filter-name 配置为 springSecurityFilterChain，所以 **DelegatingFilterProxy** 会将过滤逻辑委托给 springSecurityFilterChain。```xml<filter><filter-name>springSecurityFilterChain</filter-name>    <filter-class>    org.springframework.web.filter.DelegatingFilterProxy    </filter-class></filter>```**在 Java 中配置**只需创建一个新类，继承`AbstractSecurityWebApplicationInitializer`即可，他会自动注册`DelegatingFilterProxy`。```javapublic class SecurityWebInitializer        extends AbstractSecurityWebApplicationInitializer &#123;&#125;```#### 编写简单的安全配置Spring Security 必须配置在一个实现了 WebSecurityConfigurer 的 bean 中，或者扩展 WebSecurityConfigurerAdapter。**@EnableWebSecurity** 可以启用任意 Web 应用的安全性功能。如果碰巧使用 Spring MVC 开发，应该使用 **@EnableWebMvcSecurity** 代替。@EnableWebMvcS ecurity 额外配置了一个 Spring MVC 参数解析器，这样处理器方法就能够通过带有 **@AuthenticationPrincipal** 注解的参数获得认证用户的 principal（或 username）。另外还配置了一个 bean，在使用 Spring 表单绑定标签库来定义表单时，这个 bean 会自动添加一个隐藏的跨站请求伪造（cross-site request forgery，CSRF）token 输入域。```java@Configuration// 启用 Web 安全性// @EnableWebSecurity// 启用 Spring MVC 安全性@EnableWebMvcSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125;```可以通过重载 WebSecurityConfigurerAdapter 中的三个 **configure()** 方法来配置 Web 安全性。| 方法                                    | 描述                                        || --------------------------------------- | ------------------------------------------- || configure(WebSecurity)                  | 通过重载，配置 Spring Security 的 Filter 链 || configure(HttpSecurity)                 | 通过重载，配置如何通过拦截器保护请求        || configure(AuthenticationManagerBuilder) | 通过重载，配置 user-detail 服务             |**默认配置**```javahttp    .authorizeRequests()    // 所有请求需要认证    .anyRequest().authenticated()    .and()    // 配置支持基于表单的登录    .formLogin()    .and()    // 配置支持基于 HTTP Basic 方式的认证    .httpBasic();```由于我们没有重载 configure(AuthenticationManagerBuilder) 方法，所以没有用户存储支撑认证过程，所以没用用户，但是默认所有请求都需要认证，所以没有人能够登录成功。所以我们还需要如下配置：- 配置用户存储- 指定哪些请求需要认证，哪些不需要，以及所需要的的权限- 提供一个自定义的登录页面，替代原来简单的默认登录页### 9.2 选择查询用户详细信息的服务#### 基于内存的用户存储```java    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth                // 启用内存用户存储                .inMemoryAuthentication()                .withUser("user").password("pass9876").roles("USER").and()                .withUser("admin").password("pass9876").roles("USER","ADMIN");    &#125;```**用户详细信息配置一览表**![](../../images/sia/c5/用户配置.png)#### 基于数据库表进行认证```java        auth                // 启用数据库用户存储                .jdbcAuthentication()                .dataSource(dataSource)                // 自定义用户查询，因为实际中数据表很可能和默认的不一样                .usersByUsernameQuery("select username, password, true from Spitter where username = ?")                .authoritiesByUsernameQuery("select username, 'ROLE_USER', from Spitter where username = ?")                // 密码转码                .passwordEncoder(new StandardPasswordEncoder("123456"));```#### 基于 LDAP 进行认证```java        auth                .ldapAuthentication()                .userSearchBase("ou=people")                .userSearchFilter("&#123;uid=&#123;0&#125;&#125;&quot;)                .groupSearchBase(&quot;ou=groups&quot;)                .groupSearchFilter(&quot;member=&#123;0&#125;&quot;)                .passwordCompare()                .passwordEncoder(new Md5PasswordEncoder())                .passwordAttribute(&quot;passcode&quot;)                .and()                .contextSource()                // 配置 LDAP 服务器                // .url(&quot;ldap://monkey-kong.com:389/db=alvin,dc=com&quot;)                // 使用嵌入式服务器                .root(&quot;dc=alvin,dc=com&quot;)                // 指定LDAP服务器从类路径根目录下的users.ldif文件中加载内容                .ldif(&quot;classpath:users.ldif&quot;)        ;</code></pre><h4 id="配置自定的用户服务"><a href="#配置自定的用户服务" class="headerlink" title="配置自定的用户服务"></a>配置自定的用户服务</h4><p>提供一个自定义的 <strong>UserDetailsService</strong> 接口实现</p><pre><code class="java">/** * 自定义 spring security 用户服务 */public class SpitterUserService implements UserDetailsService &#123;    private final SpitterRepository spitterRepository;    public SpitterUserService(SpitterRepository spitterRepository) &#123;        this.spitterRepository = spitterRepository;    &#125;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        Spitter spitter = spitterRepository.findByUsername(username);        if (spitter != null) &#123;            List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();            authorities.add(new SimpleGrantedAuthority(&quot;ROLE_SPITTER&quot;));            return new User(spitter.getUsername(), spitter.getPassword(), authorities);        &#125;        throw  new UsernameNotFoundException(&quot;User &#39;&quot; + username + &quot;&#39; not found.&quot; );    &#125;&#125;</code></pre><p>配置</p><pre><code class="java">// 使用自定义用户服务auth.userDetailsService(new SpitterUserService(spitterRepository));</code></pre><h3 id="9-3-拦截请求"><a href="#9-3-拦截请求" class="headerlink" title="9.3 拦截请求"></a>9.3 拦截请求</h3><pre><code class="java">    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()                .antMatchers(&quot;/spitters/me&quot;).authenticated()                .antMatchers(HttpMethod.POST, &quot;/spittles&quot;).authenticated()                // 其他所有请求不需要认证和权限                .anyRequest().permitAll()                ;    &#125;</code></pre><p><strong>配置一览表</strong></p><p><img src="../../images/sia/c5/%E8%B7%AF%E5%BE%84%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.png"></p><p>增加角色配置</p><pre><code class="java">        http.authorizeRequests()                .antMatchers(&quot;/spitters/me&quot;)                .hasRole(&quot;SPITTER&quot;)                .antMatchers(HttpMethod.POST, &quot;/spittles&quot;)                .hasAnyAuthority(&quot;ROLE_SPITTER&quot;)                // 其他所有请求不需要认证和权限                .anyRequest().permitAll()                ;</code></pre><h4 id="使用-SPEL-进行安全保护"><a href="#使用-SPEL-进行安全保护" class="headerlink" title="使用 SPEL 进行安全保护"></a>使用 SPEL 进行安全保护</h4><p>用于定制更加特殊的请求限制。比如通过 IP 地址限制，比如限制某个角色只能在星期二进行访问。</p><p><img src="../../images/sia/c5/spel%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E6%A0%A1%E9%AA%8C.png"></p><pre><code class="java">.antMatchers(&quot;/spitters/me&quot;).access(&quot;hasRole(&#39;ROLE_SPITTER&#39;) and hasIpAddress(&#39;192.168.1.2&#39;)&quot;)</code></pre><h4 id="强制通道的安全性"><a href="#强制通道的安全性" class="headerlink" title="强制通道的安全性"></a>强制通道的安全性</h4><pre><code class="java">.and()    // 指定哪些请求需要走安全通道（https），哪些不需要    .requiresChannel()    .antMatchers(&quot;/spitter/form&quot;).requiresSecure()    .antMatchers(&quot;/&quot;).requiresInsecure()</code></pre><h4 id="防止跨站请求伪造"><a href="#防止跨站请求伪造" class="headerlink" title="防止跨站请求伪造"></a>防止跨站请求伪造</h4><p>如果一个站点欺骗用户提交请求到其他服务器的话，就会发生 CSRF 攻击，这可能会带来消极的后果。尽管提交“I’m stupid!”这样的信息到微博站点算不上什么 CSRF 攻击的最糟糕场景，但是你可以很容易想到更为严重的攻击情景，它可能会对你的银行账号执行难以预期的操作。</p><p>Spring Security通过一个同步 token 的方式来实现 CSRF 防护的功能。它将会拦截状态变化的请求（例如，非GET、HEAD、OPTIONS 和 TRACE 的请求）并检查 CSRF token。如果请求中不包含 CSRF token 的话，或者token 不能与服务器端的 token 相匹配，请求将会失败，并抛出 CsrfException 异常。</p><p><strong>Thymeleaf</strong></p><p>如果使用 Thymeleaf 作为页面模板，只要 form 标签的 action 添加 Thymeleaf 命名空间前缀，那么就会自动生成一个 “_csrf” 隐藏域。</p><pre><code class="html">&lt;form method=&quot;POST&quot; th:action=&quot;@&#123;/spittles&#125;&quot;&gt;    ...&lt;/form&gt;</code></pre><p><strong>JSP</strong></p><p>手动增加一个隐藏域。</p><pre><code class="html">&lt;input type=&quot;hidden&quot; name=&quot;$&#123;_csrf.parameterName&#125;&quot; value=&quot;$&#123;_csrf.token&#125;&quot; /&gt;</code></pre><p>如果使用了 Spring 的表单绑定标签， <code>&lt;sf:form&gt;</code>标签也会自动帮我们添加隐藏的 CSRF token 标签。</p><p>处理 CSRF 的另一种方式就是根本不去处理它，直接禁用掉，但是会有 CSRF 攻击的风险。</p><pre><code class="java">// 禁用 CSRF 防护功能http.csrf.disabled;</code></pre><h3 id="9-4-认证用户"><a href="#9-4-认证用户" class="headerlink" title="9.4 认证用户"></a>9.4 认证用户</h3><h4 id="添加自定义的登录页"><a href="#添加自定义的登录页" class="headerlink" title="添加自定义的登录页"></a>添加自定义的登录页</h4><pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;  &lt;head&gt;    &lt;title&gt;Spitter&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot;           type=&quot;text/css&quot;           th:href=&quot;@&#123;/resources/style.css&#125;&quot;&gt;&lt;/link&gt;  &lt;/head&gt;  &lt;body onload=&#39;document.f.username.focus();&#39;&gt;      &lt;div id=&quot;header&quot; th:include=&quot;page :: header&quot;&gt;&lt;/div&gt;      &lt;div id=&quot;content&quot;&gt;          &lt;a th:href=&quot;@&#123;/spitter/register&#125;&quot;&gt;注册&lt;/a&gt;          &lt;form name=&#39;f&#39; th:action=&#39;@&#123;/login&#125;&#39; method=&#39;POST&#39;&gt;               &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;用户名:&lt;/td&gt;                    &lt;td&gt;&lt;input type=&#39;text&#39; name=&#39;username&#39; value=&#39;&#39; /&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;密码:&lt;/td&gt;                    &lt;td&gt;&lt;input type=&#39;password&#39; name=&#39;password&#39;/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=&#39;2&#39;&gt;                        &lt;input id=&quot;remember_me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt;                        &lt;label for=&quot;remember_me&quot; class=&quot;inline&quot;&gt;记住我&lt;/label&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=&#39;2&#39;&gt;                        &lt;input name=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Login&quot;/&gt;                    &lt;/td&gt;                &lt;/tr&gt;               &lt;/table&gt;          &lt;/form&gt;      &lt;/div&gt;      &lt;div id=&quot;footer&quot; th:include=&quot;page :: copy&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="启用-HTTP-Basic-认证"><a href="#启用-HTTP-Basic-认证" class="headerlink" title="启用 HTTP Basic 认证"></a>启用 HTTP Basic 认证</h4><p>对于应用程序的人类用户来说，基于表单的认证是比较理想的。但是当应用程序的使用者是另外一个应用程序的<br>话，使用表单来提示登录的方式就不太适合了。</p><pre><code class="java">// 启用 httpBasic.httpBasic()    // 指定域    .realmName(&quot;Spittr&quot;)</code></pre><p>如何测试？</p><h4 id="启用-Remember-me-功能"><a href="#启用-Remember-me-功能" class="headerlink" title="启用 Remember-me 功能"></a>启用 Remember-me 功能</h4><pre><code class="java">.rememberMe()    .tokenValiditySeconds(2419200)    .key(&quot;spittrKey&quot;)</code></pre><p>存储在 cookie 中的 token 包含用户名、密码、过期时间和一个私钥——在写入 cookie 前都进行了 MD5 哈希。默认情况下，私钥的名为 SpringSecured，但在这里我们将其设置为 spitterKey，使它专门用于 Spittr 应用。</p><p>登录请求必须包含一个名为<strong>remember-me</strong>的参数。</p><pre><code class="html">&lt;input id=&quot;remember_me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt;&lt;label for=&quot;remember_me&quot; class=&quot;inline&quot;&gt;记住我&lt;/label&gt;</code></pre><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>退出功能是通过 Servlet 容器中的 Filter 实现的（默认情况下），这个 Filter 会拦截针<br>对“/logout”的请求。退出后，所有的 remember-me token 都会被清除掉。</p><pre><code class="html">&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;登出&lt;/a&gt;</code></pre><pre><code class="java">// 设置登出相关操作.logout()    .logoutSuccessUrl(&quot;/&quot;)</code></pre><h3 id="9-5-保护视图"><a href="#9-5-保护视图" class="headerlink" title="9.5 保护视图"></a>9.5 保护视图</h3><p>上面是发起请求时，校验是否登录以及登录人是否有操作权限。换个角度，我们可以不给用户显示其无权访问的连接。</p><h4 id="使用-Spring-Security-的-JSP-标签库"><a href="#使用-Spring-Security-的-JSP-标签库" class="headerlink" title="使用 Spring Security 的 JSP 标签库"></a>使用 Spring Security 的 JSP 标签库</h4><p><img src="../../images/sia/c5/SpringSecurityJSP%E6%A0%87%E7%AD%BE%E5%BA%93.png"></p><h4 id="使用-Thymeleaf-的-Spring-Security-方言"><a href="#使用-Thymeleaf-的-Spring-Security-方言" class="headerlink" title="使用 Thymeleaf 的 Spring Security 方言"></a>使用 Thymeleaf 的 Spring Security 方言</h4><p><img src="../../images/sia/c5/thymeleafsecurity%E6%96%B9%E8%A8%80.png"></p><p><strong>模板引擎中注册安全方言</strong></p><pre><code class="java">@Beanpublic SpringTemplateEngine templateEngine(TemplateResolver templateResolver) &#123;    SpringTemplateEngine templateEngine = new SpringTemplateEngine();    templateEngine.setTemplateResolver(templateResolver);    // 注册安全方言    templateEngine.addDialect(new SpringSecurityDialect());    return templateEngine;&#125;</code></pre><p><strong>在模板中生命安全方言命名空间</strong></p><pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;      xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3&quot;&gt;</code></pre><p><strong>在模板中使用</strong></p><pre><code class="html">&lt;!-- 条件渲染 --&gt;&lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;    &lt;!-- 渲染认证对象的属性 --&gt;    Hello there...&lt;span sec:authentication=&quot;name&quot;&gt;user-name&lt;/span&gt;&lt;/div&gt;&lt;!-- 基于URL权限来渲染，这样就不用页面和url拦截写两份相同的控制了 --&gt;&lt;span sec:authorize-url=&quot;/admin&quot;&gt;    &lt;br/&gt; &lt;a th:href=&quot;@&#123;/admin&#125;&quot;&gt;Admin&lt;/a&gt;&lt;/span&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;书中的代码是用 Grandle 构建，怎么跑起来是个问题。记录一下采坑过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>第 4 章 面向切面的 Spring</title>
    <link href="http://yoursite.com/2020-12-24-13Spring%E5%9F%BA%E7%A1%80/20191026sia4.html"/>
    <id>http://yoursite.com/2020-12-24-13Spring%E5%9F%BA%E7%A1%80/20191026sia4.html</id>
    <published>2020-12-24T14:13:12.000Z</published>
    <updated>2020-12-27T15:18:50.488Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面向切面编程的基本原理</li><li>通过 POJO 创建切面</li><li>使用 @AspectJ 注解</li><li>为 AspectJ 切面注入依赖</li></ul><p>在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把<strong>这些横切关注点与业务逻辑相分离</strong>正是面向切面编程（AOP）所要解决的问题。</p><p>在第2章，我们介绍了如何使用依赖注入（DI）管理和配置我们的应用对象。DI有助于应用<br>对象之间的解耦，而 AOP 可以<strong>实现横切关注点与它们所影响的对象之间的解耦</strong>。  </p><p>切面适用场景：日志、声明式事务、安全和缓存 </p><a id="more"></a><h2 id="4-1-什么是面向切面编程"><a href="#4-1-什么是面向切面编程" class="headerlink" title="4.1 什么是面向切面编程"></a>4.1 什么是面向切面编程</h2><p>在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要<br>以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</p><h3 id="定义-AOP-术语"><a href="#定义-AOP-术语" class="headerlink" title="定义 AOP 术语"></a>定义 AOP 术语</h3><ol><li>通知（advice）</li></ol><p>切面要完成的工作就是通知。通知定义了切面要做什么以及什么时候做。Spring 切面有 5 个类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul><ol start="2"><li>切点（pointcut）</li></ol><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些 AOP 框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p><ol start="3"><li>连接点（join point）</li></ol><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><ol start="4"><li>切面（Aspect）</li></ol><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</p><ol start="5"><li>引入（Introduction）</li></ol><p>引入允许我们向现有的类添加新方法或属性。</p><ol start="6"><li>织入（Weaving）</li></ol><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving,LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的。</li></ul><h3 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h3><p>Spring 提供了 4 种类型的 AOP 支持：</p><ul><li>基于代理的经典Spring AOP；</li><li>纯POJO切面；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）</li></ul><p>Spring 通知是 Java 编写的。</p><p>Spring 在运行时通知对象。</p><p>Spring 只支持方法级别的连接点。</p><h2 id="4-2-通过切点来选择连接点"><a href="#4-2-通过切点来选择连接点" class="headerlink" title="4.2 通过切点来选择连接点"></a>4.2 通过切点来选择连接点</h2><p>关于 Spring AOP 的 AspectJ 切点，最重要的一点就是 Spring 仅支持 AspectJ 切点指示器（pointcut<br>designator）的一个子集。</p><p>Spring借助AspectJ的切点表达式语言来定义Spring切面。</p><table><thead><tr><th>AspectJ 指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p>在Spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgument-Exception异常。</p><p>只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们使用其他指示器来限制所匹配的切点。</p><h3 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h3><pre><code class="java">// 设置 perform() 方法执行时触发通知@Pointcut(&quot;execution(* concert.Performance.perform(..))&quot;)// 配置的切点仅匹配concert包@Pointcut(&quot;execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*)&quot;)</code></pre><h3 id="在切点中选择-bean"><a href="#在切点中选择-bean" class="headerlink" title="在切点中选择 bean"></a>在切点中选择 bean</h3><p>Spring 还引入了一个新的 bean() 指示器，它允许我们在切点表达式中使用 bean 的 ID 来标识 bean。</p><h2 id="4-3-使用注解创建切面"><a href="#4-3-使用注解创建切面" class="headerlink" title="4.3 使用注解创建切面"></a>4.3 使用注解创建切面</h2><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><p>从演出的角度来看，观众是非常重要的，但是对演出本身的功能来讲，它并不是核心，这是一个单独的关注点。因此，将观众定义为一个切面，并将其应用到演出上就是较为明智的做法。</p><p>AspectJ提供了五个注解来定义通知</p><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><p>如果你使用JavaConfig的话，可以在配置类的类级别上通过使用 EnableAspectJAutoProxy 注解启用自动代理功能。</p><pre><code class="java">@Aspectpublic class Audience &#123;    // 定义命名的切点    @Pointcut(&quot;execution(* concert.Performance.perform(..))&quot;)    public void performance() &#123;&#125;    // 前置通知    @Before(&quot;performance()&quot;)    // @Before(&quot;execution(* concert.Performance.perform(..))&quot;)    public void silenceCellPhone() &#123;        System.out.println(&quot;Silencing cell phones&quot;);    &#125;    @Before(&quot;performance()&quot;)    public void takeSeats() &#123;        System.out.println(&quot;Taking seats&quot;);    &#125;    // 后置通知    @AfterReturning(&quot;performance()&quot;)    public void applause() &#123;        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    &#125;    // 异常通知    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund() &#123;        System.out.println(&quot;Demanding a refund&quot;);    &#125;&#125;</code></pre><p>Java 配置：</p><pre><code class="java">@Configuration// 启用 AspectJ 自动代理@EnableAspectJAutoProxy@ComponentScanpublic class ConcertConfig &#123;    @Bean    public Audience audience() &#123;        return new Audience();    &#125;&#125;</code></pre><p>XML 配置：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.0.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;  &lt;context:component-scan base-package=&quot;concert&quot;/&gt;  &lt;!-- 启用 AspectJ 自动代理 --&gt;  &lt;aop:aspectj-autoproxy /&gt;  &lt;bean class=&quot;concert.Audience&quot; /&gt;&lt;/beans&gt;</code></pre><p>不管你是使用JavaConfig还是XML，AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理，这个代理会围绕着所有该切面的切点所匹配的bean。在这种情况下，将会为Concertbean创建一个代理，Audience类中的通知方法将会在perform()调用前后执行。</p><h3 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h3><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。</p><pre><code class="java">@Around(&quot;performance()&quot;)public void watchPerformance(ProceedingJoinPoint jp) &#123;    try &#123;        System.out.println(&quot;Silencing cell phones&quot;);        System.out.println(&quot;Taking seats&quot;);        jp.proceed();        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    &#125; catch (Throwable e) &#123;        System.out.println(&quot;Demanding a refund&quot;);    &#125;&#125;</code></pre><p>需要注意的是，别忘记调用proceed()方法。如果不调这个方法的话，那么你的通知实际上会阻塞对被通知方法的调用。</p><h3 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h3><p>需求：记录每个磁道被播放的次数。<br>方法1：直接修改<code>playTrack()</code>方法，直接在每次调用的时候记录这个数量。但是，记录磁道的播放次数与播放本身是不同的关注点，因此不应该属于<code>playTrack()</code>方法。<br>方法2：创建 <code>TrackCounter</code>类，他是通知<code>playTrack()</code>方法的一个切面。</p><ol><li><p>创建切面</p><pre><code class="java">@Aspectpublic class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;&gt;(); // 切点。通知playTrack()方法，并且声明了要提供给通知方法的参数 @Pointcut(&quot;execution(* params.CompactDisc.playTrack(int)) &quot; +         &quot;&amp;&amp; args(trackNumber)&quot;) public void trackPlayed(int trackNumber) &#123; &#125; // 前置通知。参数由切点传递过来 @Before(&quot;trackPlayed(trackNumber)&quot;) public void countTrack(int trackNumber) &#123;     int currentCount = getPlayCount(trackNumber);     trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber) &#123;     return trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : 0; &#125;&#125;</code></pre><p><img src="./sia4images/%E5%A4%84%E7%90%86%E9%80%9A%E7%9F%A5%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0.png" alt="处理通知中的参数"></p></li><li><p>理解通知中参数传递<br>定义切点时，使用<code>args(trackNumber)</code>指定参数，然后该切点的通知<code>@Before(&quot;trackPlayed(trackNumber)&quot;)</code>就可以接收到指定参数了。</p></li><li><p>测试切面是否生效</p><pre><code class="java">@Autowiredprivate TrackCounter counter;</code></pre></li></ol><p>@Test<br>public void testTrackCounter() {<br>    cd.playTrack(1);<br>    cd.playTrack(2);<br>    cd.playTrack(3);<br>    cd.playTrack(3);<br>    cd.playTrack(3);<br>    cd.playTrack(3);<br>    cd.playTrack(6);<br>    cd.playTrack(7);<br>    cd.playTrack(7);</p><pre><code>assertEquals(1, counter.getPlayCount(1));assertEquals(1, counter.getPlayCount(2));assertEquals(4, counter.getPlayCount(3));assertEquals(0, counter.getPlayCount(4));assertEquals(0, counter.getPlayCount(5));assertEquals(1, counter.getPlayCount(6));assertEquals(2, counter.getPlayCount(7));</code></pre><p>}</p><pre><code>### 通过注解引入新功能目前我们还没有为对象增加任何新的方法，但是已经为对象拥有的方法添加了新功能。如果切面能够为现有的方法增加额外的功能，为什么不能为一个对象增加新的方法呢？实际上，利用被称为引入的 AOP 概念，切面可以为 Spring bean 添加新方法。通过切面为 Spring bean 添加新方法步骤。1. 定义需要额外实现的接口2. 声明切面，使用 @DeclareParents 注解将该接口应用到需要扩展的 Spring bean3. 将切面注入到 Spring 容器具体实现：1. 定义 Encoreable 接口    ```java    public interface Encoreable &#123;        void performEncore();    &#125;    ```2. 将这个接口应用到Performance实现中假设你能够访问Performance的所有实现，并对其进行修改，让它们都实现Encoreable接口。但是，从设计的角度来看，这并不是最好的做法，并不是所有的Performance都是具有Encoreable特性的。另外一方面，有可能无法修改所有的Performance实现，当使用第三方实现并且没有源码的时候更是如此。借助于 AOP 的引入功能，我们可以不必在设计上妥协或者侵入性地改变现有的实现就可以实现该功能。定义 EncoreableIntroducer 切面。该切面并没有像之前那样提供前置、后置或环绕通知，而是通过 @DeclareParents 注解，将 Encoreable 接口引入到 Performance benan 中。```java@Aspectpublic class EncoreableIntroducer &#123;    @DeclareParents(value = &quot;concert.Performance+&quot;, defaultImpl = DefaultEncoreable.class)    public static Encoreable encoreable;&#125;</code></pre><p>@DeclareParents 注解由三部分组成：</p><p>​    value：指定那种类型的 bean 要引入该接口。在本例中，就是所有实现 Performance 的类型。（标记符后面的加号表示是Performance的所有子类型，而不是Performance本身。）</p><p>​    defaultImpl：指定了为引入功能提供的实现类。在这里我们指定 DefaultEncoreable 提供实现。</p><p>​    @DeclareParents 注解所标注的静态属性指明了要引入的接口。贼这里我们所引入的是 Encoreable 接口。</p><ol start="3"><li>将 EncoreableIntroducer 切面声明为一个 bean</li></ol><pre><code class="java">@Beanpublic EncoreableIntroducer encoreableIntroducer() &#123;    return new EncoreableIntroducer();&#125;</code></pre><p>Spring 的自动代理机制将会获取到它的声明，当 Spring 发现一个 bean 使用了@Aspect 注解时，Spring 就会创建一个代理，然后将调用委托给被代理的 bean 或被引入的实现，这取决于调用的方法属于被代理的 bean 还是属于被引入的接口。</p><ol start="4"><li>测试</li></ol><pre><code class="java">@Autowiredprivate Performance performance;@Testpublic void testPerformance() &#123;    // performance.perform();    Encoreable encoreable = (Encoreable)performance;    encoreable.performEncore();    assertEquals(&quot;Default encoreable\r\n&quot;, log.getLog());&#125;</code></pre><p>其实有点没明白。这和我自定定义接口实现然后调用有啥区别？</p><h3 id="通过注解声明切面劣势"><a href="#通过注解声明切面劣势" class="headerlink" title="通过注解声明切面劣势"></a>通过注解声明切面劣势</h3><p>面向注解的切面声明有一个明显的劣势：你必须能够为通知类添加注解。为了做到这一点，必须要有源码。如果没有源码，或者不想将AspectJ注解放到你的代码之中，Spring为切面提供了另外一种可选方案，那就是在 xml 配置文件中声明切面。</p><h2 id="4-4-在-XML-中声明切面"><a href="#4-4-在-XML-中声明切面" class="headerlink" title="4.4 在 XML 中声明切面"></a>4.4 在 XML 中声明切面</h2><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面。</p><table><thead><tr><th>AOP 配置元素</th><th>用途</th></tr></thead><tbody><tr><td>&lt;aop:advisor&gt;</td><td>定义AOP通知器</td></tr><tr><td>&lt;aop:after&gt;</td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>&lt;aop:after-returning&gt;</td><td>定义返回通知</td></tr><tr><td>&lt;aop:after-throwing&gt;</td><td>定义异常通知</td></tr><tr><td>&lt;aop:around&gt;</td><td>定义环绕通知</td></tr><tr><td>&lt;aop:aspect&gt;</td><td>定义一个切面</td></tr><tr><td>&lt;aop:aspect-autoproxy&gt;</td><td>启用@Aspect注解驱动切面</td></tr><tr><td>&lt;aop:before&gt;</td><td>定义前置通知</td></tr><tr><td>&lt;aop:config&gt;</td><td>顶层AOP配置元素</td></tr><tr><td>&lt;aop:declare-parents&gt;</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>&lt;aop:pointcut&gt;</td><td>定义一个切点</td></tr></tbody></table><p>我们重新看一下 Audience 类，这一次我们将它所有的AspectJ注解全部移除掉：</p><pre><code class="java">public class Audience &#123;    public void silenceCellPhone() &#123;        System.out.println(&quot;Silencing cell phones&quot;);    &#125;    public void takeSeats() &#123;        System.out.println(&quot;Taking seats&quot;);    &#125;    public void applause() &#123;        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    &#125;    public void demandRefund() &#123;        System.out.println(&quot;Demanding a refund&quot;);    &#125;    public void watchPerformance(ProceedingJoinPoint jp) &#123;        try &#123;            System.out.println(&quot;Silencing cell phones&quot;);            System.out.println(&quot;Taking seats&quot;);            jp.proceed();            System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);        &#125; catch (Throwable e) &#123;            System.out.println(&quot;Demanding a refund&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="声明前置和后置通知"><a href="#声明前置和后置通知" class="headerlink" title="声明前置和后置通知"></a>声明前置和后置通知</h3><p>在&lt;aop:config&gt;元素内，我们可以声明一个或多个通知器、切面或者切点。</p><pre><code class="xml">&lt;!-- 顶层元素 --&gt;&lt;aop:config&gt;    &lt;!-- 定义切面 audience --&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!-- 定义切点 performance --&gt;        &lt;aop:pointcut id=&quot;performance&quot; expression=&quot;execution(* concert.Performance.perform(..))&quot; /&gt;        &lt;!-- 配置通知 --&gt;        &lt;aop:before method=&quot;silenceCellPhone&quot; pointcut-ref=&quot;performance&quot; /&gt;        &lt;aop:before method=&quot;takeSeats&quot; pointcut-ref=&quot;performance&quot; /&gt;        &lt;aop:after-returning method=&quot;applause&quot; pointcut-ref=&quot;performance&quot; /&gt;        &lt;aop:after-throwing method=&quot;demandRefund&quot; pointcut-ref=&quot;performance&quot; /&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h3 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h3><p>如果不使用成员变量存储信息的话，在前置通知和后置通知之间共享信息非常麻烦。例如，假设除了进场关闭手机和表演结束后鼓掌，我们还希望观众确保一直关注演出，并报告每个参赛者表演了多长时间。使用前置通知和后置通知实现该功能的唯一方式是在前置通知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话我们必须在一个成员变量中保存开始时间。因为Audience是单例的，如果像这样保存状态的话，将会存在<strong>线程安全</strong>问题。</p><p>使用环绕通知，可以完美的解决此问题。</p><pre><code class="xml">&lt;aop:around method=&quot;watchPerformance&quot; pointcut-ref=&quot;performance&quot; /&gt;</code></pre><h3 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h3><pre><code class="xml">&lt;bean id=&quot;trackCounter&quot; class=&quot;params.TrackCounter&quot; /&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot;            expression=&quot;execution(* params.CompactDisc.playTrack(int)) and args(trackNumber)*&quot; /&gt;        &lt;aop:before method=&quot;countTrack&quot; pointcut-ref=&quot;trackPlayed&quot; /&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h3 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h3><pre><code class="xml">&lt;aop:aspect&gt;    &lt;aop:declare-parents        types-matching=&quot;concert.Performance+&quot;        implement-interface=&quot;concert.Encoreable&quot;        default-impl=&quot;concert.DefaultEncoreable&quot;    /&gt;&lt;/aop:aspect&gt;</code></pre><h2 id="4-5-注入-AspectJ-切面"><a href="#4-5-注入-AspectJ-切面" class="headerlink" title="4.5 注入 AspectJ 切面"></a>4.5 注入 AspectJ 切面</h2><p>虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP 是一个功能比较弱的AOP解决方案。AspectJ提供了Spring AOP所不能支持的许多类型的切点。</p><p>例如，当我们需要在创建对象时应用通知，构造器切点就非常方便。不像某些其他面向对象语言中的构造器，Java构造器不同于其他的正常方法。这使得Spring基于代理的AOP无法把通知应用于对象的创建过程。</p><p>为了演示，我们为上面的演出创建一个新切面。具体来讲，我们以切面的方式创建一个评论员的角色，他会观看演出并且会在演出之后提供一些批评意见。下面的CriticAspect 就是一个这样的切面。</p><ol><li>定义切面 CriticAspect</li></ol><pre><code class="java">public aspect CriticAspect &#123;    private CriticismEngine criticismEngine;    pointcut performance():execution(* concert.Performance.perform(..));    pointcut construct():execution(concert.CriticismEngineImpl.new());    after():performance()&#123;        System.out.println(criticismEngine.getCriticism());    &#125;    after():construct()&#123;        System.out.println(&quot;After Performance constructor&quot;);    &#125;    before():construct()&#123;        System.out.println(&quot;Before Performance constructor&quot;);    &#125;    public CriticismEngine getCriticismEngine() &#123;        return this.criticismEngine;    &#125;    public void setCriticismEngine(CriticismEngine criticismEngine) &#123;        this.criticismEngine = criticismEngine;    &#125;&#125;</code></pre><p>aspect 是啥？pointcut performance() 又是啥？这看着不行 java 语法啊！</p><ol start="2"><li>定义评论引擎 CriticismEngine</li></ol><pre><code class="java">public interface CriticismEngine &#123;    String getCriticism();&#125;</code></pre><ol start="3"><li>定义并注入引擎实现</li></ol><pre><code class="java">public class CriticismEngineImpl implements CriticismEngine &#123;    private String[] criticismPool;    public CriticismEngineImpl() &#123;    &#125;    @Override    public String getCriticism() &#123;        int i = (int) (Math.random() * criticismPool.length);        return criticismPool[i];    &#125;    public void setCriticismPool(String[] criticismPool) &#123;        this.criticismPool = criticismPool;    &#125;&#125;</code></pre><pre><code class="xml">&lt;bean id=&quot;criticismEngine&quot; class=&quot;concert.CriticismEngineImpl&quot;&gt;    &lt;property name=&quot;criticismPool&quot;&gt;        &lt;list&gt;            &lt;value&gt;Worst performance ever!&lt;/value&gt;            &lt;value&gt;I laughed, I cried, then I realized I was at the wrong show.&lt;/value&gt;            &lt;value&gt;A must see show!&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ol start="4"><li>为 CriticAspect 装配 CriticismEngineImple</li></ol><p>在展示如何实现注入之前，我们必须清楚 AspectJ 切面根本不需要 Spring 就可以织入到我们的应用中。如果想使用 Spring 的依赖注入为 AspectJ 切面注入协作者，那我们就需要在 Spring 配置中把切面声明为一个 Spring 配置中的 <bean>。如下的 <bean> 声明会把 criticismEnginebean 注入到 CriticAspect 中：</p><pre><code class="xml">&lt;bean class=&quot;concert.CriticAspect&quot; factory-method=&quot;aspectOf&quot;&gt;    &lt;property name=&quot;criticismEngine&quot; ref=&quot;criticismEngine&quot; /&gt;&lt;/bean&gt;</code></pre><p>很大程度上，<bean> 的声明与我们在 Spring 中所看到的其他 <bean> 配置并没有太多的区别，但是最大的不同在于使用了factory-method属性。通常情况下，Spring bean 由 Spring 容器初始化，但是 AspectJ 切面是由 AspectJ 在运行期创建的。等到 Spring 有机会为 CriticAspect 注入 CriticismEngine 时，CriticAspect 已经被实例化了。</p><p>没懂啥意思！！！</p><p>因为 Spring 不能负责创建 CriticAspect，那就不能在 Spring 中简单地把CriticAspect 声明为一个 bean。相反，我们需要一种方式为 Spring 获得已经由AspectJ 创建的 CriticAspect 实例的句柄，从而可以注入 CriticismEngine。幸好，所有的AspectJ切面都提供了一个静态的 aspectOf() 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 factory-method 来调用asepctOf() 方法而不是调用 CriticAspect 的构造器方法。</p><p>简而言之，Spring 不能像之前那样使用 <bean> 声明来创建一个 CriticAspect实例——它已经在运行时由 AspectJ 创建完成了。Spring 需要通过 aspectOf() 工厂方法获得切面的引用，然后像 <bean> 元素规定的那样在该对象上执行依赖注入。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面向切面编程的基本原理&lt;/li&gt;
&lt;li&gt;通过 POJO 创建切面&lt;/li&gt;
&lt;li&gt;使用 @AspectJ 注解&lt;/li&gt;
&lt;li&gt;为 AspectJ 切面注入依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把&lt;strong&gt;这些横切关注点与业务逻辑相分离&lt;/strong&gt;正是面向切面编程（AOP）所要解决的问题。&lt;/p&gt;
&lt;p&gt;在第2章，我们介绍了如何使用依赖注入（DI）管理和配置我们的应用对象。DI有助于应用&lt;br&gt;对象之间的解耦，而 AOP 可以&lt;strong&gt;实现横切关注点与它们所影响的对象之间的解耦&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;切面适用场景：日志、声明式事务、安全和缓存 &lt;/p&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>第 3 章 高级装配</title>
    <link href="http://yoursite.com/2020-12-23-13Spring%E5%9F%BA%E7%A1%80/20191025sia3.html"/>
    <id>http://yoursite.com/2020-12-23-13Spring%E5%9F%BA%E7%A1%80/20191025sia3.html</id>
    <published>2020-12-23T14:13:12.000Z</published>
    <updated>2020-12-27T15:17:49.411Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="3-1-环境与-profile"><a href="#3-1-环境与-profile" class="headerlink" title="3.1 环境与 profile"></a>3.1 环境与 profile</h2><h3 id="Java-配置-profile-bean"><a href="#Java-配置-profile-bean" class="headerlink" title="Java 配置 profile bean"></a>Java 配置 profile bean</h3><pre><code class="java">@Configurationpublic class DataSourceConfig&#123;  @Bean(destroyMethod = &quot;shutdown&quot;)  @Profile(&quot;dev&quot;)  public DataSource embeddedDataSource()  &#123;    return new EmbeddedDatabaseBuilder()        .setType(EmbeddedDatabaseType.H2)        .addScript(&quot;classpath:schema.sql&quot;)        .addScript(&quot;classpath:test-data.sql&quot;)        .build();  &#125;  @Bean  @Profile(&quot;prod&quot;)  public DataSource jndiDataSource()  &#123;    JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();    jndiObjectFactoryBean.setJndiName(&quot;jdbc/myDS&quot;);    jndiObjectFactoryBean.setResourceRef(true);    jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);    return (DataSource) jndiObjectFactoryBean.getObject();  &#125;&#125;</code></pre><h3 id="XML-配置-profile-bean"><a href="#XML-配置-profile-bean" class="headerlink" title="XML 配置 profile bean"></a>XML 配置 profile bean</h3><pre><code class="xml">&lt;beans profile=&quot;dev&quot;&gt;    &lt;jdbc:embedded-database id=&quot;dataSource&quot; type=&quot;H2&quot;&gt;        &lt;jdbc:script location=&quot;classpath:schema.sql&quot; /&gt;        &lt;jdbc:script location=&quot;classpath:test-data.sql&quot; /&gt;    &lt;/jdbc:embedded-database&gt;&lt;/beans&gt;&lt;beans profile=&quot;prod&quot;&gt;    &lt;jee:jndi-lookup id=&quot;dataSource&quot;                     lazy-init=&quot;true&quot;                     jndi-name=&quot;jdbc/myDatabase&quot;                     resource-ref=&quot;true&quot;                     proxy-interface=&quot;javax.sql.DataSource&quot; /&gt;&lt;/beans&gt;</code></pre><p>带有 @Profile(“dev”) 注解的 bean，只有对应的 profile 被激活时，才会创建，否则会被忽略。</p><p>没有指定 profile 的 bean 始终都会被创建，与激活哪个 profile 没有关系。</p><h3 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h3><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性:</p><ul><li>spring.profiles.active</li><li>spring.profiles.default</li></ul><p>如果设置了 active，则激活的 profile 就是 active 指定的 profile。</p><p>如果没有设置 active，则激活的 profile 就是 default 指定的 profile。</p><p>如果 active、default 都没有设置，那么所有的 profile bean 都会被忽略。</p><p>设置这两个属性的方式：</p><ul><li>作为 DispatcherServlet 的初始化参数；</li><li>作为 Web 应用的上下文参数；</li><li>作为 JNDI 条目；</li><li>作为环境变量；</li><li>作为JVM的系统属性；</li><li>在集成测试类上，使用 @ActiveProfiles 注解设置。</li></ul><p>DispatcherServlet 的初始化参数</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;        &lt;param-value&gt;dev&lt;/param-value&gt;        &lt;/init-param&gt;&lt;/servlet&gt;</code></pre><p>Web 应用的上下文参数</p><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;    &lt;param-value&gt;dev&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><p>@ActiveProfiles 注解</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=DataSourceConfig.class)// xml 形式// @ContextConfiguration(&quot;classpath:datasource-config.xml&quot;)@ActiveProfiles(&quot;prod&quot;)public static class ProductionDataSourceTest&#123;    @Autowired    private DataSource dataSource;    @Test    public void shouldBeEmbeddedDatasource()    &#123;        // should be null, because there isn&#39;t a datasource configured in JNDI        assertNull(dataSource);    &#125;&#125;</code></pre><h2 id="3-2-条件化的-bean"><a href="#3-2-条件化的-bean" class="headerlink" title="3.2 条件化的 bean"></a>3.2 条件化的 bean</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>配置类 bean 方法增加 conditional 注解</li></ol><pre><code class="java">@Configurationpublic class MagicConfig&#123;  @Bean  @Conditional(MagicExistsCondition.class)  public MagicBean magicBean()  &#123;    return new MagicBean();  &#125;&#125;</code></pre><ol start="2"><li>编写 conditional 类</li></ol><pre><code class="java">public class MagicExistsCondition implements Condition&#123;  @Override  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)  &#123;    Environment env = context.getEnvironment();    return env.containsProperty(&quot;magic&quot;);  &#125;&#125;</code></pre><ol start="3"><li>测试</li></ol><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=MagicConfig.class)public class MagicExistsTest&#123;  @Autowired  private ApplicationContext context;  @BeforeClass  public static void settingProperty()  &#123;    // 设置环境变量    System.setProperty(&quot;magic&quot;,&quot;magic property&quot;);  &#125;  @Test  public void shouldNotBeNull()   &#123;    assertTrue(context.containsBean(&quot;magicBean&quot;));  &#125;&#125;</code></pre><h3 id="理解原理"><a href="#理解原理" class="headerlink" title="理解原理"></a>理解原理</h3><p>MagicExistsCondition 中只是使用了 ConditionContext 得到的 Environment，但<br>Condition 实现的考量因素可能会比这更多。matches() 方法会得到 ConditionContext 和<br>AnnotatedTypeMetadata 对象用来做出决策。</p><pre><code class="java">public interface ConditionContext &#123;    // 返回 BeanDefinitionRegistry 检查 bean 定义；    BeanDefinitionRegistry getRegistry();    // 返回 ConfigurableListableBeanFactory 检查 bean 是否存在，甚至探查 bean 的属性；    ConfigurableListableBeanFactory getBeanFactory();    // 返回 Environment 检查环境变量是否存在以及它的值是什么；    Environment getEnvironment();    // 返回 ResourceLoader 所加载的资源；    ResourceLoader getResourceLoader();    // 返回 ClassLoader 加载并检查类是否存在。    ClassLoader getClassLoader();&#125;</code></pre><pre><code class="java">public interface AnnotatedTypeMetadata&#123;    // 够判断带有 @Bean 注解的方法是不是还有其他特定的注解    boolean isAnnotated(String annotationType);    // 检查 @Bean 注解的方法上其他注解的属性    Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType);    Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType, boolean classValuesAsString);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType, boolean classValuesAsString);&#125;</code></pre><h3 id="Spring-自身项目中的实际应用"><a href="#Spring-自身项目中的实际应用" class="headerlink" title="Spring 自身项目中的实际应用"></a>Spring 自身项目中的实际应用</h3><p>从 Spring 4 开始，@Profile 注解进行了重构，使其基于 @Conditional 和 Condition 实现。作为如何使用@Conditional 和 Condition 的例子，我们来看一下在 Spring 4 中，@Profile是 如何实现的。</p><ol><li>profile 注解的定义</li></ol><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123;    String[] value();&#125;</code></pre><ol start="2"><li>ProfileCondition 定义</li></ol><pre><code class="java">class ProfileCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)    &#123;        if (context.getEnvironment() != null)         &#123;            MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());            if (attrs != null)             &#123;                for (Object value : attrs.get(&quot;value&quot;))                 &#123;                    if (context.getEnvironment().acceptsProfiles(((String[]) value)))                     &#123;                        return true;                    &#125;                &#125;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><p>可以看到，ProfileCondition 通过 AnnotatedTypeMetadata 得到了用于 @Profile 注解的所有属性。借助该信息，它会明确地检查 value 属性，该属性包含了 bean 的 profile 名称。然后，它根据通 ConditionContext 得到的 Environment 来检查［借助 acceptsProfiles() 方法］该 profile 是否处于激活状态。</p><h2 id="3-3-处理自动装配的歧义性"><a href="#3-3-处理自动装配的歧义性" class="headerlink" title="3.3 处理自动装配的歧义性"></a>3.3 处理自动装配的歧义性</h2><p>在自动装配中，仅有一个 bean 匹配所需的结果时，自动装配才是有效的。如果有多个匹配的 bean，则会报错：NoUniqueBeanDefinitionException。Spring 提供了两种方案来解决此问题：</p><ul><li>将可选 bean 中的某一个设为首选（primary）的 bean</li><li>使用限定符（qualifier）来帮助 Spring 将可选的 bean 的范围缩小到只有一个 bean</li></ul><pre><code class="java">public interface Dessert&#123;    void eat();&#125;@Componentpublic class Cake implements Dessert&#123;    public void eat()    &#123;        System.out.println(&quot;I am eating cakes.&quot;);    &#125;&#125;@Componentpublic class Cookies implements Dessert&#123;    public void eat()    &#123;        System.out.println(&quot;I am eating Cookies.&quot;);    &#125;&#125;@Componentpublic class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;// 配置组件扫描注入@Configuration@ComponentScanpublic class MonkeyKongConfig&#123;&#125;@Componentpublic class MonkeyKong&#123;    private Dessert dessert;    // 如果不采取措施，此处 Spring 无法确认具体注入哪个甜点    @Autowired    public void setDessert(Dessert dessert)    &#123;        this.dessert = dessert;    &#125;    public void eat()    &#123;        dessert.eat();    &#125;&#125;</code></pre><h3 id="标示首选的-bean"><a href="#标示首选的-bean" class="headerlink" title="标示首选的 bean"></a>标示首选的 bean</h3><pre><code class="java">@Component@Primarypublic class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;</code></pre><p>使用 @Primary 标示首选的 bean 后，下面测试就可以通过了</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=MonkeyKongConfig.class)public class MonkeyKongTest&#123;    @Rule    public final StandardOutputStreamLog log = new StandardOutputStreamLog();    @Autowired    MonkeyKong monkeyKong;    @Test    public void play()    &#123;        monkeyKong.eat();        assertEquals(&quot;I am eating IceCream.&quot;, log.getLog());    &#125;&#125;</code></pre><p>另外两种注入方式配置首选 bean</p><pre><code class="java">@Bean@Primarypublic Dessert iceCream()&#123;    return new IceCream();&#125;</code></pre><pre><code class="xml">&lt;bean id=&quot;iceCream&quot; class=&quot;Icecream&quot; primary=&quot;true&quot;/&gt;</code></pre><h3 id="限定自动装配的-bean"><a href="#限定自动装配的-bean" class="headerlink" title="限定自动装配的 bean"></a>限定自动装配的 bean</h3><ol><li>限定符的基本使用</li></ol><p>当首选 bean 标示超过一个时，Spring 还是无法确认到底该自动装配哪个 bean。所以需要限定。</p><pre><code class="java">@Component@Primary@Qualifier(&quot;cold&quot;) // 定义 bean 时指定限定名称public class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;@Autowired@Qualifier(&quot;cold&quot;) // 根据限定符cold自动注入，所以即使有多个 primary bean 也没有影响public void setDessert(Dessert dessert)&#123;    this.dessert = dessert;&#125;</code></pre><p>自定义的限定符（cold）一般为 bean 的类型，此处可以理解为凉的甜点。但是，如果多个 bean 都具备相同特性的话，这种做法也会出现问题，比如，现在又来了一个【冰棍】甜点。</p><pre><code class="java">@Component@Primary@Qualifier(&quot;cold&quot;)public class Popsicle implements Dessert&#123;    @Override    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;</code></pre><p>如此一来，Spring 再次遇到了歧义性的问题。需要使用更多的限定符来将可选范围限定到只有一个 bean。</p><ol start="2"><li>创建自定义限定符注解</li></ol><pre><code class="java">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,        ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Cold &#123;&#125;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,        ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Creamy &#123;&#125;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,        ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Fruity &#123;&#125;</code></pre><p>自己定义了三个限定符注解，这样就可以将 IceCream 和 Popsicle 区分开来了。</p><pre><code class="java">@Component@Primary@Qualifier(&quot;cold&quot;)@Cold@Creamypublic class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;@Autowired@Qualifier(&quot;cold&quot;)@Cold@Creamypublic void setDessert(Dessert dessert)&#123;    this.dessert = dessert;&#125;</code></pre><p>通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有 Java 编译器的限制或错误。与此同时，相对于使用原始的 @Qualifier 并借助 String 类型来指定限定符，自定义的注解也更为类型安全。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>为了创建自定义的条件化注解，我们创建一个新的注解并在这个注解上添加了@Conditional。</p><p>为了创建自定义的限定符注解，我们创建一个新的注解并在这个注解上添加了@Qualifier。</p><p>这种技术可以用到很多的 Spring 注解中，从而能够将它们组合在一起形成特定目标的自定义注解。</p><h2 id="3-4-bean-的作用域"><a href="#3-4-bean-的作用域" class="headerlink" title="3.4 bean 的作用域"></a>3.4 bean 的作用域</h2><p>在<strong>默认</strong>情况下，Spring 应用上下文中所有 bean 都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个 bean 被注入到其他 bean 多少次，每次所注入的都是同一个实例。</p><p>有时候，可能会发现，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将 class 声明为单例的 bean 就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。</p><p>Spring 的作用域：</p><ul><li>单例（Singleton）：在整个应用中，只创建 bean 的一个实例。</li><li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li><li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li></ul><h3 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h3><ol><li>设置作用域的方式</li></ol><pre><code class="java">// 组件自动注入@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad &#123;&#125;// bean 注解显示注入@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad()&#123;    return new Notepad();&#125;// xml 显示注入&lt;bean class=&quot;com.myapp.Notepad&quot; scope=&quot;prototype&quot; /&gt;</code></pre><ol start="2"><li>使用会话和请求作用域</li></ol><pre><code class="java">@Component// Session 级别，每个会话创建一个ShoppingCart@Scope(value = WebApplicationContext.SCOPE_SESSION,    proxyMode = ScopedProxyMode.TARGET_CLASS)public class ShoppingCart &#123;&#125;// StoreService@Autowiredpublic void setShoppingCart(ShoppingCart shoppingCart)&#123;    this.shoppingCart = shoppingCart;&#125;</code></pre><p>proxyMode 的理解：</p><p>StoreService 是单例的，会在 Spring 应用上下文加载的时候创建，当它创建的时候，Spring 会试图将 ShoppingCart bean 注入到 setShoppingCart() 方法中。但是 ShoppingCart bean 是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。</p><p>所以，Spring并不会将实际的 ShoppingCart bean 注入到 StoreService 中，Spring 会注入一个到ShoppingCart bean 的代理。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的 ShoppingCart bean。</p><p>proxyMode 属性被设置成了 ScopedProxyMode.INTERFACES，这表明这个代理要实现 ShoppingCart 接口，并将调用委托给实现 bean。</p><h3 id="在-XML-中声明作用域代理"><a href="#在-XML-中声明作用域代理" class="headerlink" title="在 XML 中声明作用域代理"></a>在 XML 中声明作用域代理</h3><pre><code class="xml">&lt;bean id=&quot;cart&quot; class=&quot;com.myapp.ShoppingCart&quot; scope=&quot;session&quot; &gt;    &lt;aop:scoped-proxy proxy-target-class=&quot;true&quot;/&gt;&lt;/bean&gt;</code></pre><h2 id="3-5-运行时注入"><a href="#3-5-运行时注入" class="headerlink" title="3.5 运行时注入"></a>3.5 运行时注入</h2><p>还记得第二章我们注入 CD 的 title 和 artist 时，我们都是在 java 或者 xml 中硬编码实现。</p><pre><code class="xml">&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;&lt;/bean&gt;</code></pre><p>但有的时候，我们可能会希望避免硬编码值，而是想让这些值在运行时再确定。为了实现这些功能，Spring 提供了两种在运行时求值的方式：</p><h3 id="使用属性占位符实现"><a href="#使用属性占位符实现" class="headerlink" title="使用属性占位符实现"></a>使用属性占位符实现</h3><p>属性源：</p><pre><code class="properties">disc.title=Sgt. Peppers Lonely Hearts Club Banddisc.artist=The Beatles</code></pre><p>注入属性：</p><pre><code class="java">@Configuration// 声明属性源@PropertySource(&quot;classpath:/com/soundsystem/app.properties&quot;)public class EnvironmentConfig&#123;  @Autowired  Environment env;  @Bean  public BlankDisc blankDisc()  &#123;    // 检索属性值进行注入    return new BlankDisc(        env.getProperty(&quot;disc.title&quot;),        env.getProperty(&quot;disc.artist&quot;));  &#125;&#125;</code></pre><p>验证：</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=EnvironmentConfig.class)public static class InjectFromProperties &#123;    @Autowired    private BlankDisc blankDisc;    @Test    public void assertBlankDiscProperties()     &#123;        assertEquals(&quot;The Beatles&quot;, blankDisc.getArtist());        assertEquals(&quot;Sgt. Peppers Lonely Hearts Club Band&quot;, blankDisc.getTitle());    &#125;&#125;</code></pre><p>深入学习 Spring 的 Environment:</p><pre><code class="java">public interface Environment extends PropertyResolver &#123;    String[] getActiveProfiles();    String[] getDefaultProfiles();    // 如果 environment 支持给定 profile 的话，就返回 true。    boolean acceptsProfiles(String... profiles);&#125;</code></pre><pre><code class="java">public interface PropertyResolver &#123;    boolean containsProperty(String key);    String getProperty(String key);    // 给默认值    String getProperty(String key, String defaultValue);    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);    &lt;T&gt; Class&lt;T&gt; getPropertyAsClass(String key, Class&lt;T&gt; targetType);    // 属性必须定义    String getRequiredProperty(String key) throws IllegalStateException;    &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;    String resolvePlaceholders(String text);    String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;&#125;</code></pre><ol><li>XML 属性占位符实现</li></ol><pre><code class="xml">&lt;!-- 引入属性源 --&gt;&lt;context:property-placeholder location=&quot;com/soundsystem/app.properties&quot; /&gt;&lt;!-- 使用占位符注入属性 --&gt;&lt;bean class=&quot;com.soundsystem.BlankDisc&quot;      c:_0 = &quot;$&#123;disc.title&#125;&quot;      c:_1 = &quot;$&#123;disc.artist&#125;&quot;/&gt;</code></pre><ol start="2"><li>Java 属性占位符实现</li></ol><pre><code class="java">// 修改构造器public BlankDisc(@Value(&quot;$&#123;disc.title&#125;&quot;) String title,                 @Value(&quot;$&#123;disc.artist&#125;&quot;) String artist) &#123;    this.title = title;    this.artist = artist;&#125;// 为了在 java 中使用占位符，需要配置 PropertySourcesPlaceholderConfigurer@Beanpublic static PropertySourcesPlaceholderConfigurer placeholderConfigurer()&#123;    return new PropertySourcesPlaceholderConfigurer();&#125;</code></pre><p>怎么调用？</p><h3 id="使用-SPEL-实现"><a href="#使用-SPEL-实现" class="headerlink" title="使用 SPEL 实现"></a>使用 SPEL 实现</h3><p>SpEL拥有很多特性：</p><ul><li>使用bean的ID来引用bean；</li><li>调用方法和访问对象的属性；</li><li>对值进行算术、关系和逻辑运算；</li><li>正则表达式匹配；</li><li>集合操作。</li></ul><p>SpEL 样例：</p><pre><code class="java">#&#123;1&#125;#&#123;T&#123;System&#125;.currentTimeMillis()&#125;// 计算得到ID 为sgtPeppers的bean的artist属性#&#123;sgtPeppers.artist&#125;#&#123;systemProperties[&#39;disc.title&#39;]&#125;</code></pre><p>SpEL所支持的基础表达式:</p><ol><li>字面量</li></ol><p><code>#&#123;1&#125;、#&#123;&#39;hello&#39;&#125;、#&#123;false&#125;</code></p><ol start="2"><li>引用 bean、属性和方法</li></ol><p><code>#&#123;sgtPeppers&#125;、#&#123;sgtPeppers.artist&#125;、#&#123;sgtPeppers.getArtist()?.toUpperCase()&#125;</code></p><ol start="3"><li>访问类</li></ol><pre><code>#&#123;T&#123;System&#125;.currentTimeMillis()&#125;#&#123;T&#123;java.lang.Math&#125;.PI&#125;</code></pre><p>SpEL 运算符：</p><table><thead><tr><th>运算符类型</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+、-、 * 、/、%、^</td></tr><tr><td>比较运算符</td><td>&lt; 、 &gt; 、 == 、 &lt;= 、 &gt;= 、 lt 、 gt 、 eq 、 le 、 ge</td></tr><tr><td>逻辑运算符</td><td>and 、 or 、 not 、│</td></tr><tr><td>条件运算符</td><td>?: (ternary) 、 ?: (Elvis)</td></tr><tr><td>正则表达式</td><td>matches</td></tr></tbody></table><pre><code class="java">// 类型和算术运算#&#123;2 * T&#123;java.lang.Math&#125;.PI * circle.radius&#125;#&#123;T&#123;java.lang.Math&#125;.PI * circle.radius^2&#125;#&#123;disc.title + &#39; by &#39; + disc.artist&#125;// 比较运算#&#123;counter.total == 100&#125;// 条件运算#&#123;scoreboard.score &gt; 1000 ? &quot;Winner&quot; : &quot;Loser&quot;&#125;#&#123;disc.tatle ?: &#39;Default title&#39;&#125;// 正则运算#&#123;admin.email matches &#39;[a-zA-Z0-9._%...]+\\.com&#39;&#125;  // 集合运算#&#123;jukebox.songs[4].title&#125;#&#123;jukebox.songs.?[artist eq &#39;Aerosmith&#39;]&#125;#&#123;jukebox.songs.^[artist eq &#39;Aerosmith&#39;]&#125;#&#123;jukebox.songs.$[artist eq &#39;Aerosmith&#39;]&#125;#&#123;jukebox.songs.?[artist eq &#39;Aerosmith&#39;].![title]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;3-1-环境与-profile&quot;&gt;&lt;a href=&quot;#3-1-环境与-profile&quot; class=&quot;headerlink&quot; title=&quot;3.1 环境与 profile&quot;&gt;&lt;/a&gt;3.1 环境与 profile&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>组装电脑</title>
    <link href="http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85.html"/>
    <id>http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2020-12-21T16:37:05.473Z</updated>
    
    <content type="html"><![CDATA[<p>组装电脑</p><a id="more"></a><h2 id="显卡选择"><a href="#显卡选择" class="headerlink" title="显卡选择"></a>显卡选择</h2><table><thead><tr><th>显卡型号</th><th>工艺</th><th>流处理器</th><th>核心基准/游戏加速频率</th><th>位宽</th><th>容量</th><th>频率</th><th>价格</th></tr></thead><tbody><tr><td>RX5500XT</td><td>7nm</td><td>1408</td><td>1670/1717/1845</td><td>128</td><td>8GB GBBR6</td><td>14</td><td></td></tr><tr><td>GTX 1660</td><td>12nm</td><td>1408</td><td>1530</td><td>192</td><td>6GB GDDR5</td><td>8</td><td></td></tr><tr><td>GTX 1650S</td><td>12nm</td><td>1280</td><td>1530</td><td>128</td><td>4GB</td><td>12</td><td>998</td></tr></tbody></table><p>N 卡：NVIDA</p><p>A 卡：AMD</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;组装电脑&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>使用 frp 实现远程连接和内网穿透</title>
    <link href="http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html"/>
    <id>http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2020-12-27T15:04:15.586Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用 <a href="https://github.com/fatedier/frp">frp</a> 内网穿透来实现访问内网服务和远程连接内网机器。首先 frp <strong>需要一台公网机器</strong>，没有的话就散了吧，乖乖的用向日葵等工具吧。</p><a id="more"></a><h2 id="1、访问内网服务"><a href="#1、访问内网服务" class="headerlink" title="1、访问内网服务"></a>1、访问内网服务</h2><p>场景说明：我本地启动了一个服务，但是我本机是没有外网地址的，这样我只能自己本地访问自己的服务，比如<code>http://127.0.0.1:8080</code>，别人是无法访问到的。</p><h3 id="1-1-启动服务端（公网机器）"><a href="#1-1-启动服务端（公网机器）" class="headerlink" title="1.1 启动服务端（公网机器）"></a>1.1 启动服务端（公网机器）</h3><ol><li><p>修改 frps.ini，设置 http 访问端口为 8080</p><pre><code class="json"># frps.ini[common]# frp 应用程序端口bind_port = 7000# 公网 http 监听端口。这里注意理解是公网的端口在监听vhost_http_port = 8088</code></pre></li><li><p>启动 frps</p><p><code>./frps -c ./frps.ini</code></p><p>后台运行：<code>nohup ./frps -c ./frps.ini &amp;</code></p><p><img src="../../images/%E5%85%B6%E4%BB%96/frp/frp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png"></p></li></ol><h3 id="1-2-启动客户端（本地服务所在机器）"><a href="#1-2-启动客户端（本地服务所在机器）" class="headerlink" title="1.2 启动客户端（本地服务所在机器）"></a>1.2 启动客户端（本地服务所在机器）</h3><ol><li><p>修改 frpc.ini</p><pre><code class="json"># frpc.ini[common]# 配置服务端对外的ip地址，就是公网机器IPserver_addr = **.**.**.**# 配置服务端监听的端口server_port = 7000[web]type = http# 本地服务端口local_port = 8080# 公网服务器的IP或者已解析的域名custom_domains = **.**.**.**</code></pre></li><li><p>启动 frpc</p><p><code>frpc.exe -c frpc.ini</code></p><p><img src="../../images/%E5%85%B6%E4%BB%96/frp/frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png"></p></li><li><p>访问测试 <code>http://**.**.**.**:8088</code></p></li></ol><h2 id="2、远程连接内网机器"><a href="#2、远程连接内网机器" class="headerlink" title="2、远程连接内网机器"></a>2、远程连接内网机器</h2><p>比如我在家想远程连接公司的电脑。</p><h3 id="2-1-启动服务端（公网机器）"><a href="#2-1-启动服务端（公网机器）" class="headerlink" title="2.1 启动服务端（公网机器）"></a>2.1 启动服务端（公网机器）</h3><p>和 1.1 一样，无需其他配置。</p><h3 id="2-2-启动客户端（公司电脑）"><a href="#2-2-启动客户端（公司电脑）" class="headerlink" title="2.2 启动客户端（公司电脑）"></a>2.2 启动客户端（公司电脑）</h3><ol><li><p>修改 frpc.ini</p><pre><code class="json"># frpc.ini[common]# 配置服务端对外的ip地址，就是公网机器IPserver_addr = **.**.**.**# 配置服务端监听的端口server_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 3389# 公网机器开一个 6000 端口的服务，代理到本地的 3389remote_port = 6000</code></pre></li><li><p>启动 frpc</p><p><code>frpc.exe -c frpc.ini</code></p></li><li><p>远程连接测试</p><p>在里电脑直接远程连接公司电脑</p><p><img src="../../images/%E5%85%B6%E4%BB%96/frp/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8.png"></p><p>这里要注意远程连接的用户名是<strong>域\用户名</strong>，比如公司的域是 skywares.com，我公司电脑的用户名是 alvin.li，那么远程连接的用户名是<code>skywares.com\alvin.li</code>。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍如何使用 &lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;frp&lt;/a&gt; 内网穿透来实现访问内网服务和远程连接内网机器。首先 frp &lt;strong&gt;需要一台公网机器&lt;/strong&gt;，没有的话就散了吧，乖乖的用向日葵等工具吧。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="frp" scheme="http://yoursite.com/tags/frp/"/>
    
    <category term="内网穿透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="远程连接" scheme="http://yoursite.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>第 2 章 构建 装配 Bean</title>
    <link href="http://yoursite.com/2020-12-22-13Spring%E5%9F%BA%E7%A1%80/20191022sia2.html"/>
    <id>http://yoursite.com/2020-12-22-13Spring%E5%9F%BA%E7%A1%80/20191022sia2.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2020-12-27T15:17:54.589Z</updated>
    
    <content type="html"><![CDATA[<ul><li>声明 bean</li><li>构造器注入和 Setter 方法注入</li><li>装配 bean</li><li>控制 bean 的创建和销毁</li></ul><p>Spring 配置的可选方案：</p><ul><li>在 XML 中进行显式配置</li><li>在 Java 中进行显式配置</li><li>隐式的 bean 发现机制和自动装配</li></ul><a id="more"></a><h2 id="自动化装配-bean"><a href="#自动化装配-bean" class="headerlink" title="自动化装配 bean"></a>自动化装配 bean</h2><ul><li>组件扫描（component scanning）：Spring 自动发现应用上下文中创建的 bean</li><li>自动装配（autowiring）：Spring 自动满足 bean 之间的依赖</li></ul><p>如果你不将 CD 插入（注入）到 CD 播放器中，那么 CD 播放器其实是没有太大用处的。所以，可以这样说，CD 播放器依赖于 CD 才能完成它的使命。</p><h3 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h3><p><code>@Component</code>：表明该类会作为组件类，并<br>告知Spring要为这个类创建bean。</p><pre><code class="java">@Componentpublic class SgtPeppers implements CompactDisc&#123;  private String title = &quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;;  private String artist = &quot;The Beatles&quot;;  public void play()  &#123;    System.out.print(&quot;Playing &quot; + title + &quot; by &quot; + artist);  &#125;&#125;</code></pre><p><code>@ComponentScan</code>：组件扫描默认是不启用，使用注解启用组件扫描，默认扫描该配置类所在的包</p><pre><code class="java">@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125;</code></pre><p>在 XML 中启用组件扫描：<code>&lt;context:component-scan base-package=&quot;soundsystem&quot; /&gt;</code></p><pre><code class="xml">&lt;context:component-scan base-package=&quot;soundsystem&quot; /&gt;</code></pre><p>测试：</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest&#123;  @Autowired  private CompactDisc cd;  @Test  public void cdShouldNotBeNull()  &#123;    assertNotNull(cd);  &#125;&#125;</code></pre><p>测试通过，cd 不为 null，所以 cd 已经被注入到 spring 容器。</p><p>为组件扫描的 bean 命名：<code>@Component(&quot;lonelyHeartsClub&quot;)</code></p><p>设置组件扫描的包：</p><ul><li><code>@ComponentScan(basePackages = &#123;&quot;soundsystem&quot;,&quot;aaa&quot;&#125;)</code></li><li><code>@ComponentScan(basePackageClasses = &#123;SgtPeppers.class, CDPlayer.class&#125;)</code>：扫描设置的类所在的包</li></ul><h3 id="通过为-bean-添加注解实现自动装配"><a href="#通过为-bean-添加注解实现自动装配" class="headerlink" title="通过为 bean 添加注解实现自动装配"></a>通过为 bean 添加注解实现自动装配</h3><p><strong>自动装配</strong>就是让 Spring 自动满足 bean 依赖的一种方法，在满足依赖的过程中，会在 Spring 应用上下文中寻找匹配某个 bean 需求的其他 bean。为了声明要进行自动装配，我们可以借助 Spring 的 @Autowired 注解。</p><pre><code class="java">@Componentpublic class CDPlayer implements MediaPlayer&#123;  private CompactDisc cd;  @Autowired  public CDPlayer(CompactDisc cd)  &#123;    this.cd = cd;  &#125;  public void play()  &#123;    cd.play();  &#125;&#125;</code></pre><p>Spring 创建 CDPlayer bean 的时候，会通过这个构造器来进行实例化并且会传入一个可设置给 CompactDisc 类型的 bean。</p><p>@Autowired 注解可以用在类的任何方法上。</p><p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。</p><p>如果没有匹配的 bean，那么在应用上下文创建的时候，Spring 会抛出一个异常。<code>@Autowired(required = false)</code>可以避免该异常。</p><p>如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。</p><h3 id="验证自动装配"><a href="#验证自动装配" class="headerlink" title="验证自动装配"></a>验证自动装配</h3><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest&#123;  @Rule  public final StandardOutputStreamLog log = new StandardOutputStreamLog();  @Autowired  private MediaPlayer player;  @Autowired  private CompactDisc cd;  @Test  public void cdShouldNotBeNull()  &#123;    assertNotNull(cd);  &#125;  @Test  public void play()  &#123;    player.play();    assertEquals(&quot;Playing Sgt. Pepper&#39;s Lonely Hearts Club Band by The Beatles&quot;, log.getLog());  &#125;&#125;</code></pre><p>player.play() 方法最终实际调用的的式 cd 的 play() 方法，说明 cd 成功的自动装配到了 cdplay 中。</p><h2 id="通过-Java-代码装配-bean"><a href="#通过-Java-代码装配-bean" class="headerlink" title="通过 Java 代码装配 bean"></a>通过 Java 代码装配 bean</h2><p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置 Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加 @Component 和 @Autowired 注解的，因此就不能使用自动化装配的方案了。</p><h3 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h3><pre><code class="java">@Configurationpublic class CDPlayerConfig&#123;  @Bean  public CompactDisc compactDisc()  &#123;    return new SgtPeppers();  &#125;  @Bean  public CDPlayer cdPlayer(CompactDisc compactDisc)  &#123;    return new CDPlayer(compactDisc);  &#125;&#125;</code></pre><p>带有 @Bean 注解的方法可以采用任何必要的Java功能来产生bean实例。</p><h2 id="通过-XML-装配-bean"><a href="#通过-XML-装配-bean" class="headerlink" title="通过 XML 装配 bean"></a>通过 XML 装配 bean</h2><h3 id="创建-XML-规范"><a href="#创建-XML-规范" class="headerlink" title="创建 XML 规范"></a>创建 XML 规范</h3><p>快速生成 XML 配置文件：<a href="https://spring.io/tools/sts">https://spring.io/tools/sts</a></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h3 id="声明一个简单的-lt-bean-gt"><a href="#声明一个简单的-lt-bean-gt" class="headerlink" title="声明一个简单的&lt;bean&gt;"></a>声明一个简单的<code>&lt;bean&gt;</code></h3><pre><code class="xml">&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;/&gt;</code></pre><p>XML 配置的缺点：</p><ul><li>bean的类型以字符串的形式设置在了class属性中，不能保证设置给class属性的值是真正的类</li><li>重命名了类后，xml 也需要修改</li></ul><h3 id="借助构造器注入初始化-bean"><a href="#借助构造器注入初始化-bean" class="headerlink" title="借助构造器注入初始化 bean"></a>借助构造器注入初始化 bean</h3><ol><li>使用 constructor-arg 注入</li></ol><pre><code class="xml">&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt;    &lt;constructor-arg ref=&quot;compactDisc&quot; /&gt;&lt;/bean&gt;&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;&lt;/bean&gt;&lt;!-- 注入集合 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.collections.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;        &lt;/list&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><ol start="2"><li>使用 c 命名空间注入</li></ol><pre><code class="xml">&lt;!-- 需要引入：xmlns:c=&quot;http://www.springframework.org/schema/c&quot; --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot; /&gt;&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_0=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;       c:_1=&quot;The Beatles&quot; /&gt;&lt;!-- 注入集合,c 命名空间不支持集合的注入 --&gt;</code></pre><p>上面 c:cd-ref 中的 cd 是构造器的名称，这样写有些不友好。可以使用参数索引来替代：</p><pre><code class="xml">&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_0-ref=&quot;compactDisc&quot; /&gt;&lt;!-- 只有一个参数时，索引也可以省略 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_-ref=&quot;compactDisc&quot; /&gt;</code></pre><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p><property>元素为属性的Setter方法所提供的功能与<constructor-arg>元素为构造器<br>所提供的功能是一样的。</p><ol><li>使用 property 注入</li></ol><pre><code class="xml">&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.properties.CDPlayer&quot;&gt;    &lt;property name=&quot;compactDisc&quot; ref=&quot;compactDisc&quot; /&gt;&lt;/bean&gt;&lt;!-- 注入字面量和集合 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.properties.BlankDisc&quot;&gt;    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ol start="2"><li>使用 p 命名空间注入</li></ol><pre><code class="xml">&lt;!-- 需要引入：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; --&gt;&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.properties.CDPlayer&quot; p:compactDisc-ref=&quot;compactDisc&quot; /&gt;&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot;      class=&quot;soundsystem.properties.BlankDisc&quot;      p:title=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;      p:artist=&quot;The Beatles&quot;&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 注入集合,p 命名空间不支持集合的注入 --&gt;&lt;!-- 但是，我们可以使用 Spring util-命名空间中的一些功能来简化BlankDiscbean。 --&gt;&lt;bean id=&quot;compactDisc&quot;      class=&quot;soundsystem.properties.BlankDisc&quot;      p:title=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;      p:artist=&quot;The Beatles&quot;      p:tracks-ref=&quot;trackList&quot; /&gt;&lt;util:list id=&quot;trackList&quot;&gt;      &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;    &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;    &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;&lt;/util:list&gt;</code></pre><p><a href="util:list">util:list</a>只是util-命名空间中的多个元素之一。</p><table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody><tr><td>util:constant</td><td>引用某个类型的public static域，并将其暴露为bean</td></tr><tr><td>util:list</td><td>创建一个java.util.List类型的bean，其中包含值或引用</td></tr><tr><td>util:map</td><td>创建一个java.util.Map类型的bean，其中包含值或引用</td></tr><tr><td>util:properties</td><td>创建一个java.util.Properties类型的bean</td></tr><tr><td>util:property-path</td><td>引用一个bean的属性（或内嵌属性），并将其暴露为bean</td></tr><tr><td>util:set</td><td>创建一个java.util.Set类型的bean，其中包含值或引用</td></tr></tbody></table><h2 id="导入和混合配置"><a href="#导入和混合配置" class="headerlink" title="导入和混合配置"></a>导入和混合配置</h2><p>在典型的 Spring 应用中，我们可能会同时使用自动化和显式配置。这些配置方案都不是互斥的。</p><h3 id="在-JavaConfig-中引用-XML-配置"><a href="#在-JavaConfig-中引用-XML-配置" class="headerlink" title="在 JavaConfig 中引用 XML 配置"></a>在 JavaConfig 中引用 XML 配置</h3><pre><code class="java">@Configuration@Import(CDPlayerConfig.class) // 引入配置类@ImportResource(&quot;classpath:cd-config.xml&quot;) // 引入配置文件public class SoundSystemConfig&#123;&#125;</code></pre><h3 id="在-XML-配置中引用-JavaConfig"><a href="#在-XML-配置中引用-JavaConfig" class="headerlink" title="在 XML 配置中引用 JavaConfig"></a>在 XML 配置中引用 JavaConfig</h3><pre><code class="xml">&lt;!-- 引入配置类,注入CDPlayer --&gt;&lt;bean class=&quot;soundsystem.CDPlayerConfig&quot; /&gt;&lt;!-- 引入xml,注入CD --&gt;&lt;import resource=&quot;cd-config.xml&quot;/&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;声明 bean&lt;/li&gt;
&lt;li&gt;构造器注入和 Setter 方法注入&lt;/li&gt;
&lt;li&gt;装配 bean&lt;/li&gt;
&lt;li&gt;控制 bean 的创建和销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring 配置的可选方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 XML 中进行显式配置&lt;/li&gt;
&lt;li&gt;在 Java 中进行显式配置&lt;/li&gt;
&lt;li&gt;隐式的 bean 发现机制和自动装配&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>第 21 章 函数式编程</title>
    <link href="http://yoursite.com/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"/>
    <id>http://yoursite.com/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</id>
    <published>2020-12-21T14:13:12.000Z</published>
    <updated>2020-12-21T16:01:19.293Z</updated>
    
    <content type="html"><![CDATA[<p>Java 讲义进阶之函数式编程。</p><a id="more"></a><h2 id="第一章-函数式编程和-lambda-表达式"><a href="#第一章-函数式编程和-lambda-表达式" class="headerlink" title="第一章 函数式编程和 lambda 表达式"></a>第一章 函数式编程和 lambda 表达式</h2><h3 id="lambda表达式初识"><a href="#lambda表达式初识" class="headerlink" title="lambda表达式初识"></a>lambda表达式初识</h3><pre><code class="java">public class ThreadDemo &#123;    public static void main(String[] args) &#123;        Runnable target = new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;OK&quot;);            &#125;        &#125;;        new Thread(target).start();        // jdk8 lambda        Runnable target1 = () -&gt; System.out.println(&quot;OK&quot;);        // lambda必须返回指定接口实例；并且接口中只有一个需要实现的方法        // Object target2 = () -&gt; System.out.println(&quot;OK&quot;);        new Thread(target1).start();    &#125;&#125;</code></pre><h3 id="lambda表达式常用写法"><a href="#lambda表达式常用写法" class="headerlink" title="lambda表达式常用写法"></a>lambda表达式常用写法</h3><pre><code class="java">public class LambdaDemo2 &#123;    public static void main(String[] args) &#123;        // 其实就是 doubleNum 方法的实现        Interface1 i1 = (i) -&gt; i*2;        System.out.println(i1.add(3,7));        System.out.println(i1.doubleNum(20));        // 这种是最常见写法        Interface1 i2 = i -&gt; i*2;        Interface1 i3 = (int i) -&gt; i*2;        Interface1 i4 = (int i) -&gt; &#123;            System.out.println(&quot;-------&quot;);            return i*2;        &#125;;    &#125;&#125;</code></pre><h3 id="函数接口默认方法"><a href="#函数接口默认方法" class="headerlink" title="函数接口默认方法"></a>函数接口默认方法</h3><pre><code class="java">// 函数接口，只有一个方法，就是一个接口只做一件事情的意思。告诉用户不要再加其他接口方法了@FunctionalInterfaceinterface Interface1&#123;    int doubleNum(int i);    // 默认方法。函数接口是指只有一个需要实现的方法，而不是接口中只有一个方法。    // 很重要的特性。1.8以前，接口中不敢随意增加方法，因为加了方法后，对该接口的所有实现都有影响。    default int add(int x, int y)&#123;        // x = this.doubleNum(x);        return x + y;    &#125;&#125;@FunctionalInterfaceinterface Interface2&#123;    int doubleNum(int i);    default int add(int x, int y)&#123;        return x + y;    &#125;&#125;@FunctionalInterfaceinterface Interface3 extends Interface2, Interface1&#123;    // 函数接口使用默认方法需要注意的地方，当多个接口有相同的默认方法时，需要指定使用哪个    @Override    default int add(int x, int y) &#123;        return Interface1.super.add(x,y);    &#125;&#125;</code></pre><h3 id="函数接口好处"><a href="#函数接口好处" class="headerlink" title="函数接口好处"></a>函数接口好处</h3><ul><li>可以省略接口</li><li>可以进行链式操作</li></ul><pre><code class="java">import java.text.DecimalFormat;import java.util.function.Function;interface IMoneyFormat&#123;    String format(int i);&#125;class MyMoney&#123;    private final int money;    public MyMoney(int money)&#123;        this.money = money;    &#125;    public void printMoney(IMoneyFormat moneyFormat)&#123;        System.out.println(&quot;我的存款：&quot;+moneyFormat.format(this.money));    &#125;    public void printMoney1(Function&lt;Integer, String&gt; moneyFormat)&#123;        System.out.println(&quot;我的存款：&quot;+moneyFormat.apply(this.money));    &#125;&#125;public class MoneyDemo &#123;    public static void main(String[] args) &#123;        MyMoney me = new MyMoney(999999999);        // 接口函数只有一个参数，括号可以省略        me.printMoney(i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i));        // 可以看出，lambda只需要知道接口函数的输入是什么，输出是什么即可。        // 函数接口好处1：所以可以不需要接口，使用jdk自带的function即可，Function 本身就是一个函数式接口        me.printMoney1(i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i));        // 函数接口好处2：链式操作        Function&lt;Integer, String&gt; moneyFormat = i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i);        me.printMoney1(moneyFormat.andThen(s -&gt; &quot;人民币&quot; + s));    &#125;&#125;</code></pre><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><table><thead><tr><th>接口</th><th>输入参数</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td>Predicate<T></td><td>T</td><td>boolean</td><td>断言</td></tr><tr><td>Consumer<T></td><td>T</td><td>/</td><td>消费一个数据</td></tr><tr><td>Function&lt;T,R&gt;</td><td>T</td><td>R</td><td>输入T输出R的函数</td></tr><tr><td>Supplier<T></td><td>/</td><td>T</td><td>提供一个数据</td></tr><tr><td>UnaryOperator<T></td><td>T</td><td>T</td><td>一元函数（输入输出类型相同）</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>(T,U)</td><td>R</td><td>2个输入的函数</td></tr><tr><td>BinaryOperator<T></td><td>(T,T)</td><td>T</td><td>二元函数（输入输出类型相同）</td></tr></tbody></table><pre><code class="java">public class FunctionDemo &#123;    public static void main(String[] args) &#123;        // 断言函数接口        Predicate&lt;Integer&gt; predicate = i -&gt; i&gt;0;        System.out.println(predicate.test(-9));        // 消费函数接口        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);        consumer.accept(&quot;输入的数据&quot;);        // 对于参数是基本类型的，java自带了一些带类型的函数，优先使用        IntPredicate predicate1 = i -&gt; i&gt;0;        // DoubleConsumer    &#125;&#125;</code></pre><h3 id="lambda表达式方法引用"><a href="#lambda表达式方法引用" class="headerlink" title="lambda表达式方法引用"></a>lambda表达式方法引用</h3><pre><code class="java">import java.util.ArrayList;import java.util.List;import java.util.function.*;class Dog&#123;    private String name = &quot;哮天犬&quot;;    private int food = 10;    public Dog()&#123;&#125;    public Dog(String name)&#123;        this.name = name;    &#125;    public static void bark(Dog dog)&#123;        System.out.println(dog.name + &quot;叫了&quot;);    &#125;    /**     * 吃狗粮     * JDK默认会把当前实例传入到非静态方法，参数名称为this，位置是第一个     */    public int eat(Dog this, int num)&#123;        System.out.println(&quot;吃了&quot; + num + &quot;斤狗粮&quot;);        this.food -= num;        return this.food;    &#125;    public String getName()    &#123;        return this.name;    &#125;&#125;public class MethodReferenceDemo &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.eat(3);        Consumer&lt;String&gt; consumerOrg1 = i -&gt; System.out.println(i);        // 方法引用（当输入输出参数相同，可以改写为方法引用）        Consumer&lt;String&gt; consumer1 = System.out::println;        consumer1.accept(&quot;接收的数据&quot;);        // 静态方法的方法引用        Consumer&lt;Dog&gt; consumerOrg2 = i -&gt; Dog.bark(i);        Consumer&lt;Dog&gt; consumer2 = Dog::bark;        consumer2.accept(dog);        // 非静态方法，使用对象实例的方法引用        // Function&lt;Integer, Integer&gt; function = dog::eat;        // 输入输出一样，可以变为一元函数形式        // UnaryOperator&lt;Integer&gt; function = dog::eat;        IntUnaryOperator unaryOrg = i -&gt; dog.eat(i);        IntUnaryOperator unary = dog::eat;        System.out.println(&quot;还剩下：&quot; + unary.applyAsInt(2) + &quot;斤&quot;);        // 使用类名来引用非静态方法        BiFunction&lt;Dog, Integer, Integer&gt; eatFunctionOrg = (T,U) -&gt; T.eat(U);        BiFunction&lt;Dog, Integer, Integer&gt; eatFunction = Dog::eat;        System.out.println(&quot;还剩下&quot; + eatFunction.apply(dog,2)+&quot;斤&quot;);        // 无参构造函数的方法引用        Supplier&lt;Dog&gt; supplierOrg = () -&gt; new Dog();        Supplier&lt;Dog&gt; supplier = Dog::new;        System.out.println(&quot;创建了新对象：&quot; + supplier.get().getName());        // 有参构造函数的方法引用        Function&lt;String, Dog&gt; function2Org = T -&gt; new Dog(T);        Function&lt;String, Dog&gt; function2 = Dog::new;        System.out.println(&quot;创建了新对象：&quot; + function2.apply(&quot;旺财&quot;).getName());        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 传值引用，lambda也是一样的原理。        // 存疑。        MethodReferenceDemo demo = new MethodReferenceDemo();        demo.test(list);        System.out.println(list.size());    &#125;    private void test(List&lt;String&gt; list)&#123;        list = null;    &#125;&#125;</code></pre><h3 id="lambda表达式类型推断"><a href="#lambda表达式类型推断" class="headerlink" title="lambda表达式类型推断"></a>lambda表达式类型推断</h3><pre><code class="java">interface IMath&#123;    int add(int x, int y);&#125;public class TypeDemo &#123;    public static void main(String[] args) &#123;        // 变量类型定义        IMath lambda = (x,y) -&gt; x + y;        // 数组里        IMath[] lambdas = &#123;(x,y) -&gt; x + y&#125;;        // 强转        Object lambda2 = (IMath)(x,y) -&gt; x + y;        // 通过返回类型        IMath createLambda = createLambda();        TypeDemo demo = new TypeDemo();        // 当有二义性时，使用强转对应的接口解决        demo.test((x,y) -&gt; x + y);    &#125;    public void test(IMath math)&#123;    &#125;    public static IMath createLambda()&#123;        return (x,y) -&gt; x+y;    &#125;&#125;</code></pre><h3 id="lambda表达式变量引用"><a href="#lambda表达式变量引用" class="headerlink" title="lambda表达式变量引用"></a>lambda表达式变量引用</h3><pre><code class="java">public class VarDemo &#123;    public static void main(String[] args) &#123;        final String str = &quot;我们的时间&quot;;        // lambda表达式实际上相当于匿名内部类，匿名内部类引用变量时必须是final的。（java参数是传值）        Consumer&lt;String&gt; consumer = s-&gt; System.out.println(s + str);        consumer.accept(&quot;1211&quot;);    &#125;&#125;</code></pre><h3 id="级联表达式和柯里化"><a href="#级联表达式和柯里化" class="headerlink" title="级联表达式和柯里化"></a>级联表达式和柯里化</h3><pre><code class="java">/** * 级联表达式和柯里化 * 柯里化的目的：函数标准化 * 高阶函数：返回函数的函数 */public class CurryDemo &#123;    public static void main(String[] args) &#123;        // 实现了x+y的级联表达式        Function&lt;Integer, Function&lt;Integer,Integer&gt;&gt; fun = x-&gt;y-&gt;x+y;        System.out.println(fun.apply(2).apply(3));        Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; fun2 = x-&gt;y-&gt;z-&gt;x+y+z;        System.out.println(fun2.apply(2).apply(3).apply(4));        // int[] nums = &#123;2,3,4,5,6,7&#125;;        int[] nums = &#123;2,3,4&#125;;        Function f = fun2;        for (int i=0; i&lt;nums.length; i++)&#123;            if(f instanceof Function)&#123;                Object obj = f.apply(nums[i]);                if(obj instanceof Function)&#123;                    f = (Function)obj;                &#125;else&#123;                    System.out.println(&quot;调用结束：结果为&quot; + obj);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="第三章-Stream流编程"><a href="#第三章-Stream流编程" class="headerlink" title="第三章 Stream流编程"></a>第三章 Stream流编程</h2><h3 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a>外部迭代和内部迭代</h3><ul><li>外部迭代：自己编写迭代细节</li><li>内部迭代：告诉需求</li></ul><h3 id="中间操作和终止操作"><a href="#中间操作和终止操作" class="headerlink" title="中间操作和终止操作"></a>中间操作和终止操作</h3><ul><li>中间操作：返回结果还是流</li><li>终止操作：返回的是一个结果</li></ul><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>在终止操作没有调用的情况下，中间操作不会执行</p><pre><code class="java">public class StreamDemo1 &#123;    public static void main(String[] args) &#123;        int[] nums = &#123;1,2,3&#125;;        // 外部迭代        int sum = 0;        for (int i:nums)&#123;            sum += i;        &#125;        System.out.println(&quot;结果为：&quot; + sum);        // 使用stream的内部迭代        // map就是中间操作（返回流的操作）        // sum就是终止操作        int sum2 = IntStream.of(nums).map(StreamDemo1::doubleNum).sum();        System.out.println(&quot;结果为：&quot; + sum2);        System.out.println(&quot;惰性求值就是在终止操作没有调用的情况下，中间操作不会执行&quot;);        IntStream.of(nums).map(StreamDemo1::doubleNum);    &#125;    public static int doubleNum(int i)&#123;        System.out.println(&quot;执行了乘以2&quot;);        return i*2;    &#125;&#125;</code></pre><h3 id="Stream流编程-创建"><a href="#Stream流编程-创建" class="headerlink" title="Stream流编程 - 创建"></a>Stream流编程 - 创建</h3><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>集合</td><td>Collection.stream/parallelStream</td></tr><tr><td>数组</td><td>Arrays.stream</td></tr><tr><td>数字Stream</td><td>IntStream/LongStream.range/rangeClosed String.chars()  Random.ints/longs/doubles</td></tr><tr><td>自己创建</td><td>Stream.generate/iterate</td></tr></tbody></table><pre><code class="java">public class StreamDemo2 &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 从集合创建        list.stream();        list.parallelStream();        // 从数组创建        Arrays.stream(new int[]&#123;2,3,4&#125;);        // 创建数字流        IntStream.of(1,2,3);        IntStream.rangeClosed(1,10);        // 使用random创建一个无限流        new Random().ints().limit(10);        // 自己产生流        Stream.generate(()-&gt; new Random().nextInt()).limit(20);    &#125;&#125;</code></pre><h3 id="Stream流编程-中间操作"><a href="#Stream流编程-中间操作" class="headerlink" title="Stream流编程 - 中间操作"></a>Stream流编程 - 中间操作</h3><p>无状态：当前操作和其他元素没有关系</p><p>有状态：当前操作和其他元素有依赖关系</p><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>无状态操作</td><td>map/mapToXxx （A对象转为B对象）</td></tr><tr><td></td><td>flatMap/flatMapToXxx （A对象下面有B属性，B是集合；得到所有A属下B属性的集合）</td></tr><tr><td></td><td>filter</td></tr><tr><td></td><td>peek （类似each，但是是中间操作）</td></tr><tr><td></td><td>unordered</td></tr><tr><td>有状态操作</td><td>distinct</td></tr><tr><td></td><td>sorted</td></tr><tr><td></td><td>limit/skip</td></tr></tbody></table><pre><code class="java">public class StreamDemo3 &#123;    public static void main(String[] args) &#123;        String str = &quot;my name is 007&quot;;        // 把每个单词的长度打印出来        Stream.of(str.split(&quot; &quot;)).filter(s -&gt; s.length()&gt;2).map(s -&gt; s.length())                // 调用终止操作，否则代码不会执行                .forEach(System.out::println);        // flatMap A-&gt;B属性（是个集合），最终得到所有的A元素里面的所有B属性集合        // intStream/longStream并不是Stream的子类，所以要装箱 boxed        Stream.of(str.split(&quot; &quot;)).flatMap(s-&gt; s.chars().boxed())                .forEach(i -&gt; System.out.println((char)i.intValue()));        // peek是个中间操作，和forEach类似，forEach是终止操作        System.out.println(&quot;------peek----------&quot;);        Stream.of(str.split(&quot; &quot;)).peek(System.out::println).forEach(System.out::println);        // limit,主要终于无限流        new Random().ints().filter(i-&gt; i&gt;100&amp;&amp;i&lt;1000).limit(10)                .forEach(System.out::println);    &#125;&#125;</code></pre><h3 id="Stream流编程-终止操作"><a href="#Stream流编程-终止操作" class="headerlink" title="Stream流编程 - 终止操作"></a>Stream流编程 - 终止操作</h3><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>非短路操作</td><td>forEach/forEachOrdered</td></tr><tr><td></td><td>collect/toArray</td></tr><tr><td></td><td>reduce</td></tr><tr><td></td><td>min/max/count</td></tr><tr><td>短路操作</td><td>findFirst/findAny</td></tr><tr><td></td><td>allMatch/anyMatch/noneMatch</td></tr></tbody></table><pre><code class="java">public class StreamDemo4 &#123;    public static void main(String[] args) &#123;        String str = &quot;my name is 007&quot;;        // 使用并行流        str.chars().parallel().forEach(i -&gt; System.out.println((char)i));        // 使用forEachOrdered包装顺序        str.chars().parallel().forEachOrdered(i -&gt; System.out.println((char)i));        // 收集到list        List&lt;String&gt; list = Stream.of(str.split(&quot; &quot;)).collect(Collectors.toList());        System.out.println(list);        // 使用reduce拼接字符串        Optional&lt;String&gt; letters = Stream.of(str.split(&quot; &quot;)).reduce((s1, s2)-&gt;s1+&quot;|&quot;+s2);        System.out.println(letters.orElse(&quot;&quot;));        // 带初始值的reduce        String reduce = Stream.of(str.split(&quot; &quot;)).reduce(&quot;&quot;, (s1,s2)-&gt;s1+&quot;|&quot;+s2);        System.out.println(reduce);        // 计算所有单词总长度        Integer length = Stream.of(str.split(&quot; &quot;)).map(s -&gt; s.length())                .reduce(0, (s1,s2)-&gt;s1 + s2);        System.out.println(length);        // max        Optional&lt;String&gt; max = Stream.of(str.split(&quot; &quot;))                .max((s1,s2)-&gt; s1.length() - s2.length());        System.out.println(max.get());        // 使用 findFirst 短路操作        OptionalInt i = new Random().ints().findFirst();        System.out.println(i.getAsInt());    &#125;&#125;</code></pre><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><pre><code class="java">public class StreamDemo5 &#123;    public static void main(String[] args) &#123;        // IntStream.range(1,100).parallel().peek(StreamDemo5::debug).count();        // 现在要实现先并行再串行        // 结论：多次调用parallel/sequential，以最后一次调用为准//        IntStream.range(1,100)//                .parallel().peek(StreamDemo5::debug)//                .sequential().peek(StreamDemo5::debug2)//                .count();        // 并行流使用的线程池：ForkJoinPool.commonPool        // 默认的线程数是当前机器cpu个数        // 使用这个属性修改默认线程数//        System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;5&quot;);//        IntStream.range(1,100).parallel().peek(StreamDemo5::debug).limit(6).count();        // 使用自己的线程池，不使用默认的线程池，防止被其他任务阻塞        ForkJoinPool pool = new ForkJoinPool(20);        pool.submit(()-&gt; IntStream.range(1,100).parallel()            .peek(StreamDemo5::debug).count());        pool.shutdown();        // 让主线程不退出        synchronized (pool)&#123;            try &#123;                pool.wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void debug(int i)&#123;        System.out.println(Thread.currentThread().getName() + &quot;debug &quot; + i);        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void debug2(int i)&#123;        System.err.println(&quot;debug2 &quot; + i);        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><pre><code class="java">        // 得到所有学生的年龄列表        // 尽量使用方法引用（不会多生成一个lambda$0函数），不要使用 s -&gt; s.getAge()。        List&lt;Integer&gt; ages = students.stream().map(Student::getAge)                .collect(Collectors.toList());        Set&lt;Integer&gt; ages1 = students.stream().map(Student::getAge)                .collect(Collectors.toCollection(TreeSet::new));        System.out.println(&quot;所有学生的年龄：&quot; + ages);        System.out.println(&quot;所有学生的年龄：&quot; + ages1);        // 统计汇总信息        IntSummaryStatistics agesSum = students.stream()                .collect(Collectors.summarizingInt(Student::getAge));        System.out.println(&quot;年龄汇总信息：&quot; + agesSum);        // 分块        Map&lt;Boolean, List&lt;Student&gt;&gt; genders = students.stream()                // 根据断言分成两块                .collect(Collectors.partitioningBy(s -&gt; s.getGender() == Gender.MALE));        System.out.println(&quot;男女学生列表：&quot; + genders);        // 分组（分块是一个特殊的分组）        Map&lt;Grade, List&lt;Student&gt;&gt; grades = students.stream()                .collect(Collectors.groupingBy(Student::getGrade));        System.out.println(&quot;班级学生列表：&quot; + grades);        // 得到所有班级学生个数        Map&lt;Grade, Long&gt; gradesCount = students.stream()                .collect(Collectors.groupingBy(Student::getGrade, Collectors.counting()));        System.out.println(&quot;班级学生个数列表：&quot; + gradesCount);</code></pre><h3 id="Stream-运行机制"><a href="#Stream-运行机制" class="headerlink" title="Stream 运行机制"></a>Stream 运行机制</h3><ol><li><p>所有操作是链式调用，一个元素只迭代一次</p></li><li><p>每一个中间操作返回一个新的流，流里面有一个属性sourceStage指向同一个地方，就是Head</p></li><li><p>Head -&gt; nextStage -&gt; nextStage -&gt; … -&gt; null</p></li><li><p><strong>有状态</strong>（入参一般两个参数）操作会把<strong>无状态操作</strong>截断，单独处理</p></li><li><p>并行环境下，有状态的中间操作不一定能并行操作</p></li><li><p>parallel/sequetial 这两个操作也是中间操作（也是返回stream），但是他们不创建流，他们只修改Head的并行标识（parallel）</p></li></ol><pre><code class="java">public static void main(String[] args) &#123;    Random random = new Random();    // 随机产生数据    Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; random.nextInt())        // 产生500个（无限流需要短路操作）        .limit(500)        // 第一个无状态操作        .peek(s -&gt; print(&quot;peek:&quot; + s))        // 第二个无状态操作        .filter(s -&gt; &#123;            print(&quot;filter:&quot; + s);            return s &gt; 1000000;        &#125;)        // 有状态操作        .sorted((i1,i2)-&gt;&#123;            print(&quot;sort:&quot; + i1 + &quot;,&quot; + i2);            return i1.compareTo(i2);        &#125;)        // 又一个无状态操作        .peek(s-&gt; print(&quot;peek2:&quot; + s))        // .parallel()        ;    // 终止操作    stream.count();&#125;</code></pre><h2 id="第四章-reactive-stream响应式流"><a href="#第四章-reactive-stream响应式流" class="headerlink" title="第四章 reactive stream响应式流"></a>第四章 reactive stream响应式流</h2><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>发布者和订阅者可以交流。</p><p>发布者：自来水公司</p><p>订阅者：家</p><p>背压：相当于水龙头</p><pre><code class="java">import java.util.concurrent.Flow;import java.util.concurrent.SubmissionPublisher;public class FlowDemo &#123;    public static void main(String[] args) &#123;        // 1. 定义发布者，发布的数据类型是Integer        // 直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();        // 2. 定义订阅者        Flow.Subscriber&lt;Integer&gt; subscriber = new Flow.Subscriber&lt;Integer&gt;() &#123;            private Flow.Subscription subscription;            @Override            public void onSubscribe(Flow.Subscription subscription) &#123;                // 保存订阅关系，需要用它来给发布者响应                this.subscription = subscription;                // 请求一个数据                this.subscription.request(1);            &#125;            @Override            public void onNext(Integer item) &#123;                // 接收到一个数据，处理                System.out.println(&quot;接收到数据：&quot; + item);                // 处理完调用request再请求一个数据                this.subscription.request(1);                // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了                // this.subscription.cancel();            &#125;            @Override            public void onError(Throwable throwable) &#123;                // 出现了异常（例如处理数据的时候产生了异常）                throwable.printStackTrace();                // 告诉发布者，后边不接受数据了                this.subscription.cancel();            &#125;            @Override            public void onComplete() &#123;                // 发布者close时触发                System.out.println(&quot;处理完了&quot;);            &#125;        &#125;;        // 3. 发布者和订阅者建立订阅关系        publisher.subscribe(subscriber);        // 4. 生产数据，并发布        // 这里忽略数据生产过程        int data = 111;        // submit是阻塞函数        publisher.submit(data);        publisher.submit(222);        publisher.submit(333);        // 5. 结束后，关闭发布者        // 正式环境应该放finally确保关闭        publisher.close();        // 主线程延迟停止，否则数据没有消费就退出        try &#123;            Thread.currentThread().join(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><pre><code class="java">import java.util.concurrent.Flow;import java.util.concurrent.SubmissionPublisher;public class FlowDemo2 &#123;    public static void main(String[] args) &#123;        // 1. 定义发布者，发布的数据类型是Integer        // 直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();        // 2. 定义处理器，对数据进行过滤，并转换为String类型        MyProcessor processor = new MyProcessor();        // 3. 发布者和处理器建立订阅关系        publisher.subscribe(processor);        // 4. 定义最终订阅者，消费String类型数据        Flow.Subscriber&lt;String&gt; subscriber = new Flow.Subscriber&lt;String&gt;() &#123;            private Flow.Subscription subscription;            @Override            public void onSubscribe(Flow.Subscription subscription) &#123;                // 保存订阅关系，需要用它来给发布者响应                this.subscription = subscription;                // 请求一个数据                this.subscription.request(1);            &#125;            @Override            public void onNext(String item) &#123;                // 接收到一个数据，处理                System.out.println(&quot;接收到数据：&quot; + item);                // 处理完调用request再请求一个数据                this.subscription.request(1);                // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了                // this.subscription.cancel();            &#125;            @Override            public void onError(Throwable throwable) &#123;                // 出现了异常（例如处理数据的时候产生了异常）                throwable.printStackTrace();                // 告诉发布者，后边不接受数据了                this.subscription.cancel();            &#125;            @Override            public void onComplete() &#123;                // 发布者close时触发                System.out.println(&quot;处理完了&quot;);            &#125;        &#125;;        // 5. 处理器和最终订阅者建立订阅关系        processor.subscribe(subscriber);        // 6. 生产数据，并发布        // 这里忽略数据生产过程        publisher.submit(-111);        publisher.submit(111);        // 5. 结束后，关闭发布者        // 正式环境应该放finally确保关闭        // processor.close();        publisher.close();        // 主线程延迟停止，否则数据没有消费就退出        try &#123;            Thread.currentThread().join(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;/** * 输入源数据 Integer，过滤掉小于0的，然后转换成字符串发布出去 */class MyProcessor extends SubmissionPublisher&lt;String&gt; implements Flow.Processor&lt;Integer, String&gt;&#123;    private Flow.Subscription subscription;    @Override    public void onSubscribe(Flow.Subscription subscription) &#123;        // 保存订阅关系，需要用它来给发布者响应        this.subscription = subscription;        // 请求一个数据        this.subscription.request(1);    &#125;    @Override    public void onNext(Integer integer) &#123;        // 接收到一个数据，处理        System.out.println(&quot;处理器接收到数据：&quot; + integer);        // 过滤掉小于0的数据，然后发布出去        if(integer &gt; 0)&#123;            this.submit(&quot;转换后的数据：&quot; + integer);        &#125;        // 处理完成，调用request再请求一个数据        this.subscription.request(1);        // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了        // this.subscription.cancel();    &#125;    @Override    public void onError(Throwable throwable) &#123;        // 出现了异常（例如处理数据的时候产生了异常）        throwable.printStackTrace();        // 告诉发布者，后边不接受数据了        this.subscription.cancel();    &#125;    @Override    public void onComplete() &#123;        // 发布者close时触发        System.out.println(&quot;处理器处理完了&quot;);    &#125;&#125;</code></pre><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><pre><code class="java">// 是阻塞函数。缓冲池满了就不再生产数据publisher.submit(data);</code></pre><h2 id="第五章-RxJava2-响应式编程"><a href="#第五章-RxJava2-响应式编程" class="headerlink" title="第五章  RxJava2-响应式编程"></a>第五章  RxJava2-响应式编程</h2><h3 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h3><p>RxJava = Observer + 异步处理</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;    &lt;artifactId&gt;rxjava&lt;/artifactId&gt;    &lt;version&gt;2.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code class="java">import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.functions.Consumer;import io.reactivex.schedulers.Schedulers;public class HelloRx &#123;    public static void main(String[] args) &#123;        // 事件源(被观察者)        Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;                emitter.onNext(&quot;hello&quot;);                emitter.onNext(&quot;www.monkeykong.github.io&quot;);                emitter.onNext(&quot;let`s study!&quot;);            &#125;        &#125;);        // 消费者（观察者）        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;            public void accept(String s) throws Exception &#123;                System.out.println(Thread.currentThread().getName() + &quot;== consumer == &quot; + s);            &#125;        &#125;;        // 观察者        Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;            @Override            public void onSubscribe(Disposable disposable) &#123;            &#125;            @Override            public void onNext(String s) &#123;                System.out.println(Thread.currentThread().getName() + &quot;== observer == &quot; + s);            &#125;            @Override            public void onError(Throwable throwable) &#123;            &#125;            @Override            public void onComplete() &#123;            &#125;        &#125;;        // 耦合        // observable.subscribe(consumer);        // 异步        observable.observeOn(Schedulers.newThread()).subscribe(consumer);        observable.observeOn(Schedulers.newThread()).subscribe(observer);        for (;;);    &#125;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5b17560e6fb9a01e2862246f">https://juejin.im/post/5b17560e6fb9a01e2862246f</a></p><h2 id="第五章-SpingWebFlux"><a href="#第五章-SpingWebFlux" class="headerlink" title="第五章 SpingWebFlux"></a>第五章 SpingWebFlux</h2><p>待学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 讲义进阶之函数式编程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java讲义" scheme="http://yoursite.com/tags/Java%E8%AE%B2%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>第 1 章 构建 Spring 之旅</title>
    <link href="http://yoursite.com/2020-12-21-13Spring%E5%9F%BA%E7%A1%80/20191019sia1.html"/>
    <id>http://yoursite.com/2020-12-21-13Spring%E5%9F%BA%E7%A1%80/20191019sia1.html</id>
    <published>2020-12-21T14:13:12.000Z</published>
    <updated>2020-12-27T15:16:05.366Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 最根本的使命：简化 Java 开发</p><p>为了降低 Java 开发的复杂性，Spring 采取以下4种策略：</p><ul><li>基于 POJO 的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ul><a id="more"></a><h2 id="基于-POJO-的最小侵入性编程"><a href="#基于-POJO-的最小侵入性编程" class="headerlink" title="基于 POJO 的最小侵入性编程"></a>基于 POJO 的最小侵入性编程</h2><p>很多框架通过强迫应用继承他们的类或者实现他们的接口从而导致应用和框架绑死。</p><p>Spring 竭力避免因自身的 API 而弄乱你的应用代码。Spring 不会强迫你实现 Spring 框架的接口或者继承他的类，相反，在基于 Spring 构建的应用中，他的类通常没有任何痕迹表面你使用了 Spring。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>DI 功能是如何实现的？</p><p>任何一个有实际意义的项目，都会由两个或者更多的类组成，这些类互相之间进行协作来完成特定的业务逻辑。按照传统的做法，每个对象负责管理与自己项目协作的对象(即它所依赖的对象)的引用，这将会导致高度耦合和难以测试的代码。</p><p>例如：</p><pre><code class="java">/** * 拯救少女的骑士 * DamselRescuingKnight 与 RescueDamselQuest 紧耦合，导致 DamselRescuingKnight 骑士只能执行拯救少女的任务。 */public class DamselRescuingKnight implements Knight&#123;  // 拯救少女任务  private RescueDamselQuest quest;  public DamselRescuingKnight()  &#123;    // 在构造函数自行创建了探险任务，因此极大的限制了骑士的能力。如果一个少女需要救援，这个骑士能    // 够召之即来。但是如果一条恶龙需要杀掉，或者一个圆桌需要滚起来，那么这个    // 骑士就爱莫能助了。    this.quest = new RescueDamselQuest();  &#125;  public void embarkOnQuest()  &#123;    quest.embark();  &#125;&#125;</code></pre><p>上边定义的这个骑士，因为和特定的任务紧耦合了，所以该骑士只能执行一种类型的探险任务。</p><pre><code class="java">/** * 勇敢的骑士 * 这个骑士可以接受任务赋予他的探险任务 */public class BraveKnight implements Knight &#123;  // 骑士的探索任务  private Quest quest;  public BraveKnight(Quest quest) &#123;    this.quest = quest;  &#125;  public void embarkOnQuest() &#123;    quest.embark();  &#125;&#125;</code></pre><p>BraveKnight 可以执行任何探险任务。关键点在于 BraveKnight 没有自行创建探险任务，而是在构造的时候把探险任务作为构造器参数传入。这是<strong>依赖注入</strong>的方式之一，即<strong>构造器注入</strong>（constructor injection）。</p><p>BraveKnight 没有与任何特定的 Quest 实现发生耦合。这就是 DI 所带来的最大收益(<strong>松耦合</strong>)。如果一个对象只通过接口（而不是具体实现或初始化过程）来表明依赖关系，那么这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现进行替换。</p><h3 id="通过-xml-注入-bean"><a href="#通过-xml-注入-bean" class="headerlink" title="通过 xml 注入 bean"></a>通过 xml 注入 bean</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;  &lt;!-- 勇敢的骑士注入 spring 容器，并将杀龙探险任务交给这个骑士 --&gt;  &lt;bean id=&quot;knight&quot; class=&quot;sia.knights.BraveKnight&quot;&gt;    &lt;constructor-arg ref=&quot;quest&quot; /&gt;  &lt;/bean&gt;  &lt;!-- 杀龙探险任务注入 Spring 容器，并将 System.out 交给该任务 --&gt;  &lt;bean id=&quot;quest&quot; class=&quot;sia.knights.SlayDragonQuest&quot;&gt;    &lt;constructor-arg value=&quot;#&#123;T(System).out&#125;&quot; /&gt;  &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="通过配置类注入-bean"><a href="#通过配置类注入-bean" class="headerlink" title="通过配置类注入 bean"></a>通过配置类注入 bean</h3><pre><code class="java">/** * 该功能和 knight.xml 功能相同 */@Configurationpublic class KnightConfig&#123;  @Bean  public Knight knight()  &#123;    return new BraveKnight(quest());  &#125;  @Bean  public Quest quest()  &#123;    return new SlayDragonQuest(System.out);  &#125;&#125;</code></pre><p>Spring通过应用上下文（Application Context）装载 bean 的定义并把它们组装起来。Spring 应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p><p>从应用上下文获取 bean</p><pre><code class="java">public class KnightMain&#123;  public static void main(String[] args) throws Exception  &#123;    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(            &quot;META-INF/spring/knight.xml&quot;);    Knight knight = context.getBean(Knight.class);    knight.embarkOnQuest();    context.close();  &#125;&#125;</code></pre><p>注意这个类完全不知道我们的英雄骑士接受哪种探险任务，而且完全没有意识到这是由BraveKnight来执行的。只有knights.xml文件知道哪个骑士执行哪种探险任务。</p><h2 id="应用切面"><a href="#应用切面" class="headerlink" title="应用切面"></a>应用切面</h2><h3 id="应用切面的好处"><a href="#应用切面的好处" class="headerlink" title="应用切面的好处"></a>应用切面的好处</h3><p>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-oriented-programming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p><p>诸如日志、事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。</p><p>如果将这些关注点分散到多个组件，代码将会有两个问题</p><ol><li>实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。<strong>即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中</strong>。</li><li>组件会因为那些与自身核心业务无关的代码而变得混乱。<strong>一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。</strong></li></ol><p>AOP能够使这些关注点模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所以业务组件会具有更高的内聚性，只需要关注自身业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。</p><h3 id="应用切面的简单例子"><a href="#应用切面的简单例子" class="headerlink" title="应用切面的简单例子"></a>应用切面的简单例子</h3><p>还是上面骑士的例子，假设我们需要使用吟游诗人这个服务类来记载骑士的所有事迹。</p><p>诗人类：</p><pre><code class="java">/** * 吟游诗人 */public class Minstrel&#123;  private PrintStream stream;  public Minstrel(PrintStream stream)  &#123;    this.stream = stream;  &#125;  public void singBeforeQuest()  &#123;    stream.println(&quot;Fa la la, the knight is so brave!&quot;);  &#125;  public void singAfterQuest()  &#123;    stream.println(&quot;Tee hee hee, the brave knight did embark on a quest!&quot;);  &#125;&#125;</code></pre><p>配置切面：</p><pre><code class="xml">&lt;!-- 配置切面 --&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;minstrel&quot;&gt;        &lt;aop:pointcut id=&quot;embark&quot;                      expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;embark&quot;                     method=&quot;singBeforeQuest&quot;/&gt;        &lt;aop:after pointcut-ref=&quot;embark&quot;                    method=&quot;singAfterQuest&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>当然，我们可以把诗人注入到骑士中，骑士执行完任务后，掉用骑士的方法。但是，管理他的吟游诗人并不是骑士职责范围。在我看来，吟游诗人应该做他份内的事，根本不需要骑士命令他这么做。</p><p>所以，利用AOP，你可以声明吟游诗人必须歌颂骑士的探险事迹，而骑士本身并不用直接访问Minstrel的方法。</p><p>问题：切面没有生效？</p><h2 id="使用模板消除样板式代码"><a href="#使用模板消除样板式代码" class="headerlink" title="使用模板消除样板式代码"></a>使用模板消除样板式代码</h2><p>在使用 Spring 之前，有时总会写一些版式代码。例如 JDBC，首先你需要创建一个数据库连接，然后再创建一个语句对象，最后你才能进行查询。为了平息 JDBC 可能会出现的怒火，你必须捕捉 SQLException，这是一个检查型异常，即使它抛出后你也做不了太多事情。</p><h2 id="Spring-容器"><a href="#Spring-容器" class="headerlink" title="Spring 容器"></a>Spring 容器</h2><ul><li>bean 工厂：由 org.springframework. beans. factory.eanFactory 接口定义</li><li>应用上下文：由 org.springframework.context.ApplicationContext 接口定义</li></ul><h3 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h3><ul><li>AnnotationConfigApplicationContext</li></ul><pre><code class="java">ApplicationContext ac = new AnnotationConfigApplicationContext(sia.knights.config.KnightConfig.class);</code></pre><ul><li>AnnotationConfigWebApplicationContext</li><li>ClassPathXmlApplicationContext</li></ul><pre><code class="java">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;kinght.xml&quot;);</code></pre><ul><li>FileSystemXmlapplicationcontext</li></ul><pre><code class="java">ApplicationContext ac = new FileSystemXmlapplicationcontext(&quot;c:/knight.xml&quot;);</code></pre><ul><li>XmlWebApplicationContext</li></ul><h2 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h2><ol><li>Spring 对 bean 进行实例化</li><li>Spring 将值和 bean 的引用注入到 bean 对应的属性中</li><li>如果bean实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给 setBeanName()方法；</li><li>如果bean实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入；</li><li>如果 bean 实现了 ApplicationContextAware 接口，Spring 将调用setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization() 方法；</li><li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet() 方法。类似地，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessAfterInitialization() 方法；</li><li>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，<br>直到该应用上下文被销毁；</li><li>如果 bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy() 接口方法。同<br>样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用。</li></ol><h2 id="Spring-模块"><a href="#Spring-模块" class="headerlink" title="Spring 模块"></a>Spring 模块</h2><ol><li><p>Spring 核心容器</p><p>Beans、Core、Context、Expression、Contextsupport</p></li><li><p>Spring AOP</p><p>AOP、Aspects</p></li><li><p>数据访问与集成</p><p>JDBC、Transaction、ORM、OXM、Messaging、JMS</p></li><li><p>Web 与远程调用</p><p>web、Web servlet、Web portlet、WebSocket</p></li><li><p>Instrumentation</p><p>Instrument、Instrument Tomcat</p></li><li><p>test</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring 最根本的使命：简化 Java 开发&lt;/p&gt;
&lt;p&gt;为了降低 Java 开发的复杂性，Spring 采取以下4种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 POJO 的轻量级和最小侵入性编程&lt;/li&gt;
&lt;li&gt;通过依赖注入和面向接口实现松耦合&lt;/li&gt;
&lt;li&gt;基于切面和惯例进行声明式编程&lt;/li&gt;
&lt;li&gt;通过切面和模板减少样板式代码&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 学习(一)</title>
    <link href="http://yoursite.com/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html"/>
    <id>http://yoursite.com/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html</id>
    <published>2020-11-30T14:13:12.000Z</published>
    <updated>2020-12-07T13:46:48.665Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScipt 学习。</p><a id="more"></a><h2 id="环境和-HelloWorld"><a href="#环境和-HelloWorld" class="headerlink" title="环境和 HelloWorld"></a>环境和 HelloWorld</h2><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><pre><code class="shell">-- 安装 node-- 安装 typescriptnpm install typescript -g</code></pre><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><pre><code class="typescript">function jspang() &#123;  let web: string = &quot;Hello World&quot;  console.log(web)&#125;// ts-nodejspang()</code></pre><p><strong>执行：</strong></p><pre><code class="sh"># 编译，完成会生成 Demo1.jstsc Demo1.ts# 执行node Demo1.js</code></pre><p><strong>简易执行：</strong></p><pre><code class="shell"># 安装 ts-nodenpm install -g ts-node# 直接用 ts-node 执行，省去编译命令ts-node Demo1.ts</code></pre><h2 id="TypeScript-静态类型"><a href="#TypeScript-静态类型" class="headerlink" title="TypeScript 静态类型"></a>TypeScript 静态类型</h2><p>一旦定义不可再改变。</p><pre><code class="typescript">let count: number = 1;// 编译报错// count = &#39;alvin&#39;;count = 2;</code></pre><p>自定义静态类型：</p><pre><code class="typescript">// 定义接口,相当于自定义一个静态类型interface XiaoJieJie &#123;  uname: string,  age: number&#125;const xiaohong: XiaoJieJie = &#123;  uname: &#39;xiaohong&#39;,  age: 18&#125;console.log(xiaohong.age)</code></pre><p><strong>对象静态类型：</strong></p><pre><code class="typescript">// 对象类型const xiaojiejie: &#123;  name: string,  age: number&#125; = &#123;  name: &#39;大脚&#39;,  age: 18&#125;// 数组类型const xiaojiejies: string[] = [&#39;谢大脚&#39;, &#39;留影&#39;, &#39;123&#39;]// 对象类型class Person &#123; &#125;const dajiao: Person = new Person()const jianxiaojiejie: () =&gt; string = () =&gt; &#123; return &#39;大叫&#39; &#125;// 对象类型 数组类型 类类型 函数类型</code></pre><h2 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h2><pre><code class="typescript">// type annotation 类型注解// type reference 类型推断// 类型注解。声明变量类型let count1: number;count1 = 123;// 类型推断。自动推断类型let countReference = 1;// 潜规则// 1. 能够自动分析的，无需写类型// 2. 不能自动分析得到类型的，使用类型注解function getTotal(one: number, two: number) &#123;  return one + two;&#125;const total = getTotal(1, 2)</code></pre><h2 id="返回类型注解"><a href="#返回类型注解" class="headerlink" title="返回类型注解"></a>返回类型注解</h2><pre><code class="typescript">// 指定函数返回类型function getTotal2(one: number, two: number): number &#123;  return one + two;&#125;const total2 = getTotal2(1, 2)function sayHello(): void &#123;  console.log(&#39;Hello World&#39;)&#125;function errorFunction(): never &#123;  throw new Error()  console.log(&#39;Hello World&#39;);&#125;function forNeer(): never &#123;  while (true) &#123; &#125;  console.log(&#39;Hi&#39;);&#125;// 指定对象的属性类型，必须这样function add(&#123; one, two &#125;: &#123; one: number, two: number &#125;) &#123;  return one + two&#125;const tatal3 = add(&#123; one: 1, two: 2 &#125;)</code></pre><h2 id="数组类型注解"><a href="#数组类型注解" class="headerlink" title="数组类型注解"></a>数组类型注解</h2><pre><code class="typescript">// 数组类型注解const numberArr = [1, 2, 3]const numberArr2: number[] = [1, 2, 3]const stringArr: string[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]const undefinedArr: undefined[] = [undefined, undefined]const arr: (number | string)[] = [1, &#39;string&#39;, 2]const xiaojiejies6: &#123; name: string, age: number &#125;[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]// type alias 类型别名type Lady = &#123; name: string, age: number &#125;const xiaojiejies61: Lady[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]// class 形式也可以class Madam &#123;  name: string;  age: number;&#125;const xiaojiejies62: Madam[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><pre><code class="typescript">// 元组学习// 数组无法识别数组元素类型的顺序const xiaojiejie7: (string | number)[] = [&#39;dajiao&#39;, &#39;teacher&#39;, 18]// 元组，可以校验顺序const xiaojiejie71: [string, string, number] = [&#39;dajiao&#39;, &#39;teacher&#39;, 18]</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code class="typescript">const screenResume = (name: string, age: number, bust: number) =&gt; &#123;  age &lt; 24 &amp;&amp; bust &gt;= 90 &amp;&amp; console.log(name + &#39;进入面试&#39;)  age &gt;= 23 || bust &lt; 90 &amp;&amp; console.log(name + &#39;你被淘汰&#39;)&#125;const getResume = (name: string, age: number, bust: number) =&gt; &#123;  console.log(name + &#39;年龄是&#39; + age)  console.log(name + &#39;胸围是&#39; + bust)&#125;screenResume(&#39;大脚&#39;, 18, 94)getResume(&#39;大脚&#39;, 18, 94)// 使用接口进行优化interface Girl &#123;  name: string;  age: number;  bust: number;  waistline?: number;&#125;const girl = &#123;  name: &#39;大脚&#39;,  age: 18,  bust: 94,  waistline: 21&#125;const screenResume1 = (girl: Girl) =&gt; &#123;  girl.age &lt; 24 &amp;&amp; girl.bust &gt;= 90 &amp;&amp; console.log(girl.name + &#39;进入面试&#39;)  girl.age &gt;= 23 || girl.bust &lt; 90 &amp;&amp; console.log(girl.name + &#39;你被淘汰&#39;)&#125;const getResume1 = (girl: Girl) =&gt; &#123;  console.log(girl.name + &#39;年龄是&#39; + girl.age)  console.log(girl.name + &#39;胸围是&#39; + girl.bust)  girl.waistline &amp;&amp; console.log(girl.name + &#39;腰围是&#39; + girl.waistline)&#125;screenResume1(girl)getResume1(girl)</code></pre><h2 id="接口约束类"><a href="#接口约束类" class="headerlink" title="接口约束类"></a>接口约束类</h2><pre><code class="typescript">// 定义一个类interface Girl &#123;  name: string,  age: number,  bust: number,  yaowei?: number,  [propname: string]: any,  say(): string&#125;// 用接口来约束类class XiaoJieJie implements Girl &#123;  name: string;  age: number;  bust: number;  say() &#123;    return &quot;欢迎光临，我是&quot; + this.name + &quot;！&quot;  &#125;&#125;// 定义一个对象const xiaohong = new XiaoJieJie();xiaohong.age = 22;xiaohong.name = &#39;小红&#39;;xiaohong.bust = 98;// 使用对象console.info(xiaohong.say());// 类继承class Teacher extends XiaoJieJie &#123;  teach(): string &#123;    return &#39;我来教你做&#39;;  &#125;&#125;const xiaomei = new Teacher();console.info(xiaomei.teach());</code></pre><h2 id="类的继承、重写和-super"><a href="#类的继承、重写和-super" class="headerlink" title="类的继承、重写和 super"></a>类的继承、重写和 super</h2><pre><code class="typescript">// 类的继承、重写和 superclass Lady &#123;  sayHi() &#123;    return &quot;Hi！帅哥。&quot;  &#125;&#125;class Beauty extends Lady &#123;  sayHi() &#123;    return super.sayHi() + &quot;你好。&quot;  &#125;  sayLove() &#123;    return &#39;I love you.&#39;;  &#125;&#125;console.info(new Beauty().sayHi())</code></pre><h2 id="类的访问类型"><a href="#类的访问类型" class="headerlink" title="类的访问类型"></a>类的访问类型</h2><pre><code class="typescript">// 类的访问类型// public 公共的// private 私有的（类内部）// protected 继承类class Person &#123;  public name: string;  private age: number;  protected hobby: string;&#125;class Man extends Person &#123;  say() &#123;    console.info(this.name);    // 报错    //console.info(this.age);    console.info(this.hobby);  &#125;&#125;const p11 = new Person();console.info(p11.name);// 报错//console.info(p11.age);// 报错//console.info(p11.hobby);</code></pre><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><pre><code class="typescript">class Person121 &#123;  public name: string;  constructor(name: string) &#123;    this.name = name;  &#125;&#125;class Person12 &#123;  constructor(public name: string) &#123;    console.info(&quot;111&quot;)  &#125;&#125;class Teacher12 extends Person12 &#123;  constructor() &#123;    console.info(&quot;000&quot;)    // 子类必须调用父类的构造函数    super(&quot;Alvin&quot;);    console.info(&quot;222&quot;)  &#125;&#125;console.log(new Person121(&#39;alvin&#39;).name)console.log(new Person12(&#39;alvin&#39;).name)console.log(new Teacher12().name)</code></pre><h2 id="getter、setter-和静态属性"><a href="#getter、setter-和静态属性" class="headerlink" title="getter、setter 和静态属性"></a>getter、setter 和静态属性</h2><pre><code class="typescript">// getter、setter和静态属性class Person13 &#123;  constructor(private _age: number) &#123; &#125;  get age() &#123;    return this._age;  &#125;  set age(age: number) &#123;    this._age = age;  &#125;  static sayHi() &#123;    console.info(&quot;Hi.&quot;)  &#125;&#125;const p13 = new Person13(20);console.info(p13.age);p13.age = 18;console.info(p13.age);// 报错// p13._age = 10;console.info(Person13.sayHi())</code></pre><h2 id="抽象类和只读属性"><a href="#抽象类和只读属性" class="headerlink" title="抽象类和只读属性"></a>抽象类和只读属性</h2><pre><code class="typescript">// 只读属性、抽象类class Person14 &#123;  public readonly _money: number;  constructor(money: number) &#123;    this._money = money;  &#125;&#125;const p14 = new Person14(123);console.info(p14._money)// 报错//p14._money = 122abstract class Person141 &#123;  abstract say(): string;&#125;class Person1411 extends Person141 &#123;  say() &#123;    return &quot;111&quot;  &#125;&#125;class Person1412 extends Person141 &#123;  say() &#123;    return &quot;222&quot;  &#125;&#125;console.info(new Person1411().say())console.info(new Person1412().say())</code></pre><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><pre><code class="json"># 生成 tsconfig.json 文件tsc -init# 设置编译时取出注释&quot;removeComments&quot;: true,# 执行编译tsc Demo15.ts# 发现生成的 js 还是有注释# 这样就好了tsc</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;TypeScipt 学习。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Flex 布局实战</title>
    <link href="http://yoursite.com/2020-11-15-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98.html"/>
    <id>http://yoursite.com/2020-11-15-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98.html</id>
    <published>2020-11-15T14:13:12.000Z</published>
    <updated>2020-11-24T14:51:11.298Z</updated>
    
    <content type="html"><![CDATA[<p>Flex 布局基础概念和语法。</p><a id="more"></a><pre><code class="css">justify-content: space-between;flex-direction: cloumn;justify-content: space-between;align-items: center;flex-direction: column;align-self: center;flex-wrap: wrap;justify-content: flex-end;align-content: space-between;justify-content: space-between;alignn-content: space-between;.column &#123;    flex-directon: column;    justify-content: space-between;&#125;.item &#123;    justify-content: space-between;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flex 布局基础概念和语法。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="flex" scheme="http://yoursite.com/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（六）</title>
    <link href="http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%806-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%806-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</id>
    <published>2020-11-08T15:13:12.000Z</published>
    <updated>2020-11-24T14:50:37.801Z</updated>
    
    <content type="html"><![CDATA[<p>链表常见问题</p><a id="more"></a><h2 id="1、原则和常用数据结构与技巧"><a href="#1、原则和常用数据结构与技巧" class="headerlink" title="1、原则和常用数据结构与技巧"></a>1、原则和常用数据结构与技巧</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li><p>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p></li><li><p>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p></li></ul><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><ul><li>使用容器（哈希表、数组等）</li><li>快慢指针</li></ul><h2 id="2、-快慢指针"><a href="#2、-快慢指针" class="headerlink" title="2、 快慢指针"></a>2、 快慢指针</h2><p>总体都是快指针一次跳两步，慢指针一次一步。通过调整起始边界解决不同场景。</p><p><strong>如果不在乎空间复杂度，比如笔试时，可以不用快慢指针，直接使用有序表。</strong></p><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p><pre><code class="java">// 奇数长度返回中点，偶数长度返回上中点public static Node midOrUpMidNode(Node h) &#123;    // null、一个、两个节点均返回 h    if (h == null || h.next == null || h.next.next == null) &#123;        return h;    &#125;    // 大于等于三个节点    Node slow = h.next;    Node fast = h.next.next;    while (fast.next != null &amp;&amp; fast.next.next != null) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    return slow;&#125;public static Node right1(Node h) &#123;    if (h == null) &#123;        return null;    &#125;    Node cur = h;    ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();    while (cur != null) &#123;        arr.add(cur);        cur = cur.next;    &#125;    // 6个：(6-1)/2=&gt;2 (7-1)/2=&gt;3    return arr.get((arr.size() - 1)/2);&#125;</code></pre><p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p><pre><code class="java">// 奇数长度返回中点，偶数长度返回下中点public static Node midOrDownMidNode(Node h) &#123;    // null、一个均返回 h    if (h == null || h.next == null) &#123;        return h;    &#125;    // 大于等于两个节点    Node slow = h.next;    Node fast = h.next;    while (fast.next != null &amp;&amp; fast.next.next != null) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    return slow;&#125;public static Node right2(Node h) &#123;    if (h == null) &#123;        return null;    &#125;    Node cur = h;    ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();    while (cur != null) &#123;        arr.add(cur);        cur = cur.next;    &#125;    // 6个：6/2=&gt;3 7/2=&gt;3    return arr.get(arr.size()/2);&#125;</code></pre><p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p><p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p><h2 id="3、判断链表是否为回文结构"><a href="#3、判断链表是否为回文结构" class="headerlink" title="3、判断链表是否为回文结构"></a>3、判断链表是否为回文结构</h2><p>问题：给定一个单链表的头节点head，请判断该链表是否为回文结构。 </p><p>1）栈方法特别简单（笔试用）</p><p>2）改原链表的方法就需要注意边界了（面试用）</p><h2 id="4、单链表荷兰国旗问题"><a href="#4、单链表荷兰国旗问题" class="headerlink" title="4、单链表荷兰国旗问题"></a>4、单链表荷兰国旗问题</h2><p>问题：将单向链表按某值划分成左边小、中间相等、右边大的形式</p><p>1）把链表放入数组里，在数组上做 partition（笔试用）</p><pre><code class="java">public static Node listPartition1(Node h, int pivot) &#123;    if (h == null || h.next == null) &#123;        return h;    &#125;    // 取链表节点数量    Node cur = h;    int size = 0;    while (cur != null) &#123;        size++;        cur = cur.next;    &#125;    // 链表节点放入数组    cur = h;    Node[] nodeArr = new Node[size];    nodeArr[0] = h;    for (int i = 1; i &lt; size; i++) &#123;        nodeArr[i] = cur.next;        cur = cur.next;    &#125;    // 对数组做 partition    partition(nodeArr, pivot);    // 数组数据构造节点    for (int i = 0; i &lt; size-1; i++) &#123;        nodeArr[i].next = nodeArr[i+1];    &#125;    nodeArr[size-1].next = null;    return nodeArr[0];&#125;private static void partition(Node[] nodeArr, int pivot) &#123;    if (nodeArr == null || nodeArr.length &lt;= 1) &#123;        return;    &#125;    int less = -1;    int more = nodeArr.length;    int i = 0;    while (i&lt;more) &#123;        // 发往小于区        if (nodeArr[i].value &lt; pivot) &#123;            swap(nodeArr, i++, ++less);            // 发往大于区        &#125; else if (nodeArr[i].value &gt; pivot) &#123;            swap(nodeArr, i, --more);        &#125; else &#123;            i++;        &#125;    &#125;&#125;</code></pre><p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p><p>定义六个指针，分别表示三个部分。</p><pre><code class="java">// 定义6个指针public static Node listPartition2(Node h, int pivot) &#123;    if (h == null || h.next == null) &#123;        return h;    &#125;    Node sH = null; // 小于区 head    Node sT = null; // 小于区 tail    Node eH = null; // 等于区 head    Node eT = null; // 等于去 tail    Node mH = null; // 大于区 head    Node mT = null; // 大于区 tail    Node cur = h;    Node next = null;    // 把链表节点分为三个区    while (cur != null) &#123;        next = cur.next;        cur.next = null;        // 加入小于区        if (cur.value &lt; pivot) &#123;            if (sH == null) &#123;                sH = cur;                sT = cur;            &#125; else &#123;                sT.next = cur;                sT = cur;            &#125;            // 加入等于区        &#125; else if (cur.value == pivot) &#123;            if (eH == null) &#123;                eH = cur;                eT = cur;            &#125; else &#123;                eT.next = cur;                eT = cur;            &#125;            // 加入大于区        &#125; else &#123;            if (mH == null) &#123;                mH = cur;                mT = cur;            &#125; else &#123;                mT.next = cur;                mT = cur;            &#125;        &#125;        cur = next;    &#125;    // 三个区连接起来    if (sT != null) &#123; // 有小于区        if (eH != null) &#123; // 有等于区            sT.next = eH;            if (mH != null) &#123; // 有大于区                eT.next = mH;            &#125; // 没有大于区，不做处理        &#125; else if (mH != null) &#123; // 没有等于区，但是有大于区            sT.next = mH;        &#125; // 没有等于区也没有大于区，不做处理    &#125; else if (eH != null) &#123; // 没有小区区，但是有等于区        eT.next = mH; // 有大于区没有大于区一样赋值    &#125;    return sH != null ? sH : (eH != null ? eH : mH);&#125;</code></pre><h2 id="5、深度复制"><a href="#5、深度复制" class="headerlink" title="5、深度复制"></a>5、深度复制</h2><p>一种特殊的单链表节点类描述如下 </p><pre><code class="java">class Node &#123;     int value;     Node next;     Node rand;     Node(int val) &#123;         value = val;     &#125; &#125; </code></pre><p>rand 指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。</p><p>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。 </p><p>【要求】</p><p>时间复杂度O(N)，额外空间复杂度O(1) </p><pre><code class="java">// 哈希表实现 时间复杂度：O(N) 额外空间复杂度：O(N)public static Node copyListWithRandomByMap(Node head) &#123;    // 1. 遍历链表。把链表数据放进哈希表(key:原节点,value:复制节点)    Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;();    Node cur = head;    while (cur != null) &#123;        map.put(cur, new Node(cur.value));        cur = cur.next;    &#125;    // 2. 再次遍历链表。维护复制节点 next 指针    cur = head;    while (cur != null) &#123;        // 复制节点的 next 为当前节点的 next 的复制节点        map.get(cur).next = map.get(cur.next);        // 复制节点的 rand 为当前节点的 rand 的复制节点        map.get(cur).rand = map.get(cur.rand);        cur = cur.next;    &#125;    // 3. head 的复制节点就是新头部    return map.get(head);&#125;</code></pre><pre><code class="java">// 有限指针实现 时间复杂度：O(N) 额外空间复杂度：O(1)public static Node copyListWithRandomByVar(Node head) &#123;    if (head == null) &#123;        return null;    &#125;    // 1. 遍历链表，把复制节点连接到原节点之后    Node cur = head;    Node next = null;    while (cur != null) &#123;        next = cur.next;        // 新节点插入当前节点之后        // 注意这里是取 cur.value 而不是 next，否则你复制的是下一个节点        cur.next = new Node(cur.value);        cur.next.next = next;        // 注意这里是 cur=next 而不是 cur=cur.next，因为 cur 后面插入了新节点        cur = next;    &#125;    // 2. 遍历链表，维护复制节点的 rand 指针    cur = head;    while (cur != null) &#123;        // 复制节点的 rand = 原节点的 rand 的 next        // 注意要判空        cur.next.rand = cur.rand == null ? null : cur.rand.next;        cur = cur.next.next; // 这里要一次走两步    &#125;    // 3. 遍历链表，还原原来的链表    Node copyHead = head.next;    cur = head;    Node cur2 = null;    while (cur != null) &#123;        // 当前节点的下一跳        next = cur.next.next;        // 当前节点的复制节点        cur2 = cur.next; // cur2 不可能为空，因为 cur 不为空        // 设置当前节点 next        cur.next = next;        // 设置复制节点 next        // 注意判空。        cur2.next = next == null ? null : next.next;        cur = next;    &#125;    return copyHead;&#125;</code></pre><h2 id="6、单链表交叉问题"><a href="#6、单链表交叉问题" class="headerlink" title="6、单链表交叉问题"></a>6、单链表交叉问题</h2><p><a href="https://t.me/proxy?server=47.242.50.61&amp;port=443&amp;secret=eeaac78508e450d9afa37e46eec7d1fee1617a7572652e6d6963726f736f66742e636f6d">https://t.me/proxy?server=47.242.50.61&amp;port=443&amp;secret=eeaac78508e450d9afa37e46eec7d1fee1617a7572652e6d6963726f736f66742e636f6d</a></p><p>给定两个可能有环也可能无环的单链表，头节点 head1 和 head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回 null </p><p>【要求】</p><ul><li>如果两个链表长度之和为 N，时间复杂度请达到 O(N)，额外空间复杂度 请达到 O(1)。 </li></ul><p>【思路】</p><ul><li>要么两个链表都有环，要么两个链表都无环。不存在一个有环和一个无环的单链表进行相交。</li><li>求单链表第一个入环节点，无环返回 null。loop1、loop2<ul><li>n1=head.next n2=head.next.next，n1 为慢指针，n2 为快指针</li><li>n1、n2 第一次相遇时。快指针回到 head，n2 = head</li><li>n1、n2 全部变为慢指针，下一次 n1、n2 相遇肯定是入环点</li></ul></li><li>求无环单链表第一个相交节点，不相交返回 null。（loop1==loop2==null）<ul><li>哈希表实现<ul><li>两个链表节点依次放入 Set 集合中，如果已经存在，则该节点就是第一个交点</li></ul></li><li>指针实现<ul><li>求出两个链表的长度差</li><li>长的链表先走掉长的部分</li><li>然后两个链表一起走，如果存在相等的节点则相交</li></ul></li></ul></li><li>已知两个有环单链表的入环节点 loop1、loop2，求有环单链表第一个相交节点，不相交返回 null。（loop1 != null &amp;&amp; loop2 != null）<ul><li>如果两个有环单链表相交，肯定共用一个环</li><li>在相同节点入环（ loop1 == loop2）：以入环点作为终点，求解过程和两个单链表一样的了</li><li>不相交：如果 loop1 不是链表2 中的节点，说明两个链表不相交，返回 null</li><li>在不同节点入环（loop1 != loop2）:随便返回 loop1、loop2，因为在环上</li></ul></li></ul><h2 id="7、无头删除节点问题"><a href="#7、无头删除节点问题" class="headerlink" title="7、无头删除节点问题"></a>7、无头删除节点问题</h2><p>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表常见问题&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（五）</title>
    <link href="http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%805-%E5%89%8D%E7%BC%80%E6%A0%91_%E6%A1%B6%E6%8E%92%E5%BA%8F_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"/>
    <id>http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%805-%E5%89%8D%E7%BC%80%E6%A0%91_%E6%A1%B6%E6%8E%92%E5%BA%8F_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html</id>
    <published>2020-11-08T14:13:12.000Z</published>
    <updated>2020-11-24T14:50:25.301Z</updated>
    
    <content type="html"><![CDATA[<p>前缀树和桶排序。</p><a id="more"></a><h2 id="1、前缀树"><a href="#1、前缀树" class="headerlink" title="1、前缀树"></a>1、前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上</p><p>2）字符放在路上，节点上有专属的数据项（常见的是 pass 和 end 值）</p><p>3）所有样本都这样添加，如果没有路就新建，如有路就复用</p><p>4）沿途节点的 pass 值增加 1，每个字符串结束时来到的节点 end 值增加 1</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/5/%E5%89%8D%E7%BC%80%E6%A0%91.png"></p><p>1）固定数组实现</p><p>2）哈希表实现</p><pre><code class="java">public static class Node2 &#123;    int p;    int e;    HashMap&lt;Integer, Node2&gt; paths;    public Node2() &#123;        p = 0;        e = 0;        // key：字符串 Acssic 码        // paths[i] == null 表示没路        paths = new HashMap&lt;&gt;();    &#125;&#125;/**     * map 做路劲，可以无数条     */public static class Trie2 &#123;    Node2 root;    public Trie2() &#123;        root = new Node2();    &#125;    public void insertStr(String str) &#123;        if (str == null) &#123;            return;        &#125;        Node2 curNode = root;        curNode.p++;        char[] chars = str.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            // 为null说明是新路            if (!curNode.paths.containsKey((int)chars[i])) &#123;                curNode.paths.put((int) chars[i], new Node2());            &#125;            // 注意先跳到下一个节点，然后再 p++            curNode = curNode.paths.get((int)chars[i]);            curNode.p++;        &#125;        curNode.e++;    &#125;    public int searchStr(String str) &#123;        if (str == null) &#123;            return 0;        &#125;        Node2 curNode = root;        char[] chars = str.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            // 没有路，肯定为 0            if (!curNode.paths.containsKey((int)chars[i])) &#123;                return 0;            &#125;            curNode = curNode.paths.get((int)chars[i]);        &#125;        return curNode.e;    &#125;    public void deleteStr(String str) &#123;        // 树中存在字符串才处理        if (searchStr(str) &gt; 0) &#123;            Node2 curNode = root;            // 要记得 p--            curNode.p--;            char[] chars = str.toCharArray();            for (int i = 0; i &lt; chars.length; i++) &#123;                if(--curNode.paths.get((int)chars[i]).p == 0) &#123;                    // p 为 0 了，后边就无需遍历了，直接设置为 null                    curNode.paths.remove((int)chars[i]);                    return;                &#125;                curNode = curNode.paths.get((int)chars[i]);            &#125;            curNode.e--;        &#125;    &#125;    public int prefixCount(String pre) &#123;        if (pre == null) &#123;            return 0;        &#125;        Node2 curNode = root;        char[] chars = pre.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            if (!curNode.paths.containsKey((int)chars[i])) &#123;                return 0;            &#125;            curNode = curNode.paths.get((int)chars[i]);        &#125;        return curNode.p;    &#125;&#125;</code></pre><h2 id="2、不基于比较的排序"><a href="#2、不基于比较的排序" class="headerlink" title="2、不基于比较的排序"></a>2、不基于比较的排序</h2><p>桶排序思想下的排序：<strong>计数排序和基数排序</strong></p><p>1)桶排序思想下的排序都是不基于比较的排序</p><p>2)时间复杂度为O(N)，额外空间负载度O(M)</p><p>3)应用范围有限，需要样本的数据状况满足桶的划分。一旦要求稍有升级，改写的代价增加是显而易见的。</p><h3 id="2-1-计数排序"><a href="#2-1-计数排序" class="headerlink" title="2.1 计数排序"></a>2.1 计数排序</h3><p><strong>要求：样本是整数，且范围比较窄</strong></p><p>思路：统计词频，然后倒出来。</p><pre><code class="java">// only for 0~200 valuepublic static void countSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    int max = Integer.MIN_VALUE;    for (int i = 0; i &lt; arr.length; i++) &#123;        max = Math.max(max, arr[i]);    &#125;    int[] countArr = new int[max+1];    for (int i = 0; i &lt; arr.length; i++) &#123;        countArr[arr[i]]++;    &#125;    // [0,2,2,3]    // 1 1 2 2 3 3 3    int index = 0;    for (int i = 0; i &lt; countArr.length; i++) &#123;        // 有 countArr[i] 个 i        for (int j = 0; j &lt; countArr[i]; j++) &#123;            arr[index++] = i;        &#125;    &#125;&#125;</code></pre><h3 id="2-2-基数排序"><a href="#2-2-基数排序" class="headerlink" title="2.2 基数排序"></a>2.2 基数排序</h3><p><strong>要求：样本是10进制的正整数</strong></p><p>思路：</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/5/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png"></p><p>不创建十个队列桶，而是用辅助数组实现入桶和出桶操作：</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/5/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A1%B6.png"></p><pre><code class="java">// only for non-nagetivepublic static void radixSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    // 获取最大值位数    int bitCount = getBitCount(arr);    radixSort(arr, 0, arr.length-1, bitCount);&#125;private static void radixSort(int[] arr, int l, int r, int bitCount) &#123;    // 1:个位 2:十位 3:百位 ...    for (int i = 1; i &lt;= bitCount; i++) &#123;        // 构造 count1        int[] countArr = new int[10];        for (int j = l; j &lt;= r; j++) &#123;            int bitValue = getBitValue(arr[j], i);            countArr[bitValue]++;        &#125;        // 推算 count2        for (int j = 1; j &lt; countArr.length; j++) &#123;            countArr[j] += countArr[j-1];        &#125;        // 创建help数组        int[] help = new int[r-l+1];        for (int j = r; j &gt;= l; j--) &#123;            // 得到个位/十位/百位...数是几            int bitValue = getBitValue(arr[j], i);            // 得到个位/十位/百位...小于等于当前数的个数            int lessCurCount = countArr[bitValue];            help[lessCurCount-1] = arr[j];            countArr[bitValue]--;        &#125;        // help 数组还原到 arr        for (int j = 0; j &lt; help.length; j++) &#123;            arr[l+j] = help[j];        &#125;    &#125;&#125;/**     * 获取指定位数     */private static int getBitValue(int value, int bit) &#123;    return (value/((int)Math.pow(10, bit  - 1)))%10;&#125;private static int getBitCount(int[] arr) &#123;    int maxValue = arr[0];    for (int i = 1; i &lt; arr.length; i++) &#123;        if (arr[i] &gt; maxValue) &#123;            maxValue = arr[i];        &#125;    &#125;    int bitCount = 1;    int tmp = maxValue/10;    while (tmp &gt; 0) &#123;        bitCount++;        tmp = tmp/10;    &#125;    return bitCount;&#125;</code></pre><h2 id="3、排序算法的稳定性"><a href="#3、排序算法的稳定性" class="headerlink" title="3、排序算法的稳定性"></a>3、排序算法的稳定性</h2><p>稳定性是指同样大小的样本在排序之后不会改变相对次序。</p><p>对基础类型来说，稳定性毫无意义。</p><p>对非基础类型来说，稳定性有重要意义。</p><p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的。</p><h2 id="4、排序算法总结"><a href="#4、排序算法总结" class="headerlink" title="4、排序算法总结"></a>4、排序算法总结</h2><table><thead><tr><th></th><th>时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td>O(N^2)</td><td>O(1)</td><td>无</td></tr><tr><td>冒泡排序</td><td>O(N^2)</td><td>O(1)</td><td>有</td></tr><tr><td>插入排序</td><td>O(N^2)</td><td>O(1)</td><td>有</td></tr><tr><td>归并排序</td><td>O(N*logN)</td><td>O(N)</td><td>有</td></tr><tr><td>随机快排</td><td>O(N*logN)</td><td>O(logN)</td><td>无</td></tr><tr><td>堆排序</td><td>O(N*logN)</td><td>O(1)</td><td>无</td></tr><tr><td>计数排序</td><td>O(N)</td><td>O(M)</td><td>有</td></tr><tr><td>基数排序</td><td>O(N)</td><td>O(N)</td><td>有</td></tr></tbody></table><ul><li>不基于比较的排序，对样本数据有严格要求，不易改写</li><li>基于比较得到排序，只要规定好两个样本怎么比较大小就可以直接复用</li><li>基于比较的排序，时间复杂度的极限是 O(N*logN)</li><li>时间复杂度为 O(N*logN)，额外空间复杂度低于O(N)，并且稳定的基于比较的排序是不存在的</li><li>为了绝对的速度选择快排、为了省空间选择堆排、为了稳定性选择归并</li></ul><h2 id="5、常见的坑"><a href="#5、常见的坑" class="headerlink" title="5、常见的坑"></a>5、常见的坑</h2><p>1、归并排序的额外空间复杂度可以变为O(1)，“归并排序 内部缓存法”，但是变得不再稳定。那么为啥不直接堆排呢？没意义。</p><p>2、“原地归并排序”是垃圾帖，会让时间复杂度变为 O(N^2)。</p><p>3、快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。</p><p>4、在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始的相对次序不变。要求时间复杂度O(N)、额外空间复杂度O(1)。</p><p>​    无法实现。这里分组和快排是一个道理，分组无法做到稳定性。</p><h2 id="6、工程上对排序的改进"><a href="#6、工程上对排序的改进" class="headerlink" title="6、工程上对排序的改进"></a>6、工程上对排序的改进</h2><h3 id="6-1-稳定性考虑"><a href="#6-1-稳定性考虑" class="headerlink" title="6.1 稳定性考虑"></a>6.1 稳定性考虑</h3><p>如果排序的是基本类型，直接快排；如果是引用类型，归并排序。</p><h3 id="6-2-充分利用-O-N-logN-和O-N-2-排序各自的优势"><a href="#6-2-充分利用-O-N-logN-和O-N-2-排序各自的优势" class="headerlink" title="6.2 充分利用 O(N*logN)和O(N^2)排序各自的优势"></a>6.2 充分利用 O(N*logN)和O(N^2)排序各自的优势</h3><p>快排、归并、堆排调度优秀，所以可以做到时间复杂度O(N*logN)，但是其实常数项很高；插入排序调度不好，但是常数项低。所以可以在排块、归并等排序递归样本数小于某个值比如 60 时，直接用插入排序。这样不会改变时间复杂度，但是可以减少常数项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前缀树和桶排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（三）</title>
    <link href="http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%803-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%803-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-02T14:13:12.000Z</published>
    <updated>2020-11-24T14:49:54.270Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序和快速排序。</p><a id="more"></a><h2 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h2><h3 id="1-1-归并排序流程"><a href="#1-1-归并排序流程" class="headerlink" title="1.1 归并排序流程"></a>1.1 归并排序流程</h3><ol><li>整体是递归，左边排好序+右边排好序+merge让整体有序</li><li>让其整体有序的过程里用了排外序方法</li></ol><p><img src="../../../images/%E7%AE%97%E6%B3%95/3/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png"></p><pre><code class="java">/**     * 递归实现     * 思路：先递归拆分，然后归并。     */public static void mergeSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    process(arr, 0, arr.length - 1);&#125;private static void process(int[] arr, int L, int R) &#123;    int mid = L + ((R - L) &gt;&gt; 1);    if (L == R) &#123; // base case        return;    &#125;    process(arr, L, mid);    process(arr, mid+1, R);    merge(arr, L, mid, R);&#125;/**     * 循环实现     * 思路：循环 logN 次，每次循环从 0~N-1 分组合并。     * 组的长度从 2 开始，4，8，...     * @param arr     */public static void mergeSort2(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    int mergeSize = 1; // 左组长度    while (mergeSize &lt;= arr.length) &#123;        int L = 0;        while (L &lt;= arr.length - 1) &#123;            int mid = L + mergeSize - 1;            // 如果 mid 都已经越界，本次 mergeSize 循环结束            if (mid &gt;= arr.length - 1) &#123;                break;            &#125;            int R = L + (mergeSize&lt;&lt;1) - 1;            // 判断 R 是否越界            if (R &gt; arr.length - 1) &#123;                R = arr.length - 1;            &#125;            merge(arr, L, mid, R);            // 计算下一个 L 位置            L += mergeSize&lt;&lt;1;        &#125;        // 左组长度超过一般就已经排序完成        if (mergeSize &gt; arr.length / 2) &#123;            break;        &#125;        // 每轮乘以2        mergeSize &lt;&lt;= 1;    &#125;&#125;private static void merge(int[] arr, int L, int mid, int R) &#123;    int index = 0;    int[] tmpArr = new int[R - L + 1];    int l = L;    int r = mid + 1;    while (l &lt;= mid &amp;&amp; r &lt;= R) &#123;        tmpArr[index++] = arr[l] &gt; arr[r] ? arr[r++] : arr[l++];    &#125;    // 下面两个循环只会进一个    while (l &lt;= mid) &#123;        // 注意赋值给 tmpArr        tmpArr[index++] = arr[l++];    &#125;    while (r &lt;= R) &#123;        tmpArr[index++] = arr[r++];    &#125;    for (int i = 0; i &lt; tmpArr.length; i++) &#123;        // 注意从 L+i 开始赋值        arr[L+i] = tmpArr[i];    &#125;&#125;</code></pre><h3 id="1-2-归并排序复杂度"><a href="#1-2-归并排序复杂度" class="headerlink" title="1.2 归并排序复杂度"></a>1.2 归并排序复杂度</h3><p>T(N)=2*(T/2)+O(N^1)，所以时间复杂度为 O(N * logN )</p><p>merge 过程需要辅助数组，所以额外空间复杂度为 O(N)</p><p>归并排序的实质是把比较行为变成了有序信息传递，比O(N^2)的排序快。</p><p>O(N^2)的排序在大量浪费比较行为。归并排序没有浪费比较行为，每一轮都把有序行为固定下来了。</p><h3 id="1-3-理解归并排序"><a href="#1-3-理解归并排序" class="headerlink" title="1.3 理解归并排序"></a>1.3 理解归并排序</h3><h4 id="数组小和问题"><a href="#数组小和问题" class="headerlink" title="数组小和问题"></a>数组小和问题</h4><p>在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p><p>例子： [1,3,4,2,5] </p><p>1左边比1小的数：没有</p><p>3左边比3小的数：1</p><p>4左边比4小的数：1、3</p><p>2左边比2小的数：1</p><p>5左边比5小的数：1、3、4、 2</p><p>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>暴力方法直接双重循环遍历。归并思想，在 merge 时，左组和右组都是有序的，比较时就可以算出有多少个小和，即左组遍历到 A，右组有多少个数比 A 大，就有多少个 A 小和。</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/3/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C.png"></p><pre><code class="java">public static int smallSum(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return 0;    &#125;    return process(arr, 0, arr.length-1);&#125;// 求数组 arr 中， L...R 段的数组小和public static int process(int[] arr, int L, int R) &#123;    if (L == R) &#123;        return 0;    &#125;    int M = L + ((R-L)&gt;&gt;1);    int lRes = process(arr, L, M);    int rRes = process(arr, M + 1, R);    int mRes = merge(arr, L, M, R);    return lRes+rRes+mRes;&#125;// L...M 和 M+1...R 是有序的，做合并操作让 L...R 有序，并返回 L...R 数组小和public static int merge(int[] arr, int L, int M, int R) &#123;    //System.out.println(&quot;L:&quot;+L+&quot;;M:&quot;+M+&quot;;R:&quot;+R);    int[] tmpArr = new int[R-L+1];    int index = 0;    int l = L;    int r = M + 1;    int res = 0;    while (l &lt;= M &amp;&amp; r &lt;= R) &#123;        if (arr[l] &lt; arr[r]) &#123;            // 注意先计算 res，因为后面一句会改变 l            res += (R - r + 1) * arr[l];            //System.out.println(R - r + 1);            //System.out.println(arr[l]);            //System.out.println(&quot;=====================&quot;);            tmpArr[index++] = arr[l++];        &#125; else &#123;            tmpArr[index++] = arr[r++];        &#125;    &#125;    while (l &lt;= M) &#123;        tmpArr[index++] = arr[l++];    &#125;    while (r &lt;= R) &#123;        tmpArr[index++] = arr[r++];    &#125;    // 这个不能忘记，否则左组、右组没有顺序    for (int i = 0; i &lt; tmpArr.length; i++) &#123;        arr[L+i] = tmpArr[i];    &#125;    return res;&#125;</code></pre><h4 id="数组降序对个数问题"><a href="#数组降序对个数问题" class="headerlink" title="数组降序对个数问题"></a>数组降序对个数问题</h4><p>如果x&lt;y，则(x,y)是一个降序对。比如[3,1,7,0,2]降序对有(3,1)、(3,0)、(3,2)、(1,0)、(7,0)、(7,2)共6个。</p><p>分析：降序对在 merge 时产生，右组遍历到 A，左组中比 A 大的个数就是降序对的个数。</p><pre><code class="java">while (l &lt;= M &amp;&amp; r &lt;= R) &#123;    if (arr[l] &lt;= arr[r]) &#123;        tmpArr[index++] = arr[l++];    &#125; else &#123;        res += (M - l + 1);        tmpArr[index++] = arr[r++];    &#125;&#125;</code></pre><p>所以类似求某个数左侧或者右侧大于或者小于某某的和或者个数的问题可以使用归并排序的思想。</p><h2 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h2><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><h4 id="小于区"><a href="#小于区" class="headerlink" title="小于区"></a>小于区</h4><p>给定一个数组 arr，和一个整数 num。请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边。要求额外空间复杂度 O(1)，时间复杂度O(N)。</p><p>思路：定义指针 less：小于区的右边界，初始 L - 1。遍历数组，如果 arr[i] 小于 num，把 arr[i] 发货到小于区，即 less++ 然后 less 和 i 交换。</p><pre><code class="java">public static int partition(int[] arr, int L, int R) &#123;    if (L &gt; R) &#123;        return -1;    &#125;    if (L == R) &#123;        return L;    &#125;    int less = L - 1; // 小于区为空    int num = arr[R]; // 基准    for (int i = L; i &lt; R; i++) &#123;        if (arr[i] &lt; num) &#123;            swap(arr, ++less, i);        &#125;    &#125;    swap(arr, ++less, R);    return less;&#125;</code></pre><h4 id="小于区和等于区"><a href="#小于区和等于区" class="headerlink" title="小于区和等于区"></a>小于区和等于区</h4><p>荷兰国旗问题：给定一个数组 arr，和一个整数 num。请把小于 num 的数放在数组的左边，等于num的数放在中间，大于 num 的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。</p><p>思路：和小于区思路一样，再定义一个大于区，遍历数组判断每个数应该发往哪个区。</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/3/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p><pre><code class="java">public static int[] netherlandsFlag(int[] arr, int L, int R) &#123;    if (L &gt; R) &#123;        return new int[]&#123;-1,-1&#125;;    &#125;    if (L == R) &#123;        return new int[]&#123;L,L&#125;;    &#125;    int less = L - 1; // 小于区为空    int more = R + 1; // 大于区为空    int num = arr[R]; // 基准    int index = L; // 从头开始遍历    // index 和 more 碰头时停止    while (index &lt; more) &#123;        // 比基准小，arr[index] 发往小于区，index++，因为arr[less+1]&lt;=num        if (arr[index] &lt; num) &#123;            swap(arr, ++less, index++);            // 比基准大，arr[index] 发往大于区，index不变，因为arr[more-1]?num        &#125; else if (arr[index] &gt; num) &#123;            swap(arr, index, --more);            // 与基准相等，继续下一个        &#125; else &#123;            index++;        &#125;    &#125;    return new int[]&#123;less+1, more-1&#125;;&#125;</code></pre><p>还有什么挖坑法、指针交换法，都是定义左右两个指针，要么去填坑要么去交换，虽然荷兰国旗的解法多了一个index指针，但是我觉得更容易理解。即定义一个小于区，一个大于区，遍历中间所有数字，去发货。</p><h3 id="快速排序-1-0"><a href="#快速排序-1-0" class="headerlink" title="快速排序 1.0"></a>快速排序 1.0</h3><p>在arr[L..R]范围上，进行快速排序的过程：</p><p>1）用 arr[R] 对该范围做 partition，&lt; arr[R] 的数在左部分并且保证 arr[R] 最后来到左部分的最后一个位置，记为 M； &gt;= arr[R] 的数在右部分（arr[M+1..R]）</p><p>2）对 arr[L..M-1] 进行快速排序(递归)</p><p>3）对 arr[M+1..R] 进行快速排序(递归)</p><p>因为每一次 partition 都会搞定一个数的位置且不会再变动，所以排序能完成</p><pre><code class="java">private static void process1(int[] arr, int L, int R) &#123;    // 注意这里是 &gt;=    if (L &gt;= R) &#123;        return;    &#125;    int M = partition(arr, L, R);    System.out.println(&quot;=====&gt;&quot;+M+&quot;;L:&quot;+L+&quot;;R:&quot;+R);    process1(arr, L, M-1);    process1(arr, M+1, R);&#125;</code></pre><h3 id="快速排序-2-0"><a href="#快速排序-2-0" class="headerlink" title="快速排序 2.0"></a>快速排序 2.0</h3><p>在arr[L..R]范围上，进行快速排序的过程：</p><p>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]</p><p>2）对arr[L..a-1]进行快速排序(递归)</p><p>3）对arr[b+1..R]进行快速排序(递归)</p><p>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="java">private static void process2(int[] arr, int L, int R) &#123;    // 注意这里是 &gt;=    if (L &gt;= R) &#123;        return;    &#125;    int[] ints = netherlandsFlag(arr, L, R);    System.out.println(&quot;=====&gt;less:&quot;+ints[0]+&quot;;more:&quot;+ints[1]+&quot;;L:&quot;+L+&quot;;R:&quot;+R);    process2(arr, L, ints[0]-1);    process2(arr, ints[1]+1, R);&#125;</code></pre><p>数组已经有序的时候就是复杂度最高的时候。因为总体 partition 过程是 O(N)，有序时，每次只能搞定一个数，左边递归深度为 N。</p><p>时间复杂度O(N^2)</p><h3 id="快速排序-3-0"><a href="#快速排序-3-0" class="headerlink" title="快速排序 3.0"></a>快速排序 3.0</h3><p><strong>随机快排+荷兰国旗技巧优化</strong>  </p><p>在arr[L..R]范围上，进行快速排序的过程：</p><p>1）在这个范围上，随机选一个数记为num，</p><p>1）用 num 对该范围做 partition，&lt; num 的数在左部分，== num 的数中间，&gt;num 的数在右部分。假设 == num 的数所在范围是[a,b]</p><p>2）对arr[L..a-1]进行快速排序(递归)</p><p>3）对arr[b+1..R]进行快速排序(递归)</p><p>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="java">private static void process3(int[] arr, int L, int R) &#123;    // 注意这里是 &gt;=    if (L &gt;= R) &#123;        return;    &#125;    // 将 arr[R] 随机交换    swap(arr,R,L+(int)(Math.random() * (R - L + 1)));    int[] ints = netherlandsFlag(arr, L, R);    // System.out.println(&quot;=====&gt;less:&quot;+ints[0]+&quot;;more:&quot;+ints[1]+&quot;;L:&quot;+L+&quot;;R:&quot;+R);    process3(arr, L, ints[0]-1);    process3(arr, ints[1]+1, R);&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差</p><p>2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件</p><p>3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N</p><p>4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</p><p>时间复杂度O(N*logN)，额外空间复杂度O(logN)都是这么来的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;归并排序和快速排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（四）</title>
    <link href="http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%804-%E6%AF%94%E8%BE%83%E5%99%A8_%E5%A0%86%E6%8E%92%E5%BA%8F.html"/>
    <id>http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%804-%E6%AF%94%E8%BE%83%E5%99%A8_%E5%A0%86%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-02T14:13:12.000Z</published>
    <updated>2020-11-24T14:50:07.294Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序。</p><a id="more"></a><h2 id="1、比较器"><a href="#1、比较器" class="headerlink" title="1、比较器"></a>1、比较器</h2><p>1)比较器的实质就是重载比较运算符 </p><p>2)比较器可以很好的应用在特殊标准的排序上 </p><p>3)比较器可以很好的应用在根据特殊标准排序的结构上</p><p>4)写代码变得异常容易，还用于范型编程 </p><pre><code class="java">public static class IdAscComparator implements Comparator&lt;Student &gt; &#123;    @Override    public int compare(Student o1, Student o2) &#123;        return o1.id - o2.id;    &#125;&#125;public static class AgeDescComparator implements Comparator&lt;Student &gt; &#123;    @Override    public int compare(Student o1, Student o2) &#123;        return o2.age - o1.age;    &#125;&#125;public static void main(String[] args) &#123;    Student student1 = new Student(&quot;A&quot;, 2, 20);    Student student2 = new Student(&quot;B&quot;, 3, 21);    Student student3 = new Student(&quot;C&quot;, 1, 22);    Student[] students = new Student[]&#123;student1, student2, student3&#125;;    // 自定义排序规则    // Arrays.sort(students, new IdAscComparator());    Arrays.sort(students, new AgeDescComparator());    printStudents(students);    System.out.println(&quot;=====堆==========&quot;);    // 基于 id 的小根堆    // PriorityQueue&lt;Student&gt; heap = new PriorityQueue&lt;&gt;(new IdAscComparator());    // 基于 age 的大根堆    PriorityQueue&lt;Student&gt; heap = new PriorityQueue&lt;&gt;(new AgeDescComparator());    heap.add(student1);    heap.add(student2);    heap.add(student3);    while (!heap.isEmpty()) &#123;        Student student = heap.poll();        System.out.println(&quot;Name : &quot; + student.name + &quot;, Id : &quot; + student.id + &quot;, Age : &quot; + student.age);    &#125;    System.out.println(&quot;=====有序表==========&quot;);    TreeSet&lt;Student&gt; treeAgeDesc = new TreeSet&lt;&gt;(new AgeDescComparator());    treeAgeDesc.add(student1);    treeAgeDesc.add(student2);    treeAgeDesc.add(student3);    Student studentFirst = treeAgeDesc.first();    System.out.println(&quot;Name : &quot; + studentFirst.name + &quot;, Id : &quot; + studentFirst.id + &quot;, Age : &quot; + studentFirst.age);    Student studentLast = treeAgeDesc.last();    System.out.println(&quot;Name : &quot; + studentLast.name + &quot;, Id : &quot; + studentLast.id + &quot;, Age : &quot; + studentLast.age);&#125;</code></pre><h2 id="2、堆结构"><a href="#2、堆结构" class="headerlink" title="2、堆结构"></a>2、堆结构</h2><p>1）堆结构就是用数组实现的完全二叉树结构</p><p>​    完全二叉树：向着全二叉树的过程。</p><p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><p>4）堆结构的 heapInsert 与 heapify 操作</p><p>​    heapInsert：插入节点放到堆尾，往上层移动</p><p>​    heapify ：移除头部节点，尾部节点补上，往下层移动</p><p>5）堆结构的增大和减少 </p><p>6）优先级队列结构，就是堆结构 </p><pre><code class="java">public static class MyMaxHeap &#123;    private int size;    private final int limit;    private int[] heap;    public MyMaxHeap(int limit) &#123;        this.limit = limit;        size = 0;        heap = new int[limit];    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    public boolean isFull() &#123;        return size == limit;    &#125;    public void push(int num) &#123;        if (isFull()) &#123;            throw new RuntimeException(&quot;your heap is full.&quot;);        &#125;        // 插入到堆尾        heap[size] = num;        // 堆尾元素向上移动        heapInsert(heap, size++);    &#125;    /**         * heap[curIndex] 向上移动         */    private void heapInsert(int[] arr, int curIndex) &#123;        // 有两种情况？        int parentIndex = (curIndex-1) &gt;&gt; 1;        // 还没有到达堆顶并且还需要往上走。注意这里需要等于号，等于0时刚好是堆顶        while (parentIndex &gt;= 0 &amp;&amp; arr[curIndex] &gt; arr[parentIndex]) &#123;            swap(arr, parentIndex, curIndex);            curIndex = parentIndex;            parentIndex = (curIndex-1) &gt;&gt; 1;        &#125;    &#125;    public int pop() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;your heap is empty.&quot;);        &#125;        int ans = heap[0];        // 把堆尾部放到堆顶        swap(heap, 0, --size);        heapify(heap, 0, size);        return ans;    &#125;    /**         * 从 curIndex 开始，往下移动         */    private void heapify(int[] arr, int curIndex, int size) &#123;        // index 向下层移动 left=2i+1 right=(i+1)*2        int leftChildIndex = (curIndex &lt;&lt; 1) + 1;        int rightChildIndex = (curIndex + 1) &lt;&lt; 1;        // 有子孩子 &amp;&amp; 小于子孩子        while (leftChildIndex &lt;= size-1) &#123;            // rightChildIndex &gt; size-1 表示没有右孩子            int childMax = rightChildIndex &gt; size-1 ? leftChildIndex :            (arr[leftChildIndex] &gt; arr[rightChildIndex]) ? leftChildIndex : rightChildIndex;            // 不小于子孩子的，heapfy 完成            if (arr[curIndex] &gt;= arr[childMax]) &#123;                break;            &#125;            // 往下移动            swap(arr, curIndex, childMax);            curIndex = childMax;            leftChildIndex = (curIndex &lt;&lt; 1) + 1;            rightChildIndex = (curIndex + 1) &lt;&lt; 1;        &#125;    &#125;    private void swap(int[] arr, int pi, int ci) &#123;        int tmp = arr[pi];        arr[pi] = arr[ci];        arr[ci] = tmp;    &#125;&#125;</code></pre><h3 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h3><p>取决于，你有没有动态改信息的需求！</p><p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p><p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>1，先让整个数组都变成大根堆结构，建立堆的过程: </p><ol><li><p>从上到下的方法，时间复杂度为 O(N*logN) </p></li><li><p>从下到上的方法，时间复杂度为O(N) </p></li></ol><p>2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)</p><p>3，堆的大小减小成 0 之后，排序完成 </p><pre><code class="java">// 堆排序额外空间复杂度为 O(1)public static void heapSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    // O(N*logN)    //        for (int i = 0; i &lt; arr.length; i++) &#123;    //            // heap cur    //            heapInsert(arr, i);    //        &#125;    // O(N)    for (int i = arr.length - 1; i &gt;= 0; i--) &#123;        heapify(arr, i, arr.length);    &#125;    // O(N*logN)    int heapSize = arr.length;    for (int i = 0; i &lt; arr.length; i++) &#123;        // 最大元素归位。堆顶元素和堆尾元素交换        swap(arr, heapSize-1, 0);        // heap index size        // heapSize-1        // 堆顶元素是不准的，需要调整        heapify(arr, 0, --heapSize);    &#125;&#125;/**     * 从 curIndex 开始往下移动，把 arr[curIndex] 放在合适的位置     */private static void heapify(int[] arr, int curIndex, int heapSize) &#123;    int leftIndex = (curIndex &lt;&lt; 1) + 1;    int rightIndex = (curIndex + 1) &lt;&lt; 1;    // 下移条件：1. 有儿子 2. 值比儿子中较大值小    while (leftIndex &lt; heapSize) &#123;        int maxIndex = rightIndex &gt;= heapSize ? leftIndex : arr[leftIndex] &gt; arr[rightIndex] ? leftIndex : rightIndex;        if (arr[curIndex] &gt;= arr[maxIndex]) &#123;            break;        &#125;        swap(arr, curIndex, maxIndex);        curIndex = maxIndex;        leftIndex = (curIndex &lt;&lt; 1) + 1;        rightIndex = (curIndex + 1) &lt;&lt; 1;    &#125;&#125;/**     * 新元素插入在 heap[curIndex]，请把 heap[0...curIndex] 组织成大根堆     * 就是新元素不断往上移动     */private static void heapInsert(int[] heap, int curIndex) &#123;    int parentIndex = (curIndex - 1)&gt;&gt;1;    // 上移条件：1. 有 parent 2. 比 parent 大    while (parentIndex &gt;= 0 &amp;&amp; heap[curIndex] &gt; heap[parentIndex]) &#123;        swap(heap, curIndex, parentIndex);        curIndex = parentIndex;        parentIndex = (curIndex - 1)&gt;&gt;1;    &#125;&#125;</code></pre><h3 id="堆相关题目"><a href="#堆相关题目" class="headerlink" title="堆相关题目"></a>堆相关题目</h3><p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过 k，并且 k 相对于数组长度来说是比较小的。</p><p>请选择一个合适的排序策略，对这个数组进行排序。 </p><pre><code class="java">public static void distanceLessKSort(int[] arr, int k) &#123;    // k==0，表示本身有序    if (k == 0) &#123;        return;    &#125;    // 默认小根堆    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();    // 把前 k 个元素加入堆中    int i = 0;    for (; i &lt; Math.min(arr.length, k); i++) &#123;        minHeap.add(arr[i]);    &#125;    // 堆逐渐后移    int j = 0;    for (; i &lt; arr.length; i++,j++) &#123;        // 堆里增加一个元素        minHeap.add(arr[i]);        // 把当前堆顶弹出来        arr[j] = minHeap.poll();    &#125;    // 堆中剩下的元素弹出    while (!minHeap.isEmpty()) &#123;        arr[j++] = minHeap.poll();    &#125;&#125;private static int[] generateRandomArrLessK(int maxSize, int maxValue, int k) &#123;    int[] arr = new int[(int)(Math.random() * (maxSize + 1))];    for (int i = 0; i &lt; arr.length; i++) &#123;        arr[i] = (int)(Math.random() * (maxValue + 1)) - (int)(Math.random() * (maxValue + 1));    &#125;    Arrays.sort(arr);    // 随机交换，但是长度不大于k    boolean[] swapArr = new boolean[arr.length];    for (int i = 0; i &lt; arr.length; i++) &#123;        int j = Math.min(arr.length - 1, i + (int)(Math.random() * (k+1)));        if (!swapArr[i] &amp;&amp; !swapArr[j]) &#123;            int tmp = arr[i];            arr[i] = arr[j];            arr[j] = tmp;            swapArr[i] = true;            swapArr[j] = true;        &#125;    &#125;    return arr;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（二）</title>
    <link href="http://yoursite.com/2020-10-30-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%802.html"/>
    <id>http://yoursite.com/2020-10-30-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%802.html</id>
    <published>2020-10-30T14:13:12.000Z</published>
    <updated>2020-11-24T14:49:29.433Z</updated>
    
    <content type="html"><![CDATA[<p>认识基本数据结构，单向链表、双向链表、栈、队列、哈希表和有序表；认识递归。</p><a id="more"></a><h2 id="1、单向链表和双向链表"><a href="#1、单向链表和双向链表" class="headerlink" title="1、单向链表和双向链表"></a>1、单向链表和双向链表</h2><h3 id="1-1-结构"><a href="#1-1-结构" class="headerlink" title="1.1 结构"></a>1.1 结构</h3><pre><code class="java">public static class Node &#123;    public int value;    public Node next;    public Node(int data) &#123;        value = data;    &#125;&#125;public static class DoubleNode &#123;    public int value;    public DoubleNode pre;    public DoubleNode next;    public DoubleNode(int data) &#123;        value = data;    &#125;&#125;</code></pre><h3 id="1-2-简单练习题"><a href="#1-2-简单练习题" class="headerlink" title="1.2 简单练习题"></a>1.2 简单练习题</h3><h4 id="单链表和双链表如何反转？"><a href="#单链表和双链表如何反转？" class="headerlink" title="单链表和双链表如何反转？"></a>单链表和双链表如何反转？</h4><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC.png"></p><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC.png"></p><pre><code class="java">public static Node reverseLinkedList(Node h) &#123;    Node pre = null;    Node next = null;    while (h != null) &#123;        next = h.next;        h.next = pre;        pre = h;        h = next;    &#125;    return pre;&#125;public static DoubleNode reverseDoubleList(DoubleNode h) &#123;    DoubleNode pre = null;    DoubleNode next = null;    while (h != null) &#123;        next = h.next;        h.next = pre;        h.pre = next;        pre = h;        h = next;    &#125;    return pre;&#125;</code></pre><p>对数器</p><pre><code class="java">public static Node testReverseLinkedList(Node h) &#123;    if (h == null) &#123;        return null;    &#125;    // 把所有 node 装入 list    ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;();    while (h != null) &#123;        nodes.add(h);        h = h.next;    &#125;    // 重新设置每个 node 的 next 指针    nodes.get(0).next = null;    for (int i = 1; i &lt; nodes.size(); i++) &#123;        nodes.get(i).next = nodes.get(i-1);    &#125;    // 返回最后一个节点就是新链表的头节点    return nodes.get(nodes.size() - 1);&#125;public static DoubleNode testReverseDoubleList(DoubleNode h) &#123;    if (h == null) &#123;        return null;    &#125;    // 把所有 node 装入 list    ArrayList&lt;DoubleNode&gt; nodes = new ArrayList&lt;&gt;();    while (h != null) &#123;        nodes.add(h);        h = h.next;    &#125;    // 重新设置每个 node 的 next 指针和 pre 指针    nodes.get(0).next = null;    for (int i = 1; i &lt; nodes.size(); i++) &#123;        nodes.get(i-1).pre = nodes.get(i);        nodes.get(i).next = nodes.get(i-1);    &#125;    nodes.get(nodes.size() - 1).pre = null;    // 返回最后一个节点就是新链表的头节点    return nodes.get(nodes.size() - 1);&#125;</code></pre><h4 id="把给定值都删除"><a href="#把给定值都删除" class="headerlink" title="把给定值都删除"></a>把给定值都删除</h4><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%80%BC.png"></p><pre><code class="java">public static Node removeValue(Node h, int num) &#123;    // 找到新头部    while (h != null) &#123;        if (h.value != num) &#123;            break;        &#125;        h = h.next;    &#125;    if (h == null) &#123;        return null;    &#125;    // head来到 第一个不需要删的位置    Node pre = h;    Node cur = h;    while (cur.next != null) &#123;        cur = cur.next;        if (cur.value == num) &#123;            pre.next = cur.next;        &#125; else &#123;            pre = cur;        &#125;    &#125;    return h;&#125;</code></pre><h2 id="2、栈和队列"><a href="#2、栈和队列" class="headerlink" title="2、栈和队列"></a>2、栈和队列</h2><h3 id="2-1-逻辑概念"><a href="#2-1-逻辑概念" class="headerlink" title="2.1 逻辑概念"></a>2.1 逻辑概念</h3><ul><li>栈：数据先进后出，犹如弹匣</li><li>队列：数据先进先出，好似排队</li></ul><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png"></p><h3 id="2-2-栈和队列实际实现"><a href="#2-2-栈和队列实际实现" class="headerlink" title="2.2 栈和队列实际实现"></a>2.2 栈和队列实际实现</h3><h4 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h4><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.png"></p><p>四个基础方法全部实现，自由组合即可。</p><p>双向链表，维护 head、tail 两个指针的移动。所有操作均是 O(1)。</p><pre><code class="java">public static class Node&lt;T&gt; &#123;    public T value;    public Node&lt;T&gt; next;    public Node&lt;T&gt; pre;    public Node(T value) &#123;        this.value = value;    &#125;&#125;public static class DoubleEndsQueue&lt;T&gt; &#123;    Node&lt;T&gt; head;    Node&lt;T&gt; tail;    public void addFromHead(T value) &#123;        Node&lt;T&gt; cur = new Node&lt;&gt;(value);        if (head == null) &#123;            head = cur;            tail = cur;        &#125; else &#123;            cur.next = head;            head.pre = cur;            head = cur;        &#125;    &#125;    public void addFromTail(T value) &#123;        Node&lt;T&gt; cur = new Node&lt;&gt;(value);        if (head == null) &#123;            head = cur;            tail = cur;        &#125; else &#123;            cur.pre = tail;            tail.next = cur;            tail = cur;        &#125;    &#125;    public T popFromHead() &#123;        if (head == null) &#123;            return null;        &#125;        Node&lt;T&gt; cur = head;        if (head == tail) &#123;            head = null;            tail = null;        &#125; else &#123;            head = head.next;            head.pre = null;            cur.next = null;        &#125;        return cur.value;    &#125;    public T popFromTail() &#123;        if (head == null) &#123;            return null;        &#125;        Node&lt;T&gt; cur = tail;        if (head == tail) &#123;            head = null;            tail = null;        &#125; else &#123;            tail = tail.pre;            tail.next = null;            cur.pre = null;        &#125;        return cur.value;    &#125;    public boolean isEmpty() &#123;        return head == null;    &#125;&#125;</code></pre><h4 id="数组实现（固定大小）"><a href="#数组实现（固定大小）" class="headerlink" title="数组实现（固定大小）"></a>数组实现（固定大小）</h4><p><strong>数组实现固定大小栈</strong></p><pre><code class="java">public static class MyStack &#123;    private int[] arr;    // 下一个入栈位置。也就是下一个出栈前一个位置    private int index;    private final int limit;    public MyStack(int limit) &#123;        this.limit = limit;        index = 0;        arr = new int[limit];    &#125;    public void push(int num) &#123;        if (index &gt;= limit) &#123;            throw new RuntimeException(&quot;栈已满，不能再加！&quot;);        &#125;        arr[index] = num;        index++;    &#125;    public int pop() &#123;        if (index == 0) &#123;            throw new RuntimeException(&quot;栈为空，不能再拿！&quot;);        &#125;        int res = arr[index-1];        index--;        return res;    &#125;&#125;</code></pre><p><strong>环形数组实现固定大小队列</strong></p><pre><code class="java">public static class MyQueue &#123;    // 固定大小数组    private int[] arr;    // 下一个入队位置    private int pushi;    // 下一个出队位置    private int popi;    // 最大大小    private final int limit;    // 当前队列大小    private int size;    public MyQueue(int limit) &#123;        pushi = 0;        popi = 0;        size = 0;        this.limit = limit;        arr = new int[limit];    &#125;    public void push(int num) &#123;        if (limit == size) &#123;            throw new RuntimeException(&quot;队列已满，不能再加！&quot;);        &#125;        arr[pushi] = num;        size++;        pushi = nextIndex(pushi);    &#125;    public int pop() &#123;        if (size == 0) &#123;            throw new RuntimeException(&quot;队列为空，不能再拿！&quot;);        &#125;        int res = arr[popi];        size--;        popi = nextIndex(popi);        return res;    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    // 如果现在的下标是i，返回下一个位置    private int nextIndex(int index) &#123;        // 入队的顺序 012345012345        // 出队的顺序 012345012345        return (index &lt; limit -1) ? index+1 : 0;    &#125;&#125;</code></pre><h3 id="2-3-简单练习题"><a href="#2-3-简单练习题" class="headerlink" title="2.3 简单练习题"></a>2.3 简单练习题</h3><p><strong>1、用数组实现不超过固定大小的队列和栈？</strong></p><p>见 2.2</p><p><strong>2、实现一个特俗的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</strong></p><ul><li>要求 pop、push、getMin 都是 O(1)</li><li>可以使用现有栈结构</li></ul><p>思路：弄两个栈。一个数据栈一个最小栈，两个栈等高。</p><pre><code class="java">public static class MyStack &#123;    private Stack&lt;Integer&gt; dataStack;    private Stack&lt;Integer&gt; minStack;    public MyStack() &#123;        dataStack = new Stack&lt;&gt;();        minStack = new Stack&lt;&gt;();    &#125;    public void push(int num) &#123;        if (minStack.isEmpty()) &#123;            minStack.push(num);        &#125; else &#123;            // 最小栈栈顶和num比较            minStack.push(Math.min(minStack.peek(), num));        &#125;        dataStack.push(num);    &#125;    public int pop() &#123;        if (minStack.isEmpty()) &#123;            throw new RuntimeException(&quot;栈为空，不可拿数据！&quot;);        &#125;        minStack.pop();        return dataStack.pop();    &#125;    public int getMin() &#123;        if (this.minStack.isEmpty()) &#123;            throw new RuntimeException(&quot;栈为空，不可拿数据！&quot;);        &#125;        return minStack.peek();    &#125;&#125;</code></pre><p><strong>3、用栈结构实现队列结构</strong></p><pre><code class="java">public static class MyQueue &#123;    private Stack&lt;Integer&gt; pushStack;    private Stack&lt;Integer&gt; pollStack;    public MyQueue() &#123;        pushStack = new Stack&lt;&gt;();        pollStack = new Stack&lt;&gt;();    &#125;    public void push(Integer num) &#123;        pushStack.push(num);        pushToPoll();    &#125;    public Integer poll() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空，不能再拿数据&quot;);        &#125;        pushToPoll();        return pollStack.pop();    &#125;    public Integer peek() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空，不能再拿数据&quot;);        &#125;        pushToPoll();        return pollStack.peek();    &#125;    public boolean isEmpty() &#123;        return pushStack.isEmpty() &amp;&amp; pollStack.isEmpty();    &#125;    private void pushToPoll() &#123;        if (pollStack.isEmpty()) &#123;            // 一定要遍历完            while (!pushStack.isEmpty()) &#123;                pollStack.push(pushStack.pop());            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4、用队列结构实现栈结构</strong></p><pre><code class="java">public static class MyStack &#123;    private Queue&lt;Integer&gt; queue;    private Queue&lt;Integer&gt; help;    public MyStack() &#123;        queue = new LinkedList&lt;&gt;();        help = new LinkedList&lt;&gt;();    &#125;    public void push(Integer num) &#123;        queue.offer(num);    &#125;    public Integer pop() &#123;        queueToHelp();        Integer res = queue.poll();        helpToQueue();        return res;    &#125;    public Integer peek() &#123;        queueToHelp();        Integer res = queue.poll();        help.offer(res);        helpToQueue();        return res;    &#125;    public boolean isEmpty() &#123;        return queue.isEmpty();    &#125;    private void queueToHelp() &#123;        while (queue.size() &gt; 1) &#123;            help.offer(queue.poll());        &#125;    &#125;    private void helpToQueue() &#123;        Queue&lt;Integer&gt; tmp = queue;        queue = help;        help = tmp;    &#125;&#125;</code></pre><h2 id="3、递归"><a href="#3、递归" class="headerlink" title="3、递归"></a>3、递归</h2><h3 id="3-1-递归例子"><a href="#3-1-递归例子" class="headerlink" title="3.1 递归例子"></a>3.1 递归例子</h3><p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p><p>1）将[L..R]范围分成左右两半。左：[L..Mid] 右[Mid+1..R]</p><p>2）左部分求最大值，右部分求最大值</p><p>3） [L..R]范围上的最大值，是 max{左部分最大值，右部分最大值}</p><p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p><pre><code class="java">public static Integer getMax(int[] arr) &#123;    if (arr == null || arr.length == 0) &#123;        return 0;    &#125;    return process(arr, 0, arr.length - 1);&#125;private static Integer process(int[] arr, int L, int R) &#123;    if (L == R) &#123; // arr[L..R]范围上只有一个数，直接返回，base case        return arr[L];    &#125;    int mid = L + ((R - L) &gt;&gt; 1);    Integer l = process(arr, L, mid);    Integer r = process(arr, mid + 1, R);    return Math.max(l, r);&#125;</code></pre><h3 id="3-2-递归的脑图"><a href="#3-2-递归的脑图" class="headerlink" title="3.2 递归的脑图"></a>3.2 递归的脑图</h3><p>递归的脑图有利于理解和分析递归，递归不是玄学，递归底层是利用系统栈来实现的。任何递归函数都一定可以改成非递归。</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E9%80%92%E5%BD%92%E8%84%91%E5%9B%BE.png"></p><h3 id="3-3-Master-公式"><a href="#3-3-Master-公式" class="headerlink" title="3.3 Master 公式"></a>3.3 Master 公式</h3><p>形如 *<em>T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)*</em>的递归函数，可以直接通过Master公式来确定时间复杂度</p><ul><li><p>如果 log(b,a) &lt; d，复杂度为O(N^d)</p></li><li><p>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))</p></li><li><p>如果 log(b,a) == d，复杂度为O(N^d * logN)</p></li></ul><p>上面例子：T(N) = 2 * T(N/2) + O(N^0)。所以 log(2,2) &gt; 0，所以复杂度为 O(N^log(2,2)) = O(N)。</p><h2 id="4、哈希表和有序表"><a href="#4、哈希表和有序表" class="headerlink" title="4、哈希表和有序表"></a>4、哈希表和有序表</h2><h3 id="4-1-哈希表"><a href="#4-1-哈希表" class="headerlink" title="4.1 哈希表"></a>4.1 哈希表</h3><ol><li><p>在使用层面上可以理解为一种集合结构</p></li><li><p>如果只有 key，没有伴随数据 value，可以使用 HashSet 结构</p></li><li><p>如果既有 key，又有伴随数据 value，可以使用 HashMap 结构</p></li><li><p>有无伴随数据是 HashMap 和 HashSet 唯一的区别，底层的实际结构是一回事</p></li><li><p>使用哈希表增（put）、删（remove）、改（put）和查（get）操作可以认为时间复杂度为 O(1)，但是常数时间比较大</p></li><li><p>放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小</p></li><li><p>放入哈希表的东西，如果是引用类型，内部按引用传递，内存占用是 8 字节</p></li></ol><h3 id="4-2-有序表"><a href="#4-2-有序表" class="headerlink" title="4.2 有序表"></a>4.2 有序表</h3><ol><li>有序表在使用层面上可以理解为一种集合结构</li><li>有 key 无 value，可以使用 TreeSet</li><li>有 key 有 value，可以使用 TreeMap</li><li>有无 value 是 TreeSet 和 TreeMap 的唯一区别，底层结构一样</li><li>使用有序表增（put）、删（remove）、改（put）和查（get）操作可以认为时间复杂度为  <strong>O(logN)</strong></li><li>放基础类型，按值传递，内存占用同值大小相同</li><li>放引用类型，按引用传递，内存占用8字节</li><li>有序表把 key 按照顺序组织起来，而哈希表完全不组织</li><li>红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 <strong>O(logN)</strong><ul><li>void put(K key, V value)，向有序表添加或更新记录</li><li>V get(K key)，根据 key 查询 value</li><li>void remove(K key)</li><li>boolean containsKey(K key)</li><li>K firstKey()，返回所有键值的排序结果中，最小的那个</li><li>K lastKey()，返回最大那个 key</li><li>K floorKey(K key)，返回 &lt;= key，离 key 最近的那个</li><li>K ceilingKey(K key)，返回 &gt;= key，离 key 最近的那个</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;认识基本数据结构，单向链表、双向链表、栈、队列、哈希表和有序表；认识递归。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（一）</title>
    <link href="http://yoursite.com/2020-10-28-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%801-%E5%A4%8D%E6%9D%82%E5%BA%A6_%E5%AF%B9%E6%95%B0%E5%99%A8_%E4%BA%8C%E5%88%86%E6%B3%95_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html"/>
    <id>http://yoursite.com/2020-10-28-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%801-%E5%A4%8D%E6%9D%82%E5%BA%A6_%E5%AF%B9%E6%95%B0%E5%99%A8_%E4%BA%8C%E5%88%86%E6%B3%95_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html</id>
    <published>2020-10-28T14:13:12.000Z</published>
    <updated>2020-10-30T15:04:37.344Z</updated>
    
    <content type="html"><![CDATA[<p><strong>评估算法优劣的核心指标</strong></p><ul><li>时间复杂度</li><li>额外空间复杂度</li><li>常数项时间</li></ul><p><strong>二分法</strong></p><p><strong>异或操作</strong></p><a id="more"></a><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><p>什么是时间复杂度？</p><ul><li>常数时间的操作</li><li>确定算法流程的总操作数量与样本数量之间的表达式关系</li><li>只看表达式最高阶项的部分</li></ul><p>什么是常数时间操作？</p><blockquote><p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间，那么这个操作就是常数时间的操作。</p><p>linkedList 底层是一个双向链表，通过指针关联，不是连续区间，无法算出偏移量，所以不是常数时间。数组是直接寻址，可以认为是连续内存区间，直接计算偏移量。</p></blockquote><p>常见的常数时间操作有哪些？</p><ul><li>常见的算数运算（+、-、*、/、%）</li><li>常见的位运算（&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;、&amp;、|、~、^）</li><li>赋值、比较、自增、自减</li><li>数组寻址操作</li></ul><p>如何确定总操作数量和样本数量之间的表达式关系？</p><ol><li>分析算法的流程，按照最差情况分析</li><li>把整个流程拆分位一个个基本动作，保证每个动作都是常数时间操作</li><li>如果数据量为 N，看看基本动作的数量和 N 是什么关系</li></ol><h2 id="2、时间复杂度估算实践"><a href="#2、时间复杂度估算实践" class="headerlink" title="2、时间复杂度估算实践"></a>2、时间复杂度估算实践</h2><h3 id="2-1-选择排序"><a href="#2-1-选择排序" class="headerlink" title="2.1 选择排序"></a>2.1 选择排序</h3><p>过程：</p><ul><li><p>arr[0~N-1]范围上，找到最小值所在位置，然后把最小值交换到0位置。</p></li><li><p>arr[1~N-1]范围上，找到最小值所在位置，然后把最小值交换到1位置。</p></li><li><p>arr[2~N-1]范围上，找到最小值所在位置，然后把最小值交换到2位置。</p></li><li><p>…</p></li><li><p>arr[N-1~N-1]范围上，找到最小值所在位置，然后把最小值交换到N-1位置。</p></li></ul><p>估算：</p><ul><li>常数操作数量=(N + N-1 + N-2 + … + 1)<em>(1看操作 + 1比较操作 + 1交换操作)=(1x1+n</em>(n-1)/2)*3=a(N^2)+bN + c。（a、b、c都是常数）</li></ul><p>所以选择排序的时间复杂度为 O(N^2)</p><h3 id="2-2-冒泡排序"><a href="#2-2-冒泡排序" class="headerlink" title="2.2 冒泡排序"></a>2.2 冒泡排序</h3><p>过程：</p><ul><li>arr[0~N-1]范围上，arr[0]和arr[1]比较，谁大谁来到1位置；arr[1]和arr[2]比较，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到 N-1 位置</li><li>arr[0~N-2]范围上，重复上面过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到 N-2 位置</li><li>arr[0~N-3]范围上，重复上面过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到 N-3 位置</li><li>…</li><li>arr[0~1]范围上，重复上面过程，但最后一步是arr[0]和arr[1]，谁大谁来到 1 位置</li></ul><p>估算：</p><ul><li>常数操作数量=(N-1 + N-2 + … + 1)(1看操作+1比较操作+1交换)</li></ul><p>所以冒泡排序的时间复杂度为 O(N^2)</p><h3 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h3><p>过程：</p><ul><li>arr[0~1]范围上，arr[0]和arr[1]比较，谁大谁来到1位置</li><li>arr[0~2]范围上，arr[2]和arr[1]比较，谁大谁来到2位置，如果arr[2]大于arr[1]，比较完成；arr[1]和arr[0]比较，谁大谁来到1位置</li><li>arr[0~3]范围上，arr[3]和arr[2]比较，谁大谁来到3位置，如果arr[3]大于arr[2]，比较完成；arr[2]和arr[1]比较，谁大谁来到2位置；…</li><li>…</li><li>arr[0~N-1]范围上，arr[N-1]和arr[N-2]比较，谁大谁来到 N-1 位置上；</li></ul><p>左神的过程描述：</p><ul><li><p>想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。</p></li><li><p>想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。</p></li><li><p>…</p></li><li><p>想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p></li><li><p>想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p></li></ul><p>估算：</p><ul><li>按照最坏情况。常数操作=(1 + 2 + 3 + … + N-1) * 3</li></ul><p>所以插入排序的时间复杂度为 O(N^2)</p><h2 id="3、额外空间复杂度"><a href="#3、额外空间复杂度" class="headerlink" title="3、额外空间复杂度"></a>3、额外空间复杂度</h2><p>输入参数的空间和输出结果的空间不算额外空间，因为这些都是必须的，和实现目标有关的。</p><p>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去，这部分空间就是额外空间。</p><p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是 O(1)。</p><h2 id="4、常数项"><a href="#4、常数项" class="headerlink" title="4、常数项"></a>4、常数项</h2><p>时间复杂度相同的算法不一定一样好。时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。这时一般放弃理论分析，而是生成随机数据直接测。</p><p>不是不能纯分析，而是没必要，因为虽然都是一个常数操作，但是所花费的时间也可能是不同的。比如，位运算的常数时间远小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。</p><p>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p><p><strong>什么是最优解？</strong></p><p>先满足时间复杂度尽可能低，然后使用最少的额外空间。一般忽略常数项这个因素，因为这个因素只决定了实现层次的优化和考虑，而和怎么<strong>解决这个问题的思想</strong>无关。</p><p><strong>常见时间复杂度排序</strong></p><ul><li>O(1)</li><li>O(logN)</li><li>O(N)</li><li>O(N*logN)</li><li>O(N^2) O(N^3) … O(N^K)</li><li>O(2^N) O(3^N) … O(K^N)</li><li>O(N!)</li></ul><h2 id="5、认识对数器"><a href="#5、认识对数器" class="headerlink" title="5、认识对数器"></a>5、认识对数器</h2><p>1，你想要测的方法a</p><p>2，实现复杂度不好但是容易实现的方法b</p><p>3，实现一个随机样本产生器</p><p>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样</p><p>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b</p><p>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。 </p><h2 id="6、二分法"><a href="#6、二分法" class="headerlink" title="6、二分法"></a>6、二分法</h2><p>最常见的是在一个有序数组上，开展二分搜索。但是有序并不是使用二分的必要条件，只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p><ol><li>在一个有序数组中，找某个数是否存在 </li></ol><p><img src="../../../images/%E7%AE%97%E6%B3%95/1/%E4%BA%8C%E5%88%86%E6%B3%95.png"></p><pre><code class="java">private static boolean bsExist(int[] arr, int target) &#123;    if (arr == null || arr.length == 0) &#123;        return false;    &#125;    int L = 0;    int R = arr.length - 1;    int mid = 0;    // 需要等于，L=R 时也需要判断    while (L &lt;= R) &#123;        // mid = (L + R) / 2 不安全，可能越界        mid = L + (R-L)/2;        // mid = L + ((R-L)&gt;&gt;1);        if (target == arr[mid]) &#123;            return true;        &#125;        // 这里加一减一如何理解？        // mid 已经排除，可以直接跳过        if (arr[mid] &gt; target) &#123;            R = mid - 1;        &#125; else &#123;            L = mid + 1;        &#125;    &#125;    return false;&#125;</code></pre><ol start="2"><li>在一个有序数组中，找&gt;=某个数最左侧的位置 </li></ol><pre><code class="java">    private static int nearestIndex(int[] arr, int num) &#123;        if (arr == null || arr.length == 0) &#123;            return -1;        &#125;        int index=-1;        int L=0;        int R=arr.length-1;        int mid = 0;        while (L &lt;= R) &#123;            mid = L + ((R-L)&gt;&gt;1);            if (arr[mid] &gt;= num) &#123;                R = mid - 1;                index = mid;            &#125; else &#123;                L = mid + 1;            &#125;        &#125;        return index;    &#125;</code></pre><ol start="3"><li>在一个有序数组中，找&lt;=某个数最右侧的位置 </li></ol><p>同2</p><ol start="4"><li>局部最小值问题 </li></ol><blockquote><p>局部最小问题。从数组中找到一个局部最小值。</p><ol><li>arr[1] &gt; arr[0] arr[0]局部最小</li><li>arr[n-1] &gt; arr[n] arr[n]局部最小</li><li>arr[i-1] &gt; arr[i] &amp;&amp; arr[i+1] &gt; arr[i] arr[i] 局部最小</li></ol></blockquote><h2 id="7、异或"><a href="#7、异或" class="headerlink" title="7、异或"></a>7、异或</h2><p>异或运算：相同为0，不同为1</p><p>同或运算：相同为1，不同为0</p><p>能长时间记住的概率接近0%</p><p>所以，异或运算就记成<strong>无进位相加</strong>！</p><h3 id="7-1-异或运算性值"><a href="#7-1-异或运算性值" class="headerlink" title="7.1 异或运算性值"></a>7.1 异或运算性值</h3><ul><li>0^N=N</li><li>N^N=0</li><li>异或满足交换律和结合律</li></ul><h3 id="7-2-异或题目"><a href="#7-2-异或题目" class="headerlink" title="7.2 异或题目"></a>7.2 异或题目</h3><p><strong>1、如何不用额外变量交换两个数?</strong></p><pre><code class="java">// 前提 a、b 位于不指向同一个内存int a = 1, b = 2;a = a ^ b; // a=a^b b=bb = a ^ b; // b=a^b^b=a a=a^ba = a ^ b; // a=a^b^a=bSystem.out.println(a + &quot;======&quot; + b);</code></pre><p><strong>2、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？</strong></p><p>全部异或。因为 N^N=0，0^N=N。</p><p><strong>3、怎么把一个int类型的数，提取出最右侧的1来？</strong></p><pre><code class="json">原数：0001 0010取反：1110 1101加一：1110 1110相与：0000 0010(~a+1)&amp;a</code></pre><p><strong>4、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数？</strong></p><pre><code class="java">// 一个数组中有一种数出现了奇数次，其他数都出现了偶数次private static void printOddTimesNum1(int[] arr) &#123;    int eor = 0;    for (int i = 0; i &lt; arr.length; i++) &#123;        eor ^= arr[i];    &#125;    System.out.println(&quot;======&gt;&quot; + eor);&#125;// 一个数组中有两种数出现了奇数次，其他数都出现了偶数次private static void printOddTimesNum2(int[] arr) &#123;    int eor = 0;    for (int i = 0; i &lt; arr.length; i++) &#123;        eor ^= arr[i];    &#125;    // eor=a^b    // a!=b    // eor中肯定存在1，并且a、b中一个1一个0    // 找到最右侧1    int rightOne = eor &amp; (~eor + 1);    int a = 0;    for (int i = 0; i &lt; arr.length; i++) &#123;        if ((arr[i] &amp; rightOne) &gt; 0) &#123;            a ^= arr[i];        &#125;    &#125;    System.out.println(a+&quot;=========&quot;+(a^eor));&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;评估算法优劣的核心指标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;li&gt;额外空间复杂度&lt;/li&gt;
&lt;li&gt;常数项时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二分法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异或操作&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(八)</title>
    <link href="http://yoursite.com/2020-10-11-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(8)-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html"/>
    <id>http://yoursite.com/2020-10-11-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(8)-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html</id>
    <published>2020-10-11T15:43:12.000Z</published>
    <updated>2020-11-24T14:44:05.123Z</updated>
    
    <content type="html"><![CDATA[<ul><li>分布式事务</li></ul><a id="more"></a><h2 id="1、分布式事务"><a href="#1、分布式事务" class="headerlink" title="1、分布式事务"></a>1、分布式事务</h2><p><strong>事务（Transaction）</strong>，一般是指要做的或所做的事情，由<strong>事务开始(begin transaction)**和</strong>事务结束(end transaction)**之间执行的全体操作组成。</p><p><strong>简单的讲就是，要么全部被执行，要么就全部失败。</strong></p><p>那<strong>分布式事务</strong>，自然就是运行在分布式系统中的事务，是由<strong>多个不同的机器上的事务组合而成</strong>的。同上，只有分布式系统中所有事务执行了才能是成功，否则失败。</p><p>事务的基本特征 ACID：</p><ul><li>原子性（Atomicity）<ul><li>一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li></ul></li><li>一致性（Consistency）<ul><li>指事务执行前和执行后，数据是完整的。</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li></ul></li><li>持久性（Durability）<ul><li>也称为永久性，一个事务一旦提交，它对数据库中数据的改变就应该是永久性的保存下来了。</li></ul></li></ul><hr><p><strong>分布式事务的目标：解决多个独立事务一致性的问题。</strong></p><p>我们遇到的问题：</p><p>分布式事务：一个功能，横跨多个微服务，由于每个微服务不在一个库，没法用数据库事务来保证事务。</p><p>网约车例子：乘客支付订单。支付系统中，支付表更新，订单系统，订单库 订单状态更新为已支付。</p><p>订单，支付表，在不同的库，如何保证两个库之间的事务。</p><p>支付操作：支付修改余额，修改订单状态。</p><p>SCI：销售单和库存、采购单和库存</p><h2 id="2、分布式事务解决方案"><a href="#2、分布式事务解决方案" class="headerlink" title="2、分布式事务解决方案"></a>2、分布式事务解决方案</h2><h3 id="2-1-二阶段提交协议-2PC"><a href="#2-1-二阶段提交协议-2PC" class="headerlink" title="2.1 二阶段提交协议(2PC)"></a>2.1 二阶段提交协议(2PC)</h3><p>基于 XA/JTA 规范，采取强一致性，遵从 ACID。</p><p>XA 是一个分布式事务架构规范，主要定义了 TM 和 RM ，JTA 是 XA 的一个具体 Java 实现。</p><h4 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h4><p>XA 是由 X/Open 组织提出的分布式事务的架构（或者叫协议）。XA 架构主要定义了（全局）事务管理器（<strong>Transaction Manager</strong>）和（局部）资源管理器（<strong>Resource Manager</strong>）之间的接口。XA 接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。也就是说，在基于 XA 的一个事务中，我们可以针对多个资源进行事务管理，例如一个系统访问多个数据库，或既访问数据库、又访问像消息中间件这样的资源。这样我们就能够实现在多个数据库和消息中间件直接实现全部提交、或全部取消的事务。XA 规范不是 java 的规范，而是一种通用的规范。</p><h4 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h4><p>JTA(Java Transaction API)，是 J2EE 的编程接口规范，它是 XA 协议的 JAVA 实现。它主要定义了：</p><p>一个事务管理器的接口 javax.transaction.TransactionManager，定义了有关事务的开始、提交、撤回等操作。<br>一个满足 XA 规范的资源定义接口 javax.transaction.xa.XAResource，一种资源如果要支持 JTA 事务，就需要让它的资源实现该 XAResource 接口，并实现该接口定义的两阶段提交相关的接口。</p><p><img src="../../images/springcloud/8/2PC.png"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1、准备阶段</p><p>TM 给每个 RM 发送  <strong>Prepare</strong> 消息，每个 RM 要么直接返回失败（如<strong>权限验证失败、本地作业执行故障等</strong>），要么在本地执行事务，<strong>写本地的 redo 和 undo 日志，但不提交</strong>，到达一种“万事俱备，只欠东风”的状态。</p><p>2、提交阶段</p><ul><li>TM 接收到 RM 的失败消息或者超时，直接给每个 RM 发送回滚消息（rollback），各个 RM 回滚本地事务，释放事务过程中的锁资源。</li><li>TM 接收到所有 RM 的成功消息，直接给每个 RM 发送提交消息（commit），各个 RM 提交本地事务，释放事务过程中的锁资源。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>单点故障</strong>：事务的发起、提交还是取消，均是由老大协调者管理的，只要协调者宕机，那就凉凉了。</li><li><strong>同步阻塞缺点</strong>：从上面介绍以及例子可看出，我们的参与系统中在没收到老大的真正提交还是取消事务指令的时候，就是锁定当前的资源，并不真正的做些事务相关操作，所以，整个分布式系统环境就是阻塞的。</li><li><strong>数据不一致缺点</strong>：就是说在老大协调者向小弟们发送真正提交事务的时候，部分网路故障，造成部分系统没收到真正的指令，那么就会出现部分提交部分没提交，因此，这就会导致数据的不一致。就是十个 RM 只发了五个 TM 就挂了。</li></ul><h4 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h4><p>当协调者出错，同时参与者也出错时，两阶段无法保证事务执行的完整性。<br>考虑协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使有了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。知道的人已经被灭口了。</p><p>就是说即使新的 TM 上台，也无法知道这个事务应该提交还是回滚。</p><h3 id="2-2-三阶段提交协议-3PC"><a href="#2-2-三阶段提交协议-3PC" class="headerlink" title="2.2 三阶段提交协议(3PC)"></a>2.2 三阶段提交协议(3PC)</h3><p>采取强一致性，遵从 ACID。</p><p>在二阶段上增加了：<strong>超时（TM、RM 均引入超时机制）</strong>和<strong>预提交机制</strong>。</p><p>有这三个主阶段，canCommit、preCommit、doCommit 这三个阶段</p><p><img src="../../images/springcloud/8/3PC.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1、CanCommit 阶段</p><p>TM 向所有 RM 发送 commit 请求，RM 如果可以提交就返回 yes 响应，否则返回 no 响应。</p><p>2、PreCommit 阶段</p><ul><li>所有 RM 返回 yes，执行事务的预执行</li><li>存在 RM 返回 no，或者 RM 响应超时，执行事务的中断</li></ul><p>3、DoCommit 阶段</p><ul><li>TM 发送 commit/rollback 请求</li><li>RM commit/rollback 事务</li><li>RM 事务处理完成向 TM 发送 Ack 响应</li><li>TM 确定事务完成</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>解决了一部分同步阻塞问题（超时时间内还是会阻塞），但是还是有<strong>单点故障、数据不一致性问题</strong>。PreCommit 阶段后，如果 TM 发出的是 rollback 请求，假设只有一个 RM 收到并进行了 rollback 操作，然后 TM 挂了。其他 RM 会根据 3PC 选择继续 Commit，此时系统状态发生不一致性。</p><h4 id="2-和-3-的区别"><a href="#2-和-3-的区别" class="headerlink" title="2 和 3 的区别"></a>2 和 3 的区别</h4><p>1、加了询问，增大成功概率。</p><p>2、对于 TM 和 RM 都设置了超时机制（在2PC中，只有 TM 拥有超时机制，即如果在一定时间内没有收到 RM 的消息则默认失败）。 TM 挂了，RM 等待超时后，默认提交事务。有一丢丢进步。</p><p>3、如果参与者异常了，协调者也异常了，会造成其他参与者提交。<br>PreCommit 是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。</p><h3 id="2-3-柔性事务-最终一致性形式"><a href="#2-3-柔性事务-最终一致性形式" class="headerlink" title="2.3 柔性事务(最终一致性形式)"></a>2.3 柔性事务(最终一致性形式)</h3><p>柔性事务基于 CAP 理论和 BASE 理论。</p><p><strong>BASE</strong>：全称是，Basically Avaliable（基本可用），Soft state（软状态），Eventually consistent（最终一致性）三个短语的缩写，来自 eBay 的架构师提出。</p><ul><li><strong>Basically Avaliable：</strong>就是在分布式系统环境中，允许牺牲掉部分不影响主流程的功能的不可用，将其降级以确保核心服务的正常可用。</li><li><strong>Soft state：</strong>就是指在事务中，我们允许系统存在中间状态，且并不影响我们这个系统。就拿数据库的主从复制来说，是完全允许复制的时候有延时的发生的。</li><li><strong>Eventually consistent：</strong>还是以数据库主从复制为例说，虽然主从复制有小延迟，但是很快最终就数据保持一致了。</li></ul><p>分布式事务不可能 100% 解决，只能提高成功概率。两阶段之间时间，毫秒级别。补救措施：</p><ul><li><p>定时任务补偿。程序或脚本补偿。</p></li><li><p>人工介入。</p></li></ul><p>通常说的柔性事务分为：补偿型、异步确保型、最大努力通知型</p><h4 id="补偿型-TCC"><a href="#补偿型-TCC" class="headerlink" title="补偿型-TCC"></a>补偿型-TCC</h4><p>TCC（Try、Confirm、Cancel），两阶段补偿型方案。</p><p>从名字可以看出，实现一个事务，需要定义三个 API：预先占有资源，确认提交实际操作资源，取消占有（回滚）。</p><ul><li>try：预留，即资源的预留和锁定。</li><li>confirm：确认，其实就是真正的执行。</li><li>cancel：撤销，可以理解为吧预留阶段的动作撤销。</li></ul><p>如果后两个环节执行一半失败了，<strong>记录日志，补偿处理，通知人工</strong>。</p><p>2PC 是资源层面的分布式事务，强一致性，一直会持有资源的锁。TCC 是在业务层面的分布式事务，<strong>可以跨数据库、跨不同业务系统来实现事务</strong>，最终一致性，不会一直持有锁，将锁的粒度变小了，每操作完一个库，就释放了锁。使用哪一种类型都是相对而言的，如果请求量少，跨越的数据库少，用 2PC 比 TCC 性能要高，因为 TCC 多了几次接口调用。而此时的 2PC 不怕占用资源，反正请求少并发低。高并发场景下 TCC 优势更大。<strong>但是 TCC 对业务的侵入较大和业务紧耦合。</strong></p><p>例子：</p><p>飞猪：</p><ul><li>武汉-&gt;西安 南方航空</li><li>西安-&gt;西宁 东方航空</li></ul><p><img src="../../images/springcloud/8/TCC.png"></p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>利用<strong>各个系统本地事务</strong>来实现分布式事务。</p><p> 本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 <strong>将业务的执行和将消息放入消息表中的操作放在同一个事务中</strong>，这样就能保证消息放入本地表中业务肯定是执行成功的。 </p><p>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。</p><p>如果调用失败也没事，会有 <strong>后台任务定时去读取本地消息表</strong>，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。</p><p>这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是<strong>幂等</strong>的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。</p><p>可以看到本地消息表其实实现的是<strong>最终一致性</strong>，容忍了数据暂时不一致的情况。</p><h4 id="异步确保型-MQ"><a href="#异步确保型-MQ" class="headerlink" title="异步确保型-MQ"></a>异步确保型-MQ</h4><p>RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。</p><p>第一步先给 Broker 发送事务消息即半消息，<strong>半消息不是说一半消息，而是这个消息对消费者来说不可见</strong>，然后<strong>发送成功后发送方再执行本地事务</strong>。</p><p>再根据<strong>本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令</strong>。</p><p> 并且 RocketMQ 的发送方会提供一个<strong>反查事务状态接口</strong>，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。 </p><p> 如果<strong>是 Commit 那么订阅方就能收到这条消息</strong>，然后再做对应的操作，做完了之后再消费这条消息即可。 </p><p> 如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。 </p><p> 可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。 </p><p><img src="../../images/springcloud/8/%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D%E5%9E%8B-MQ.png"></p><p> 可以看到消息事务实现的也是最终一致性。 </p><h4 id="最大努力通知型（多次尝试）"><a href="#最大努力通知型（多次尝试）" class="headerlink" title="最大努力通知型（多次尝试）"></a>最大努力通知型（多次尝试）</h4><p>其实我觉得本地消息表也可以算最大努力，异步确保型也可以算最大努力。</p><p>就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。</p><p>事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。</p><p>所以<strong>最大努力通知其实只是表明了一种柔性事务的思想</strong>：我已经尽力我最大的努力想达成事务的最终一致了。</p><p>适用于对时间不敏感的业务，例如短信通知。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。</p><p>而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。</p><p>本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。</p><h2 id="消息中间件实现"><a href="#消息中间件实现" class="headerlink" title="消息中间件实现"></a>消息中间件实现</h2><p>本地事务+定时任务+消息队列+事件表</p><p><img src="../../images/springcloud/8/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1.png"></p><pre><code class="sh">CREATE TABLE `tbl_order_event` (  `id` int(16) NOT NULL,  `order_type` varchar(32) DEFAULT NULL COMMENT &#39;事件类型（支付表支付完成，订单表修改状态）&#39;,  `process` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT &#39;事件环节（new,published,processed)&#39;,  `content` varchar(255) DEFAULT NULL COMMENT &#39;事件内容，保存事件发生时需要传递的数据&#39;,  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</code></pre><pre><code class="sh">http://localhost:8161/index.htmladmin/admin</code></pre><p>service-jms-consumer</p><p>service-jms-produce</p><h2 id="3、seata-框架"><a href="#3、seata-框架" class="headerlink" title="3、seata 框架"></a>3、seata 框架</h2><p>开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。有 AT、TCC、SAGA 和 SA 四种事务模式。</p><pre><code>官网：http://seata.io/zh-cn/docs/overview/what-is-seata.html</code></pre><p><strong>AT 模式和 TCC 模式总体架构图</strong></p><p><img src="../../images/springcloud/8/seata_2pc.png"></p><ul><li>TM：定义全局事务的范围：开始、提交或回滚全局事务</li><li>TC：维护全局事务和分支事务的状态，驱动全局事务的提交或回滚</li><li>RM：与 TC 交谈以注册分支事务和报告分支事务状态，驱动分支事务的提交或回滚</li></ul><h3 id="3-1-AT-模式"><a href="#3-1-AT-模式" class="headerlink" title="3.1 AT 模式"></a>3.1 AT 模式</h3><p><strong>前提</strong></p><ul><li>基于本地 ACID 事务的关系型数据库</li><li>Java 应用，通过 JDBC 访问数据库</li></ul><p><strong>整体机制</strong></p><p>2PC 的演变：</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源</li><li>二阶段：<ul><li>提交异步化，非常快速地完成</li><li>回滚通过一阶段的回滚日志进行反向补偿</li></ul></li></ul><p><strong>单个分支事务执行过程</strong></p><p><img src="../../images/springcloud/8/AT%E6%A8%A1%E5%BC%8F%E5%88%86%E6%94%AF%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png"></p><p><strong>全局事务之间写隔离</strong></p><ul><li>一阶段提交本地事务之前，需要获取<strong>全局锁</strong></li><li>拿不到<strong>全局锁</strong>，不能提交本地事务</li><li>拿<strong>全局锁</strong>的尝试限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁</li></ul><p><img src="../../images/springcloud/8/AT%E5%86%99%E9%9A%94%E7%A6%BB-%E5%85%A8%E5%B1%80%E6%8F%90%E4%BA%A4.png"></p><p><img src="../../images/springcloud/8/AT%E5%86%99%E9%9A%94%E7%A6%BB-%E5%85%A8%E5%B1%80%E5%9B%9E%E6%BB%9A.png"></p><p><strong>读隔离</strong></p><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。 </p><p> 如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。 </p><p><img src="../../images/springcloud/8/AT%E8%AF%BB%E9%9A%94%E7%A6%BB.png"></p><h3 id="3-2-TCC-模式"><a href="#3-2-TCC-模式" class="headerlink" title="3.2 TCC 模式"></a>3.2 TCC 模式</h3><p> 所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。 </p><p>AT 模式：</p><ul><li>prepare：在本地事务中，一并提交业务数据和相应的回滚日志记录</li><li>commit：马上成功结束，<strong>自动</strong>异步批量清理回滚日志</li><li>rollback：通过回滚日志，<strong>自动</strong>生成补偿操作，完成数据回滚</li></ul><p>TCC 模式：</p><ul><li>prepare：调用<strong>自定义</strong>的 prepare 逻辑</li><li>commit：调用<strong>自定义</strong>的 commit 逻辑</li><li>rollback：调用<strong>自定义</strong>的 rollback 逻辑</li></ul><h3 id="3-3-Saga-模式"><a href="#3-3-Saga-模式" class="headerlink" title="3.3 Saga 模式"></a>3.3 Saga 模式</h3><p>长事务解决方案，每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者， 一阶段正向服务和二阶段补偿服务都由业务开发实现。 </p><p><strong>适用场景</strong></p><ul><li>业务流程长、业务流程多</li><li>参与者包含其他公司或遗留系统，无法提供 TCC 模式要求的三个接口</li></ul><p><strong>优势</strong></p><ul><li>一阶段提交本地事务，无锁性能高</li><li>时间驱动架构，参与者可异步执行，高吞吐</li><li>补偿服务易于实现</li></ul><p><strong>缺点</strong></p><ul><li>不保证隔离性</li></ul><h2 id="4、seata-demo"><a href="#4、seata-demo" class="headerlink" title="4、seata demo"></a>4、seata demo</h2><h3 id="4-1-启动-eureka"><a href="#4-1-启动-eureka" class="headerlink" title="4.1 启动 eureka"></a>4.1 启动 eureka</h3><p>不再赘述</p><h3 id="4-2-下载并配置-seata-server"><a href="#4-2-下载并配置-seata-server" class="headerlink" title="4.2 下载并配置 seata server"></a>4.2 下载并配置 seata server</h3><p><strong>创建 seata-server 数据库</strong></p><pre><code class="sql">-- 创建数据库-- 分支事务表CREATE TABLE `branch_table` (  `branch_id` bigint(20) NOT NULL,  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `transaction_id` bigint(20) DEFAULT NULL,  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `status` tinyint(4) DEFAULT NULL,  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  PRIMARY KEY (`branch_id`) USING BTREE,  KEY `idx_xid` (`xid`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;-- 全局事务表CREATE TABLE `global_table` (  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `transaction_id` bigint(20) DEFAULT NULL,  `status` tinyint(4) NOT NULL,  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `timeout` int(11) DEFAULT NULL,  `begin_time` bigint(20) DEFAULT NULL,  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  PRIMARY KEY (`xid`) USING BTREE,  KEY `idx_gmt_modified_status` (`gmt_modified`,`status`) USING BTREE,  KEY `idx_transaction_id` (`transaction_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;-- 全局锁CREATE TABLE `lock_table` (  `row_key` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `xid` varchar(96) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `transaction_id` bigint(20) DEFAULT NULL,  `branch_id` bigint(20) NOT NULL,  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `table_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `pk` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  PRIMARY KEY (`row_key`) USING BTREE,  KEY `idx_branch_id` (`branch_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;</code></pre><p><strong>下载 seata-server</strong></p><pre><code>https://github.com/seata/seata/releases</code></pre><p><strong>修改配置</strong></p><p>1、file.conf</p><pre><code class="json">service &#123;  #transaction service group mapping  #my_test_tx_group 客户端必须和此一致  vgroup_mapping.my_test_tx_group = &quot;default&quot;  #only support when registry.type=file, please don&#39;t set multiple addresses  #seata-server服务的地址  default.grouplist = &quot;127.0.0.1:8091&quot;  #disable seata  disableGlobalTransaction = false&#125;store &#123;  ## store mode: file、db  # 修改  mode = &quot;db&quot;  ## file store property  file &#123;    ## store location dir    dir = &quot;sessionStore&quot;  &#125;  ## database store property  # db信息修改  db &#123;    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.    datasource = &quot;druid&quot;    ## mysql/oracle/h2/oceanbase etc.    db-type = &quot;mysql&quot;    #神坑。必须写 driverClassName，不可写 driver-class-name    driverClassName = &quot;com.mysql.cj.jdbc.Driver&quot;    url = &quot;jdbc:mysql://127.0.0.1:3306/seata-server?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;    user = &quot;root&quot;    password = &quot;root&quot;  &#125;&#125;</code></pre><p>2、registry.conf</p><pre><code class="json">registry &#123;  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa  # 修改  type = &quot;eureka&quot;  nacos &#123;    serverAddr = &quot;localhost&quot;    namespace = &quot;&quot;    cluster = &quot;default&quot;  &#125;  # 注意如果 eureka 需要密码，记得加上 alvin:pass9876@  eureka &#123;    serviceUrl = &quot;http://alvin:pass9876@localhost:8761/eureka&quot;    application = &quot;default&quot;    weight = &quot;1&quot;  &#125;  redis &#123;    serverAddr = &quot;localhost:6379&quot;    db = &quot;0&quot;  &#125;  zk &#123;    cluster = &quot;default&quot;    serverAddr = &quot;127.0.0.1:2181&quot;    session.timeout = 6000    connect.timeout = 2000  &#125;  consul &#123;    cluster = &quot;default&quot;    serverAddr = &quot;127.0.0.1:8500&quot;  &#125;  etcd3 &#123;    cluster = &quot;default&quot;    serverAddr = &quot;http://localhost:2379&quot;  &#125;  sofa &#123;    serverAddr = &quot;127.0.0.1:9603&quot;    application = &quot;default&quot;    region = &quot;DEFAULT_ZONE&quot;    datacenter = &quot;DefaultDataCenter&quot;    cluster = &quot;default&quot;    group = &quot;SEATA_GROUP&quot;    addressWaitTime = &quot;3000&quot;  &#125;  file &#123;    name = &quot;file.conf&quot;  &#125;&#125;config &#123;  # file、nacos 、apollo、zk、consul、etcd3  type = &quot;file&quot;  nacos &#123;    serverAddr = &quot;localhost&quot;    namespace = &quot;&quot;  &#125;  consul &#123;    serverAddr = &quot;127.0.0.1:8500&quot;  &#125;  apollo &#123;    app.id = &quot;seata-server&quot;    apollo.meta = &quot;http://192.168.1.204:8801&quot;  &#125;  zk &#123;    serverAddr = &quot;127.0.0.1:2181&quot;    session.timeout = 6000    connect.timeout = 2000  &#125;  etcd3 &#123;    serverAddr = &quot;http://localhost:2379&quot;  &#125;  file &#123;    name = &quot;file.conf&quot;  &#125;&#125;</code></pre><p><strong>启动 seata-server</strong></p><p><code>D:\seata-server-1.3.0\seata\bin\seata-server.bat</code></p><p>登录 eureka 控制台（<code>http://localhost:8761/</code>），发现 seata-server 已经作为一个服务注册进来。</p><h3 id="4-3-编写测试服务"><a href="#4-3-编写测试服务" class="headerlink" title="4.3 编写测试服务"></a>4.3 编写测试服务</h3><h4 id="创建测试库"><a href="#创建测试库" class="headerlink" title="创建测试库"></a><strong>创建测试库</strong></h4><pre><code class="sql">-- 创建三个数据库-- 创建业务表DROP TABLE IF EXISTS `seate-rm-one`.tbl_one;DROP TABLE IF EXISTS `seate-rm-two`.tbl_two;DROP TABLE IF EXISTS `seate-rm-three`.tbl_three;CREATE TABLE `seate-rm-one`.tbl_one(id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50)) ENGINE INNODB DEFAULT CHARSET utf8;CREATE TABLE `seate-rm-two`.tbl_two(id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50)) ENGINE INNODB DEFAULT CHARSET utf8;CREATE TABLE `seate-rm-three`.tbl_three(id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50)) ENGINE INNODB DEFAULT CHARSET utf8;SELECT * FROM `seate-rm-one`.tbl_one;SELECT * FROM `seate-rm-two`.tbl_two;SELECT * FROM `seate-rm-three`.tbl_three;-- 三个库均创建 undo_log 表，用于 RM 回滚CREATE TABLE `undo_log` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `branch_id` bigint(20) NOT NULL,  `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `rollback_info` longblob NOT NULL,  `log_status` int(11) NOT NULL,  `log_created` datetime NOT NULL,  `log_modified` datetime NOT NULL,  `ext` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE,  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;</code></pre><p>神坑：</p><ul><li>业务表必须要主键</li></ul><p>seata 相关脚本官网位置：</p><pre><code>https://github.com/seata/seata/tree/1.3.0/script</code></pre><h4 id="创建测试服务"><a href="#创建测试服务" class="headerlink" title="创建测试服务"></a><strong>创建测试服务</strong></h4><p>1、pom</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.monkeykong&lt;/groupId&gt;    &lt;artifactId&gt;seata-rm-one&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;seata-rm-one&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;        &lt;seata.version&gt;1.3.0&lt;/seata.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- web --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- eureka client --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql:阿里巴巴数据库连接池 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql:connector --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- seata --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-seata&lt;/artifactId&gt;            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;                    &lt;groupId&gt;io.seata&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;!-- seata-all --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.seata&lt;/groupId&gt;            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;            &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>2、properties</p><pre><code class="properties"># 服务名称spring.application.name=seata-rm-oneserver.port=8001# 注册中心eureka.client.enabled=trueeureka.client.service-url.defaultZone=http://alvin:pass9876@localhost:8761/eureka/eureka.instance.hostname=localhost# mybatis 配置## mybatis 配置文件所在路径mybatis.config-location=classpath:mybatis/mybatis.cfg.xml#mybatis.type-aliases-package=## 所有 mapper 映射文件mybatis.mapper-locations[0]=classpath:mybatis/mapper/*.xml# 数据源配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver## sqlyog 客户端连接不上:ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;spring.datasource.url=jdbc:mysql://localhost:3306/seate-rm-one?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=rootspring.datasource.dbcp2.initial-size=5spring.datasource.dbcp2.min-idle=5spring.datasource.dbcp2.max-idle=5spring.datasource.dbcp2.max-wait-millis=200spring.datasource.dbcp2.validation-query=SELECT 1spring.datasource.dbcp2.test-while-idle=truespring.datasource.dbcp2.test-on-borrow=falsespring.datasource.dbcp2.test-on-return=falsespring.cloud.alibaba.seata.tx-service-group=my_test_tx_group</code></pre><p>3、配置数据源代理</p><pre><code class="java">// 排除数据源自动装配@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)/** * 数据源代理 */@Configurationpublic class DataSourceConfiguration &#123;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    public DataSource druidDataSource()&#123;        DruidDataSource druidDataSource = new DruidDataSource();        return druidDataSource;    &#125;    @Primary    @Bean(&quot;dataSource&quot;)    public DataSourceProxy dataSource(DataSource druidDataSource)&#123;        return new DataSourceProxy(druidDataSource);    &#125;    @Bean    public SqlSessionFactory sqlSessionFactory(DataSourceProxy dataSourceProxy)throws Exception&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()                .getResources(&quot;classpath*:/mybatis/mapper/*.xml&quot;));        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());        return sqlSessionFactoryBean.getObject();    &#125;&#125;</code></pre><p>4、启动服务测试</p><pre><code class="java">@GetMapping(&quot;/rm1&quot;)public String rm1() &#123;    rmOneService.rm1();    return &quot;rm1 成功&quot;;&#125;//此注解开启全局事务@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)public void rm1() &#123;    rm2();    rm3();    One o = new One();    o.setName(&quot;rm1&quot;);    mapper.insertSelective(o);    //        int i = 1/0;&#125;private void rm2() &#123;    restTemplate.getForEntity(&quot;http://seata-rm-two/test/rm2&quot;, null);&#125;private void rm3() &#123;    restTemplate.getForEntity(&quot;http://seata-rm-three/test/rm3&quot;, null);&#125;</code></pre><p>seata RM 启动成功日志：</p><pre><code class="json"># TM 要连接的 seata-server 地址NettyClientChannelManager  : will connect to 192.168.238.1:8091# 为 TM 创建 NettyPoolNettyPoolableFactory  : NettyPool create channel to transactionRole:TMROLE,address:192.168.238.1:8091,msg:&lt; RegisterTMRequest&#123;applicationId=&#39;seata-rm-two&#39;, transactionServiceGroup=&#39;my_test_tx_group&#39;&#125; &gt;# TM 注册成功TmNettyRemotingClient    : register TM success. client version:1.3.0, server version:1.3.0,channel:[id: 0xc2bcb0b5, L:/192.168.238.1:55335 - R:/192.168.238.1:8091]# TM 注册成功NettyPoolableFactory  : register success, cost 9 ms, version:1.3.0,role:TMROLE,channel:[id: 0xc2bcb0b5, L:/192.168.238.1:55335 - R:/192.168.238.1:8091]</code></pre><h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>访问：<code>http://localhost:8001/test/rm1</code></p><p><strong>事务失败</strong></p><p>1、全局事务表，有一个全局事务</p><p><img src="../../images/springcloud/8/seata-%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E8%A1%A8.png"></p><p>2、分支事务表，有两个分支事务</p><p><img src="../../images/springcloud/8/seata-%E5%88%86%E6%94%AF%E4%BA%8B%E5%8A%A1%E8%A1%A8.png"></p><p>3、锁定表，两条锁定数据</p><p><img src="../../images/springcloud/8/seata-%E9%94%81%E5%AE%9A%E8%A1%A8.png"></p><p>4、回滚表，两个库各一条记录</p><p><img src="../../images/springcloud/8/seata-%E5%9B%9E%E6%BB%9A%E8%A1%A8.png"></p><p>5、日志信息</p><pre><code class="json"># SeataRmOneApplication 日志## 全局事务开始DefaultGlobalTransaction  : Begin new global transaction [192.168.238.1:8091:63599496698793984]## 全局事务回滚完成DefaultGlobalTransaction  : [192.168.238.1:8091:63599496698793984] rollback status: Rollbacked# SeataRmTwoApplication 日志## 分支事务完成，xid 变为 nullweb.SeataHandlerInterceptor  : xid in change during RPC from 192.168.238.1:8091:63599496698793984 to null## 分支事务回滚RmBranchRollbackProcessor    : rm handle branch rollback process:xid=192.168.238.1:8091:63599496698793984,branchId=63599496786874369,branchType=AT,resourceId=jdbc:mysql://localhost:3306/seate-rm-two,applicationData=null## 分支事务回滚中...AbstractRMHandler            : Branch Rollbacking: 192.168.238.1:8091:63599496698793984 63599496786874369 jdbc:mysql://localhost:3306/seate-rm-two## 通过 undo_log 回滚并删除 undo_logAbstractUndoLogManager       : xid 192.168.238.1:8091:63599496698793984 branch 63599496786874369, undo_log deleted with GlobalFinished## 分支事务回滚完成AbstractRMHandler            : Branch Rollbacked result: PhaseTwo_Rollbacked</code></pre><p>6、业务表均无数据，分布式事务成功</p><pre><code class="sql">SELECT * FROM `seate-rm-one`.tbl_one;SELECT * FROM `seate-rm-two`.tbl_two;SELECT * FROM `seate-rm-three`.tbl_three;</code></pre><p><strong>事务成功</strong></p><p>业务表正常插入数据。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(七)</title>
    <link href="http://yoursite.com/2020-10-10-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(7)-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"/>
    <id>http://yoursite.com/2020-10-10-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(7)-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</id>
    <published>2020-10-10T15:43:12.000Z</published>
    <updated>2020-11-24T14:43:52.598Z</updated>
    
    <content type="html"><![CDATA[<ul><li>分布式锁</li></ul><a id="more"></a><h2 id="1、我们真的需要锁么？"><a href="#1、我们真的需要锁么？" class="headerlink" title="1、我们真的需要锁么？"></a>1、我们真的需要锁么？</h2><p>需要锁的条件：</p><ol><li>多任务环境下。（进程，线程）</li><li>任务都对同一共享资源进行写操作。</li><li>对资源的访问是互斥的。</li></ol><p>操作周期：</p><ol><li>竞争锁。获取锁后才能对资源进行操作。</li><li>占有锁。操作中。</li><li>其他竞争者，任务阻塞。</li><li>占有锁者，释放锁。继续从 1 开始。</li></ol><p>分布式锁应用场景：</p><p>​    服务集群，比如 N 个订单服务，接受到大量司机的发送的对一个订单的抢单请求。如果是单个服务，可以用 jvm 锁控制，但是服务集群，jvm 就不行了。因为不在一个 jvm 中。jvm 锁解决不了分布式环境中的加锁问题。</p><h2 id="2、分布式锁解决方案"><a href="#2、分布式锁解决方案" class="headerlink" title="2、分布式锁解决方案"></a>2、分布式锁解决方案</h2><p>服务启动：</p><p><img src="../../images/springcloud/7/%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1.png"></p><p>jmeter 测试：10个司机同时抢一张订单。</p><p><img src="../../images/springcloud/7/jmeter%E6%B5%8B%E8%AF%951.png"></p><p><img src="../../images/springcloud/7/jmeter%E6%B5%8B%E8%AF%952.png"></p><p><img src="../../images/springcloud/7/jmeter%E6%B5%8B%E8%AF%953.png"></p><h3 id="2-1-无锁情况"><a href="#2-1-无锁情况" class="headerlink" title="2.1 无锁情况"></a>2.1 无锁情况</h3><p>测试结果：全部枪单成了。。。</p><pre><code class="json">@Qualifier(&quot;grabNoLockService&quot;)司机:5 执行抢单逻辑司机:7 执行抢单逻辑司机:1 执行抢单逻辑司机:2 执行抢单逻辑司机:9 执行抢单逻辑司机:5 抢单成功司机:7 抢单成功司机:1 抢单成功司机:2 抢单成功司机:9 抢单成功司机:10 执行抢单逻辑司机:4 执行抢单逻辑司机:6 执行抢单逻辑司机:8 执行抢单逻辑司机:3 执行抢单逻辑司机:10 抢单成功司机:8 抢单成功司机:6 抢单成功司机:4 抢单成功司机:3 抢单成功</code></pre><p>结论：没锁肯定不行的。本来只有一张订单，现在你分出去十张订单了。</p><h3 id="2-1-JVM-锁"><a href="#2-1-JVM-锁" class="headerlink" title="2.1 JVM 锁"></a>2.1 JVM 锁</h3><p>测试结果：有两个司机枪单成功了。</p><pre><code class="json">@Qualifier(&quot;grabJvmLockService&quot;)司机:4 执行抢单逻辑司机:4 抢单成功司机:3 执行抢单逻辑司机:3 抢单失败司机:5 执行抢单逻辑司机:5 抢单失败司机:7 执行抢单逻辑司机:7 抢单失败司机:6 执行抢单逻辑司机:6 抢单失败司机:1 执行抢单逻辑司机:1 抢单成功司机:8 执行抢单逻辑司机:8 抢单失败司机:9 执行抢单逻辑司机:9 抢单失败司机:10 执行抢单逻辑司机:10 抢单失败司机:2 执行抢单逻辑司机:2 抢单失败</code></pre><p>结论：JVM 锁无法解决分布式，集群环境的问题。因为 JVM 锁只能控制单个 JVM 内部同步。所以需要分布式锁。</p><h3 id="2-2-基于-MySQL-实现分布式锁"><a href="#2-2-基于-MySQL-实现分布式锁" class="headerlink" title="2.2 基于 MySQL 实现分布式锁"></a>2.2 基于 MySQL 实现分布式锁</h3><p>测试结果：只有一个司机抢单成功，OK 的。</p><pre><code class="json">加锁对象:OrderLock(orderId=1001, driverId=2)司机:2 执行抢单逻辑司机:2 抢单成功解锁对象:OrderLock(orderId=1001, driverId=2)加锁对象:OrderLock(orderId=1001, driverId=4)司机:4 执行抢单逻辑司机:4 抢单失败解锁对象:OrderLock(orderId=1001, driverId=4)加锁对象:OrderLock(orderId=1001, driverId=10)司机:10 执行抢单逻辑司机:10 抢单失败解锁对象:OrderLock(orderId=1001, driverId=10)加锁对象:OrderLock(orderId=1001, driverId=9)司机:9 执行抢单逻辑司机:9 抢单失败解锁对象:OrderLock(orderId=1001, driverId=9)加锁对象:OrderLock(orderId=1001, driverId=1)司机:1 执行抢单逻辑司机:1 抢单失败解锁对象:OrderLock(orderId=1001, driverId=1)加锁对象:OrderLock(orderId=1001, driverId=8)司机:8 执行抢单逻辑司机:8 抢单失败解锁对象:OrderLock(orderId=1001, driverId=8)加锁对象:OrderLock(orderId=1001, driverId=5)司机:5 执行抢单逻辑司机:5 抢单失败解锁对象:OrderLock(orderId=1001, driverId=5)加锁对象:OrderLock(orderId=1001, driverId=7)司机:7 执行抢单逻辑司机:7 抢单失败解锁对象:OrderLock(orderId=1001, driverId=7)加锁对象:OrderLock(orderId=1001, driverId=3)司机:3 执行抢单逻辑司机:3 抢单失败解锁对象:OrderLock(orderId=1001, driverId=3)加锁对象:OrderLock(orderId=1001, driverId=6)司机:6 执行抢单逻辑司机:6 抢单失败解锁对象:OrderLock(orderId=1001, driverId=6)</code></pre><p>结论：基于 MySQL 可以实现分布式锁。</p><p>存在的问题：</p><ul><li><p>如果中间出现异常了，如何释放锁？比如加锁后服务器断电了，finally 都来不及跑。</p><ul><li>用存储过程可以解决？具体怎么解决？加锁-操作订单-释放锁 放在一个 sp 中？</li></ul></li><li><p>MySQL 的并发是有限制的，不适合高并发场景。<strong>具体并发数要看机器的配置而定。</strong></p><ul><li><p>压测结果：<a href="https://help.aliyun.com/document_detail/150351.html?spm=a2c4g.11186623.6.1463.1e732d02nCMBBa">https://help.aliyun.com/document_detail/150351.html?spm=a2c4g.11186623.6.1463.1e732d02nCMBBa</a></p><p>4核 16GB ：最大连接数 4000，QPS  39766.67  四万左右，TPS  1988.33  两千左右</p><p>8核 16GB ：最大连接数 4000，QPS   64750.34 六万左右，TPS   3237.52 三千左右</p></li><li><p>牛逼点的：<a href="https://help.aliyun.com/document_detail/101100.html?spm=5176.11065259.1996646101.searchclickresult.5a6316bcjenDJn">https://help.aliyun.com/document_detail/101100.html?spm=5176.11065259.1996646101.searchclickresult.5a6316bcjenDJn</a></p></li></ul></li></ul><h3 id="2-3-基于-Redis-实现分布式锁"><a href="#2-3-基于-Redis-实现分布式锁" class="headerlink" title="2.3 基于 Redis 实现分布式锁"></a>2.3 基于 Redis 实现分布式锁</h3><pre><code class="sh">stringRedisTemplate 用法https://blog.csdn.net/zzz127333092/article/details/88742088</code></pre><p>redis：内存存储的数据结构服务器，内存数据库。redis 是单进程单线程的。</p><p>可用于：数据库，高速缓存，消息队列。采用单线程模型，并发能力强大。10 万并发没问题。</p><p>测试结果：只有一个司机抢单成功，OK 的。</p><pre><code class="json">司机:2 执行抢单逻辑司机:2 抢单成功司机:5 执行抢单逻辑司机:5 抢单失败司机:4 执行抢单逻辑司机:4 抢单失败司机:9 执行抢单逻辑司机:9 抢单失败司机:3 执行抢单逻辑司机:3 抢单失败司机:8 执行抢单逻辑司机:8 抢单失败司机:10 执行抢单逻辑司机:10 抢单失败司机:7 执行抢单逻辑司机:7 抢单失败司机:6 执行抢单逻辑司机:6 抢单失败司机:1 执行抢单逻辑司机:1 抢单失败</code></pre><p>结论：如果 redis 是单节点是 OK 的。但是如果是多节点，由于 Redis 的主从复制（replication）是异步的，这可能导致丧失锁的安全性。</p><blockquote><p>《Redis 分布锁》</p></blockquote><h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><p><strong><em>加锁</em></strong></p><pre><code class="shell">SET orderId driverId NX PX 30000set order_1001 driver_001 nx px 30000</code></pre><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p><strong><em>释放锁</em></strong></p><p>关键，判断是不是自己加的锁。</p><p><strong><em>关注点</em></strong>：</p><ol><li><p>orderId，是我们的 key，要锁的目标。一个单只能分配给一个司机，所以以 orderId 作为 key。</p></li><li><p>driverId 是我们的司机ID，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。即一个订单被一个司机抢。</p></li><li><p>NX 表示只有当 orderId 不存在的时候才能 SET 成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</p></li><li><p>PX 30000表示这个锁有一个 30 秒的自动过期时间。当然，这里 30 秒只是一个例子，客户端可以选择合适的过期时间。</p></li><li><p><strong>这个锁必须要设置一个过期时间。</strong>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分区，导致它再也无法和 Redis 节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。antirez在后面的分析中也特别强调了这一点，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p></li><li><p>此操作不能分割。</p><pre><code class="sh">SETNX orderId driverIdEXPIRE orderId 30虽然这两个命令和前面算法描述中的一个 SET 命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX 后崩溃了，那么就没有机会执行 EXPIRE 了，导致它一直持有这个锁。造成死锁。</code></pre></li><li><p>必须给 key 设置一个 value，并且保证每个线程不一样，用于释放锁时判断是否是自己的锁。如果 value 在每个线程间一样。会发生 <strong>误解锁</strong>的问题。</p><pre><code class="sh">1.客户端1获取锁成功。2.客户端1在某个操作上阻塞了很长时间。3.过期时间到了，锁自动释放了。4.客户端2获取到了对应同一个资源的锁。5.客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</code></pre></li><li><p>释放锁的操作，得释放自己加的锁。</p><pre><code class="sh">1.客户端1获取锁成功。2.客户端1访问共享资源。3.客户端1为了释放锁，先执行&#39;GET&#39;操作获取随机字符串的值。4.客户端1判断随机字符串的值，与预期的值相等。5.客户端1由于某个原因阻塞住了很长时间。6.过期时间到了，锁自动释放了。7.客户端2获取到了对应同一个资源的锁。8.客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</code></pre></li><li><p>redis故障问题。</p><p>如果 redis 故障了，所有客户端无法获取锁，服务变得不可用。为了提高可用性，我们给 redis 配置主从，当master不可用时，系统切换到 slave，但是由于 Redis 的主从复制（replication）是异步的，这可能导致丧失锁的安全性。</p><pre><code class="sh">1.客户端1从 Master 获取了锁。2.Master 宕机了，存储锁的 key 还没有来得及同步到Slave上。3.Slave 升级为 Master。4.客户端2从新的Master获取到了对应同一个资源的锁。</code></pre><p>客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p></li><li><p>这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。应该设置稍微短一些，如果线程持有锁，开启线程自动延长有效期（<strong>自动续租锁</strong>）。</p></li></ol><p><strong><em>还有一点，如果在过期时间内，程序没有执行完，是不能让key过期的，所以要延时。</em></strong></p><pre><code class="sh">断点打在：rlock.lock();执行完，之后，等着，去redis查看，看过期时间，是不是一直在变，答案：一直在变。到20时，自动加到30.</code></pre><p>为了解决 9、10 问题。antirez 设计了 Redlock 算法</p><p>Redis 的作者 antirez 给出了一个更好的实现，称为 Redlock，算是 Redis 官方对于实现分布式锁的指导规范。Redlock 的算法描述就放在 Redis 的官网上：</p><p><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p><h4 id="RedLock（多master）"><a href="#RedLock（多master）" class="headerlink" title="RedLock（多master）"></a>RedLock（多master）</h4><p>debug</p><pre><code class="sh">断点达到：rLock.lock()执行完后，看结果，发现如果是 3 个 redis 节点，则有 2 个节点中 设置了值。</code></pre><p>目的：对共享资源做互斥访问。   </p><p>因此 antirez 提出了新的分布式锁的算法 Redlock，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p><p>运行 Redlock 算法的客户端依次执行下面各个步骤，来完成 获取锁 的操作：</p><ol><li>获取当前时间（毫秒数）。</li><li>按顺序依次向 N 个 Redis 节点执行 <strong>获取锁</strong> 的操作。这个获取操作跟前面基于单 Redis 节点的 <strong>获取锁</strong> 的过程相同，包含 value driverId ，也包含<strong>过期时间</strong>(比如 <code>PX 30000</code> ，<strong>即锁的有效时间</strong>)。为了保证在某个Redis 节点不可用的时候算法能够继续运行，这个 <strong>获取锁</strong> 的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用，或者该 Redis 节点上的锁已经被其它客户端持有（注：Redlock 原文中这里只提到了 Redis 节点不可用的情况，但也应该包含其它的失败情况）。</li><li>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</li><li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。</li><li>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起 <strong>释放锁</strong> 的操作（即前面介绍的Redis Lua脚本）。</li></ol><p>当然，上面描述的只是 获取锁 的过程，而 释放锁 的过程比较简单：客户端向所有Redis节点发起 释放锁 的操作，不管这些节点当时在获取锁的时候成功与否。</p><blockquote><p>问题：Redis 节点崩溃重启，是否会对分布式锁造成影响？</p><p>答案：影响肯定是有的。即使持久化方式设置为每次修改都刷盘，也是会收到操作系统刷盘的影响的。antirez 提出延迟重启，让所有锁过期的方案。</p></blockquote><p>由于 N 个 Redis 节点中的大多数能正常工作就能保证 Redlock 正常工作，因此理论上它的可用性更高。我们前面讨论的单 Redis 节点的分布式锁在 failover 的时候锁失效的问题，在 Redlock 中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟 Redis 对数据的持久化程度有关。</p><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><ol><li>客户端1成功锁住了A, B, C， <strong>获取锁</strong> 成功（但D和E没有锁住）。</li><li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li><li>节点C重启后，客户端2锁住了C, D, E， <strong>获取锁</strong> 成功。</li></ol><p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis 的 AOF 持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis 允许设置成每次修改数据都进行 fsync，但这会降低性能。当然，即使执行了 fsync 也仍然有可能丢失数据（这取决于系统而不是 Redis 的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez 又提出了<strong>延迟重启</strong> (delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><blockquote><p>问题：为啥释放锁时要向所有 Redis 节点发送释放消息？</p><p>答案：因为异步通信模型中可能存在客户端向服务器是正常的，但是反方向却有问题。</p></blockquote><p>关于 Redlock 还有一点细节值得拿出来分析一下：在最后 释放锁 的时候，antirez 在算法描述中特别强调，客户端应该向所有 Redis 节点发起<strong>释放锁</strong>的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？设想这样一种情况，客户端发给某个 Redis 节点的 获取锁 的请求成功到达了该Redis节点，这个节点也成功执行了 <code>SET</code> 操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在 Redis 这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些 Redis 节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(六)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(6)-config.html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(6)-config.html</id>
    <published>2020-10-04T15:43:12.000Z</published>
    <updated>2020-11-24T14:43:49.616Z</updated>
    
    <content type="html"><![CDATA[<ul><li>配置中心</li><li>bus 消息总线同步刷新配置</li></ul><a id="more"></a><h2 id="1、配置中心"><a href="#1、配置中心" class="headerlink" title="1、配置中心"></a>1、配置中心</h2><h3 id="1-1-为什么需要配置中心？"><a href="#1-1-为什么需要配置中心？" class="headerlink" title="1.1 为什么需要配置中心？"></a>1.1 为什么需要配置中心？</h3><p>单体应用，配置写在配置文件中，没有什么大问题。如果要切换环境 可以切换不同的 profile（2种方式），但在微服务中。</p><ol><li><p>微服务比较多。成百上千，配置很多，需要集中管理。</p></li><li><p>管理不同环境的配置。</p></li><li><p>需要动态调整配置参数，更改配置不停服。</p></li></ol><h3 id="1-2-配置中心介绍"><a href="#1-2-配置中心介绍" class="headerlink" title="1.2 配置中心介绍"></a>1.2 配置中心介绍</h3><p>分布式配置中心包括 3 个部分：</p><ol><li>存放配置的地方：git ，本地文件 等。</li><li>config  server。从 1 读取配置。</li><li>config client。是 config server 的客户端，消费配置。</li></ol><p><img src="../../images/springcloud/configserver.png"></p><p><a href="https://m.sohu.com/a/116745628_466839">https://m.sohu.com/a/116745628_466839</a></p><p>配置都不会自己更新，都是需要触发 client 才去 git 上拉取的。或者触发在 config-server 上查看配置时，才去 git 上拉取。</p><h3 id="1-3-服务搭建-基于-Github"><a href="#1-3-服务搭建-基于-Github" class="headerlink" title="1.3 服务搭建-基于 Github"></a>1.3 服务搭建-基于 Github</h3><h4 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h4><pre><code class="shell">https://github.com/Monkey-kong/config-center.git</code></pre><p>上传配置 ribbon-consumer.dev.properties</p><pre><code class="properties">myconfig=&quot;config test v1&quot;</code></pre><h4 id="2-创建配置中心服务"><a href="#2-创建配置中心服务" class="headerlink" title="2. 创建配置中心服务"></a>2. 创建配置中心服务</h4><p>pom</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件</p><pre><code class="properties">spring.application.name=config-serverserver.port=9999eureka.client.service-url.defaultZone=http://alvin:pass9876@localhost:8761/eureka/# 拉取配置的仓库地址spring.cloud.config.server.git.uri=https://github.com/Monkey-kong/config-center.git# 仓库的分支spring.cloud.config.label=master</code></pre><p>启动类</p><pre><code class="java">@EnableConfigServer</code></pre><h4 id="3-配置匹配规则"><a href="#3-配置匹配规则" class="headerlink" title="3. 配置匹配规则"></a>3. 配置匹配规则</h4><p><strong>注意文件名称格式必须按照规则来</strong></p><pre><code>获取配置规则：根据前缀匹配/&#123;name&#125;-&#123;profiles&#125;.properties/&#123;name&#125;-&#123;profiles&#125;.yml/&#123;name&#125;-&#123;profiles&#125;.json/&#123;label&#125;/&#123;name&#125;-&#123;profiles&#125;.ymlname 服务名称profile 环境名称，开发、测试、生产：dev qa prdlable 仓库分支、默认master分支匹配原则：从前缀开始。</code></pre><h4 id="4-启动测试拉取"><a href="#4-启动测试拉取" class="headerlink" title="4.启动测试拉取"></a>4.启动测试拉取</h4><p>启动服务后访问服务</p><pre><code class="properties"># 同一分支，不同 profilehttp://localhost:9999/master/ribbon-consumer.dev.propertieshttp://localhost:9999/master/ribbon-consumer.test.propertieshttp://localhost:9999/master/ribbon-consumer.prd.properties# 切换分支http://localhost:9999/v1.0Release/ribbon-consumer.dev.propertieshttp://localhost:9999/v1.0Release/ribbon-consumer.test.propertieshttp://localhost:9999/v1.0Release/ribbon-consumer.prd.properties</code></pre><p>正确配置后能读到来自git的配置文件</p><h3 id="1-4-客户端配置"><a href="#1-4-客户端配置" class="headerlink" title="1.4 客户端配置"></a>1.4 客户端配置</h3><p>配置文件</p><p>修改 application.properties 为 bootstrap.properties</p><pre><code class="properties">#直接URL方式查找配置中心spring.cloud.config.uri=http://localhost:9999/#通过注册中心查找#spring.cloud.config.discovery.enabled=true#spring.cloud.config.discovery.service-id=a-configspring.cloud.config.profile=devspring.cloud.config.label=dev</code></pre><p>引入依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>使用远程配置</p><pre><code class="java">@RestControllerpublic class ConfigCenterTestController &#123;    @Value(&quot;$&#123;myconfig&#125;&quot;)    String myconfig;    @GetMapping    public String getMyConfig() &#123;        return myconfig;    &#125;&#125;</code></pre><p>测试</p><pre><code>http://localhost:9001/</code></pre><h2 id="2、刷新配置"><a href="#2、刷新配置" class="headerlink" title="2、刷新配置"></a>2、刷新配置</h2><h3 id="2-1-重启服务可以刷新"><a href="#2-1-重启服务可以刷新" class="headerlink" title="2.1 重启服务可以刷新"></a>2.1 重启服务可以刷新</h3><h3 id="2-2-actuator-单服务刷新"><a href="#2-2-actuator-单服务刷新" class="headerlink" title="2.2 actuator 单服务刷新"></a>2.2 actuator 单服务刷新</h3><ol><li>开启 actuator 中的 refresh 端点</li><li>Controller 中添加 <code>@RefreshScope</code> 注解</li><li>向客户端 url <code>http://localhost:9001/actuator/refresh</code> 发送Post请求</li><li>测试：<code>http://localhost:9001/</code></li></ol><h3 id="2-3-Bus-多服务刷新"><a href="#2-3-Bus-多服务刷新" class="headerlink" title="2.3 Bus 多服务刷新"></a>2.3 Bus 多服务刷新</h3><p>所有微服务注册到 Bus，有事件时 Bus 通过需要处理的微服务。</p><h4 id="erlang安装"><a href="#erlang安装" class="headerlink" title="erlang安装"></a>erlang安装</h4><p><a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a></p><h4 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h4><p><a href="http://www.rabbitmq.com/install-windows.html">http://www.rabbitmq.com/install-windows.html</a></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>path 中添加 <code>%ERLANG_HOME%\bin</code>，cmd 中输入 <code>erl</code>验证。</p><pre><code class="bash"># 启动服务RabbitMQ Service - start# 开启RabbitMQ节点cd D:\rabbitmq\rabbitmq_server-3.8.9\sbinrabbitmqctl start_app# 开启RabbitMQ管理模块的插件，并配置到RabbitMQ节点上rabbitmq-plugins enable rabbitmq_management</code></pre><h4 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h4><p><a href="http://localhost:15672/">http://localhost:15672</a></p><p>用户名密码均为guest</p><h4 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h4><p>配置文件</p><pre><code class="properties">spring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guest</code></pre><p>依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动两个微服务</p><p>修改配置文件后向其中一个端点发送post请求</p><p><a href="http://localhost:91/actuator/bus-refresh">http://localhost:91/actuator/bus-refresh</a></p><p>观察另一个服务是否也跟着刷新了</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;配置中心&lt;/li&gt;
&lt;li&gt;bus 消息总线同步刷新配置&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话管理(一)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(1).html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(1).html</id>
    <published>2020-10-04T12:43:12.000Z</published>
    <updated>2020-11-24T14:44:08.234Z</updated>
    
    <content type="html"><![CDATA[<p>分布式会话基本概念理解。</p><a id="more"></a><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="1-1-Session、Cookies-与-Token"><a href="#1-1-Session、Cookies-与-Token" class="headerlink" title="1.1 Session、Cookies 与 Token"></a>1.1 Session、Cookies 与 Token</h3><p>我们使用浏览器访问网站，使用的是 http 协议，http 协议是无状态的，即两次不同请求服务器无法知晓是谁请求的。浏览器每次请求 Header 中会带有 UA 信息，服务器根据 UA 信息生成一个唯一字符串(session)，然后下发给浏览器，后边浏览器每次请求都在 Cookies 中带上这个 session。所以使用 Session、Cookies 技术可以实现自动保持会话。</p><p>如果浏览器禁用 Cookies，或者是 app 请求，可以使用 token 代替 session，客户端每次请求手动把 token 加入请求参数或者放入请求 header 中。token 可以实现跨平台。</p><h3 id="1-2-浏览器同源策略与跨域"><a href="#1-2-浏览器同源策略与跨域" class="headerlink" title="1.2 浏览器同源策略与跨域"></a>1.2 浏览器同源策略与跨域</h3><h4 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h4><p>域名、协议、端口都会造成不同源。</p><p>浏览器的同源策略是一种安全功能，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。所以 a.com 下的 js 脚本采用 ajax 读取 b.com 里面的文件数据是会报错的。</p><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><script>、<img> 、<iframe>、<link>、<video>这些标签都可以发起跨域请求，就是说不受同源策略的限制#### jsonp 跨域访问原理此方法只能发起 GET 请求，通过 jsonp 发送的请求，会随带 cookie 一起发送。#### CORS在浏览器中指定 Origin 来源，如果在服务器接受范围，请求则成功CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 `GET` 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。## 2、ShiroShiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 SpringSecurity，可能没有 Spring Security 做的功能强大，但是在实际工作时 可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。#### 核心功能**Authentication**：身份认证/登录，验证用户是不是拥有相应的身份；**Authorization**：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；**Session Manager**：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；**Cryptography**：加密（解密 摘要算法），保护数据的安全性，如密码加密存储到数据库，而不是明文存储；**Web Support**：Web 支持，可以非常容易的集成到 Web 环境；**Caching**：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；**Concurrency**：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；**Testing**：提供测试支持；**Run As**：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；**Remember Me**：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。#### 组件**Subject**：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；**SecurityManager**：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；**Realm**：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。## 3、Spring securitySpring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于 Spring 的应用程序提供身份验证和授权支持。它与 Spring MVC 有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。### 3.1 基本使用pom```xml<dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-security</artifactId></dependency><dependency>    <groupId>org.springframework.security</groupId>    <artifactId>spring-security-test</artifactId>    <scope>test</scope></dependency>```直接启动，生成默认密码```Using generated security password: 6e86c6e9-d661-41ae-aabc-bea8817c4f7b```使用该密码和用户名 user 来访问系统。### 3.2 自定义用户名和密码使用配置文件：```propertiesspring.security.user.name=111spring.security.user.password=111```使用类配置：```java@Configuration@EnableWebSecuritypublic class MyConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        String pass1 = new BCryptPasswordEncoder().encode("123");        String pass2 = new BCryptPasswordEncoder().encode("123");        System.out.println("pass1:" + pass1);        System.out.println("pass2:" + pass2);        // super.configure(http);        // 哪些地址需要登录        http.authorizeRequests()            // 所有请求都需要验证            .anyRequest().authenticated()            .and()            // 自定义登录页            .formLogin().loginPage("/login.html")            .loginProcessingUrl("/login").permitAll()            // 登录失败跳转页面            .failureUrl("/login.html?error")            // 登录成功跳转页面            .defaultSuccessUrl("/ok", true).permitAll()            // 配置登录页的表单 name            .passwordParameter("oo")            .usernameParameter("xx")            // 根据不同的异常类型，做不同的处理，跳转不同的页面            .failureHandler(new AuthenticationFailureHandler() {                @Override                public void onAuthenticationFailure(HttpServletRequest request,                                                    HttpServletResponse response,                                                    AuthenticationException e) throws IOException, ServletException {                    e.printStackTrace();                    // 判断异常信息                    request.getRequestDispatcher(request.getRequestURL().toString()).forward(request, response);                    // 记录登录失败的次数，禁止登录                }            })            .and()            .csrf() // 默认所有 post 请求都会拦截            //.disable() // 如果 disable 掉，则不会下发 csrf token            .csrfTokenRepository(new HttpSessionCsrfTokenRepository()) // 下发 csrf token            ;    }    // 基于 session 的登录，本身并发量不是很高，如果并发量高，直接用 JWT 代替，并写 redis 了。    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        // 注释掉后，所有默认配置失效。配置文件中的用户名和密码不生效了        // super.configure(auth);        auth.inMemoryAuthentication()            .withUser("123").password(new BCryptPasswordEncoder().encode("123")).roles("admin")            .and()            .withUser("321").password("321").roles("user")        ;    }    @Bean    PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }    // 如果已经配置 configure(AuthenticationManagerBuilder auth)，这里无效果    @Bean    public UserDetailsService userDetailsService() {        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();        User user = new User("4", new BCryptPasswordEncoder().encode("4"), true, true, true, true, Collections.singletonList(new SimpleGrantedAuthority("4")));        manager.createUser(user);        manager.createUser(User.withUsername("5").password(new BCryptPasswordEncoder().encode("5")).roles("5").build());        return manager;    }}```**User 对象**如果需要增加新字段，自己定义一个新类，继承 User 即可。```java    private String password;    private final String username;    private final Set<GrantedAuthority> authorities;    private final boolean accountNonExpired;    private final boolean accountNonLocked;    private final boolean credentialsNonExpired;    private final boolean enabled;```**Session 中存储的对象**?```javaEnumeration<String> attributeNames = request.getSession().getAttributeNames();//        while (attributeNames.hasMoreElements()) {//            String string = (String) attributeNames.nextElement();//            System.out.println(string);//            System.out.println(request.getSession().getAttribute(string));//            //        }SecurityContext attribute = (SecurityContext)request.getSession().getAttribute("SPRING_SECURITY_CONTEXT");System.out.println(attribute.getAuthentication().getAuthorities());```### 3.3 忽略静态请求```java@Overridepublic void configure(WebSecurity web) throws Exception {    web.ignoring().antMatchers("/img/**","/js/**");    //    super.configure(web);}```### 3.4 自定义登录页面和表单属性见 3.2## 4、OauthOAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。- Spring Social- Spring Session- JWT## 5、CSRF CSRF (Cross Site Request Forgery)攻击，中文名：**跨站请求伪造**。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用 POST 方式提交参数的页面。问题解决：- 全站 hash（可以完全禁止，但是一般都不会这么做），token 存放在页面上，每次请求下发这个 token。没有放在 cookies 中，别的 tab 页面获取不到这个数据，所以安全。cookies 中的数据是有可能共享的。- 全站 post 请求- 敏感操作手机验证码二次验证或者图片验证- 外部链接提示免责信息## 6、OpenID系统的第一部分是身份验证，即如何通过 URI 来认证用户身份。目前的网站都是依靠用户名和密码来登录认证，这就意味着大家在每个网站都需要注册用户名和密码，即便你使用的是同样的密码。如果使用 OpenID ，你的网站地址（URI）就是你的用户名，而你的密码安全的存储在一个 OpenID 服务网站上（你可以自己建立一个 OpenID 服务网站，也可以选择一个可信任的 OpenID 服务网站来完成注册）。## 7、CAS中心认证服务（Central Authentication Service）SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式会话基本概念理解。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式会话" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/"/>
    
  </entry>
  
</feed>
