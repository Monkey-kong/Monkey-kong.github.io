<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-30T05:11:11.393Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>monkey-kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql 调优(十三) Java SPI 机制详解</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_13_JavaSPI%E6%9C%BA%E5%88%B6.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_13_JavaSPI机制.html</id>
    <published>2020-08-29T14:13:12.000Z</published>
    <updated>2020-08-30T05:11:11.393Z</updated>
    
    <content type="html"><![CDATA[<ul><li>case … when + sum + group by 行转列</li><li>case when … 搜索</li><li>if + sum + group by 行转列</li><li>拼接 sql + prepare … from … + execute + deallocate prepare 行转列</li><li>with rollup 汇总行</li><li>union all 汇总行</li><li>group_concat() 分组拼接展示</li><li>union all 列转行</li></ul><a id="more"></a><h2 id="1、什么是-SPI？"><a href="#1、什么是-SPI？" class="headerlink" title="1、什么是 SPI？"></a>1、什么是 SPI？</h2><p>SPI 全称为 (<strong>Service Provider Interface</strong>) ，是 JDK 内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql 和 postgresql 都有不同的实现提供给用户，而 Java 的 SPI 机制可以为某个接口寻找服务实现。</p><p><img src="../../images/mysql/13/spi.jpg" alt=""></p><p>  如上图所示，接口对应的抽象SPI接口；实现方实现SPI接口；调用方依赖SPI接口。</p><p>SPI 接口的定义在调用方，在概念上更依赖调用方；组织上位于调用方所在的包中，<strong>实现位于独立的包中</strong>。</p><p>当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 <strong>META-INF/services/</strong> 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个 jar 包（一般都是以 jar 包做依赖）的 META-INF/services/ 中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK 中查找服务实现的工具类是：<strong>java.util.ServiceLoader</strong>。</p><h2 id="2、SPI-的用途"><a href="#2、SPI-的用途" class="headerlink" title="2、SPI 的用途"></a>2、SPI 的用途</h2><p>数据库 DriverManager、Spring、ConfigurableBeanFactory 等都用到了 SPI 机制，这里以数据库DriverManager 为例，看一下其实现的内幕。</p><p>DriverManager 是 jdbc 里管理和注册不同数据库 driver 的工具类。针对一个数据库，可能会存在着不同的数据库驱动实现。我们在使用特定的驱动实现时，不希望修改现有的代码，而希望通过一个简单的配置就可以达到效果。 在使用 mysql 驱动的时候，会有一个疑问，DriverManager 是怎么获得某确定驱动类的？我们在运用 Class.forName(“com.mysql.jdbc.Driver”) 加载 mysql 驱动后，就会执行其中的静态代码把 driver 注册到 DriverManager 中，以便后续的使用。</p><h3 id="JDBC-使用-SPI-实现细节"><a href="#JDBC-使用-SPI-实现细节" class="headerlink" title="JDBC 使用 SPI 实现细节"></a>JDBC 使用 SPI 实现细节</h3><p>DriverManager.getConnection 获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/test?"</span> +</div><div class="line">  <span class="string">"useSSL=false&amp;serverTimezone=Hongkong&amp;allowPublicKeyRetrieval=true"</span>, <span class="string">"root"</span>, <span class="string">"Pass9876"</span>);</div><div class="line"></div><div class="line">ensureDriversInitialized();</div></pre></td></tr></table></figure><p>调用 ServiceLoader 的 hasNext 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If the driver is packaged as a Service Provider, load it.</span></div><div class="line"><span class="comment">// Get all the drivers through the classloader</span></div><div class="line"><span class="comment">// exposed as a java.sql.Driver.class service.</span></div><div class="line"><span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></div><div class="line"></div><div class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</div><div class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</div><div class="line"></div><div class="line">        <span class="comment">/* Load these drivers, so that they can be instantiated.</span></div><div class="line"><span class="comment">                     * It may be the case that the driver class may not be there</span></div><div class="line"><span class="comment">                     * i.e. there may be a packaged driver with the service class</span></div><div class="line"><span class="comment">                     * as implementation of java.sql.Driver but the actual class</span></div><div class="line"><span class="comment">                     * may be missing. In that case a java.util.ServiceConfigurationError</span></div><div class="line"><span class="comment">                     * will be thrown at runtime by the VM trying to locate</span></div><div class="line"><span class="comment">                     * and load the service.</span></div><div class="line"><span class="comment">                     *</span></div><div class="line"><span class="comment">                     * Adding a try catch block to catch those runtime errors</span></div><div class="line"><span class="comment">                     * if driver not available in classpath but it's</span></div><div class="line"><span class="comment">                     * packaged as service and that service is there in classpath.</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (driversIterator.hasNext()) &#123;</div><div class="line">                driversIterator.next();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// Do nothing</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>最终调用的是 LazyClassPathLookupIterator 的 hasNextService 方法中的 nextProviderClass 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Loads and returns the next provider class.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Class&lt;?&gt; nextProviderClass() &#123;</div><div class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// static final String PREFIX = "META-INF/services/";</span></div><div class="line">            String fullName = PREFIX + service.getName();</div><div class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</div><div class="line">                configs = ClassLoader.getSystemResources(fullName);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loader == ClassLoaders.platformClassLoader()) &#123;</div><div class="line">                <span class="comment">// The platform classloader doesn't have a class path,</span></div><div class="line">                <span class="comment">// but the boot loader might.</span></div><div class="line">                <span class="keyword">if</span> (BootLoader.hasClassPath()) &#123;</div><div class="line">                    configs = BootLoader.findResources(fullName);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    configs = Collections.emptyEnumeration();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                configs = loader.getResources(fullName);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</div><div class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// META-INF/services/ 下的配置文件</span></div><div class="line">        pending = parse(configs.nextElement());</div><div class="line">    &#125;</div><div class="line">    String cn = pending.next();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 加载配置类</span></div><div class="line">        <span class="keyword">return</span> Class.forName(cn, <span class="keyword">false</span>, loader);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</div><div class="line">        fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Class.forName 加载 Driver 实现类，会执行静态块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        DriverManager.registerDriver(<span class="keyword">new</span> Driver());</div><div class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DriverManager.registerDriver，把 Driver 实现放入 registeredDrivers 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></div><div class="line"><span class="function"><span class="params">                                  DriverAction da)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Register the driver if it has not already been added to our list */</span></div><div class="line">    <span class="keyword">if</span> (driver != <span class="keyword">null</span>) &#123;</div><div class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    println(<span class="string">"registerDriver: "</span> + driver);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>回到 DriverManager.getConnection 方法，循环 registeredDrivers，取出 Driver 进行 connect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123;</div><div class="line">    <span class="comment">// If the caller does not have permission to load the driver then</span></div><div class="line">    <span class="comment">// skip it.</span></div><div class="line">    <span class="keyword">if</span> (isDriverAllowed(aDriver.driver, callerCL)) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</div><div class="line">            Connection con = aDriver.driver.connect(url, info);</div><div class="line">            <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Success!</span></div><div class="line">                println(<span class="string">"getConnection returning "</span> + aDriver.driver.getClass().getName());</div><div class="line">                <span class="keyword">return</span> (con);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</div><div class="line">            <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</div><div class="line">                reason = ex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SPI-demo"><a href="#SPI-demo" class="headerlink" title="SPI demo"></a>SPI demo</h3><p>创建接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShout</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">IShout</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"miao miao"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">IShout</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"wang wang"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 resource 目录下新建 META-INF/services 目录，然后创建配置文件 unit13_jdbc.spi.IShout，文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unit13_jdbc.spi.Dog</div><div class="line">unit13_jdbc.spi.Cat</div></pre></td></tr></table></figure><p>验证是否生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPIMain</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</div><div class="line">        Iterator&lt;IShout&gt; iterator = shouts.iterator();</div><div class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">            IShout s = iterator.next();</div><div class="line">            s.shout();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 控制台输出</span></div><div class="line">wang wang</div><div class="line">miao miao</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;case … when + sum + group by 行转列&lt;/li&gt;
&lt;li&gt;case when … 搜索&lt;/li&gt;
&lt;li&gt;if + sum + group by 行转列&lt;/li&gt;
&lt;li&gt;拼接 sql + prepare … from … + execute + deallocate prepare 行转列&lt;/li&gt;
&lt;li&gt;with rollup 汇总行&lt;/li&gt;
&lt;li&gt;union all 汇总行&lt;/li&gt;
&lt;li&gt;group_concat() 分组拼接展示&lt;/li&gt;
&lt;li&gt;union all 列转行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十二) 经典笔试题</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_12_%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_12_经典笔试题.html</id>
    <published>2020-08-29T14:13:12.000Z</published>
    <updated>2020-08-29T14:19:00.512Z</updated>
    
    <content type="html"><![CDATA[<ul><li>case … when + sum + group by 行转列</li><li>case when … 搜索</li><li>if + sum + group by 行转列</li><li>拼接 sql + prepare … from … + execute + deallocate prepare 行转列</li><li>with rollup 汇总行</li><li>union all 汇总行</li><li>group_concat() 分组拼接展示</li><li>union all 列转行</li></ul><a id="more"></a><h2 id="1、第一题"><a href="#1、第一题" class="headerlink" title="1、第一题"></a>1、第一题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 数据准备</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</div><div class="line">   <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</div><div class="line">   <span class="keyword">type</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'1-姓名 2-性别 3-年龄'</span>, </div><div class="line">   t_id <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'userId'</span>,</div><div class="line">   <span class="keyword">value</span> <span class="built_in">varchar</span>(<span class="number">50</span>)</div><div class="line">);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'张三'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">200</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">'男'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">300</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="string">'50'</span>);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">101</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">'刘二'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">201</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">'男'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">301</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="string">'30'</span>);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">102</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">'刘三'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">202</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'女'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">302</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'10'</span>);</div><div class="line"></div><div class="line">+<span class="comment">-----+------+------+--------+</span></div><div class="line">| id  | type | t_id | value  |</div><div class="line">+<span class="comment">-----+------+------+--------+</span></div><div class="line">| 100 |    1 |    1 | 张三   |</div><div class="line">| 101 |    1 |    2 | 刘二   |</div><div class="line">| 102 |    1 |    3 | 刘三   |</div><div class="line">| 200 |    2 |    1 | 男     |</div><div class="line">| 201 |    2 |    2 | 男     |</div><div class="line">| 202 |    2 |    3 | 女     |</div><div class="line">| 300 |    3 |    1 | 50     |</div><div class="line">| 301 |    3 |    2 | 30     |</div><div class="line">| 302 |    3 |    3 | 10     |</div><div class="line">+<span class="comment">-----+------+------+--------+</span></div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>50</td></tr><tr><td>刘二</td><td>男</td><td>30</td></tr><tr><td>刘三</td><td>女</td><td>10</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">case</span> s.type <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> s.value <span class="keyword">end</span>) <span class="string">'姓名'</span>,</div><div class="line">  <span class="keyword">max</span>(<span class="keyword">case</span> s.type <span class="keyword">when</span> <span class="number">2</span> <span class="keyword">then</span> s.value <span class="keyword">end</span>) <span class="string">'性别'</span>,</div><div class="line">  <span class="keyword">max</span>(<span class="keyword">case</span> s.type <span class="keyword">when</span> <span class="number">3</span> <span class="keyword">then</span> s.value <span class="keyword">end</span>) <span class="string">'年龄'</span></div><div class="line"><span class="keyword">from</span> student s</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.t_id</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="2、第二题"><a href="#2、第二题" class="headerlink" title="2、第二题"></a>2、第二题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp(rq <span class="built_in">varchar</span>(<span class="number">20</span>),shengfu <span class="built_in">varchar</span>(<span class="number">20</span>));</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'胜'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'胜'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'负'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'负'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-10'</span>,<span class="string">'胜'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-10'</span>,<span class="string">'负'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-10'</span>,<span class="string">'负'</span>);</div></pre></td></tr></table></figure><p>如果要生成下列结果, 该如何写 sql 语句?</p><table><thead><tr><th>日期</th><th>胜场数</th><th>负场数</th></tr></thead><tbody><tr><td>2005-05-09</td><td>2</td><td>2</td></tr><tr><td>2005-05-10</td><td>1</td><td>2</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> rq <span class="string">'日期'</span>, </div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> shengfu <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'胜场数'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> shengfu <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) <span class="string">'负场数'</span> </div><div class="line">  <span class="keyword">FROM</span> tmp</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> rq</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="3、第三题"><a href="#3、第三题" class="headerlink" title="3、第三题"></a>3、第三题</h2><h3 id="1、case-列-when-列值-then"><a href="#1、case-列-when-列值-then" class="headerlink" title="1、case 列 when 列值 then"></a>1、case 列 when 列值 then</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_score</div><div class="line">(</div><div class="line">  <span class="keyword">name</span>    <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</div><div class="line">  subject <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</div><div class="line">  score   <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>)</div><div class="line">);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="string">'语文'</span>, <span class="number">78.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="string">'数学'</span>, <span class="number">88.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="string">'英语'</span>, <span class="number">98.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'李四'</span>, <span class="string">'语文'</span>, <span class="number">89.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'李四'</span>, <span class="string">'数学'</span>, <span class="number">76.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'李四'</span>, <span class="string">'英语'</span>, <span class="number">90.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'王五'</span>, <span class="string">'语文'</span>, <span class="number">99.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'王五'</span>, <span class="string">'数学'</span>, <span class="number">66.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'王五'</span>, <span class="string">'英语'</span>, <span class="number">91.0</span>);</div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>王五</td><td>99</td><td>66</td><td>91</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="string">'姓名'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'英语'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'英语'</span></div><div class="line"><span class="keyword">from</span> student_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></div><div class="line">;</div></pre></td></tr></table></figure><h3 id="2、case-when-表达式-then"><a href="#2、case-when-表达式-then" class="headerlink" title="2、case when 表达式 then"></a>2、case when 表达式 then</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_score_result(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),yuwen <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>) ,shuxue <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>),yingyu <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>));</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student_score_result`</span>(<span class="string">`name`</span>, <span class="string">`yuwen`</span>, <span class="string">`shuxue`</span>, <span class="string">`yingyu`</span>) <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="number">78.0</span>, <span class="number">88.0</span>, <span class="number">98.0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student_score_result`</span>(<span class="string">`name`</span>, <span class="string">`yuwen`</span>, <span class="string">`shuxue`</span>, <span class="string">`yingyu`</span>) <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="number">89.0</span>, <span class="number">76.0</span>, <span class="number">90.0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student_score_result`</span>(<span class="string">`name`</span>, <span class="string">`yuwen`</span>, <span class="string">`shuxue`</span>, <span class="string">`yingyu`</span>) <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="number">99.0</span>, <span class="number">66.0</span>, <span class="number">91.0</span>);</div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>及格</td><td>优秀</td><td>不及格</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="string">'姓名'</span>, </div><div class="line">  <span class="keyword">case</span> <span class="keyword">when</span> yuwen &gt;= <span class="number">80</span> <span class="keyword">then</span> <span class="string">'优秀'</span> <span class="keyword">when</span> yuwen &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span> <span class="keyword">else</span> <span class="string">'不及格'</span> <span class="keyword">end</span> <span class="string">'语文'</span>, </div><div class="line">  <span class="keyword">case</span> <span class="keyword">when</span> shuxue &gt;= <span class="number">80</span> <span class="keyword">then</span> <span class="string">'优秀'</span> <span class="keyword">when</span> shuxue &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span> <span class="keyword">else</span> <span class="string">'不及格'</span> <span class="keyword">end</span> <span class="string">'数学'</span>, </div><div class="line">  <span class="keyword">case</span> <span class="keyword">when</span> yingyu &gt;= <span class="number">80</span> <span class="keyword">then</span> <span class="string">'优秀'</span> <span class="keyword">when</span> yingyu &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span> <span class="keyword">else</span> <span class="string">'不及格'</span> <span class="keyword">end</span> <span class="string">'英语'</span></div><div class="line"><span class="keyword">from</span> student_score_result</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="4、第四题"><a href="#4、第四题" class="headerlink" title="4、第四题"></a>4、第四题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> yj01(</div><div class="line">       <span class="keyword">month</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</div><div class="line">       deptno <span class="built_in">varchar</span>(<span class="number">10</span>),</div><div class="line">       yj <span class="built_in">decimal</span>(<span class="number">10</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'一月份'</span>,<span class="string">'01'</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'二月份'</span>,<span class="string">'02'</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'二月份'</span>,<span class="string">'03'</span>,<span class="number">5</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'三月份'</span>,<span class="string">'02'</span>,<span class="number">8</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'三月份'</span>,<span class="string">'04'</span>,<span class="number">9</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'三月份'</span>,<span class="string">'03'</span>,<span class="number">8</span>);</div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>部门</th><th>一月</th><th>二月</th><th>三月</th></tr></thead><tbody><tr><td>01</td><td>10</td><td></td><td></td></tr><tr><td>02</td><td></td><td>10</td><td>8</td></tr><tr><td>03</td><td></td><td>5</td><td>8</td></tr><tr><td>04</td><td></td><td></td><td>9</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> deptno <span class="string">'部门'</span>, </div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">'一月份'</span> <span class="keyword">then</span> yj <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'一月'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">'二月份'</span> <span class="keyword">then</span> yj <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'二月'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">'三月份'</span> <span class="keyword">then</span> yj <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'三月'</span></div><div class="line"><span class="keyword">from</span> yj01</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="5、第五题"><a href="#5、第五题" class="headerlink" title="5、第五题"></a>5、第五题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> tb_score;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_score(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</div><div class="line">    userid <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</div><div class="line">    subject <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">COMMENT</span> <span class="string">'科目'</span>,</div><div class="line">    score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'成绩'</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="string">'语文'</span>,<span class="number">90</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="string">'数学'</span>,<span class="number">92</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="string">'英语'</span>,<span class="number">80</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="string">'语文'</span>,<span class="number">88</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="string">'数学'</span>,<span class="number">90</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="string">'英语'</span>,<span class="number">75.5</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'语文'</span>,<span class="number">70</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'数学'</span>,<span class="number">85</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'英语'</span>,<span class="number">90</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'政治'</span>,<span class="number">82</span>);</div><div class="line"></div><div class="line">+<span class="comment">----+--------+---------+-------+</span></div><div class="line">| id | userid | subject | score |</div><div class="line">+<span class="comment">----+--------+---------+-------+</span></div><div class="line">|  1 | 001    | 语文    |    90 |</div><div class="line">|  2 | 001    | 数学    |    92 |</div><div class="line">|  3 | 001    | 英语    |    80 |</div><div class="line">|  4 | 002    | 语文    |    88 |</div><div class="line">|  5 | 002    | 数学    |    90 |</div><div class="line">|  6 | 002    | 英语    |  75.5 |</div><div class="line">|  7 | 003    | 语文    |    70 |</div><div class="line">|  8 | 003    | 数学    |    85 |</div><div class="line">|  9 | 003    | 英语    |    90 |</div><div class="line">| 10 | 003    | 政治    |    82 |</div><div class="line">+<span class="comment">----+--------+---------+-------+</span></div><div class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</div></pre></td></tr></table></figure><h3 id="1、-case…when…-then-group-by-sum-行转列"><a href="#1、-case…when…-then-group-by-sum-行转列" class="headerlink" title="1、 case…when….then + group by + sum 行转列"></a>1、 <strong>case…when….then + group by + sum 行转列</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> userid, </div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'英语'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'政治'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'政治'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="2、-IF-group-by-sum-行转列："><a href="#2、-IF-group-by-sum-行转列：" class="headerlink" title="2、 IF() + group by + sum 行转列："></a>2、 <strong>IF() + group by + sum 行转列：</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> userid,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="3、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行"><a href="#3、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行" class="headerlink" title="3、 SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行"></a>3、 SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行</h3><p>with ROLLUP 用法</p><h3 id="4、-SUM-IF-生成列-UNION-生成汇总行"><a href="#4、-SUM-IF-生成列-UNION-生成汇总行" class="headerlink" title="4、 SUM(IF()) 生成列 + UNION 生成汇总行"></a>4、 SUM(IF()) 生成列 + UNION 生成汇总行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> userid,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span>,</div><div class="line"><span class="keyword">sum</span>(score) <span class="string">'总分'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line"><span class="keyword">union</span></div><div class="line"><span class="keyword">select</span> <span class="string">'Total'</span>,<span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span>,</div><div class="line">  <span class="keyword">sum</span>(score)</div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="5、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行"><a href="#5、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行" class="headerlink" title="5、 SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行"></a>5、 <strong>SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">IFNULL</span>(userid,<span class="string">'Total'</span>) userid,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span>,</div><div class="line"><span class="keyword">sum</span>(score) <span class="string">'总分'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line"><span class="keyword">with</span> <span class="keyword">rollup</span></div><div class="line">;</div></pre></td></tr></table></figure><h3 id="6、-动态，适用于列不确定情况"><a href="#6、-动态，适用于列不确定情况" class="headerlink" title="6、 动态，适用于列不确定情况"></a>6、 动态，适用于列不确定情况</h3><p>思路就是拼接 sql 语句然后用 <strong>PREPARE name from sqlStr、EXECUTE name 、DEALLOCATE PREPARE name </strong> 预处理、执行、回收资源。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> @EE=<span class="string">''</span>;</div><div class="line"><span class="keyword">select</span> @EE :=<span class="keyword">CONCAT</span>(@EE,<span class="string">'sum(if(subject= \''</span>,subject,<span class="string">'\',score,0)) as '</span>,subject, <span class="string">','</span>) <span class="keyword">AS</span> aa <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> subject <span class="keyword">FROM</span> tb_score) A ;</div><div class="line"><span class="comment">-- select @EE;</span></div><div class="line"></div><div class="line"><span class="keyword">SET</span> @QQ = <span class="keyword">CONCAT</span>(<span class="string">'select ifnull(userid,\'TOTAL\')as userid,'</span>,@EE,<span class="string">' sum(score) as TOTAL from tb_score group by userid WITH ROLLUP'</span>);</div><div class="line"><span class="comment">-- SELECT @QQ;</span></div><div class="line"></div><div class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> @QQ;</div><div class="line"><span class="keyword">EXECUTE</span> stmt;</div><div class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> stmt;</div></pre></td></tr></table></figure><h3 id="7、-合并字段显示：利用group-concat"><a href="#7、-合并字段显示：利用group-concat" class="headerlink" title="7、 合并字段显示：利用group_concat()"></a>7、 <strong>合并字段显示：利用group_concat()</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> userid,<span class="keyword">GROUP_CONCAT</span>(<span class="string">`subject`</span>,<span class="string">":"</span>,score)<span class="keyword">AS</span> 成绩 </div><div class="line"><span class="keyword">FROM</span> tb_score</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userid</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="8、列转行"><a href="#8、列转行" class="headerlink" title="8、列转行"></a>8、列转行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_score1(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</div><div class="line">    userid <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</div><div class="line">    cn_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'语文成绩'</span>,</div><div class="line">    math_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'数学成绩'</span>,</div><div class="line">    en_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'英语成绩'</span>,</div><div class="line">    po_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'政治成绩'</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score1(userid,cn_score,math_score,en_score,po_score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="number">90</span>,<span class="number">92</span>,<span class="number">80</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score1(userid,cn_score,math_score,en_score,po_score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="number">88</span>,<span class="number">90</span>,<span class="number">75.5</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score1(userid,cn_score,math_score,en_score,po_score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="number">70</span>,<span class="number">85</span>,<span class="number">90</span>,<span class="number">82</span>);</div><div class="line"></div><div class="line">+<span class="comment">----+--------+----------+------------+----------+----------+</span></div><div class="line">| id | userid | cn_score | math_score | en_score | po_score |</div><div class="line">+<span class="comment">----+--------+----------+------------+----------+----------+</span></div><div class="line">|  1 | 001    |       90 |         92 |       80 |        0 |</div><div class="line">|  2 | 002    |       88 |         90 |     75.5 |        0 |</div><div class="line">|  3 | 003    |       70 |         85 |       90 |       82 |</div><div class="line">+<span class="comment">----+--------+----------+------------+----------+----------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><p> 本质是将userid的每个科目分数分散成一条记录显示出来 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 把每一列查询出来拼起来</span></div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'语文'</span> <span class="keyword">AS</span> course,cn_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">union</span> all </div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'数学'</span> <span class="keyword">AS</span> course,math_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">union</span> all </div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'英语'</span> <span class="keyword">AS</span> course,en_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">union</span> all </div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'政治'</span> <span class="keyword">AS</span> course,po_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">order</span> <span class="keyword">by</span> userid </div><div class="line">;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;case … when + sum + group by 行转列&lt;/li&gt;
&lt;li&gt;case when … 搜索&lt;/li&gt;
&lt;li&gt;if + sum + group by 行转列&lt;/li&gt;
&lt;li&gt;拼接 sql + prepare … from … + execute + deallocate prepare 行转列&lt;/li&gt;
&lt;li&gt;with rollup 汇总行&lt;/li&gt;
&lt;li&gt;union all 汇总行&lt;/li&gt;
&lt;li&gt;group_concat() 分组拼接展示&lt;/li&gt;
&lt;li&gt;union all 列转行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十一) 读写分离</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_11_%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_11_读写分离.html</id>
    <published>2020-08-29T14:13:12.000Z</published>
    <updated>2020-08-29T09:16:10.498Z</updated>
    
    <content type="html"><![CDATA[<ul><li>读写分离的概念和优点</li><li>mysql-proxy 实现读写分离</li><li>amoeba 实现读写分离</li></ul><a id="more"></a><h2 id="1、读写分离介绍"><a href="#1、读写分离介绍" class="headerlink" title="1、读写分离介绍"></a>1、读写分离介绍</h2><p>MySQL 读写分离基本原理是让 master 数据库处理写操作，slave 数据库处理读操作。master 将写操作的变更同步到各个 slave 节点。</p><p>读写分离如何提高性能？</p><p>1、物理服务器增加，机器处理能力提升，拿硬件换性能</p><p>2、主从只负责各自的读和写，极大程度缓解 X 锁和 S 锁的争用</p><p>3、slave 可以配置 MyISAM 存储引擎，提升查询性能以及节约系统开销</p><p>4、master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步的</p><p>5、slave 可以单独设置一些参数来提升其读的性能</p><p>6、增加冗余，提高可用性？</p><h2 id="2、读写分离之-mysql-proxy"><a href="#2、读写分离之-mysql-proxy" class="headerlink" title="2、读写分离之 mysql-proxy"></a>2、读写分离之 mysql-proxy</h2><h3 id="1、硬件配置"><a href="#1、硬件配置" class="headerlink" title="1、硬件配置"></a>1、硬件配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proxy  192.168.238.66</div><div class="line">master 192.168.238.68</div><div class="line">slave  192.168.238.70</div></pre></td></tr></table></figure><h3 id="2、master、slave-配置主从复制"><a href="#2、master、slave-配置主从复制" class="headerlink" title="2、master、slave 配置主从复制"></a>2、master、slave 配置主从复制</h3><p>略过</p><h3 id="3、进行-proxy-的相关配置"><a href="#3、进行-proxy-的相关配置" class="headerlink" title="3、进行 proxy 的相关配置"></a>3、进行 proxy 的相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">1、下载mysql-proxy</span></div><div class="line">https://downloads.mysql.com/archives/proxy/#downloads</div><div class="line"><span class="meta">#</span><span class="bash">2、上传软件到proxy的机器</span></div><div class="line">cd /opt</div><div class="line">直接通过xftp进行上传</div><div class="line"><span class="meta">#</span><span class="bash">3、解压安装包</span></div><div class="line">tar -zxvf mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit.tar.gz</div><div class="line"><span class="meta">#</span><span class="bash">4、创建链接</span></div><div class="line">ln -s mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit mysql-proxy</div><div class="line"><span class="meta">#</span><span class="bash">5、进入mysql-proxy的目录</span></div><div class="line">cd mysql-proxy</div><div class="line"><span class="meta">#</span><span class="bash">6、创建目录</span></div><div class="line">mkdir conf</div><div class="line">mkdir logs</div><div class="line"><span class="meta">#</span><span class="bash">7、添加环境变量</span></div><div class="line"><span class="meta">#</span><span class="bash">打开/etc/profile文件</span></div><div class="line">vi /etc/profile</div><div class="line"><span class="meta">#</span><span class="bash">在文件的最后面添加一下命令</span></div><div class="line">export PATH=$PATH:/opt/mysql-proxy/bin</div><div class="line"><span class="meta">#</span><span class="bash">8、执行命令让环境变量生效</span></div><div class="line">source /etc/profile</div><div class="line"><span class="meta">#</span><span class="bash">9、进入conf目录，创建文件并添加一下内容</span></div><div class="line">vi mysql-proxy.conf</div><div class="line">添加内容</div><div class="line">[mysql-proxy]</div><div class="line">user=root</div><div class="line">proxy-address=192.168.238.66:4040</div><div class="line">proxy-backend-addresses=192.168.238.68:3306</div><div class="line">proxy-read-only-backend-addresses=192.168.238.70:3306</div><div class="line">proxy-lua-script=/opt/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua</div><div class="line">log-file=/opt/mysql-proxy/logs/mysql-proxy.log</div><div class="line">log-level=debug</div><div class="line">daemon=true</div><div class="line"><span class="meta">#</span><span class="bash">10、开启mysql-proxy</span></div><div class="line">mysql-proxy --defaults-file=/root/mysql-proxy/conf/mysql-proxy.conf</div><div class="line"><span class="meta">#</span><span class="bash">11、查看是否安装成功，打开日志文件</span></div><div class="line">cd /opt/mysql-proxy/logs</div><div class="line">tail -100 mysql-proxy.log</div><div class="line"><span class="meta">#</span><span class="bash">内容如下：表示安装成功</span></div><div class="line">2020-08-29 16:00:34: (critical) plugin proxy 0.8.5 started</div><div class="line">2020-08-29 16:00:34: (debug) max open file-descriptors = 1024</div><div class="line">2020-08-29 16:00:34: (message) proxy listening on port 192.168.238.66:4040</div><div class="line">2020-08-29 16:00:34: (message) added read/write backend: 192.168.238.68:3306</div><div class="line">2020-08-29 16:00:34: (message) added read-only backend: 192.168.238.70:3306</div><div class="line">2020-08-29 16:00:34: (debug) now running as user: root (0/0)</div></pre></td></tr></table></figure><h3 id="4、进行连接"><a href="#4、进行连接" class="headerlink" title="4、进行连接"></a>4、进行连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -ppass9876 -h192.168.238.66 -P 4040</div></pre></td></tr></table></figure><h2 id="3、读写分离之-Amoeba"><a href="#3、读写分离之-Amoeba" class="headerlink" title="3、读写分离之 Amoeba"></a>3、读写分离之 Amoeba</h2><h3 id="1、什么是-Amoeba？"><a href="#1、什么是-Amoeba？" class="headerlink" title="1、什么是 Amoeba？"></a>1、什么是 Amoeba？</h3><p>​        Amoeba(变形虫)项目，专注 分布式数据库 proxy 开发。座落于 Client、DB Server(s) 之间。对客户端透明。具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的 query 到目标数据库、可并发请求多台数据库合并结果。</p><p>主要解决：</p><ul><li><p>降低数据切分带来的复杂多数据库结构</p></li><li><p>提供切分规则并降低数据切分规则给应用带来的影响</p></li><li><p>降低 db 与客户端的连接数</p></li><li><p>读写分离</p></li></ul><h3 id="2、为什么要用-Amoeba"><a href="#2、为什么要用-Amoeba" class="headerlink" title="2、为什么要用 Amoeba"></a>2、为什么要用 Amoeba</h3><p>目前要实现 mysql 的主从读写分离，主要有以下几种方案：</p><p>1、 通过程序实现，网上很多现成的代码，比较复杂，如果添加从服务器要更改多台服务器的代码。</p><p>2、通过 mysql-proxy 来实现，由于 mysql-proxy 的主从读写分离是通过 lua 脚本来实现，目前 lua 的脚本的开发跟不上节奏，而写没有完美的现成的脚本，因此导致用于生产环境的话风险比较大，据网上很多人说mysql-proxy 的性能不高。</p><p>3、自己开发接口实现，这种方案门槛高，开发成本高，不是一般的小公司能承担得起。</p><p>4、 利用阿里巴巴的开源项目 Amoeba 来实现，具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的query到目标数据库，并且安装配置非常简单。</p><h3 id="3、安装-Amoeba"><a href="#3、安装-Amoeba" class="headerlink" title="3、安装 Amoeba"></a>3、安装 Amoeba</h3><p>1、安装 jdk</p><p>2、下载 amoeba：<a href="https://sourceforge.net/projects/amoeba/" target="_blank" rel="external">https://sourceforge.net/projects/amoeba/</a> 直接解压即可</p><p>3、修改配置</p><p><strong>dbServers.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">factoryConfig</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.mysql.net.MysqlServerConnectionFactory"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionManager"</span>&gt;</span>$&#123;defaultManager&#125;<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sendBufferSize"</span>&gt;</span>64<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"receiveBufferSize"</span>&gt;</span>128<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- mysql port --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span>&gt;</span>3306<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- mysql schema --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schema"</span>&gt;</span>copy_test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- mysql user --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>pass9876<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">factoryConfig</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dbServer</span> <span class="attr">name</span>=<span class="string">"writedb"</span>  <span class="attr">parent</span>=<span class="string">"abstractServer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">factoryConfig</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- mysql ip --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ipAddress"</span>&gt;</span>192.168.238.68<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">factoryConfig</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dbServer</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dbServer</span> <span class="attr">name</span>=<span class="string">"slave"</span>  <span class="attr">parent</span>=<span class="string">"abstractServer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">factoryConfig</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- mysql ip --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ipAddress"</span>&gt;</span>192.168.238.70<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">factoryConfig</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dbServer</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dbServer</span> <span class="attr">name</span>=<span class="string">"myslave"</span> <span class="attr">virtual</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">poolConfig</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.server.MultipleServerPool"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Load balancing strategy: 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loadbalance"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- Separated by commas,such as: server1,server2,server1 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolNames"</span>&gt;</span>slave<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">poolConfig</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dbServer</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>amoeba.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>pass9876<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">queryRouter</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.mysql.parser.MysqlQueryRouter"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ruleLoader"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.route.TableRuleFileLoader"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ruleFile"</span>&gt;</span>$&#123;amoeba.home&#125;/conf/rule.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"functionFile"</span>&gt;</span>$&#123;amoeba.home&#125;/conf/ruleFunctionMap.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlFunctionFile"</span>&gt;</span>$&#123;amoeba.home&#125;/conf/functionMap.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LRUMapSize"</span>&gt;</span>1500<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultPool"</span>&gt;</span>writedb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"writePool"</span>&gt;</span>writedb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readPool"</span>&gt;</span>myslave<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"needParse"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">queryRouter</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="4、测试-Amoeba"><a href="#4、测试-Amoeba" class="headerlink" title="4、测试 Amoeba"></a>4、测试 Amoeba</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 启动 Amoeba 服务</span></div><div class="line">/opt/amoeba-mysql-3.0.5-RC/bin/launcher</div><div class="line"></div><div class="line"><span class="comment">--在安装amoeba的服务器上登录mysql</span></div><div class="line">mysql -h192.168.238.66 -uroot -ppass9876 -P8066</div><div class="line"><span class="comment">--分别在master、slave、amoeba上登录mysql</span></div><div class="line"><span class="keyword">use</span> msb</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</div><div class="line"><span class="comment">--在amoeba上插入数据</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</div><div class="line"><span class="comment">--在master和slave上分别查看表中的数据</span></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</div><div class="line"><span class="comment">--将master上的mysql服务停止，继续插入数据会发现插入不成功，但是能够查询</span></div><div class="line"><span class="comment">--将master上的msyql服务开启，停止slave上的mysql，发现插入成功，但是不能够查询</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;读写分离的概念和优点&lt;/li&gt;
&lt;li&gt;mysql-proxy 实现读写分离&lt;/li&gt;
&lt;li&gt;amoeba 实现读写分离&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十)</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_10_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_10_主从复制.html</id>
    <published>2020-08-29T14:13:12.000Z</published>
    <updated>2020-08-29T07:33:39.775Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主从复制用途</li><li>主从复制原理</li><li>主从复制延时分析和 MTS</li><li>主从复制安装</li></ul><a id="more"></a><h2 id="1-为什么需要主从复制"><a href="#1-为什么需要主从复制" class="headerlink" title="1. 为什么需要主从复制"></a>1. 为什么需要主从复制</h2><p>1、表锁导致其他事务无法读。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、结构的扩展。业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘 I/O 访问的频率，提高单个机器的 I/O 性能。</p><h2 id="2-什么是-MySQL-主从复制"><a href="#2-什么是-MySQL-主从复制" class="headerlink" title="2. 什么是 MySQL 主从复制"></a>2. 什么是 MySQL 主从复制</h2><p>MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用<strong>异步复制</strong>方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h2 id="3-主从复制的原理"><a href="#3-主从复制的原理" class="headerlink" title="3. 主从复制的原理"></a>3. 主从复制的原理</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>1、master 开启 binlog 日志</p><p>2、slave 在一定时间间隔内对 master binlog 日志进行探测，看是否有改变。如果有改变，则开始一个 <strong>I/O Thread</strong> 用于请求 master 二进制事件。</p><p>3、master 为每个 slave I/O Thread启动一个 dump 线程，用于向 slave I/O Thread 发送二进制事件</p><p>4、slave 接收到二进制事件后，将数据保存在 slave 本地的<strong>中继日志</strong>中</p><p>5、slave 启动 <strong>SQL Thread</strong> 从中继日志读取二进制日志，在本地重放，使得数据和 master 保持一致</p><p>6、最后 I/O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒</p><h3 id="3-2-原理解析"><a href="#3-2-原理解析" class="headerlink" title="3.2 原理解析"></a>3.2 原理解析</h3><p>1、slave 会生成两个线程，I/O Thread、SQL Thread</p><p>2、master 会生成一个 log dump 线程，用来给 slave I/O Thread 传 binlog</p><p>3、I/O Thread 请求 master 的 binlog，写入本地的 relay-log</p><p>4、SQL Thread 读取 relay-log，并解析成 sql 语句逐一执行</p><h3 id="3-3-具体步骤"><a href="#3-3-具体步骤" class="headerlink" title="3.3 具体步骤"></a>3.3 具体步骤</h3><p>1、 slave 执行 change master to 语句连接主库，提供连接的用户一切条件（user、password、port、ip），并且让从库知道，二进制日志的起点位置（file、position）；然后 start slave</p><p>2、slave I/O Thread 和 master dump Thread 建立连接</p><p>3、slave T/O Thread 向 slave 发起 binlog 请求</p><p>4、master 将本地 binlog 以 events 的方式发送给 slave 的 I/O Thread</p><p>5、slave I/O Thread 接收 binlog events，并存放到本地 relay-log 中，传送过来的信息会记录到 master.info 中</p><p>6、slave SQL Thread 读取 relay-log，并把读取过的记录存放到 relay-log.info 中。默认情况下，已经应用过的 relay 会自动被清理（purge）。</p><h2 id="4-主从形式"><a href="#4-主从形式" class="headerlink" title="4. 主从形式"></a>4. 主从形式</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><h3 id="多主一丛"><a href="#多主一丛" class="headerlink" title="多主一丛"></a>多主一丛</h3><h3 id="联级复制"><a href="#联级复制" class="headerlink" title="联级复制"></a>联级复制</h3><h2 id="5-主从同步延时分析"><a href="#5-主从同步延时分析" class="headerlink" title="5. 主从同步延时分析"></a>5. 主从同步延时分析</h2><p>MySQL 主从复制都是单线程操作，master 对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写的，所以效率很高，slave 的 SQL Thread 线程将 master 的  DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 I/O 操作是随机的，不是顺序的，所以成本要高很多，另一方面，由于 SQL Thread 也是单线程的，当 master 的并发较高时，产生的 DML 数量超过 slave 的 SQL Thread 所能处理的速度，或者当 slave 中有大型的 query 语句产生了锁等待，那么延时就产生了。</p><p>解决方案：</p><p>1、业务的持久化层的实现采用分库结构，MySQL 服务可平行扩展，分散压力</p><p>2、单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库</p><p>3、服务的基础架构在业务和 MySQL 之间加入 memcache 或者 redis 的 cache 层，降低 MySQL 的读压力。</p><p>4、不同业务的 MySQL 物理上放在不同的及其上，分散压力</p><p>5、使用比主库更好的硬件设备作为 slave，MySQL 压力小，延迟自然会变小</p><p>6、使用更加强劲的硬件设备</p><h2 id="6-MTS-并行复制技术"><a href="#6-MTS-并行复制技术" class="headerlink" title="6. MTS 并行复制技术"></a>6. MTS 并行复制技术</h2><p>支持事务级别的 sql 进行并发回放, 默认是 database 级别(也就是只能并发 database)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 组提交</div><div class="line">## 哪些需要组提交</div><div class="line">1. transaction <span class="keyword">prepare</span></div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span></div><div class="line">## MySQL <span class="number">5.1</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write  # fsync</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>  # fsync</div><div class="line">总结：每个事务都需要三次fsync</div><div class="line">## MySQL <span class="number">5.5</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write         # <span class="keyword">group</span> fsync</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>   # fsync</div><div class="line">总结：<span class="keyword">binlog</span> 可以组提交了</div><div class="line">## MySQL <span class="number">5.6</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write         # <span class="keyword">group</span> fsync</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>   # 不需要fsync了，因为<span class="number">1</span>，<span class="number">2</span>都fsync，就能保证整个事务提交</div><div class="line">总结：少了最后一步的fsync，性能提升很多</div><div class="line">## MySQL <span class="number">5.7</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # 不fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write         # 在写入<span class="keyword">binlog</span>之前，去<span class="keyword">group</span> fsync <span class="keyword">prepare</span> <span class="keyword">log</span>。 然后再<span class="keyword">group</span> fsync <span class="keyword">binlog</span></div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>   # 不需要fsync了，因为<span class="number">1</span>，<span class="number">2</span>都fsync，就能保证整个事务提交</div><div class="line">总结：相当于<span class="number">1</span>，<span class="number">2</span> 合在一起组提交，性能提升更多</div></pre></td></tr></table></figure><h3 id="6-1-为什么要用-MTS"><a href="#6-1-为什么要用-MTS" class="headerlink" title="6.1 为什么要用 MTS"></a>6.1 为什么要用 MTS</h3><p> 解决单线程复制的延迟问题 </p><blockquote><p> note1：当master有多个线程在写数据，那么MTS效果会非常好<br>note2：如果master对大表进行DDL，这样的延迟是没办法避免 的</p></blockquote><h3 id="6-2-开启MTS的重要参数"><a href="#6-2-开启MTS的重要参数" class="headerlink" title="6.2 开启MTS的重要参数"></a>6.2 开启MTS的重要参数</h3><table><thead><tr><th>参数</th><th>comment</th><th>默认配置</th><th>推荐配置</th></tr></thead><tbody><tr><td>slave_parallel_workers</td><td>applier threads 数量</td><td>0</td><td>16</td></tr><tr><td>slave_parallel_type</td><td>并行方式</td><td>DATABASE</td><td>LOGICAL_CLOCK</td></tr><tr><td>slave_preserve_commit_order</td><td>并行排序提交</td><td>0</td><td>1</td></tr><tr><td>master_info_repository</td><td>master_info 持久化方式</td><td>FILE</td><td>DATABASE</td></tr><tr><td>relay_log_info_repository</td><td>relay_info持久化方式</td><td>FILE</td><td>DATABASE</td></tr><tr><td>relay_log_recovery</td><td>重新获取 relay log</td><td>0</td><td>1</td></tr></tbody></table><h3 id="6-3-重要组件"><a href="#6-3-重要组件" class="headerlink" title="6.3 重要组件"></a>6.3 重要组件</h3><blockquote><ol><li>IO thread并没有改变</li><li>SQL thread 会变成 Coordinator线程</li><li>会新增很多 work 线程来受 Coordinator调度</li></ol></blockquote><h3 id="6-4-Binlog-和-MTS"><a href="#6-4-Binlog-和-MTS" class="headerlink" title="6.4 Binlog 和 MTS"></a>6.4 Binlog 和 MTS</h3><blockquote><p> 同一个 last_committed 可以并行执行<br>同一个 last_committed 中的 sequence_number 默认是无序的 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#160628 16:29:10 server id 12616406  end_log_pos 259 CRC32 0x9565260a GTIDlast_committed=0sequence_number=1</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 427 CRC32 0xaa1d4add GTIDlast_committed=0sequence_number=2</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 682 CRC32 0x0715f36a GTIDlast_committed=0sequence_number=3</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 937 CRC32 0x2998c5ed GTIDlast_committed=0sequence_number=4</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1192 CRC32 0xd58951f3 GTIDlast_committed=4sequence_number=5</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1447 CRC32 0xbf77ba5f GTIDlast_committed=4sequence_number=6</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1702 CRC32 0x3e74905f GTIDlast_committed=4sequence_number=7</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1957 CRC32 0xc31cbd6d GTIDlast_committed=4sequence_number=8</div></pre></td></tr></table></figure><h3 id="6-5-顺序"><a href="#6-5-顺序" class="headerlink" title="6.5 顺序"></a>6.5 顺序</h3><ul><li><p><strong>当 slave_preserve_commit_order=0时</strong> </p><blockquote><p> 没有办法保证顺序，在恢复的过程中会有问题,到时候你怎么start slave 呢？<br>start slave until SQL_AFTER_MTS_GAPS ; reset slave </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Master执行顺序: last_committed=0,sequence_number=1,2,3,4  </div><div class="line">slave执行顺序： 有可能就是 last_committed=0,sequence_number=1,4,3,2</div></pre></td></tr></table></figure></li><li><p><strong>当slave_preserve_commit_order=1时</strong> </p><blockquote><p> 后一个sequence_number提交的时候，会等待前一个sequence_number完成。<br>Waiting for preceding transaction to commit </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Master执行顺序: last_committed=0,sequence_number=1,2,3,4  </div><div class="line">slave执行顺序： 有可能就是 last_committed=0,sequence_number=1,2,3,4</div></pre></td></tr></table></figure></li></ul><h2 id="7-主从复制安装配置"><a href="#7-主从复制安装配置" class="headerlink" title="7. 主从复制安装配置"></a>7. 主从复制安装配置</h2><h3 id="1、基础设置准备"><a href="#1、基础设置准备" class="headerlink" title="1、基础设置准备"></a>1、基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">操作系统：</span></div><div class="line">centos6.5</div><div class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></div><div class="line">5.7</div><div class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></div><div class="line">node2:192.168.238.68（主）</div><div class="line">node3:192.168.238.70（从）</div></pre></td></tr></table></figure><h3 id="2、安装-MySQL-数据库"><a href="#2、安装-MySQL-数据库" class="headerlink" title="2、安装 MySQL 数据库"></a>2、安装 MySQL 数据库</h3><p>略过</p><h3 id="3、在-node2、node3-分别创建数据库"><a href="#3、在-node2、node3-分别创建数据库" class="headerlink" title="3、在 node2、node3 分别创建数据库"></a>3、在 node2、node3 分别创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--注意两台必须全部执行</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">database</span> copy_test;</div></pre></td></tr></table></figure><h3 id="4、主服务器（node2）配置"><a href="#4、主服务器（node2）配置" class="headerlink" title="4、主服务器（node2）配置"></a>4、主服务器（node2）配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 指定 binlog 路径和名称</div><div class="line">log-bin=/usr/local/mysql/logs/log_bin.log</div><div class="line"># 二进制日志格式，有row、statement、mixed三种格式</div><div class="line"># row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍</div><div class="line"># statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。</div><div class="line"># MySQL默认采用基于语句的复制，效率比较高。</div><div class="line"># mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</div><div class="line">binlog-format=ROW</div><div class="line"># 指定log-bin参数后，无需指定log_bin，log-bin相当于一个快速设置方式。log_bin表示是否启动bin log</div><div class="line"># 注意开启 logbin 后必须指定 server_id，必须要 server_id</div><div class="line">server_id=1</div><div class="line"># 指定哪些数据库需要将更新记录到二进制日志中。</div><div class="line"># 其他所有没有显示指定的数据库将忽略，不记录日志</div><div class="line"># SHOW MASTER STATUS 可以查看binlog源的状态信息</div><div class="line">binlog_do_db=copy_test</div></pre></td></tr></table></figure><h3 id="5、从服务器（node3）配置"><a href="#5、从服务器（node3）配置" class="headerlink" title="5、从服务器（node3）配置"></a>5、从服务器（node3）配置</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--授权操作</span></div><div class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</div><div class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</div><div class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'pass9876'</span>;</div><div class="line"><span class="comment">--刷新权限</span></div><div class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</div><div class="line"></div><div class="line">log-bin=/usr/local/mysql/logs/log_bin.log</div><div class="line">binlog-format=ROW</div><div class="line">server_id=2</div></pre></td></tr></table></figure><h3 id="6、重启主服务器-MySQL-服务"><a href="#6、重启主服务器-MySQL-服务" class="headerlink" title="6、重启主服务器 MySQL 服务"></a>6、重启主服务器 MySQL 服务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service mysql.server restart</div><div class="line">mysql -r root -p</div><div class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</div></pre></td></tr></table></figure><h3 id="7、重启从服务器并进行相关配置"><a href="#7、重启从服务器并进行相关配置" class="headerlink" title="7、重启从服务器并进行相关配置"></a>7、重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></div><div class="line">service mysqld restart</div><div class="line"><span class="meta">#</span><span class="bash">登录mysql</span></div><div class="line">mysql -uroot -p</div><div class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></div><div class="line">change master to master_host='192.168.238.68',master_user='root',master_password='pass9876',master_port=3306,master_log_file='log_bin.000018',master_log_pos=154;</div><div class="line"><span class="meta">#</span><span class="bash">启动slave</span></div><div class="line">start slave</div><div class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></div><div class="line">show slave status\G</div></pre></td></tr></table></figure><h3 id="8、验证"><a href="#8、验证" class="headerlink" title="8、验证"></a>8、验证</h3><p>node2 上操作，查看数据是否同步到 node3</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;主从复制用途&lt;/li&gt;
&lt;li&gt;主从复制原理&lt;/li&gt;
&lt;li&gt;主从复制延时分析和 MTS&lt;/li&gt;
&lt;li&gt;主从复制安装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(九)</title>
    <link href="http://yoursite.com/2020-08-27-mysql/mysql_9_%E4%BA%8B%E5%8A%A1.html"/>
    <id>http://yoursite.com/2020-08-27-mysql/mysql_9_事务.html</id>
    <published>2020-08-27T14:13:12.000Z</published>
    <updated>2020-08-29T06:51:42.983Z</updated>
    
    <content type="html"><![CDATA[<ul><li>理解事务的 4 种隔离级别</li><li>各个隔离级别可能出现的问题</li><li>演示脏读、不可重复读、幻读</li><li>RR 级别如何解决幻读问题？</li></ul><a id="more"></a><h2 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1. 准备数据"></a>1. 准备数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--查看是否是自动提交 1表示开启，0表示关闭</span></div><div class="line"><span class="keyword">select</span> @@autocommit;</div><div class="line"><span class="comment">--设置关闭</span></div><div class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">--准备数据</span></div><div class="line"> <span class="keyword">create</span> <span class="keyword">table</span> psn(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</div><div class="line"><span class="comment">--插入数据</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'lisi'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'wangwu'</span>);</div><div class="line"><span class="keyword">commit</span>;</div></pre></td></tr></table></figure><h2 id="2-隔离级别和异常情况"><a href="#2-隔离级别和异常情况" class="headerlink" title="2. 隔离级别和异常情况"></a>2. 隔离级别和异常情况</h2><table><thead><tr><th>隔离级别</th><th>异常情况</th><th>异常情况</th><th>异常情况</th></tr></thead><tbody><tr><td>读未提交/read uncommited</td><td>脏读</td><td>不可重复读</td><td>幻读</td></tr><tr><td>读已提交/read commited</td><td></td><td>不可重复读</td><td>幻读</td></tr><tr><td>可重复读/repeatable read</td><td></td><td></td><td>幻读</td></tr><tr><td>序列化/serializable</td><td></td><td></td></tr></tbody></table><p>RR 是通过 MMVC 机制实现的。</p><p>Serializable：通过加 X 锁实现。</p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>查看全局隔离级别和当前事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> @@global.tx_isolation, @@tx_isolation;</div><div class="line"></div><div class="line"># 设定全局的隔离级别 设定会话 global 替换为 session 即可 把set语法温习一下</div><div class="line"># SET [GLOABL] config_name = 'foobar';</div><div class="line"># SET @@[session.|global.]config_name = 'foobar';</div><div class="line"># SELECT @@[global.]config_name;</div><div class="line"></div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="number">0</span>;</div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="string">'READ-UNCOMMITTED'</span>;</div><div class="line"></div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="number">1</span>;</div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="string">'READ-COMMITTED'</span>;</div><div class="line"></div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="number">2</span>;</div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="string">'REPEATABLE-READ'</span>;</div><div class="line"></div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="number">3</span>;</div><div class="line"><span class="keyword">SET</span> @@gloabl.tx_isolation = <span class="string">'SERIALIZABLE'</span>;</div></pre></td></tr></table></figure><h3 id="测试脏读-read-uncommited"><a href="#测试脏读-read-uncommited" class="headerlink" title="测试脏读 read uncommited"></a>测试脏读 read uncommited</h3><p>就是可以读取别的事务<strong>没有提交</strong>的数据。产生脏读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">A:<span class="keyword">update</span> psn <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'msb'</span>;</div><div class="line">A:selecet * from psn</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;  <span class="comment">--读取的结果msb。产生脏读，因为A事务并没有commit，读取到了不存在的数据</span></div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn; <span class="comment">--读取的数据是msb,因为A事务已经commit，数据永久的被修改</span></div></pre></td></tr></table></figure><h3 id="测试不可重复读-read-commited"><a href="#测试不可重复读-read-commited" class="headerlink" title="测试不可重复读 read commited"></a>测试不可重复读 read commited</h3><p>就是设置隔离级别只有提交了才能读取得到。在一个事务中，别的事务可能修改数据，所以别的事务提交前提交后本事务中读取到的数据是不一样的，叫做不可重复读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line"><span class="comment">--执行到此处的时候发现，两个窗口读取的数据是一致的</span></div><div class="line">A:<span class="keyword">update</span> psn <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'zhangsan'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn; <span class="comment">-- 数据没变，说明没有脏读问题</span></div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--读取到更新的数据</span></div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--也读取到更新的数据</span></div><div class="line"><span class="comment">--发现同一个事务中多次读取数据出现不一致的情况即不可重复读</span></div></pre></td></tr></table></figure><h3 id="测试幻读-repeatable-read"><a href="#测试幻读-repeatable-read" class="headerlink" title="测试幻读 repeatable read"></a>测试幻读 repeatable read</h3><p>幻读还是每太理解。是没有读取到数据，但是却又不能操作？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line"><span class="comment">--此时两个窗口读取的数据是一致的</span></div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'sisi'</span>);</div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--读取到添加的数据</span></div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--读取不到添加的数据，说明没有不可重复读的问题了</span></div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'sisi'</span>);<span class="comment">--报错，无法插入数据</span></div><div class="line"><span class="comment">--此时发现读取不到数据，但是在插入的时候不允许插入，出现了幻读，设置更高级别的隔离级别即可解决</span></div></pre></td></tr></table></figure><p>B 发现我查询 id 为 4 的记录明明没有呀，为啥不让我插入，这就是幻读。</p><p> 其实 RR 也是可以避免幻读的，通过对 select 操作手动加 行X锁（SELECT … FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id = 1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。 </p><p> 不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。 </p><h3 id="测试-RR-级别防止幻读"><a href="#测试-RR-级别防止幻读" class="headerlink" title="测试 RR 级别防止幻读"></a>测试 RR 级别防止幻读</h3><p>A：读取 id 为 5 的数据，不存在则插入。</p><p>B：干扰事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>; // 无数据，说明应该可以插入才对</div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'sisi'</span>); </div><div class="line">B:<span class="keyword">commit</span>;</div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'sisi'</span>); // 发现报错了，提示主键冲突</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>; // 再查一遍，还是没有，见鬼了？这就是幻读</div><div class="line"></div><div class="line">在 RR 级别要解决幻读问题，在第三行加上 X 锁即可（for <span class="keyword">update</span>），这样第<span class="number">5</span>行B是插入不进来的。</div></pre></td></tr></table></figure><h3 id="测试-serializable"><a href="#测试-serializable" class="headerlink" title="测试 serializable"></a>测试 serializable</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn; // 加锁了</div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line"><span class="comment">--此时两个窗口读取的数据是一致的</span></div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'sisi'</span>); // 阻塞</div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'sisi'</span>); // 成功</div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line">B:报错，主键重复</div></pre></td></tr></table></figure><p>总结：</p><p>​    现在学习的是数据库级别的事务，需要掌握的就是事务的隔离级别和产生的数据不一致的情况</p><p>后续会学习声明式事务及事务的传播特性以及分布式事务</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;理解事务的 4 种隔离级别&lt;/li&gt;
&lt;li&gt;各个隔离级别可能出现的问题&lt;/li&gt;
&lt;li&gt;演示脏读、不可重复读、幻读&lt;/li&gt;
&lt;li&gt;RR 级别如何解决幻读问题？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(八)</title>
    <link href="http://yoursite.com/2020-08-26-mysql/mysql_8_%E9%94%81%E6%9C%BA%E5%88%B6.html"/>
    <id>http://yoursite.com/2020-08-26-mysql/mysql_8_锁机制.html</id>
    <published>2020-08-26T14:13:12.000Z</published>
    <updated>2020-08-29T03:49:47.974Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 锁机制。</p><a id="more"></a><h2 id="1-MySQL-锁的基本介绍"><a href="#1-MySQL-锁的基本介绍" class="headerlink" title="1. MySQL 锁的基本介绍"></a>1. MySQL 锁的基本介绍</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>​        相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的<strong>存储引擎</strong>支持不同的锁机制。比如，MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）；InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 </p><ul><li>表级锁：开销小，加锁块，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发度低</li><li>行级锁：开销大，加锁慢；会出现死锁；锁粒度小，发生锁冲突的概率小，并发度高</li></ul><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量<strong>按索引条件并发更新少量不同数据</strong>，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h2 id="2-MyISAM-表锁"><a href="#2-MyISAM-表锁" class="headerlink" title="2. MyISAM 表锁"></a>2. MyISAM 表锁</h2><p>MySQL的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。  </p><p>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！ </p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`NAME`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'a'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'b'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'c'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'d'</span>);</div></pre></td></tr></table></figure><h3 id="MyISAM写锁阻塞读的案例："><a href="#MyISAM写锁阻塞读的案例：" class="headerlink" title="MyISAM写锁阻塞读的案例："></a><strong>MyISAM写锁阻塞读的案例：</strong></h3><p>当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">获取表的write锁定<br>lock table mylock write;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">当前session对表的查询，插入，更新操作都可以执行<br>select * from mylock;<br>insert into mylock values(5,’e’);</td><td style="text-align:center">当前session对表的查询会被阻塞<br>select * from mylock；</td></tr><tr><td style="text-align:center">释放锁：<br>unlock tables；</td><td style="text-align:center">当前session能够立刻执行，并返回对应结果</td></tr></tbody></table><p>当前 session：锁定表可读可写；非锁定表不可读不可写</p><p>其他 session：锁定表不可读不可写；非锁定表可读可写</p><h3 id="MyISAM读阻塞写的案例："><a href="#MyISAM读阻塞写的案例：" class="headerlink" title="MyISAM读阻塞写的案例："></a><strong>MyISAM读阻塞写的案例：</strong></h3><p>一个 session 使用 lock table 给表加读锁，这个 session 可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个 session 可以查询表中的记录，但更新就会出现锁等待。</p><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">获得表的read锁定<br>lock table mylock read;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">当前session可以查询该表记录：<br>select * from mylock;</td><td style="text-align:center">当前session可以查询该表记录：<br>select * from mylock;</td></tr><tr><td style="text-align:center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td style="text-align:center">当前session可以查询或者更新未锁定的表<br>select * from mylock<br>insert into person values(1,’zhangsan’);</td></tr><tr><td style="text-align:center">当前session插入或者更新表会提示错误<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td style="text-align:center">当前session插入数据会等待获得锁<br>insert into mylock values(6,’f’);</td></tr><tr><td style="text-align:center">释放锁<br>unlock tables;</td><td style="text-align:center">获得锁，更新成功</td></tr></tbody></table><p>当前 session：锁定表可读不可写；非锁定表不可读不可写</p><p>其他 session：锁定表可读不可写（写需等待锁）；非锁定表可读可写</p><h3 id="加锁时机"><a href="#加锁时机" class="headerlink" title="加锁时机"></a>加锁时机</h3><ul><li>读锁：MyISAM 在执行查询前，涉及的所有表加读锁</li><li>写锁：MyISAM 在执行更新操作前，涉及的所有表加写锁</li></ul><h3 id="MyISAM的并发插入问题"><a href="#MyISAM的并发插入问题" class="headerlink" title="MyISAM的并发插入问题"></a><strong>MyISAM的并发插入问题</strong></h3><p>MyISAM 表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM 也支持查询和插入操作的并发执行。</p><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">获取表的read local锁定<br>lock table mylock read local</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">当前session不能对表进行更新或者插入操作<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td style="text-align:center">其他session可以查询该表的记录<br>select* from mylock</td></tr><tr><td style="text-align:center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td style="text-align:center">其他session可以进行插入操作，但是更新会阻塞<br>update mylock set name = ‘aa’ where id = 1;</td></tr><tr><td style="text-align:center">当前session不能访问其他session插入的记录；</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">释放锁资源：unlock tables</td><td style="text-align:center">当前session获取锁，更新操作完成</td></tr><tr><td style="text-align:center">当前session可以查看其他session插入的记录</td></tr></tbody></table><p>当前 session：锁定表可读不可写；非锁定表不可读不可写</p><p>其他 session：锁定表可读可插入，不可更新不可删除；非锁定表可读可写</p><p> 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_%'</span>;</div><div class="line">+<span class="comment">----------------------------+-------+</span></div><div class="line">| Variable_name              | Value |</div><div class="line">+<span class="comment">----------------------------+-------+</span></div><div class="line">| Table_locks_immediate      | 136   |</div><div class="line">| Table_locks_waited         | 5     |</div></pre></td></tr></table></figure><h2 id="3-InnoDB-锁"><a href="#3-InnoDB-锁" class="headerlink" title="3. InnoDB 锁"></a>3. InnoDB 锁</h2><h3 id="3-1-事务及其-ACID-属性"><a href="#3-1-事务及其-ACID-属性" class="headerlink" title="3.1 事务及其 ACID 属性"></a>3.1 事务及其 ACID 属性</h3><ul><li>Actomicity</li><li>Consistent</li><li>Isolation</li><li>Durable</li></ul><h3 id="3-2-并发事务带来的问题"><a href="#3-2-并发事务带来的问题" class="headerlink" title="3.2 并发事务带来的问题"></a>3.2 并发事务带来的问题</h3><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来一下问题：</p><ul><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><p>上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。</p><p>数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，需要根据具体的业务需求来决定使用哪种隔离级别。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">read uncommitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">read committed</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">repeatable read</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p> 可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%innodb_row_lock%'</span>;</div><div class="line">+<span class="comment">-------------------------------+-------+</span></div><div class="line">| Variable_name                 | Value |</div><div class="line">+<span class="comment">-------------------------------+-------+</span></div><div class="line">| Innodb_row_lock_current_waits | 0     |</div><div class="line">| Innodb_row_lock_time          | 0     |</div><div class="line">| Innodb_row_lock_time_avg      | 0     |</div><div class="line">| Innodb_row_lock_time_max      | 0     |</div><div class="line">| Innodb_row_lock_waits         | 0     |</div><div class="line">+<span class="comment">-------------------------------+-------+</span></div><div class="line"><span class="comment">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span></div></pre></td></tr></table></figure><h3 id="3-3-InnoDB-的行锁模式及加锁方法"><a href="#3-3-InnoDB-的行锁模式及加锁方法" class="headerlink" title="3.3 InnoDB 的行锁模式及加锁方法"></a>3.3 InnoDB 的行锁模式及加锁方法</h3><p><strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p><strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。</p><p><strong>加共享锁时机</strong>：select 不会加任何锁。可以 select … lock in share mode</p><p><strong>加排他锁时机</strong>：update、delete、insert 给涉及到的数据加排他锁；select … for update；</p><p>所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过 for update 和 lock in share mode 锁的方式查询数据，但可以直接通过 select …from… 查询数据，因为<strong>普通查询没有任何锁机制</strong>。（这个隔离级别有关，serializable 还是会加锁的）</p><h3 id="3-4-InnoDB-行锁实现方式"><a href="#3-4-InnoDB-行锁实现方式" class="headerlink" title="3.4 InnoDB 行锁实现方式"></a>3.4 InnoDB 行锁实现方式</h3><p>InnoDB 行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p><p>1、在不通过索引条件查询的时候，InnoDB 使用的是表锁而不是行锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_no_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_no_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</div></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">set autocommit=0<br>select * from tab_no_index where id = 1;</td><td style="text-align:center">set autocommit=0<br>select * from tab_no_index where id =2</td></tr><tr><td style="text-align:center">select * from tab_no_index where id = 1 for update</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select * from tab_no_index where id = 2 for update;</td></tr></tbody></table><p>session1 只给一行加了排他锁，但是 session2 在请求其他行的排他锁的时候，会出现锁等待。原因是<strong>在没有索引的情况下，innodb 只能使用表锁。</strong></p><p>当前 session：锁定表可读可写；其他表可读可写</p><p>其他 session：锁定表不可读不可写（select … 除外）；其他表可读可写</p><p>2、创建带索引的表进行条件查询，InnoDB 使用的是行锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_with_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">id</span>(<span class="keyword">id</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</div></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">set autocommit=0<br>select * from tab_with_indexwhere id = 1;</td><td style="text-align:center">set autocommit=0<br>select * from tab_with_indexwhere id =2</td></tr><tr><td style="text-align:center">select * from tab_with_indexwhere id = 1 for update</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select * from tab_with_indexwhere id = 2 for update;</td></tr></tbody></table><p>当前 session：锁定数据可读可写；其他表可读可写</p><p>其他 session：锁定数据不可读不可写（select … 除外）；其他表可读可写</p><p>3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是<strong>如果是使用相同的索引键，是会出现冲突的。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">id</span>;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'4'</span>);</div></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">set autocommit=0</td><td style="text-align:center">set autocommit=0</td></tr><tr><td style="text-align:center">select * from tab_with_index where id = 1 and name=’1’ for update</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select * from tab_with_index where id = 1 and name=’4’ for update<br>虽然session2访问的是和session1不同的记录，但是因为使用了相同的索引，所以需要等待锁</td></tr></tbody></table><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong><br>（1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。<br>（2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。<br>（3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。<br>（4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p><p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong><br>（1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。<br>（2）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p><p>在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p><ul><li>尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小；</li><li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 锁机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 安装</title>
    <link href="http://yoursite.com/2020-08-18-mysql/mysql_0_%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD.html"/>
    <id>http://yoursite.com/2020-08-18-mysql/mysql_0_安装与卸载.html</id>
    <published>2020-08-18T14:13:12.000Z</published>
    <updated>2020-08-29T14:20:31.077Z</updated>
    
    <content type="html"><![CDATA[<p>服务器参数设置。</p><p>MySQL 安装与卸载。</p><a id="more"></a><h2 id="1-安装-MySQL"><a href="#1-安装-MySQL" class="headerlink" title="1. 安装 MySQL"></a>1. 安装 MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 下载二进制包。选择：Linux - Generic 和 Linux - Generic(glibc x.xx)(x86,64bit)</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 下载地址：https://dev.mysql.com/downloads/mysql/</span></span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></div><div class="line">yum search libaio</div><div class="line">yum install libaio</div><div class="line">yum search libnuma </div><div class="line">yum install numactl </div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 创建 mysql 用户；解压安装包</span></div><div class="line">groupadd mysql</div><div class="line">useradd -r -g mysql -s /bin/false mysql</div><div class="line">cd /usr/local</div><div class="line">tar zxvf /path/to/mysql-VERSION-OS.tar.gz #记得改为自己的安装包</div><div class="line">ln -s full-path-to-mysql-VERSION-OS mysql #记得改为自己的安装包</div><div class="line">cd mysql</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 这个文件夹干啥的？</span></div><div class="line">mkdir mysql-files</div><div class="line">chown mysql:mysql mysql-files</div><div class="line">chmod 750 mysql-files</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 启动服务 kYrgW!ec.47d</span></div><div class="line">bin/mysqld --initialize --user=mysql #记得记住临时密码 n_u=T=eld0i.</div><div class="line">bin/mysql_ssl_rsa_setup</div><div class="line">bin/mysqld_safe --user=mysql &amp;</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 复制工具脚本到 init.d</span></div><div class="line">cp support-files/mysql.server /etc/init.d/mysql.server</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 配置 PATH 环境变量</span></div><div class="line">vim /etc/profile</div><div class="line">  export MYSQL_HOME="/usr/local/mysql"</div><div class="line">  export PATH=$PATH:$MYSQL_HOME/bin</div><div class="line">source /etc/profile</div><div class="line">echo $PATH</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 设置开机自动启动</span></div><div class="line">chkconfig --add mysql.server</div><div class="line">chkconfig --list</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 连接 mysql，重置密码</span></div><div class="line">mysql -uroot -p</div><div class="line">ALTER USER 'root'@'localhost' IDENTIFIED BY 'pass9876';</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 开启远程连接</span></div><div class="line">use mysql</div><div class="line">update user set host = '%' where user = 'root';</div><div class="line">flush privileges;</div><div class="line">vim /etc/sysconfig/iptables</div><div class="line">  -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</div><div class="line">service iptables restart</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 创建新用户</span></div><div class="line">create user client identified by '123456';</div><div class="line">flush privileges;</div><div class="line">show grants for client;</div></pre></td></tr></table></figure><h2 id="2-使用配置文件"><a href="#2-使用配置文件" class="headerlink" title="2. 使用配置文件"></a>2. 使用配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">basedir=/usr/local/mysql</div><div class="line">datadir=/usr/local/mysql/data</div><div class="line">user=mysql</div><div class="line">character-set-server=utf8</div><div class="line"></div><div class="line">[mysqld_safe]</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld.log</span></div><div class="line"><span class="meta">#</span><span class="bash">pid-file=/var/run/mysqld/mysqld.pid</span></div><div class="line"></div><div class="line">[client]</div><div class="line">default-character-set=utf8</div></pre></td></tr></table></figure><h2 id="2-卸载-MySQL"><a href="#2-卸载-MySQL" class="headerlink" title="2. 卸载 MySQL"></a>2. 卸载 MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">service mysql.server stop</div><div class="line"><span class="meta">#</span><span class="bash"> 找到所有文件夹，依次删除</span></div><div class="line">find / -name mysql</div><div class="line">rm -rf /usr/local/mysql</div><div class="line">rm -f /etc/my.cnf</div><div class="line">rm -rf /etc/init.d/mysql.server</div><div class="line">rm -rf /usr/lib64/mysql/</div><div class="line">rm -rf /usr/share/mysql/</div><div class="line">rm -rf mysql-5.7.31-linux-glibc2.12-x86_64</div><div class="line"></div><div class="line">userdel mysql</div><div class="line">groupdel mysql</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器参数设置。&lt;/p&gt;
&lt;p&gt;MySQL 安装与卸载。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(七)</title>
    <link href="http://yoursite.com/2020-08-16-mysql/mysql_7.html"/>
    <id>http://yoursite.com/2020-08-16-mysql/mysql_7.html</id>
    <published>2020-08-16T14:13:12.000Z</published>
    <updated>2020-08-26T15:42:10.180Z</updated>
    
    <content type="html"><![CDATA[<p>服务器参数设置。</p><a id="more"></a><h2 id="1-MySQL-系统参数"><a href="#1-MySQL-系统参数" class="headerlink" title="1. MySQL 系统参数"></a>1. MySQL 系统参数</h2><h3 id="1-1-参数说明"><a href="#1-1-参数说明" class="headerlink" title="1.1 参数说明"></a>1.1 参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">## general 参数</div><div class="line"># mysql 安装目录</div><div class="line">basedir=/usr/local/mysql</div><div class="line"># 数据文件目录</div><div class="line">datadir=/usr/local/mysql/data</div><div class="line"># mysql.socket表示server和client在同一台服务器，并且使用localhost进行连接，就会使用socket进行连接</div><div class="line"># socket=/usr/local/mysql/mysql.sock</div><div class="line"># pid 文件目录</div><div class="line">#pid_file=/usr/local/mysql/mysql.pid</div><div class="line"># 端口</div><div class="line">port=3306</div><div class="line"># 默认存储引擎</div><div class="line">default_storage_engine=InnoDB</div><div class="line"># 跳过密码登录</div><div class="line">#skip-grant-tables=ON</div><div class="line"># 用户?</div><div class="line">user=mysql</div><div class="line"></div><div class="line">## 字符集相关参数</div><div class="line"># server 端字符集</div><div class="line">character_set_server=utf8</div><div class="line"># client 端字符集</div><div class="line"># character_set_client=utf8</div><div class="line"># 数据库默认字符集</div><div class="line"># character_set_database=utf8</div><div class="line"># mysql 发送给客户端的结果集所用的字符集</div><div class="line"># character_set_results=utf8</div><div class="line"># mysql处理客户端发来的信息时，会把这些数据转换成连接的字符集格式</div><div class="line"># character_set_connection=utf8</div><div class="line"># character_set_system=utf8</div><div class="line"></div><div class="line"></div><div class="line">## connection 相关参数</div><div class="line"># mysql 的最大连接数,如果数据库的并发连接请求比较大,应该调高该值</div><div class="line">max_connections=200</div><div class="line"># 限制每个用户的连接个数</div><div class="line">max_user_connections=10</div><div class="line"># mysql 能够暂存的连接数,当mysql的线程在一个很短时间内得到非常多的连接请求时就会起作用</div><div class="line"># 如果mysql的连接数量达到max_connections时,新的请求会放入一个堆栈中,以等待某一个连接的释放</div><div class="line"># 如果等待连接的数量超过back_log,则不再接收连接资源</div><div class="line">back_log=50</div><div class="line"># mysql在关闭一个非交互的连接之前需要等待的时长。短连接。比如jdbc</div><div class="line">wait_timeout=43200</div><div class="line"># mysql在关闭一个交互连接之前需要等待的时长。长连接。比如连接池、命令行。</div><div class="line"># 但是连接池中的连接有时长限制，连接池会定时关闭长期没用到的连接。</div><div class="line"># 所以这个定时关闭连接的间隔最好小于 wait_timeout</div><div class="line">interactive_timeout=43200</div><div class="line"></div><div class="line"></div><div class="line">## log相关参数</div><div class="line"># 指定错误日志文件名称，用于记录当mysqld启动和停止时</div><div class="line"># 以及服务器在运行中发生任何严重错误的相关信息</div><div class="line">log_error=/usr/local/mysql/logs/log_error.log</div><div class="line"></div><div class="line">### binlog 设置</div><div class="line"># 指定 binlog 路径和名称</div><div class="line">log-bin=/usr/local/mysql/logs/log_bin.log</div><div class="line"># 指定log-bin参数后，无需指定log_bin，log-bin相当于一个快速设置方式。log_bin表示是否启动bin log</div><div class="line"># 神坑，必须要 server_id</div><div class="line"># If you specify the --log-bin option without also specifying the server_id system variable, the server</div><div class="line"># is not allowed to start. (Bug #11763963, Bug #56739) </div><div class="line">server_id=1</div><div class="line"># 指定哪些数据库需要将更新记录到二进制日志中。</div><div class="line"># 其他所有没有显示指定的数据库将忽略，不记录日志</div><div class="line"># SHOW MASTER STATUS 可以查看binlog源的状态信息</div><div class="line">binlog_do_db=sakila</div><div class="line"># 指定哪些数据库不需要记录日志</div><div class="line"># binlog_ignore_db=</div><div class="line"># binlog 刷盘机制</div><div class="line"># 0-不控制,让OS控制刷盘</div><div class="line"># 1-每次提交事务,刷盘</div><div class="line"># N-指定多少次提交事务后同步磁盘</div><div class="line">sync_binlog=2</div><div class="line"></div><div class="line">### redo log 设置</div><div class="line"># redo log 日志文件大小(64M)</div><div class="line">innodb_log_file_size=67108864</div><div class="line"># redo log 日志个数</div><div class="line">innodb_log_files_in_group=3</div><div class="line"># redo log 日志路径</div><div class="line">innodb_log_group_home_dir=/usr/local/mysql/logs/</div><div class="line"># redo log 刷盘机制,刷盘系统调用:fsync</div><div class="line"># 0-事务提交数据写入InnoDB LogBuffer,然后每秒写入OS cache page并刷盘</div><div class="line"># 1-事务提交立即刷盘</div><div class="line"># 2-事务提交数据写入OS cache page,每秒刷盘</div><div class="line">innodb_flush_log_at_trx_commit=1</div><div class="line"></div><div class="line">### undo log 设置</div><div class="line"># 回滚日志位置一般设置到不同的存储设备</div><div class="line">innodb_undo_directory=/usr/local/mysql/logs/</div><div class="line"># 回滚段的数量</div><div class="line">innodb_rollback_segments=256</div><div class="line"># undo tablespaces 的数量,初始化后不可修改,否则会导致服务无法启动</div><div class="line"># innodb_undo_tablespaces=2</div><div class="line"></div><div class="line">### general log 设置</div><div class="line"># 是否开启查询日志记录</div><div class="line">general_log=ON</div><div class="line">general_log_file=/usr/local/mysql/logs/general_log.log</div><div class="line"></div><div class="line">### slow log 设置</div><div class="line"># 是否开启慢日志</div><div class="line">slow_query_log=ON</div><div class="line">slow_query_log_file=/usr/local/mysql/logs/slow_query_log.log</div><div class="line">long_query_time=2</div><div class="line">log_slow_admin_statements=ON</div><div class="line"></div><div class="line">## 缓存相关参数</div><div class="line"># 索引缓冲区的大小(只对 MyISAM 表起作用),默认(8M=&gt;16M)</div><div class="line">key_buffer_size=16777216</div><div class="line"></div><div class="line">### 查询缓存 5.7.20 被弃用,8 被移除</div><div class="line"># 查询缓存的大小,默认(1M=&gt;4M)</div><div class="line">query_cache_size=4194304</div><div class="line"># 缓存类型</div><div class="line"># 0-禁用</div><div class="line"># 1-缓存所有查询结果,除非显示指定 sql_no_cache</div><div class="line"># 2-只缓存 sql_cache 指定的查询</div><div class="line">query_cache_type=2</div><div class="line"># 缓存块最小大小(默认 4K=&gt;0.25K)</div><div class="line">query_cache_min_res_unit=256</div><div class="line"># 超过此大小的查询不缓存(默认 1M=&gt;2M)</div><div class="line">query_cache_limit=2097152</div><div class="line"></div><div class="line"># 每个需要排序的线程分派缓冲区的大小(默认 256K=&gt;1M)</div><div class="line"># 可根据引擎设置:innodb_sort_buffer_size、myisam_sort_buffer_size</div><div class="line">sort_buffer_size=1048576</div><div class="line"># MySQL server 接收的最大数据包大小(4M=&gt;32M)</div><div class="line">max_allowed_packet=33554432</div><div class="line"># 设置关联缓冲的大小(256K=&gt;2M)</div><div class="line">join_buffer_size=2097152</div><div class="line"># 服务器线程缓存数量，当断开连接时，客户端的线程被放到缓存中以响应下一个客户而不是销毁</div><div class="line"># 如果线程重新被请求，那么请求将从缓存中读取</div><div class="line"># 如果缓存中是空的或者是新的请求，这个线程将被重新请求和创建</div><div class="line"># 如果有很多新的线程，增加这个值即可（10=&gt;5）</div><div class="line">thread_cache_size=5</div><div class="line"></div><div class="line">## InnoDB 相关参数</div><div class="line"># 缓存数据和索引的内存大小，最大可设置物理内存的 80%（128M=&gt;64M）</div><div class="line">innodb_buffer_pool_size=67108864</div><div class="line"># 设置 InnoDB 线程的并发数，0 表示不限制</div><div class="line"># 如果设置一般为服务器的核心数或者核心数的两倍(0=&gt;8)</div><div class="line">innodb_thread_concurrency=8</div><div class="line"># (16M=&gt;64M)</div><div class="line">innodb_log_buffer_size=67108864</div><div class="line"># 读入缓冲区大小(128K=&gt;256K)</div><div class="line"># 对表进行顺序扫描的请求将分配到一个读入缓冲区</div><div class="line">read_buffer_size=262144</div><div class="line"># MySQL 随机读缓冲区大小（256K=&gt;512K）</div><div class="line">read_rnd_buffer_size=524288</div><div class="line"># 是否为每张表分配一个新的文件</div><div class="line">innodb_file_per_table=ON</div><div class="line"></div><div class="line">[mysqld_safe]</div><div class="line">#log_error=/usr/local/mysql/logs/log_error.log</div><div class="line">#pid-file=/var/run/mysqld/mysqld.pid</div><div class="line"></div><div class="line">[client]</div><div class="line">default-character-set=utf8</div><div class="line"># client 端字符集</div><div class="line">#character_set_client=utf8</div></pre></td></tr></table></figure><h3 id="1-2-查看查询缓存状态"><a href="#1-2-查看查询缓存状态" class="headerlink" title="1.2 查看查询缓存状态"></a>1.2 查看查询缓存状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%Qcache%'</span>;</div></pre></td></tr></table></figure><ul><li>Qcache_free_blocks：缓存中相邻内存块的个数，如果值比较大说明查询缓存中碎片比较多</li><li>Qcache_free_memory：查询缓存中剩余的内存大小</li><li>Qcache_hits：表示有多少查询命中缓存</li><li>Qcache_inserts：多少次未命中而插入</li><li>Qcache_lowmem_prunes：多少条查询因为内存不足而被移除 cache</li><li>Qcache_queries_in_cache：当前 cache 中缓存的查询条数</li><li>Qcache_total_blocks：当前 cache 中 block 的数量</li></ul><h3 id="1-3-查看线程缓存状态"><a href="#1-3-查看线程缓存状态" class="headerlink" title="1.3 查看线程缓存状态"></a>1.3 查看线程缓存状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%Threads%'</span>;</div></pre></td></tr></table></figure><ul><li>Threads_cached：当前线程缓存中有多少空闲线程</li><li>Threads_connected：当前已建立连接的数量</li><li>Threads_created：最近一次启动服务，已创建线程的数量</li><li>Threads_running：当前激活的线程数</li></ul><h2 id="2-mysql-日志"><a href="#2-mysql-日志" class="headerlink" title="2. mysql 日志"></a>2. mysql 日志</h2><h3 id="2-1-日志的作用"><a href="#2-1-日志的作用" class="headerlink" title="2.1 日志的作用"></a>2.1 日志的作用</h3><p>保证数据不丢失，主要体现在两个方面</p><ol><li>能够恢复到任何时间点的状态。通过 binlog 实现</li><li>任何时候 MySQL 突然崩溃,重启之后之前已经提交的记录不会丢失。redolog undolog 实现。<ul><li>已提交的数据不会丢失</li><li>未提交完整的数据自动回滚</li></ul></li></ol><h3 id="2-2-WAL-机制"><a href="#2-2-WAL-机制" class="headerlink" title="2.2 WAL 机制"></a>2.2 WAL 机制</h3><p>为什么不直接更改磁盘中的数据，而要在内存中更改，然后还需要写日志，最后再落盘这么复杂？</p><p>主要是性能问题。直接写磁盘是<strong>随机写</strong>，开销很大，没办法满足 MySQL 性能要求。所以设计成先在内存中对数据进行更改，再异步落盘。但是内存总是不可靠，万一断电重启，还没来得及落盘的内存数据就会丢失，所以还需要加上写日志这个步骤。虽然写日志也是写磁盘，但是写日志是<strong>顺序写</strong>。</p><h3 id="2-3-核心日志模块"><a href="#2-3-核心日志模块" class="headerlink" title="2.3 核心日志模块"></a>2.3 核心日志模块</h3><h4 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志 redo log"></a>重做日志 redo log</h4><p>InnoDB 存储引擎产生，记录数据库中每个页的修改，而不是某一行或者某几行修改成怎样，可以用来恢复提交后的物理数据页（所以只能恢复到最后一次提交的位置）。</p><p>redo log 就是 WAL 的典型应用，MySQL 在有事务提交时，只会在内存中修改对应的数据页和记录 redo log 日志，完成后即表示事务提交成功，至于磁盘数据文件的更新则由后台线程异步处理。</p><p>redo log 保证了 MySQL 数据<strong>一致性和持久性</strong>（MySQL 崩溃了，重启后仍然可以通过 redo log 里的记录进行重放，重新刷盘）。</p><p>redo log 大小固定，循环写入，相当于一个环形，所以是顺序写。当 redo log 满了，就需要对旧的记录进行擦除，擦除之前必须确保被擦除的记录在内存中的数据页都已刷到磁盘中了。在 redo log 满了到擦除旧记录之前，是不能再接收新的更新请求的，所以有可能导致 MySQL 卡顿。所以针对并发量大的系统，<strong>适当设置 redo log 的文件大小</strong>非常重要。</p><h4 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志 undo log"></a>回滚日志 undo log</h4><p>主要提供回滚的作用，另外一个作用就是多个行版本控制（MVCC），保证事务的<strong>原子性</strong>。在数据修改的流程中，会记录一条与当前操作相反的逻辑日志到 undo log 中。</p><h4 id="归档日志-binlog"><a href="#归档日志-binlog" class="headerlink" title="归档日志 binlog"></a>归档日志 binlog</h4><p>binlog 在 MySQL 的 server 产生，不属于任何引擎，主要记录用户对数据库操作的 SQL 语句（除了查询语句）。之所以叫做归档日志，因为 binlog 不会像 redo log 一样擦除旧日志，而是追加，操作 <code>max_binlog_size</code>  就新起一个文件。</p><p>日志可能是基于事务来记录的（如 InnoDB），而事务是绝对不可能也不应该跨文件记录的，所以 <code>max_binlog_size</code> 和实际的 binlog 日志大小不一定相等。</p><h4 id="binlog-和-redo-log-的区别"><a href="#binlog-和-redo-log-的区别" class="headerlink" title="binlog 和 redo log 的区别"></a>binlog 和 redo log 的区别</h4><ul><li>redolog 是 innodb 独有的，binlog 是所有 engine 都可以使用的</li><li>redolog 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑。物理日志：记录内存地址上存的啥；逻辑日志：记录 sql 语句。</li><li>redolog 是循环写的，空间会用完（存在内存的缓冲区中，肯定小）；binlog 是可以追加的，不会覆盖之前的日志信息。</li></ul><h3 id="2-4-三个日志都必须开启吗？"><a href="#2-4-三个日志都必须开启吗？" class="headerlink" title="2.4 三个日志都必须开启吗？"></a>2.4 三个日志都必须开启吗？</h3><ul><li>redo log 保证数据的持久性，必不可少。如果没有 MySQL 肯定不能认为修改了内存数据就表示操作成功。</li><li>undo log 保证事务原子性，必不可少。为啥必不可少？如果我知道哪个事务有问题，我把这个事务的 redo log 做一遍相反的操作不也可以实现吗？</li><li>binlog <ul><li>主从模式必不可少，因为从库的数据同步依赖的就是 binlog</li><li>单机模式如果不考虑数据库基于某个时间点还原，那么 binlog 就不是必须的。redo log 就可以保证 crash-safe 了。</li></ul></li></ul><h3 id="2-5-两阶段提交"><a href="#2-5-两阶段提交" class="headerlink" title="2.5 两阶段提交"></a>2.5 两阶段提交</h3><p>问题：为什么 redo log 要分两步写，中间再穿插写 binlog 呢？</p><p>redo log 影响主库数据，binlog 影响从库数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致，这个是需要两阶段提交的前提。</p><p>redo log 和 binlog 其实就是很典型的分布式事务场景，因为两者本身就是两个独立的个体，要想保持一致，就必须使用分布式事务解决方案来处理。而将 redo log 分成两步，其实就是使用了两阶段提交协议（2PC）。</p><p><img src="../../images/mysql/7/两阶段提交.png" alt=""></p><p>所以将 redo log 分成两步写，中间插入 binlog 才能保证 redo log 和 binlog 内容一致，从而保证主从数据一致。</p><h3 id="2-6-组提交"><a href="#2-6-组提交" class="headerlink" title="2.6 组提交"></a>2.6 组提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">T1 (--prepare--binlog---------------------commit)</div><div class="line">T2 (-----prepare-----binlog----commit)</div><div class="line">T3 (--------prepare-------binlog------commit)</div><div class="line"> </div><div class="line">解析：</div><div class="line">    redo log prepare的顺序：T1 --》T2 --》T3</div><div class="line">    binlog的写入顺序：T1 --》 T2 --》T3</div><div class="line">    redo log commit的顺序：T2 --》 T3 --》T1</div><div class="line"> </div><div class="line">结论：由于binlog写入的顺序和redo log提交结束的顺序不一致，导致binlog和redo log所记录的事务提交结束的顺序不一样，最终导致的结果就是主从数据不一致。binlog 记录的是：i=1;i=2;i=3;redo log 记录的是：i=2;i=3;i=1</div></pre></td></tr></table></figure><ul><li>两阶段提交没法保证多个事务的提交顺序，所以还需要再加一个锁来保证提交的原子性，从而保证多事务情况下，两个日志的提交顺序一致。 prepare_commit_mutex 锁保证一个事务获取到锁后才能进入 prepare，一直到 commit 结束才能释放锁。并发量大时，会导致锁争用，性能不好。</li><li>两阶段提交还有一个问题就是每个事务提交都会进行两次 fsync（写磁盘）</li></ul><p>MySQL 5.6 引入了 binlog 组提交，即 BLGC。基本思想是引入队列机制保证 InnoDB commit 顺序 binlog 落盘顺序一致，并将事务分组，组内的 binlog 刷盘动作交给一个事务进行，实现组提交的目的。</p><p>组提交图</p><h4 id="第一阶段（prepare-阶段）"><a href="#第一阶段（prepare-阶段）" class="headerlink" title="第一阶段（prepare 阶段）"></a>第一阶段（prepare 阶段）</h4><p>持有 prepare_commit_mutex，并且 write/fsync redo log 到磁盘，设置为 prepared 状态，完成后就释放 prepare_commit_mutex，binlog 不做任何操作。</p><h4 id="第二阶段（commit-阶段）"><a href="#第二阶段（commit-阶段）" class="headerlink" title="第二阶段（commit 阶段）"></a>第二阶段（commit 阶段）</h4><ol><li>Flush Stage（写入 binlog 缓存）<ul><li>持有 Lock_log mutex（leader 持有，follower 等待）</li><li>获取队列中的一组 binlog（队列中的所有事务）</li><li>写入 binlog 缓存</li></ul></li><li>Sync Stage（将 binlog 落盘）<ul><li>释放 Lock_log mutex，持有 Lock_sync mutex（leader 持有，follower 等待）</li><li>将一组 binlog 落盘（fsync 动作，最耗时，假设 sync_binlog 为 1</li></ul></li><li>Commit Stage（InnoDB commit，清除 undo 信息）<ul><li>释放 Lock_sync mutex，持有 Lock_commit mutex（leader 持有，follower 等待）</li><li>遍历队列中的事务，逐一进行 InnoDB commit</li><li>释放 Lock_commit mutex</li></ul></li></ol><p>每个队列各自有 mutex 保护，同一个组队列之间是顺序的（flush-&gt;sync-&gt;commit）</p><p>组之间队列可以并发执行，即当一组事务在进行 commit 阶段时，其他新事务可以进行 flush 阶段，实现真正意义上的组提交，大幅度降低磁盘的 IOPS 消耗。（没太懂。。。）</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>锁粒度更小，2PC 锁 prepare 到 commit 整个事务流程，组提交拆分为四个小阶段上锁</li><li>组提交是批量刷盘，相比之前的单条记录都要刷盘，能大幅降低磁盘的 IO 消耗</li></ul><h3 id="2-7-数据恢复流程"><a href="#2-7-数据恢复流程" class="headerlink" title="2.7 数据恢复流程"></a>2.7 数据恢复流程</h3><p>MySQL 重启后，提供服务前会先做的事 – 数据恢复流程：</p><p><img src="../../images/mysql/7/Mysql数据恢复流程.png" alt=""></p><h3 id="2-7-两个参数"><a href="#2-7-两个参数" class="headerlink" title="2.7 两个参数"></a>2.7 两个参数</h3><h4 id="sync-binlog，控制-binlog-刷盘，默认1"><a href="#sync-binlog，控制-binlog-刷盘，默认1" class="headerlink" title="sync_binlog，控制 binlog 刷盘，默认1"></a>sync_binlog，控制 binlog 刷盘，默认1</h4><ul><li>0：MySQL 不控制，让操作系统控制。性能最好，但是最可能丢失 binlog</li><li>1：每次事务提交前，刷盘。性能最差，只有 prepared 状态的事务会丢失，这可以借助 undo log 自动回滚，所以不会丢失任何事务</li><li>N：提交 N 次事务组后，刷盘。该值越高，性能越好，风险也越大。</li></ul><h4 id="innodb-flush-log-at-trx-commit，控制-redo-log-刷盘，默认-1"><a href="#innodb-flush-log-at-trx-commit，控制-redo-log-刷盘，默认-1" class="headerlink" title="innodb_flush_log_at_trx_commit，控制 redo log 刷盘，默认 1"></a>innodb_flush_log_at_trx_commit，控制 redo log 刷盘，默认 1</h4><p>ACID 特性和性能之前的一个权衡。</p><ul><li>0：每秒写入 OS cache page，然后刷盘</li><li>1：每次事务提交，日志刷盘</li><li>2：每次事务提交写入 OS cache page，然后每秒刷盘</li></ul><p><img src="../../images/mysql/7/redolog.png" alt=""></p><p>reference： <a href="https://blog.csdn.net/wenyiCodeDog/article/details/106581741" target="_blank" rel="external">https://blog.csdn.net/wenyiCodeDog/article/details/106581741</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器参数设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(五)</title>
    <link href="http://yoursite.com/2020-08-13-mysql/mysql_5.html"/>
    <id>http://yoursite.com/2020-08-13-mysql/mysql_5.html</id>
    <published>2020-08-13T14:13:12.000Z</published>
    <updated>2020-08-16T06:46:50.167Z</updated>
    
    <content type="html"><![CDATA[<p>查询优化</p><a id="more"></a><h2 id="1-查询慢的原因"><a href="#1-查询慢的原因" class="headerlink" title="1. 查询慢的原因"></a>1. 查询慢的原因</h2><ul><li>网络</li><li>CPU</li><li>IO</li><li>上下文切换</li><li>系统调用</li><li>生成统计信息</li><li>锁等待时间</li></ul><h2 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2. 优化数据访问"></a>2. 优化数据访问</h2><p>查询性能低下的原因主要是访问的数据太多，所以应该在达到目的的前提下尽可能检索更少的数据。</p><ul><li>确认应用程序是否在检索大量超过需要的数据<ul><li>不要查询不需要的数据，如果只要指定行数的数据，可以用 limit 优化</li><li>需要哪些字段就查询哪些字段，禁止 <code>select *</code></li><li>如果需要不断的执行相同的查询，并且每次返回的数据完全相同，应该把这部分数据缓存起来。比如配置信息等</li></ul></li><li>确认 mysql 服务器是否在分析大量超过需要的数据行</li></ul><h2 id="3-优化执行过程"><a href="#3-优化执行过程" class="headerlink" title="3. 优化执行过程"></a>3. 优化执行过程</h2><h3 id="3-1-查询缓存"><a href="#3-1-查询缓存" class="headerlink" title="3.1 查询缓存"></a>3.1 查询缓存</h3><p>解析查询语句之前，如果查询缓存是开启的，会优先检查该查询是否命中缓存，如果命中并且用户权限没有问题则会直接返回缓存结果。</p><h3 id="3-2-语法解析器和预处理"><a href="#3-2-语法解析器和预处理" class="headerlink" title="3.2 语法解析器和预处理"></a>3.2 语法解析器和预处理</h3><p>MySQL 语法解析器通过关键字解析 sql 语句，校验 sql 语法是否正确，生成一个语法树。预处理进一步检查语法树是否合法，例如表名和列名是否存在，是否有歧义，用户是否有权限等。</p><h3 id="3-3-查询优化器"><a href="#3-3-查询优化器" class="headerlink" title="3.3 查询优化器"></a>3.3 查询优化器</h3><h4 id="计算查询代价"><a href="#计算查询代价" class="headerlink" title="计算查询代价"></a>计算查询代价</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> film_actor;</div><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'last_query_cost'</span>;</div></pre></td></tr></table></figure><p><code>last_query_cost</code> 上次查询 sql 的代价，这是 mysql 经过一系列的统计信息计算出来的。</p><ul><li>每个表或索引的页面个数</li><li>索引的基础</li><li>索引和数据行的长度</li><li>索引的分布情况</li></ul><h4 id="有时可能选择错误的执行计划"><a href="#有时可能选择错误的执行计划" class="headerlink" title="有时可能选择错误的执行计划"></a>有时可能选择错误的执行计划</h4><ul><li>统计信息不准确<ul><li>InnoDB 基于 mvcc 架构，并不能维护一个数据表行数的精确统计信息</li></ul></li><li>估算的成本不等于实际执行的成本<ul><li>顺序读、内存读等影响。mysql 不知道哪些页面在内存中哪些在磁盘中，所以实际执行过程中到底需要多少次 IO 是无法得知的。</li></ul></li></ul><h4 id="优化器的优化策略"><a href="#优化器的优化策略" class="headerlink" title="优化器的优化策略"></a>优化器的优化策略</h4><ul><li>静态优化，直接对解析树进行分析并优化，只需一次</li><li>动态优化，与查询的上下文有关，也可能和取值、索引对应的行数有关。动态优化每次执行时都需要重新评估。</li></ul><p><img src="../../images/mysql/5/数据量大可能不走索引.png" alt=""></p><p>查询的数据量较大时，可能不走索引。理论上没问题，但是 mysql 中有自己的优化器。</p><h4 id="优化器的优化类型"><a href="#优化器的优化类型" class="headerlink" title="优化器的优化类型"></a>优化器的优化类型</h4><ul><li>重新定义关联表的顺序，并不是按照 sql 写的顺序关联。可以使用 <strong><code>select straight_join</code></strong> 强制使用 sql 顺序。</li><li>将外连接转化为内连接，内连接效率更好</li><li>等价变换，简化表达式</li><li>优化 count()，min()，max()，通过索引 B+ 树查找，无需全表扫描。</li><li>预估并转化为常数表达式</li><li>索引覆盖扫描</li><li>子查询优化 </li><li>等值传播。关联字段，一个表加过滤就行。</li></ul><h4 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h4><ul><li>Simple Nested-Loop Join，就是嵌套循环遍历，笛卡尔集</li><li>Index Nested-Loop Join，如果非驱动表有索引会走索引，这样不用每次扫描整个表。如果是主键索引速度更快，否则还有回表查询。</li><li>Block Nested-Loop Join，如果有 join 列有索引会走第二种的索引方式，如果没有会建一个 join buffer，然后将驱动表中的所有 join 相关的列都存放到该 buffer 中，然后批量与匹配表进行匹配，将第一种方法中的<strong>多次比较合并为一次</strong>，<strong>降低了非驱动表的访问频率</strong>。<ul><li>join buffer 会缓存所有参与查询的列而不只是 join 列</li><li>join_buffer_size 大小可以调整</li><li>join_buffer_size 默认值 256k，最大值 5.1.22 版本之前是 4G-1，之后 64 位系统可以申请更大空间</li><li>需要开启 <strong><code>block_nested_loop</code></strong> 为 on，默认为 on。<ul><li>show variables like ‘%optimizer_switch%’</li></ul></li></ul></li></ul><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p>排序是一个成本很高的操作，从性能角度看应该尽量避免或者说尽量避免对大量数据进行排序。尽量使用索引进行排序。</p><p>非索引排序规则（<strong>filesort</strong>）：</p><ul><li>数据量小于 <strong><code>sort_buffer_size</code></strong> 则内存中快速排序；</li><li>如果 buffer 不够，先将树分块，每个独立的快使用快速排序进行排序，并将各个块的排序结果放到磁盘上，然后将各个块的排序结果合并返回最终排序结果；</li></ul><p>两次传输排序，效率较低，因为第二次读取数据更多的是随机 IO，读取数据成本较高。当排序列的总大小超过 <strong><code>max_length_for_sort_data</code></strong> 时两次排序，否则单次排序。</p><ul><li><p>第一次：将需要排序的字段读取出来，进行排序</p></li><li><p>第二次：将排好序的结果按照需要区读取数据行</p></li></ul><p>单次传输排序，只需一次顺序 IO 读取所有数据，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据</p><ul><li>第一次：读取查询所需要的所有列，进行排序，排序后直接返回需要查询的列</li></ul><h2 id="4-优化特定类型的查询"><a href="#4-优化特定类型的查询" class="headerlink" title="4. 优化特定类型的查询"></a>4. 优化特定类型的查询</h2><h3 id="4-1-优化-count-查询"><a href="#4-1-优化-count-查询" class="headerlink" title="4.1 优化 count() 查询"></a>4.1 优化 count() 查询</h3><ul><li>myisam 的 count 函数比较快是有条件的，只有没有 where 条件的 count(*) 才块</li><li>使用近似值代替，有些场景不需要完全精确的值，比如可以使用 explain 来获取近似的值。很多 OLAP 应用中，需要计算够一个列值的基数，hyperloglog 是一个计算近似值的算法。</li><li>count 需要扫描大量行才能获取精确值，本身很难优化，可以考虑增加<strong>汇总表</strong>或者增加<strong>外部缓存系统</strong>。</li></ul><h3 id="4-2-优化关联查询"><a href="#4-2-优化关联查询" class="headerlink" title="4.2 优化关联查询"></a>4.2 优化关联查询</h3><ul><li><p>确保 on 或者 using 字句中的列上有索引</p><p>创建索引时要考虑关联的顺序。关联顺序是 B、A，则只需要在 A 表上建立索引即可，没有用到的索引只会带来额外的负担。</p></li><li><p>确保 group by 和 order by 中的表达式只涉及到一个表中的列</p><p>这样 MySQL 才可能用索引来优化</p></li></ul><h3 id="4-3-优化子查询"><a href="#4-3-优化子查询" class="headerlink" title="4.3 优化子查询"></a>4.3 优化子查询</h3><p>使用关联查询代替。</p><h3 id="4-4-优化-limit-分页"><a href="#4-4-优化-limit-分页" class="headerlink" title="4.4 优化 limit 分页"></a>4.4 优化 limit 分页</h3><p>尽可能使用覆盖索引，而不是查询所有列。但是通常需求一般都是要查询很多列的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- filesort、没有覆盖索引导致每行数据都需要回表</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>;</div><div class="line"><span class="comment">-- 索引排序、覆盖索引无需回表</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film.film_id,film.description <span class="keyword">from</span> film <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>) <span class="keyword">as</span> lim <span class="keyword">using</span>(film_id);</div></pre></td></tr></table></figure><ol><li><code>select film_id from film order by title limit 50,5</code> 覆盖索引无需回表，并且使用索引排序</li><li><code>using(film_id)</code> 关联查询，主键索引</li></ol><h3 id="4-5-优化-union-查询"><a href="#4-5-优化-union-查询" class="headerlink" title="4.5 优化 union 查询"></a>4.5 优化 union 查询</h3><p>mysql 通过创建并填充临时表的方式来执行 union 查询，因此很多优化策略在 union 查询中没法很好使用。经常需要手工将 where、limit、order by 等字句下推到各个子查询中，以便优化器进行优化。</p><p>尽量使用 <code>union all</code>，否则会自动加上 distinct，这个操作代价很高。</p><h2 id="5-推荐使用自定义变量"><a href="#5-推荐使用自定义变量" class="headerlink" title="5. 推荐使用自定义变量"></a>5. 推荐使用自定义变量</h2><h3 id="5-1-自定义变量的使用"><a href="#5-1-自定义变量的使用" class="headerlink" title="5.1 自定义变量的使用"></a>5.1 自定义变量的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> @one := <span class="number">1</span>;</div><div class="line"><span class="keyword">set</span> @min_actor := (<span class="keyword">select</span> <span class="keyword">min</span>(actor_id) <span class="keyword">from</span> actor);</div><div class="line"><span class="keyword">set</span> @last_week := <span class="keyword">current_date</span> - <span class="built_in">interval</span> <span class="number">1</span> <span class="keyword">week</span>;</div><div class="line"><span class="keyword">select</span> @last_week;</div></pre></td></tr></table></figure><h3 id="5-2-自定义变量的限制"><a href="#5-2-自定义变量的限制" class="headerlink" title="5.2 自定义变量的限制"></a>5.2 自定义变量的限制</h3><ol><li>无法使用查询缓存</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者 limit 子句</li><li>自定义变量的生命周期在一个连接中有效，所以不能用来做连接之间的通信</li><li>不能显示的声明自定义变量的类型</li><li>mysql 优化器可能会将这些变量优化掉，可能导致代码不按照预想的方式运行</li><li>赋值符号<code>:=</code>优先级非常低，尽量明确使用括号</li><li>使用未定义变量不会产生任何错误</li></ol><h3 id="5-3-自定义变量的使用案例"><a href="#5-3-自定义变量的使用案例" class="headerlink" title="5.3 自定义变量的使用案例"></a>5.3 自定义变量的使用案例</h3><h4 id="优化排名语句"><a href="#优化排名语句" class="headerlink" title="优化排名语句"></a>优化排名语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 在给一个变量赋值的同时使用这个变量</span></div><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">rownum</span> <span class="keyword">from</span> actor <span class="keyword">limit</span> <span class="number">10</span>;</div></pre></td></tr></table></figure><h4 id="避免重新查询刚刚更新的数据"><a href="#避免重新查询刚刚更新的数据" class="headerlink" title="避免重新查询刚刚更新的数据"></a>避免重新查询刚刚更新的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么</span></div><div class="line"><span class="keyword">update</span> var_test <span class="keyword">set</span> updtime = <span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> @updtime := <span class="keyword">now</span>();</div><div class="line"><span class="keyword">select</span> @updtime;</div></pre></td></tr></table></figure><h4 id="使用时注意取值的顺序"><a href="#使用时注意取值的顺序" class="headerlink" title="使用时注意取值的顺序"></a>使用时注意取值的顺序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">-- 全部查询出来了？</span></div><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> first_name;</div><div class="line"></div><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span>+<span class="number">1</span>) &lt;= <span class="number">1</span>;</div></pre></td></tr></table></figure><h2 id="8-sql-汇总"><a href="#8-sql-汇总" class="headerlink" title="8. sql 汇总"></a>8. sql 汇总</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> film_actor;</div><div class="line"><span class="comment">-- 查看执行代价（需要扫描多少页）</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'last_query_cost'</span>;</div><div class="line"><span class="comment">-- 默认 256k，用于 blocked nested_loop join</span></div><div class="line">join_buffer_size </div><div class="line"><span class="comment">-- 开启、关闭 block_nested_loop</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%optimizer_switch%'</span>;</div><div class="line"><span class="comment">-- filesort 的内存排序缓冲区大小，超过此大小要分块排序，默认 256k。innodb(1024k=1m) myisam(8m)</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%sort_buffer_size%'</span>;</div><div class="line"><span class="comment">-- 决定排序方式，大于此值则两次传输，默认 1k</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_length_for_sort_data%'</span>;</div></pre></td></tr></table></figure><h2 id="9-问题"><a href="#9-问题" class="headerlink" title="9. 问题"></a>9. 问题</h2><ol><li><p>MySAM count 快的问题</p></li><li><p>子查询优化，到底子查询有何不妥？具体要怎么优化？</p></li><li><p>max_length_for_sort_data 默认才 1k？这个具体指什么大小？</p></li><li><p>hyperloglog  算法？</p></li><li><p>两个表关联，只需要一个表建立索引即可？</p></li><li><p>开窗函数</p></li><li><p>行转列</p><p>name subject socre =&gt; name yuwen shuxue yingyu</p><ol><li>oracle：join、union、decode、case when</li><li>mysql：join、union、case when</li></ol></li></ol><p>CBU RBU</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查询优化&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(六)</title>
    <link href="http://yoursite.com/2020-08-13-mysql/mysql_6.html"/>
    <id>http://yoursite.com/2020-08-13-mysql/mysql_6.html</id>
    <published>2020-08-13T14:13:12.000Z</published>
    <updated>2020-08-16T10:50:06.527Z</updated>
    
    <content type="html"><![CDATA[<p>分区表。</p><a id="more"></a><h2 id="1-分区表到底应用场景"><a href="#1-分区表到底应用场景" class="headerlink" title="1. 分区表到底应用场景"></a>1. 分区表到底应用场景</h2><ul><li>表非常大以至于无法全部都放在内存中</li><li>表只在最后的部分有热点数据，其他均是历史数据</li><li>分区表的数据更容易维护<ul><li>批量删除大量数据可以使用清除整个分区的方式</li><li>对一个独立分区进行优化、检查、修复等操作</li></ul></li><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>可以使用分区表来避免某些特殊的瓶颈<ul><li>innodb 的单个索引的互斥访问</li><li>ext3 文件系统的 inode 锁竞争</li></ul></li><li>可以备份和恢复独立的分区</li></ul><h2 id="2-分区表的限制"><a href="#2-分区表的限制" class="headerlink" title="2. 分区表的限制"></a>2. 分区表的限制</h2><ul><li>一个表最多 1024 个分区，5.7 的时候可以支持 8196 个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li></ul><h2 id="3-分区表的原理"><a href="#3-分区表的原理" class="headerlink" title="3. 分区表的原理"></a>3. 分区表的原理</h2><ul><li>由多个相关的底层表实现</li><li>存储引擎管理分区的各个底层表和管理普通表一样</li><li>分区表的索引只是在各个底层表上各自加上一个完全相同的索引</li></ul><h3 id="3-1-select-查询"><a href="#3-1-select-查询" class="headerlink" title="3.1 select 查询"></a>3.1 select 查询</h3><p>当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据。</p><h3 id="3-2-insert-操作"><a href="#3-2-insert-操作" class="headerlink" title="3.2 insert 操作"></a>3.2 insert 操作</h3><p>分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表。</p><h3 id="3-3-delete-操作"><a href="#3-3-delete-操作" class="headerlink" title="3.3 delete 操作"></a>3.3 delete 操作</h3><p>分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作。</p><h3 id="3-4-update-操作"><a href="#3-4-update-操作" class="headerlink" title="3.4 update 操作"></a>3.4 update 操作</h3><p>分区层先打开并锁住所有的底层表，确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该在哪个分区，最后对底层表进行写入操作，并对源数据进行删除。</p><h3 id="3-5-支持过滤"><a href="#3-5-支持过滤" class="headerlink" title="3.5 支持过滤"></a>3.5 支持过滤</h3><p>如果 where 条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉。</p><h3 id="3-6-支持行锁"><a href="#3-6-支持行锁" class="headerlink" title="3.6 支持行锁"></a>3.6 支持行锁</h3><p>虽然每个操作都会分区层先打开并锁住所有的底层表，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，例如 innodb，则会在分区层释放对应的表锁。</p><h2 id="4-分区表的类型"><a href="#4-分区表的类型" class="headerlink" title="4. 分区表的类型"></a>4. 分区表的类型</h2><h3 id="4-1-范围分区"><a href="#4-1-范围分区" class="headerlink" title="4.1 范围分区"></a>4.1 范围分区</h3><p>根据列值在给定范围内将行分配给分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    store_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (store_id) (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">6</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">11</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">16</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</div><div class="line">);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>,fname,job_code,sotre_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>,<span class="number">1</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>,fname,job_code,sotre_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>,<span class="number">1</span>,<span class="number">33</span>);</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employeees;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> quarterly_report_status (</div><div class="line">    report_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    report_status <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    report_updated <span class="keyword">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(report_updated) ) (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-01-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-04-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-07-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-10-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-01-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-04-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p6 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-07-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p7 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-10-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p8 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2010-01-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p9 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE)</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="4-2-列表分区"><a href="#4-2-列表分区" class="headerlink" title="4.2 列表分区"></a>4.2 列表分区</h3><p>和 range 分区类似。只是匹配一个列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span>,</div><div class="line">    store_id <span class="built_in">INT</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span>(store_id) (</div><div class="line">    <span class="keyword">PARTITION</span> pNorth <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">17</span>),</div><div class="line">    <span class="keyword">PARTITION</span> pEast <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">20</span>),</div><div class="line">    <span class="keyword">PARTITION</span> pWest <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">4</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">18</span>),</div><div class="line">    <span class="keyword">PARTITION</span> pCentral <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>, fname, store_id) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'alvin'</span>, <span class="number">17</span>);</div><div class="line"><span class="comment">-- ERROR 1526 (HY000): Table has no partition for value 88</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>, fname, store_id) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'alvin'</span>, <span class="number">88</span>);</div></pre></td></tr></table></figure><h3 id="4-3-列分区"><a href="#4-3-列分区" class="headerlink" title="4.3 列分区"></a>4.3 列分区</h3><p>5.5 开始支持 column 分区，可以认为是 range 和 list 分区的升级版。</p><p>5.5 之后可以使用 column 分区代替他们，但是 column 分区只接收普通列不接受表达式。</p><p>允许多列分区。</p><p>支持非整型类型分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rc1 (</div><div class="line">    a <span class="built_in">INT</span>,</div><div class="line">    b <span class="built_in">INT</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> <span class="keyword">COLUMNS</span>(a, b) (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">5</span>, <span class="number">12</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE, MAXVALUE)</div><div class="line">);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> rc1 <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">10</span>), (<span class="number">5</span>,<span class="number">11</span>), (<span class="number">5</span>,<span class="number">12</span>);</div><div class="line"><span class="keyword">SELECT</span> (<span class="number">5</span>,<span class="number">10</span>) &lt; (<span class="number">5</span>,<span class="number">12</span>), (<span class="number">5</span>,<span class="number">11</span>) &lt; (<span class="number">5</span>,<span class="number">12</span>), (<span class="number">5</span>,<span class="number">12</span>) &lt; (<span class="number">5</span>,<span class="number">12</span>);</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">10</span>) &lt; <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>), <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">11</span>) &lt; <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>), <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>) &lt; <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>);</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees_by_lname (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    store_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> <span class="keyword">COLUMNS</span> (lname)  (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'g'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'m'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'t'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE)</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="4-4-hash-分区"><a href="#4-4-hash-分区" class="headerlink" title="4.4 hash 分区"></a>4.4 hash 分区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span>,</div><div class="line">    store_id <span class="built_in">INT</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>( <span class="keyword">YEAR</span>(hired) )</div><div class="line"><span class="comment">-- liner hash。hash 算法不同</span></div><div class="line"><span class="comment">-- PARTITION BY LINEAR HASH( YEAR(hired) )</span></div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">4</span>;</div></pre></td></tr></table></figure><h3 id="4-5-key-分区"><a href="#4-5-key-分区" class="headerlink" title="4.5 key 分区"></a>4.5 key 分区</h3><p>和 hash 类似，只是可以不指定列，根据主键自己拿。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k1 (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>()</div><div class="line"><span class="comment">-- 也有 liner key</span></div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">-- ERROR 1503 (HY000): A UNIQUE INDEX must include all columns in the table's partitioning function</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k2 (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</div><div class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (<span class="keyword">name</span>)</div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>()</div><div class="line"><span class="comment">-- 也有 liner key</span></div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">2</span>;</div></pre></td></tr></table></figure><h3 id="4-6-子分区"><a href="#4-6-子分区" class="headerlink" title="4.6 子分区"></a>4.6 子分区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts (<span class="keyword">id</span> <span class="built_in">INT</span>, purchased <span class="built_in">DATE</span>)</div><div class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(purchased) )</div><div class="line">    <span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>( <span class="keyword">TO_DAYS</span>(purchased) )</div><div class="line">    <span class="keyword">SUBPARTITIONS</span> <span class="number">2</span> (</div><div class="line">        <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1990</span>),</div><div class="line">        <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2000</span>),</div><div class="line">        <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</div><div class="line">    );</div></pre></td></tr></table></figure><h2 id="5-如何使用分区"><a href="#5-如何使用分区" class="headerlink" title="5. 如何使用分区"></a>5. 如何使用分区</h2><p>如果需要从非常大的表中查询出某一段时间的记录，而这张表中包含很多年的历史数据，数据是按照时间排序的，此时应该如何查询数据呢？</p><p>因为数据量较大，肯定不能在每次查询的时候都全表扫描。考虑到索引在空间和维护上的消耗，也不希望使用索引，即使使用索引，会发现会产生大量的碎片，还会产生大量的随机 IO。但是当数据量超大的时候，索引也就无法起作用了，此时可以考虑使用分区来解决。</p><h3 id="5-1-全量扫描，不要任何索引"><a href="#5-1-全量扫描，不要任何索引" class="headerlink" title="5.1 全量扫描，不要任何索引"></a>5.1 全量扫描，不要任何索引</h3><p>使用简单的分区方式存放表，不要任何索引，根据分区规则大致定位需要的数据为止，通过 where 条件将需要的数据限制在少数分区中，这种策略适用于以正常的方式访问大量数据。</p><h3 id="5-2-索引数据，并分离热点"><a href="#5-2-索引数据，并分离热点" class="headerlink" title="5.2 索引数据，并分离热点"></a>5.2 索引数据，并分离热点</h3><p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中，这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存。</p><h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h2><ul><li>null 值会使分区过滤无效</li><li>分区列和索引列不匹配，会导致查询无法进行分区过滤</li><li>选择分区的成本可能很高</li><li>打开并锁住所有底层表的成本可能很高</li><li>维护分区的成本可能很高</li></ul><p>最好不要 update 分区键。</p><p>热数据和离线数据区分。什么场景、哪个表，什么情况下用分区表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分区表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(三)</title>
    <link href="http://yoursite.com/2020-08-10-mysql/mysql_3.html"/>
    <id>http://yoursite.com/2020-08-10-mysql/mysql_3.html</id>
    <published>2020-08-10T14:13:12.000Z</published>
    <updated>2020-08-12T16:03:28.758Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-聚簇索引和非聚簇索引"><a href="#1-聚簇索引和非聚簇索引" class="headerlink" title="1. 聚簇索引和非聚簇索引"></a>1. 聚簇索引和非聚簇索引</h2><h3 id="1-1-聚簇索引"><a href="#1-1-聚簇索引" class="headerlink" title="1.1 聚簇索引"></a>1.1 聚簇索引</h3><p>不是索引类型，而是一种数据的存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。</p><p>优点：</p><ol><li>可以把相关的数据保存在一起</li><li>数据访问更快，因为索引和数据保存在同一个树中</li><li>覆盖索引的查询可以直接使用页节点中的主键值</li></ol><p>缺点：</p><ol><li>聚簇数据最大限度的提高了 IO 密集型应用的性能，但是如果数据全部放在内存中，本来就不需要太多的 IO，那么聚簇索引就没有什么优势</li><li>插入的速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式</li><li>更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置</li><li>在插入新行、主键被更新导致需要移动行的时候，可能面临<strong>页分裂</strong>问题。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于<strong>页分裂</strong>导致数据存储不连续的时候。</li></ol><h3 id="1-2-非聚簇索引"><a href="#1-2-非聚簇索引" class="headerlink" title="1.2 非聚簇索引"></a>1.2 非聚簇索引</h3><p>将数据文件和索引文件分开存放。</p><h2 id="2-索引匹配方式"><a href="#2-索引匹配方式" class="headerlink" title="2. 索引匹配方式"></a>2. 索引匹配方式</h2><h3 id="2-1-全值匹配"><a href="#2-1-全值匹配" class="headerlink" title="2.1 全值匹配"></a>2.1 全值匹配</h3><p>可以和组合索引中所有列进行匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> staffs(</div><div class="line"></div><div class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</div><div class="line"></div><div class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">24</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span> <span class="keyword">comment</span> <span class="string">'姓名'</span>,</div><div class="line"></div><div class="line">    age <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">comment</span> <span class="string">'年龄'</span>,</div><div class="line"></div><div class="line">    pos <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span> <span class="keyword">comment</span> <span class="string">'职位'</span>,</div><div class="line"></div><div class="line">    add_time <span class="keyword">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'入职时间'</span></div><div class="line"></div><div class="line">  ) <span class="keyword">charset</span> utf8 <span class="keyword">comment</span> <span class="string">'员工记录表'</span>;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> staffs <span class="keyword">add</span> <span class="keyword">index</span> idx_nap(<span class="keyword">name</span>, age, pos);</div><div class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> staffs;</div><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="string">'23'</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span>;</div></pre></td></tr></table></figure><h3 id="2-2-匹配最左前缀"><a href="#2-2-匹配最左前缀" class="headerlink" title="2.2 匹配最左前缀"></a>2.2 匹配最左前缀</h3><p>可以只匹配的组合索引的前面几列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="string">'23'</span>;</div><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span>;</div><div class="line"><span class="comment">-- 全表扫描</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> age = <span class="string">'23'</span>;</div></pre></td></tr></table></figure><h3 id="2-3-匹配列前缀"><a href="#2-3-匹配列前缀" class="headerlink" title="2.3 匹配列前缀"></a>2.3 匹配列前缀</h3><p>可以匹配某一列的值的开头部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'J%'</span>;</div><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'J%'</span> <span class="keyword">and</span> age = <span class="number">23</span>;</div><div class="line"><span class="comment">-- 全表扫描</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%y'</span>;</div></pre></td></tr></table></figure><h3 id="2-4-匹配范围值"><a href="#2-4-匹配范围值" class="headerlink" title="2.4 匹配范围值"></a>2.4 匹配范围值</h3><p>范围查询也可以匹配索引，但是会中断组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span>;</div><div class="line"><span class="comment">-- age 未走索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span> <span class="keyword">and</span> age = <span class="number">23</span>;</div></pre></td></tr></table></figure><h3 id="2-5-精确匹配某一列并范围匹配另外一列"><a href="#2-5-精确匹配某一列并范围匹配另外一列" class="headerlink" title="2.5 精确匹配某一列并范围匹配另外一列"></a>2.5 精确匹配某一列并范围匹配另外一列</h3><p>可以查询第一列的全部和第二列的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age &gt; <span class="number">25</span>;</div></pre></td></tr></table></figure><h3 id="2-6-只访问索引查询-覆盖索引"><a href="#2-6-只访问索引查询-覆盖索引" class="headerlink" title="2.6 只访问索引查询-覆盖索引"></a>2.6 只访问索引查询-覆盖索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age,pos <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">25</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span>;</div></pre></td></tr></table></figure><h2 id="3-索引优化细节"><a href="#3-索引优化细节" class="headerlink" title="3. 索引优化细节"></a>3. 索引优化细节</h2><h3 id="3-1-索引列不要使用表达式"><a href="#3-1-索引列不要使用表达式" class="headerlink" title="3.1 索引列不要使用表达式"></a>3.1 索引列不要使用表达式</h3><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id=<span class="number">4</span>;</div><div class="line"><span class="comment">-- possible_keys:null key:idx_actor_last_name ?</span></div><div class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id+<span class="number">1</span>=<span class="number">5</span>;</div></pre></td></tr></table></figure><h3 id="3-2-尽量使用主键查询"><a href="#3-2-尽量使用主键查询" class="headerlink" title="3.2 尽量使用主键查询"></a>3.2 尽量使用主键查询</h3><p>尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表查询。</p><h3 id="3-3-使用前缀索引"><a href="#3-3-使用前缀索引" class="headerlink" title="3.3 使用前缀索引"></a>3.3 使用前缀索引</h3><p>有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性更高的索引可以让       mysql 在查找的时候过滤掉更多的行。</p><p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOB,TEXT,VARCHAR类型的列，必须要使用前缀索引，因为 mysql 不允许索引这些列的完整长度，使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，通过又不能太长。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 查询不同长度前缀的选择性</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">3</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel3,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">4</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel4,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">5</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel5,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">6</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel6,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">7</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel7,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">8</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel8 </div><div class="line"><span class="keyword">from</span> citydemo;</div><div class="line"></div><div class="line"><span class="comment">-- 选择合适的长度创建前缀索引</span></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> citydemo <span class="keyword">add</span> <span class="keyword">key</span>(city(<span class="number">7</span>));</div></pre></td></tr></table></figure><p>注意：前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：mysql无法使用前缀索引做order by 和 group by。 </p><h3 id="3-4-使用索引扫描来排序"><a href="#3-4-使用索引扫描来排序" class="headerlink" title="3.4 使用索引扫描来排序"></a>3.4 使用索引扫描来排序</h3><p>mysql有两种方式可以生成有序的结果：</p><ol><li><p>通过排序操作</p></li><li><p>通过索引顺序扫描</p><p>如果 explain 出来的 type 列的值为 index，则说明mysql使用了索引扫描来做排序。extra：Using filesort 表示没有用索引排序。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--sakila数据库中rental表在rental_date,inventory_id,customer_id上有rental_date的索引</span></div><div class="line"><span class="comment">--使用rental_date索引为下面的查询做排序</span></div><div class="line"><span class="comment">-- 索引排序</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id,customer_id\G</div><div class="line"><span class="comment">-- 索引排序</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>\G</div><div class="line"><span class="comment">-- Using filesort</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date&gt;<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> rental_date,inventory_id\G</div><div class="line"><span class="comment">-- Using filesort 两个字段排序不一样</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>,customer_id <span class="keyword">asc</span>\G</div><div class="line"><span class="comment">-- Using filesort 使用了非索引列排序</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id,staff_id\G</div></pre></td></tr></table></figure><h3 id="3-5-union-all-in-or都能够使用索引，但是推荐使用in"><a href="#3-5-union-all-in-or都能够使用索引，但是推荐使用in" class="headerlink" title="3.5 union all,in,or都能够使用索引，但是推荐使用in"></a>3.5 union all,in,or都能够使用索引，但是推荐使用in</h3><h3 id="3-6-范围列可以用到索引"><a href="#3-6-范围列可以用到索引" class="headerlink" title="3.6 范围列可以用到索引"></a>3.6 范围列可以用到索引</h3><p>范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列</p><h3 id="3-7-强制类型转换会全表扫描"><a href="#3-7-强制类型转换会全表扫描" class="headerlink" title="3.7 强制类型转换会全表扫描"></a>3.7 强制类型转换会全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> typecast_test(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, phone <span class="built_in">varchar</span>(<span class="number">11</span>));</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> typecast_test <span class="keyword">add</span> <span class="keyword">index</span> idx_phone(phone);</div><div class="line"><span class="comment">-- 查看表状态</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%typecast%'</span>\G</div><div class="line"><span class="keyword">alter</span> talbe typecast <span class="keyword">engine</span>=<span class="string">'innodb'</span>;</div><div class="line"><span class="comment">-- type:index</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> typecast_test <span class="keyword">where</span> phone = <span class="number">1</span>;</div><div class="line"><span class="comment">-- type:ref</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> typecast_test <span class="keyword">where</span> phone = <span class="string">'1'</span>;</div><div class="line"><span class="comment">-- 查看 mysql 数据文件位置</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">`%datadir%`</span>;</div></pre></td></tr></table></figure><p>index 和 ref 区别？</p><h3 id="3-8-更新频繁、区分度不高字段不建索引"><a href="#3-8-更新频繁、区分度不高字段不建索引" class="headerlink" title="3.8 更新频繁、区分度不高字段不建索引"></a>3.8 更新频繁、区分度不高字段不建索引</h3><p>更新可能会变更 B+ 树，可能导致页分裂、页合并等问题。</p><p>区分度不高，即使建立了索引页不能有效的过滤数据。</p><p>一般区分度在 80% 以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算。</p><h3 id="3-9-索引列不为-null"><a href="#3-9-索引列不为-null" class="headerlink" title="3.9 索引列不为 null"></a>3.9 索引列不为 null</h3><p>创建索引的列，不允许为null，可能会得到不符合预期的结果。</p><h3 id="3-10-表连接不超过-3-张"><a href="#3-10-表连接不超过-3-张" class="headerlink" title="3.10 表连接不超过 3 张"></a>3.10 表连接不超过 3 张</h3><p>当需要进行表连接的时候，最好不要超过三张表，因为需要 join 的字段，数据类型必须一致。</p><h3 id="3-11-尽量使用-limit"><a href="#3-11-尽量使用-limit" class="headerlink" title="3.11 尽量使用 limit"></a>3.11 尽量使用 limit</h3><p>能使用limit的时候尽量使用limit。这个索引有啥关系？</p><h3 id="3-12-单表索引建议控制在-5-个以内"><a href="#3-12-单表索引建议控制在-5-个以内" class="headerlink" title="3.12 单表索引建议控制在 5 个以内"></a>3.12 单表索引建议控制在 5 个以内</h3><h3 id="3-13-单索引字段数不允许超过-5-个"><a href="#3-13-单索引字段数不允许超过-5-个" class="headerlink" title="3.13 单索引字段数不允许超过 5 个"></a>3.13 单索引字段数不允许超过 5 个</h3><h3 id="3-14-错误的概念"><a href="#3-14-错误的概念" class="headerlink" title="3.14 错误的概念"></a>3.14 错误的概念</h3><ul><li>索引越多越好</li><li>过早优化，在不了解系统的情况下进行优化</li></ul><h2 id="4-索引监控"><a href="#4-索引监控" class="headerlink" title="4. 索引监控"></a>4. 索引监控</h2><p><code>show status like &#39;Handler_read%&#39;;</code></p><ul><li>Handler_read_first：读取索引第一个条目的次数</li><li>Handler_read_key：通过 index 获取数据的次数</li><li>Handler_read_last：读取索引最后一个条目的次数</li><li>Handler_read_next：通过索引读取下一条数据的次数</li><li>Handler_read_prev：通过索引读取上一条数据的次数</li><li>Handler_read_rnd：从固定位置读取数据的次数</li><li>Handler_read_rnd_next：从数据节点读取下一条数据的次数</li></ul><p>导入大量数据时，可以先把创建索引属性关掉，先把数据文件拷贝过来，然后再打开索引。</p><p>OLAP 联机分析系统。对历史数据进行分析，以确定未来规划等。</p><p>Cardinality：基数。count(distinct city) 近似值。常用于确定关联哪一个列。</p><p>hyperloglog：<a href="https://www.jianshu.com/p/55defda6dcd2" target="_blank" rel="external">https://www.jianshu.com/p/55defda6dcd2</a> </p><p>join 内部实现方式</p><p>A join B 不一定是先读 A 再读 B，MySQL 会进行优化。可以关闭。</p><p>最好 小表 join 大表。</p><p>下面两个 sql 区别</p><p>select  * from t1 join t2 on t1.id =  t2.id and t1.name = ‘aa’</p><p>select  * from t1 join t2 on t1.id =  t2.id  where t1.name = ‘aa’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-聚簇索引和非聚簇索引&quot;&gt;&lt;a href=&quot;#1-聚簇索引和非聚簇索引&quot; class=&quot;headerlink&quot; title=&quot;1. 聚簇索引和非聚簇索引&quot;&gt;&lt;/a&gt;1. 聚簇索引和非聚簇索引&lt;/h2&gt;&lt;h3 id=&quot;1-1-聚
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-08-09-mysql/mysql_2.html"/>
    <id>http://yoursite.com/2020-08-09-mysql/mysql_2.html</id>
    <published>2020-08-09T07:26:13.598Z</published>
    <updated>2020-08-31T16:07:23.317Z</updated>
    
    <content type="html"><![CDATA[<p>title: MySql 调优(二)<br>tags:</p><ul><li>MySQL<br>comments: true<br>toc: true<br>categories: MySQL<br>date: 2020-08-09 22:13:12</li></ul><ul><li>范式、主键、字符集、存储引擎、拆分的选择</li><li>执行计划</li><li>索引的数据结构和基本概念</li></ul><a id="more"></a><h2 id="1-schema-与数据类型优化"><a href="#1-schema-与数据类型优化" class="headerlink" title="1. schema 与数据类型优化"></a>1. schema 与数据类型优化</h2><h3 id="1-1-合理使用范式和反范式"><a href="#1-1-合理使用范式和反范式" class="headerlink" title="1.1 合理使用范式和反范式"></a>1.1 合理使用范式和反范式</h3><h4 id="范式优点"><a href="#范式优点" class="headerlink" title="范式优点"></a>范式优点</h4><ul><li>更新通常比反范式快</li><li>很少或者没有冗余数据</li><li>范式化的数据比较小，可以放在内存中，操作比较快</li></ul><h4 id="范式缺点"><a href="#范式缺点" class="headerlink" title="范式缺点"></a>范式缺点</h4><ul><li>通常需要进行关联</li></ul><h4 id="反范式优点"><a href="#反范式优点" class="headerlink" title="反范式优点"></a>反范式优点</h4><ul><li>所有的数据都在同一张表中，可以避免关联</li><li>可以设计有效的索引</li><li>空间换时间的思想</li></ul><h4 id="反范式缺点"><a href="#反范式缺点" class="headerlink" title="反范式缺点"></a>反范式缺点</h4><ul><li>数据冗余较多</li><li>删除数据时会造成表有些有用的信息丢失，完全反范式所有内容存在一张表，删除用户消息导致用户信息都丢了，所以一般混合使用，user 表和 message 表都存用户类型字段。</li><li>需要确保数据的一致性不会被破坏，确保更新时冗余字段也被更新</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>在企业上很难做到严格意义上的范式或者反范式，一般混合使用。</p><ul><li>比如用户表和用户信息表均冗余用户类型字段。这样既方便了消息的查询也避免了没有消息时，用户类型信息的丢失</li><li>另一个从父表冗余数据到子表的理由是<strong>排序</strong>的需要？索引排序？</li><li><strong>缓存衍生值</strong>也是有用的。比如维护一个 num_messages 字段到 user 表，记录每个用户发了多少消息。或者说订单表存一个订单价格字段，而不用每次从订单商品中去计算价格</li></ul></li></ul><p>一、二、三四范式？</p><h3 id="1-2-主键的选择"><a href="#1-2-主键的选择" class="headerlink" title="1.2 主键的选择"></a>1.2 主键的选择</h3><ol><li>代理主键：与业务无关，无意义的数字序列</li><li>自然主键：事物属性中的自然唯一标识</li></ol><p>推荐使用代理主键</p><ul><li>不与业务耦合，更容易维护</li><li>通用的主键策略？：减少需要编写的源码数量？减少系统的总体拥有成本？</li></ul><h3 id="1-3-字符集的选择"><a href="#1-3-字符集的选择" class="headerlink" title="1.3 字符集的选择"></a>1.3 字符集的选择</h3><p>字符集直接决定了数据在 MySQL 中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少 IO 操作次数。 </p><ol><li>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间</li><li>如果可以确定不需要存放多种语言，就没必要使用 utf8 或者其他 unicode 字符类型，造成大量的存储空间浪费</li><li>MySQL 的字符集类型可以精确到字段</li></ol><h3 id="1-4-存储引擎的选择"><a href="#1-4-存储引擎的选择" class="headerlink" title="1.4 存储引擎的选择"></a>1.4 存储引擎的选择</h3><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td></tr><tr><td>支持事务</td><td>否</td><td>是</td></tr><tr><td>支持表锁</td><td>是</td><td>是</td></tr><tr><td>支持行锁</td><td>否</td><td>是</td></tr><tr><td>支持外键</td><td>否</td><td>是</td></tr><tr><td>支持全文索引</td><td>是</td><td>是（5.6之后）</td></tr><tr><td>适合操作类型</td><td>大量 select</td><td>大量 insert、delete、update</td></tr></tbody></table><h3 id="1-5-适当的数据冗余"><a href="#1-5-适当的数据冗余" class="headerlink" title="1.5 适当的数据冗余"></a>1.5 适当的数据冗余</h3><p>即适当的反范式。</p><ul><li>被频繁引用，且只能通过 join 2张（或者更多）大表2的方式才能得到的独立小字段。</li><li>这样的场景由于每次 join 仅仅只是为了取得某个小字段的值，join 到的记录又大，会造成大量不必要的 IO，完全可以通过空间换时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</li></ul><h3 id="1-6-适当的拆分"><a href="#1-6-适当的拆分" class="headerlink" title="1.6 适当的拆分"></a>1.6 适当的拆分</h3><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其<strong>拆分到另外的独立表</strong>中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是<strong>每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</strong> </p><h2 id="2-执行计划"><a href="#2-执行计划" class="headerlink" title="2. 执行计划"></a>2. 执行计划</h2><p>官网地址： <a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.6/en/explain-output.html</a> </p><table><thead><tr><th style="text-align:center">Column</th><th style="text-align:center">Meaning</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">The <code>SELECT</code> identifier</td></tr><tr><td style="text-align:center">select_type</td><td style="text-align:center">The <code>SELECT</code> type</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">The table for the output row</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:center">The matching partitions</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">The join type</td></tr><tr><td style="text-align:center">possible_keys</td><td style="text-align:center">The possible indexes to choose</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">The index actually chosen</td></tr><tr><td style="text-align:center">key_len</td><td style="text-align:center">The length of the chosen key</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center">The columns compared to the index</td></tr><tr><td style="text-align:center">rows</td><td style="text-align:center">Estimate of rows to be examined</td></tr><tr><td style="text-align:center">filtered</td><td style="text-align:center">Percentage of rows filtered by table condition</td></tr><tr><td style="text-align:center">extra</td><td style="text-align:center">Additional information</td></tr></tbody></table><h3 id="2-1-id"><a href="#2-1-id" class="headerlink" title="2.1 id"></a>2.1 id</h3><p>1、id 相同，从上到下，依次执行</p><p>2、id 不同，id 越大优先级越高</p><p>​    <code>explain select * from ip_test where id in (select max(id) from ip_test);</code></p><h3 id="2-2-select-type"><a href="#2-2-select-type" class="headerlink" title="2.2 select_type"></a>2.2 select_type</h3><ul><li>SIMPLE：简单查询</li><li>primary：最外层查询</li><li>union</li><li>dependent union</li><li>union result</li><li>subquery</li><li>dependent subquery</li><li>derived</li><li>uncachable subquery</li></ul><h3 id="2-3-table"><a href="#2-3-table" class="headerlink" title="2.3 table"></a>2.3 table</h3><p>对应行正在访问哪一个表，表名或者别名。</p><h3 id="2-4-type"><a href="#2-4-type" class="headerlink" title="2.4 type"></a>2.4 type</h3><p><strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> </p><p>一般情况下，<strong>得保证查询至少达到range级别，最好能达到ref</strong></p><ul><li><p>all：全表扫描</p></li><li><p>index：全索引扫描。查询时覆盖索引；使用了索引进行排序。其实也是全表扫描，只是可能用到覆盖索引。</p></li><li><p>range：利用索引查询的时候限制了范围，避免了 index 的全索引扫描。<code>=,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;=, is null,between,like,in()</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</div></pre></td></tr></table></figure></li><li><p>index_subquery：利用索引来关联子查询，不再扫描全表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</div></pre></td></tr></table></figure></li><li><p>unique_subquery：和 index_subquery 类似，使用的是唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</div></pre></td></tr></table></figure></li><li><p>index_merge：多个索引组合使用</p></li><li><p>ref_or_null：既需要关联条件，也需要 null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table</div><div class="line"><span class="keyword">WHERE</span> key_column=expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></li><li><p>ref：使用了<strong>非唯一索引</strong>进行数据的查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</div></pre></td></tr></table></figure></li><li><p>eq_ref：使用唯一索引进行数据查找（primary kye 或者 unique not null index）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</div><div class="line"><span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</div><div class="line"><span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</div><div class="line"><span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</div></pre></td></tr></table></figure></li><li><p>const：这个表至多有一个匹配行（主键索引或者唯一索引加了等于条件）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</div></pre></td></tr></table></figure></li><li><p>system：表只有一行记录</p></li></ul><p>all -&gt; index -&gt; range -&gt; ref -&gt;const</p><h3 id="2-5-possible-keys"><a href="#2-5-possible-keys" class="headerlink" title="2.5 possible_keys"></a>2.5 possible_keys</h3><p>显示可能应用在这张表中的索引，一个或多个；查询涉及到的字段上若存在索引，则该索引将被列出，但是不一定被查询实际使用。</p><h3 id="2-6-key"><a href="#2-6-key" class="headerlink" title="2.6 key"></a>2.6 key</h3><p>实际使用的索引，如果为 null，则没有使用索引。</p><h3 id="2-3-key-len"><a href="#2-3-key-len" class="headerlink" title="2.3 key_len"></a>2.3 key_len</h3><p>索引中使用的字节数，在不损失精度的情况下，<strong>长度越短越好</strong></p><h3 id="2-4-ref"><a href="#2-4-ref" class="headerlink" title="2.4 ref"></a>2.4 ref</h3><p>显示索引的哪一列被使用了？</p><h3 id="2-5-rows"><a href="#2-5-rows" class="headerlink" title="2.5 rows"></a>2.5 rows</h3><p>大致估算找出所需记录需要读取的行数。不影响结果的情况下，越少越好。</p><h3 id="2-6-extra"><a href="#2-6-extra" class="headerlink" title="2.6 extra"></a>2.6 extra</h3><ul><li>using filesort：无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</li><li>using temporary：建立临时表来保存中间结果，查询完成之后把临时表删除</li><li>using index：当前查询走<strong>覆盖索引</strong>，不用回表。</li><li>using where：使用 where 进行条件过滤</li></ul><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><h3 id="3-1-索引优点"><a href="#3-1-索引优点" class="headerlink" title="3.1 索引优点"></a>3.1 索引优点</h3><ol><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机 IO 变成顺序 IO？</li></ol><h3 id="3-2-索引的用处"><a href="#3-2-索引的用处" class="headerlink" title="3.2 索引的用处"></a>3.2 索引的用处</h3><ol><li>快速查找匹配 where 字句的行</li><li>如果可以在多个索引中进行选择，会自动选择扫描最少行的索引</li><li>如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行</li><li>当有表连接的时候，从其他表检索行数据？</li><li>查找特定索引列的 min 或 max 值</li><li>如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组？</li><li>在某些情况下，可以优化查询以检索值而无需查询数据行。覆盖索引。</li></ol><h3 id="3-3-索引的分类"><a href="#3-3-索引的分类" class="headerlink" title="3.3 索引的分类"></a>3.3 索引的分类</h3><ol><li><p>主键索引</p></li><li><p>唯一索引</p></li><li><p>普通索引</p></li><li><p>全文索引</p></li><li><p>组合索引</p><p>注意索引的顺序会影响查询，同时需要考虑如何更好的满足排序和分组。</p><p>使用范围查询，可以走索引，但是范围查询后面的字段索引失效。</p></li></ol><h3 id="3-4-索引采用的数据结构"><a href="#3-4-索引采用的数据结构" class="headerlink" title="3.4 索引采用的数据结构"></a>3.4 索引采用的数据结构</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><ul><li>基于哈希表实现的索引，只有精确匹配索引所有列的查询才有效果</li><li>在 MySQL 中，只有 memory 的存储引擎显示支持哈希索引</li><li>哈希索引自身只需存储对应的 hash 值，所以所有结构十分紧凑，所以查找速度非常快</li></ul><p>哈希索引的限制：</p><ol><li><strong>无法覆盖索引：</strong>哈希索引中只包含哈希值和行指针，不存储字段值，索引肯定会回表，无法覆盖索引。</li><li><strong>无法排序：</strong>哈希索引数据不是按照索引值顺序存储的，无法进行排序</li><li><strong>无法部分列匹配查找：</strong>哈希索引不支持部分列匹配查找，哈希索引使用索引列的全部内容来计算哈希值</li><li><strong>无法范围查询：</strong>哈希索引支持等值比较查询。不支持任何范围查询</li><li><strong>哈希冲突问题：</strong>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有行指针，逐行进行比较，直到找到所有符合条件的行</li><li><strong>哈希冲突问题：</strong>哈希冲突比较多的话，维护的成本也会很高，因为链表很长。</li></ol><p><strong>如何避免 hash 冲突？</strong></p><ul><li>扰动函数</li><li>不要直接用 %？</li></ul><h4 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+ 树"></a>2. B+ 树</h4><p>二叉树</p><ul><li>不平衡</li><li>节点深</li></ul><p>二叉搜索树</p><p>平衡二叉树(AVL)</p><ul><li>查询速度块，修改、删除慢</li></ul><p>红黑树</p><ul><li>平衡修改、删除效率</li></ul><p>这些二叉树，最终都会由<strong>于节点过深导致 IO 次数过多</strong>，影响数据读取的效率，所以不合适。</p><p>B 树：</p><ol><li><p>所有键值分布在整棵树中</p></li><li><p>搜索有可能在非叶子节点结束</p></li><li><p>每个节点最多拥有 m 个子树</p></li><li><p>根节点至少有 2 个子树</p></li><li><p>分支节点至少拥有 m/2 棵子树</p></li><li><p>所有叶子节点都在同一层，每个节点最多可以有 m-1 个 key，并且以<strong>升序</strong>排列</p><p>每个节点都有 key，同时和包含 data，而每个页存储的空间是有限的，如果 data 比较大的话，会导致每个节点存储的 key 数量变小。大量空间用来存 data 了，三层的 B 数只能存 4096 kb 数据。</p></li></ol><p><strong>B+ 树</strong>：</p><p>对 B 树进行优化</p><ol><li>每个节点可以包含更多的节点，这样可以降低树的高度；将数据的范围变为多个区间，区间越多，数据检索越快</li><li>非叶子节点存储 key，叶子节点存储 key 和数据</li><li>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高</li></ol><p>B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点之间是一种链式环结构。因此可以对 B+ 树进行两种查询运算：1. 对于主键的范围查找和分页查找；2. 从根节点开始，进行随机查找。</p><p>InnoDB 是通过 B+ 树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键。</p><p><strong>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后通过主键索引找到对应的记录，叫做回表。</strong></p><h3 id="3-5-索引相关名词"><a href="#3-5-索引相关名词" class="headerlink" title="3.5 索引相关名词"></a>3.5 索引相关名词</h3><h4 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h4><p>普通索引叶子节点没有存行记录，存储的是主键。所以需要回去再找主键索引树，这就是回表。</p><h4 id="2-覆盖索引"><a href="#2-覆盖索引" class="headerlink" title="2. 覆盖索引"></a>2. 覆盖索引</h4><p>基本介绍：</p><ol><li><p>当查询的列在叶子节点已经有了，就不需要再查询一遍主键索引树了，这就是覆盖索引。</p></li><li><p>不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值。</p></li><li><p>不同的存储引擎实现覆盖索引的方式不同，Innodb 是叶子节点存了行数据，MyISam 叶子节点存的是内存地址。</p></li><li><p>不是所有的搜索引擎都支持覆盖索引，memory 不支持覆盖索引。</p></li></ol><p>优势：</p><ol><li>索引条目通常远小于数据行大小，覆盖索引只需要读取索引，所以可以极大减少数据的访问量，极大的减少 IO 访问。</li><li>一些存储引擎比如 MYISAM 在内存中只缓存索引，数组依赖操作系统来缓存，如果不走覆盖索引，访问数据需要调用系统调用，可能会导致严重性能问题。</li><li>InnoDB 为聚簇索引，覆盖索引对 InnoDB 的支持特别有用</li></ol><p>实际操作：</p><ol><li>explain 的 extra 的值为 <code>using index</code> 时表示使用了覆盖索引。</li></ol><h4 id="3-最左匹配"><a href="#3-最左匹配" class="headerlink" title="3. 最左匹配"></a>3. 最左匹配</h4><p>根据 name、age 建立组合索引。<code>where name = ? and age = ?</code> 可以匹配索引，但是 <code>where age = ？</code> 不会走索引。可以在建立组合索引时，name、age 互换。如果单独建立 name、age 两个索引，会涉及到索引合并优化。</p><h4 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4. 索引下推"></a>4. 索引下推</h4><p>取出索引的同时，<strong>判断是否可以进行where条件过滤再进行索引查询</strong>，也就是说提前执行 where 的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。 和 sql 查询的<strong>谓词下推</strong>类似， <strong>始终将过滤表达式尽可能移至靠近数据源的位置。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;title: MySql 调优(二)&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL&lt;br&gt;comments: true&lt;br&gt;toc: true&lt;br&gt;categories: MySQL&lt;br&gt;date: 2020-08-09 22:13:12&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;范式、主键、字符集、存储引擎、拆分的选择&lt;/li&gt;
&lt;li&gt;执行计划&lt;/li&gt;
&lt;li&gt;索引的数据结构和基本概念&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>学习的方法</title>
    <link href="http://yoursite.com/2020-08-05-%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>http://yoursite.com/2020-08-05-无关技术/学习的方法.html</id>
    <published>2020-08-05T14:13:12.000Z</published>
    <updated>2020-08-09T15:03:27.877Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习的陷阱</li><li>学习的方法</li></ul><a id="more"></a><h2 id="学习的陷阱"><a href="#学习的陷阱" class="headerlink" title="学习的陷阱"></a>学习的陷阱</h2><ol><li>追求广度，没有深度，新语言新技术学了一大堆，没有一个用得好；</li><li>代码行数论英雄，追求数量忽略质量；</li><li>大厂围城，错把平台赋能当个人能力，导致技术停滞；</li></ol><h2 id="学习的方法"><a href="#学习的方法" class="headerlink" title="学习的方法"></a>学习的方法</h2><p>1.了解全局<br>在学习时要进行一个全局的了解。弄清楚到底要学什么。</p><p>2.确定范围<br>集中精力去明确自己到底要学什么。<br>时间是前提。根据时间不同，范围不同，要切合时间。</p><p>3.定义目标<br>在全力以赴启动学习前，要明确成功的含义；<br>在尝试学习任何东西之前，自己的脑海中都应该清楚地描绘出成功的样子。<br>具体的，无二义性的。可以制作出一套开源，并且精美的后台框架。</p><p>4.寻找资源<br>寻找资源的时候要尝试收集到多种多样的资源，而不只是读一本关于这个主题的书，<br>资源可以是多种多样的不局限书籍来源。</p><p>5.创建学习计划<br>学习是一个自然的过程，从而A到B，最后达到Z，你需要找出一个最短的时间从A到Z的正确路径。</p><p>6.筛选资源<br>有了学习资料和学习计划后，接下来就可以对这些资料或者是资源进行一个个筛选，<br>挑选最有价值的几项来帮助你实现自己的学习目标就可以啦。</p><p>7.开始学习 浅尝辄止<br>要专注于自己需要的知识技能，能在下一步动手操作最小的那一部分知识</p><p>8.动手操作 边学边玩<br>学习中最重要的一步。比如工作原理、这么做会产生什么问题、应该如何解决这些问题等。</p><p>9.全面掌握 学以致用<br>需要一个真实有用、能反复迭代的项目。将内容和目标关联起来。<br>碰到技术难题不要灰心，继续在这块知识领域深耕</p><p>10.乐为人师 融会贯通<br>将自己学会的知识传授与人的过程就是深入理解知识、内化于自己的思想的重要过程。</p><p>1-6步主要目的是研究，不用反复，7-10步要反复</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;学习的陷阱&lt;/li&gt;
&lt;li&gt;学习的方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="无关技术" scheme="http://yoursite.com/categories/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="无关技术" scheme="http://yoursite.com/tags/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(一)</title>
    <link href="http://yoursite.com/2020-08-05-mysql/mysql_1.html"/>
    <id>http://yoursite.com/2020-08-05-mysql/mysql_1.html</id>
    <published>2020-08-05T14:13:12.000Z</published>
    <updated>2020-08-31T14:23:42.563Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Mysql 基本架构</li><li>性能监控</li><li>数据类型的优化</li></ul><a id="more"></a><h2 id="0-MySql-的基本架构"><a href="#0-MySql-的基本架构" class="headerlink" title="0. MySql 的基本架构"></a>0. MySql 的基本架构</h2><p><img src="../../images/mysql/1/mysql架构.png" alt=""></p><h2 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h2><h3 id="1-1-profiles、profile"><a href="#1-1-profiles、profile" class="headerlink" title="1.1 profiles、profile"></a>1.1 profiles、profile</h3><p>查看 sql 消耗的时间、cpu、io 等信息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 设置后，show profiles 才有显示</div><div class="line"><span class="keyword">set</span> profiling = <span class="number">1</span>;</div><div class="line"># 业务查询语句</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mylock;</div><div class="line"># 查看 sql 查询总耗时</div><div class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</div><div class="line"># 查看详细耗时</div><div class="line"><span class="keyword">show</span> profile;</div><div class="line"># 查看指定 sql</div><div class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">2</span>;</div><div class="line"># cpu 信息也展示出来</div><div class="line"><span class="keyword">show</span> profile cpu;</div><div class="line"># 展示所有</div><div class="line"><span class="keyword">show</span> profile all;</div><div class="line"># 官网地址：SQL Statements -&gt; Database Administration Statements -&gt; SHOW Statements</div></pre></td></tr></table></figure><p>问题：java 执行的 sql 好像监控不到</p><h3 id="1-2-performance-schema"><a href="#1-2-performance-schema" class="headerlink" title="1.2 performance_schema"></a>1.2 performance_schema</h3><p>数据不会持久化。每次重启 mysql 服务后会清空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 查看是否开启</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'performance_schema'</span>;</div><div class="line"></div><div class="line"># 语句事件记录表。当前语句、历史语句、聚合信息</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%statement%'</span>;</div><div class="line"></div><div class="line"># 等待事件记录表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%wait%'</span>;</div><div class="line"></div><div class="line"># 事务事件记录表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%transaction%'</span>;</div><div class="line"></div><div class="line"># 监控文件系统层调用</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%file%'</span>;</div><div class="line"></div><div class="line"># 配置表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%setup%'</span>;</div><div class="line"></div><div class="line"># 有些 instruments 和 consumers 默认没有启动，需要手动开启</div><div class="line">## 比如，开启等待事件监控功能</div><div class="line"><span class="keyword">UPDATE</span> setup_instruments <span class="keyword">SET</span> ENABLED = <span class="string">'YES'</span>, TIMED = <span class="string">'YES'</span><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'wait%'</span>;</div><div class="line"><span class="keyword">UPDATE</span> setup_consumers <span class="keyword">SET</span> ENABLED = <span class="string">'YES'</span><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%wait%'</span>;</div><div class="line"></div><div class="line"># 查看相关的一些系统变量</div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%performance_schema%'</span>;</div></pre></td></tr></table></figure><h3 id="1-3-show-processlist"><a href="#1-3-show-processlist" class="headerlink" title="1.3 show processlist"></a>1.3 show processlist</h3><p>查看连接的线程个数，观察是否有大量线程处于不正常的状态或者其他不正常的特征。</p><h2 id="2-schema-与数据类型优化"><a href="#2-schema-与数据类型优化" class="headerlink" title="2. schema 与数据类型优化"></a>2. schema 与数据类型优化</h2><h3 id="2-1-数据类型的优化"><a href="#2-1-数据类型的优化" class="headerlink" title="2.1 数据类型的优化"></a>2.1 数据类型的优化</h3><h4 id="长度越小越好"><a href="#长度越小越好" class="headerlink" title="长度越小越好"></a>长度越小越好</h4><p>尽量使用可以正确存储数据的最小数据类型，越小的数据类型占用更少的磁盘空间、内存和 CPU 缓存，并且处理时需要的 CPU 周期更少。</p><h4 id="类型越简单越好"><a href="#类型越简单越好" class="headerlink" title="类型越简单越好"></a>类型越简单越好</h4><ol><li>整型比字符操作代价更低</li><li>使用自建类型来存储日期和时间，而不是字符串</li><li>使用整型来存储 IP 地址，而不是字符串</li></ol><h4 id="尽量避免-null"><a href="#尽量避免-null" class="headerlink" title="尽量避免 null"></a>尽量避免 null</h4><p>​    null 列对 mysql 来说很难优化，因为可为 null 的列使得索引、索引统计和值比较都更加复杂。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><p>整数类型： TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。  尽量使用满足需求的最小数据类型 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 1 2 3 4 8 = 18 字节</span></div><div class="line"><span class="comment">-- 长度没有限制作用</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> int_test(a tinyint(<span class="number">2</span>), b <span class="built_in">smallint</span>(<span class="number">2</span>), c mediumint, d <span class="built_in">int</span>, e <span class="built_in">bigint</span>);</div><div class="line">tinyint:-128(10000000)~127(01111111)</div></pre></td></tr></table></figure></li><li><p>字符和字符串类型</p><ul><li>char：长度固定；最长 255 字符；适用于身份证号、手机号、摘要算法等定长字符串</li><li>varchar：长度可变；可以设置最大长度；最大空间 65535 个字节；适用于长度变化频繁、多字节字符（汉字、特殊字符）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- char、varchar 指定长度后，不能超过该长度</span></div><div class="line"><span class="comment">-- char 不指定长度，默认为 1</span></div><div class="line"><span class="comment">-- varchar 必须指定长度，否则建表失败</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> char_test(a <span class="built_in">char</span>(<span class="number">4</span>), b <span class="built_in">char</span>, c <span class="built_in">varchar</span>(<span class="number">4</span>), d <span class="built_in">varchar</span>(<span class="number">20</span>));</div></pre></td></tr></table></figure></li><li><p>datetime 和 timestamp</p><ul><li>datetime：占用 8 个字节；存储方式与时区无关；时间范围（100000101-99991231）精确到毫秒；</li><li>timestamp：占用 4 个字节；存储方式依赖数据库时区，时区变化，数据会变；时间范围（19700101-20380119）；精确到毫秒；更适合于 跨时区的业务。</li><li>date：占用 3 个字节；时间范围（10000101-99991231）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> date_test(a datetime, a1 datetime(<span class="number">6</span>),b <span class="keyword">timestamp</span>, b1 <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="literal">null</span> <span class="keyword">default</span> <span class="literal">null</span>,c <span class="built_in">date</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> date_test <span class="keyword">values</span>(<span class="keyword">now</span>(),<span class="keyword">now</span>(<span class="number">6</span>),<span class="keyword">now</span>(),<span class="string">'20200808121212.123'</span>,<span class="keyword">now</span>());</div><div class="line"></div><div class="line">mysql&gt; select * from date_test\G</div><div class="line">*************************** 1. row ***************************</div><div class="line"> a: 2020-08-29 21:45:55</div><div class="line">a1: 2020-08-29 21:45:55.862122</div><div class="line"> b: 2020-08-29 21:45:55</div><div class="line">b1: 2020-08-08 12:12:12.123</div><div class="line"> c: 2020-08-29</div></pre></td></tr></table></figure></li><li><p>使用枚举代替字符串类型</p><ul><li>mysql 会根据枚举值把数据压缩到一个或两个字节中，内部会将每个值在列表中的位置保存为<strong>整数</strong>。并且在表的 <code>.frm</code> 文件中保存“数字-字符串”映射关系的查找表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`enum_test`</span>  (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`e`</span> enum(<span class="string">'男'</span>,<span class="string">'女'</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`enum_test`</span>(e) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="number">2</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`enum_test`</span>(e) <span class="keyword">VALUES</span>(<span class="string">'男'</span>),(<span class="string">'女'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`enum_test`</span>(e) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="string">'1'</span>),(<span class="string">'女'</span>);</div><div class="line"></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> enum_test;</div><div class="line"><span class="keyword">select</span> e+<span class="number">1</span> <span class="keyword">from</span> enum_test;</div></pre></td></tr></table></figure></li><li><p>使用 <code>int(32) unsigned</code> 来存 ip 地址，因为 ip 地址本来就是 32 位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> ip_test(host <span class="built_in">int</span>(<span class="number">32</span>) <span class="keyword">unsigned</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ip_test <span class="keyword">values</span>(<span class="keyword">inet_aton</span>(<span class="string">'192.168.238.68'</span>));</div><div class="line"><span class="keyword">select</span> <span class="keyword">inet_ntoa</span>(host) <span class="keyword">from</span> ip_test;</div></pre></td></tr></table></figure></li></ul><h2 id="3-二进制"><a href="#3-二进制" class="headerlink" title="3. 二进制"></a>3. 二进制</h2><p>1、byte 占用一个字节， 8 位，对于计算机来说表数范围为 0000 0000 ~ 1111 1111</p><p>2、最高位表示符号位</p><p>3、计算机用补码表数</p><p>4、正数和 0 的补码 = 源码</p><p>5、负数的补码 = 其对应正数按位取反 + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binVal4 =<span class="number">0B10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">// 的值为？</span></div><div class="line"><span class="comment">// 1. int 类型 32 位，高位为 1，所以是个负数</span></div><div class="line"><span class="comment">// 2. 该负数对应正数按位取反的值 = 0B10000000 00000000 00000000 00000011 - 1</span></div><div class="line">    = <span class="number">0B10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000010</span></div><div class="line"><span class="comment">// 3. 该负数对应正数 = OB01111111 11111111 11111111 11111101      </span></div><div class="line"><span class="comment">// 4. 该负数 = OB11111111 11111111 11111111 11111101</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// byte 类型，-127 的补码？</span></div><div class="line"><span class="comment">// 1. 127 的源码 = 0111 1111</span></div><div class="line"><span class="comment">// 2. 127 的源码按位取反 = 1000 0000</span></div><div class="line"><span class="comment">// 3. 127 的源码按位取反 + 1 = 1000 0001</span></div><div class="line"></div><div class="line"><span class="comment">// byte 类型，-128 的补码？</span></div><div class="line"><span class="comment">// 1. 128 的源码 = 1000 0000</span></div><div class="line"><span class="comment">// 2. 128 的源码按位取反 = 0111 1111</span></div><div class="line"><span class="comment">// 3. 128 的源码按位取反 + 1 = 1000 0000</span></div><div class="line"></div><div class="line"><span class="comment">// byte 类型，-129 的补码？</span></div><div class="line"><span class="comment">// 1. 129 的源码 = 1000 0001</span></div><div class="line"><span class="comment">// 2. 129 的源码按位取反 = 0111 1110</span></div><div class="line"><span class="comment">// 3. 129 的源码按位取反 + 1 = 0111 1111</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Mysql 基本架构&lt;/li&gt;
&lt;li&gt;性能监控&lt;/li&gt;
&lt;li&gt;数据类型的优化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-07-26-jvm/jvm%E5%AD%A6%E4%B9%A011_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-07-26-jvm/jvm学习11_面试问题.html</id>
    <published>2020-07-26T12:22:06.288Z</published>
    <updated>2020-08-05T12:16:09.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-命令汇总"><a href="#1-命令汇总" class="headerlink" title="1. 命令汇总"></a>1. 命令汇总</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 设定 GC 日志参数(只记录 GC 的)</span></div><div class="line">java -Xms200M -Xmx200M -Xloggc:/root/testJvm/logs/T15_FullGC_Problem01-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails T15_FullGC_Problem01</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程</span></div><div class="line">top</div><div class="line"><span class="meta">#</span><span class="bash"> 定位具体程序</span></div><div class="line">jps</div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程中哪个线程</span></div><div class="line">top -Hp 2234</div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程所有线程详细信息</span></div><div class="line">jstack -l 2234</div><div class="line"><span class="meta">#</span><span class="bash"> 进程号转 16 进制</span></div><div class="line">printf "%x\n" 2407</div><div class="line">jstack 2234|grep 967 -A 3</div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程中线程个数</span></div><div class="line">jstack -l 2539 | grep "java.lang.Thread.State" | wc -l</div><div class="line">jstat -gc 2599 500</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-命令汇总&quot;&gt;&lt;a href=&quot;#1-命令汇总&quot; class=&quot;headerlink&quot; title=&quot;1. 命令汇总&quot;&gt;&lt;/a&gt;1. 命令汇总&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM 学习（十一）</title>
    <link href="http://yoursite.com/2020-07-24-jvm/jvm%E5%AD%A6%E4%B9%A011_jvm%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93.html"/>
    <id>http://yoursite.com/2020-07-24-jvm/jvm学习11_jvm常见参数总结.html</id>
    <published>2020-07-24T14:13:12.000Z</published>
    <updated>2020-07-24T16:53:25.400Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 常见参数总结。</p><a id="more"></a><h2 id="1-CMS-的日志格式"><a href="#1-CMS-的日志格式" class="headerlink" title="1. CMS 的日志格式"></a>1. CMS 的日志格式</h2><p><code>java -Xms20M -Xms20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC T15_FullGC_Problem01</code></p><p>[GC (Allocation Failure) [ParNew: 5504K-&gt;640K(6144K), 0.0361611 secs] 5504K-&gt;1085K(19840K), 0.0362611 secs] [Times: user=0.01 sys=0.02, real=0.03 secs] </p><blockquote><p>ParNew：年轻代收集器</p><p>5504K-&gt;640K：收集前后的对比</p><p>(6144K)：整个年轻代容量</p><p>5504K-&gt;1085K：整个堆情况</p><p>(19840K)：整个堆大小</p></blockquote><p>[GC (CMS Initial Mark) [1 CMS-initial-mark: 8362K(13696K)] 9696K(19840K), 0.0223401 secs] [Times: user=0.00 sys=0.03, real=0.02 secs] </p><blockquote><p>8362K(13696K)：老年代已经使用（老年代最大空间）</p><p>9696K(19840K)：整个堆使用（最大）</p></blockquote><p>[CMS-concurrent-mark-start]<br>[CMS-concurrent-mark: 0.037/0.037 secs] [Times: user=0.01 sys=0.02, real=0.04 secs] </p><blockquote><p>这里的时间意义不大，因为是并发执行</p></blockquote><p>[CMS-concurrent-preclean-start]<br>[CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </p><blockquote><p>标记 Card 为 Dirty，也称为 Card Marking</p></blockquote><p>[GC (CMS Final Remark)  [YG occupancy: 1653 K (6144 K)] [Rescan (parallel) , 0.0036149 secs] [weak refs processing, 0.0000216 secs] [class unloading, 0.0023396 secs] [scrub symbol table, 0.0005398 secs]  [scrub string table, 0.0008483 secs] [1 CMS-remark: 8362K(13696K)] 10016K(19840K), 0.0080645 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </p><blockquote><p>最终（重新）标记</p><p>STW  阶段。YG occupancy：年轻代占用及容量</p><p>Rescan (parallel) ：STW 下的存活对象标记</p><p>weak refs processing：弱引用处理</p><p>class unloading：卸载用不到的 class（对  metaspace、pengrem 的回收）</p><p>scrub symbol table：</p><p>​    由于前面有一些 class 卸载了，有一些指向这些 class 的常量也可以处理掉</p><p>CMS-remark: 8362K(13696K)：阶段过后的老年代占用容量</p><p>10016K(19840K)：阶段过后的堆占用以及容量</p></blockquote><p>[CMS-concurrent-sweep-start]<br>[CMS-concurrent-sweep: 0.005/0.005 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </p><blockquote><p>标记已经完成了，开始进行并发清理</p></blockquote><p>[CMS-concurrent-reset-start]<br>[CMS-concurrent-reset: 0.019/0.019 secs] [Times: user=0.00 sys=0.02, real=0.02 secs] </p><blockquote><p>重置内部结构，为下次 GC 做准备</p></blockquote><h2 id="2-G1-的日志格式（1-8-开始基本成熟）"><a href="#2-G1-的日志格式（1-8-开始基本成熟）" class="headerlink" title="2. G1 的日志格式（1.8 开始基本成熟）"></a>2. G1 的日志格式（1.8 开始基本成熟）</h2><p>PS+PO、PN+CMS 都要指定 young 区大小（-xmn），不指定也会有一个默认比例。但是 G1 不推荐指定 young 区大小，因为 G1 会进行动态调整（可以设定范围区间），调整的依据就是 YGC STW 时间。</p><p><code>java -Xms20M -Xms20M -XX:+PrintGCDetails -XX:+UseG1GC T15_FullGC_Problem01</code></p><p>G1 调优目标：不要 FullGC(SerialOld）</p><p>CMS目标：不要 FullGC(SerialOld）</p><p>[GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0247906 secs]<br>   [Parallel Time: 24.4 ms, GC Workers: 1]<br>      [GC Worker Start (ms):  59371.3]<br>      [Ext Root Scanning (ms):  0.9]<br>      [Update RS (ms):  10.8]<br>         [Processed Buffers:  55]<br>      [Scan RS (ms):  0.5]<br>      [Code Root Scanning (ms):  0.0]<br>      [Object Copy (ms):  12.1]<br>      [Termination (ms):  0.0]<br>         [Termination Attempts:  1]<br>      [GC Worker Other (ms):  0.0]<br>      [GC Worker Total (ms):  24.4]<br>      [GC Worker End (ms):  59395.7]<br>   [Code Root Fixup: 0.0 ms]<br>   [Code Root Purge: 0.0 ms]<br>   [Clear CT: 0.0 ms]<br>   [Other: 0.4 ms]<br>      [Choose CSet: 0.0 ms]<br>      [Ref Proc: 0.0 ms]<br>      [Ref Enq: 0.0 ms]<br>      [Redirty Cards: 0.0 ms]<br>      [Humongous Register: 0.0 ms]<br>      [Humongous Reclaim: 0.0 ms]<br>      [Free CSet: 0.0 ms]<br>   [Eden: 3072.0K(3072.0K)-&gt;0.0B(2048.0K) Survivors: 1024.0K-&gt;1024.0K Heap: 15.5M(20.0M)-&gt;14.0M(20.0M)]<br> [Times: user=0.03 sys=0.00, real=0.02 secs]</p><blockquote><p>young：年轻代 </p><p>Evacuation：复制存活对象</p><p>initial-mark：混合回收的阶段，这里是 YGC 混合老年代回收（MixedGC）</p></blockquote><p>[GC concurrent-root-region-scan-start]<br>[GC concurrent-root-region-scan-end, 0.0253766 secs]<br>[GC concurrent-mark-start]</p><blockquote><p>混合回收的其他阶段</p><p>无法进行  evacuation，进行 FGC</p><p>G1 中如果出现 FGC 是很可怕的事情，应该要排查问题了，很可能存在内存泄漏了。</p></blockquote><h2 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3. 常用参数"></a>3. 常用参数</h2><h3 id="3-1-通用参数"><a href="#3-1-通用参数" class="headerlink" title="3.1 通用参数"></a>3.1 通用参数</h3><ul><li><p>-Xmn -Xms -Xmx -Xss</p><p>年轻代 最小堆 最大堆 栈空间</p></li><li><p>-XX:+UseTLAB</p><p>使用 TLAB，默认打开</p></li><li><p>-XX:+PrintTLAB</p><p>打印 TLAB 的使用情况</p></li><li><p>-XX:TLABSize</p><p>设置 TLAB 大小</p></li><li><p>-XX:+DisableExplictGC</p><p>System.gc() 不管用(FGC)</p></li><li><p>-XX:+PrintGC</p></li><li><p>-XX:+PrintGCDetails</p></li><li><p>-XX:+PrintHeapAtGC</p></li><li><p>-XX:+PrintGCTimeStamps</p></li><li><p>-XX:+PrintGCApplicationConcurrentTime(低)</p><p>打印应用程序时间</p></li><li><p>-XX:+PrintGCApplicationStoppedTime（低）</p><p>打印暂停时长</p></li><li><p>-XX:+PrintReferenceGC(重要性低)</p><p>记录回收了多少种不同引用类型的引用</p></li><li><p>-verbose:class</p><p>类加载详细过程</p></li><li><p>-XX:+PrintVMOptions</p></li><li><p>-XX:+PrintFlagsFinal  -XX:+PrintFlagsInitial</p><p><strong>必须会用</strong>。比如查看 G1 相关参数</p><p>java -XX:+PrintFlagsFinal -version | grep G1</p></li><li><p>-Xloggc:/opt/log/gc.log</p></li><li><p>-XX:MaxTenuringThreshold</p><p>GC 升代年龄，最大值 15。CMS 默认 6，其他默认 15</p></li><li><p>锁自旋次数 -XX:PreBlockSpin 热点代码检测参数 -XX:CompileThreshold 逃逸分析 标量替换</p><p>这些不建议设置</p></li></ul><h3 id="3-2-Parallel-常用参数"><a href="#3-2-Parallel-常用参数" class="headerlink" title="3.2 Parallel 常用参数"></a>3.2 Parallel 常用参数</h3><ul><li><p>-XX:SurvivorRatio：survivor 区比例。默认 8:1:1</p></li><li><p>-XX:PreTenureSizeThreshold</p><p>大对象到底多大。超过这个参数，直接分配到 old 区</p></li><li><p>-XX:MaxTenuringThresholdd</p></li><li><p>-XX:+ParallelGCThreads</p><p>并行收集器 的线程数，同样 适用于 CMS，一般设置为和 CPU 核数相同</p></li><li><p>-XX:+UseAdaptiveSizePolicy</p><p>自动选择各区大小比例</p></li></ul><h3 id="3-3-CMS-常用参数"><a href="#3-3-CMS-常用参数" class="headerlink" title="3.3 CMS 常用参数"></a>3.3 CMS 常用参数</h3><ul><li><p>-XX:+UseConcMarkSweepGC</p></li><li><p>-XX:ParallelCMSThreads</p><p>CMS 线程数量，一般为线程的一半。不能设置太大把 CPU 全部占用了，那就相当于 STW 了。</p></li><li><p>-XX:CMSInitiatingOccupancyFaction</p><p>使用多少比例的老年代后开始 CMS 收集，默认是 68%（近似值）。如果频繁发生 SerialOld 卡顿，应该调小这个参数（调小后会频繁 CMS 回收，但也没办法）。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection</p><p>在 FGC 时进行压缩</p></li><li><p>-XX:CMSFullGCsBeforeCompaction</p><p>多少次 FGC 之后进行压缩</p></li><li><p>-XX:+CMSClassUnloadingEnabled （1.8 之前）</p><p>回收 metaspace、perm</p></li><li><p>-XX:+CMSInitiatingPermOccupancyFraction（1.8 之前）</p><p>达到什么比例时进行 Perm 回收</p></li><li><p>GCTimeRatio</p><p>设置 GC 时间占用程序运行时间的百分比</p></li><li><p>-XX:MaxGCPauseMillis</p><p>停顿时间，是一个建议时间，GC 会尝试用各种手段达到这个时间，比如减小年轻代空间</p></li></ul><h3 id="3-4-G1-常用参数"><a href="#3-4-G1-常用参数" class="headerlink" title="3.4 G1 常用参数"></a>3.4 G1 常用参数</h3><ul><li><p>-XX:+UseG1GC</p></li><li><p>-XX:MaxGCPauseMillis</p><p>建议值，G1 会尝试调整 young 区的块数来达到这个值</p></li><li><p>-XX:GCPauseIntervalMillis</p><p>? GC 的间隔时间</p></li><li><p>-XX:+G1HeapRegionSize</p><p>分区大小，建议逐渐增大该值，1 2 4 8 16 32，需要实际调整，看多大适合。</p><p>随着 size 增加，垃圾存活时间更长，GC 间隔更长，但每次 GC 的时间也会更长。</p><p>ZGC 做了改进（动态区块大小）</p></li><li><p>G1NewSizePercent</p><p>新生代最小比例，默认为 5%</p></li><li><p>G1MaxNewSizePercent</p><p>新生代最小比例，默认为60%</p></li><li><p>GCTimeRatio</p><p>GC 时间建议比例，G1 会根据这个值调整堆空间比例</p></li><li><p>ConcGCThreads</p><p>线程数量</p></li><li><p>InitiatingHeapOccupancyPercent</p><p>启动 G1 的堆空间占用比例</p></li></ul><h2 id="4-作业"><a href="#4-作业" class="headerlink" title="4. 作业"></a>4. 作业</h2><h2 id="5-纤程-协程"><a href="#5-纤程-协程" class="headerlink" title="5. 纤程/协程"></a>5. 纤程/协程</h2><p>程序 进程 线程 纤程</p><p>一个线程内部分多条路径，就是纤程。</p><p>栈的记录和切换。</p><p>线程启动需要调用内核，线程的并发比较重量级，线程间切换消耗的资源也比较多。</p><p>纤程和线程类似，也是栈结构切换，操作也会调用内核，但是纤程之间的切换是在用户空间完成。</p><p>启动一个线程大概需要 1m 内存，所以操作系统支撑不了多少线程。</p><p>纤程的数量可以比线程多很多。</p><p>-javaagent:D:\maven-rep\co\paralleluniverse\quasar-core\0.8.0\quasar-core-0.8.0.jar</p><p>目前 java 不持支，适用 agent 代理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 常见参数总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（十）</title>
    <link href="http://yoursite.com/2020-07-23-jvm/jvm%E5%AD%A6%E4%B9%A0%2010_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.html"/>
    <id>http://yoursite.com/2020-07-23-jvm/jvm学习 10_垃圾回收算法.html</id>
    <published>2020-07-23T14:13:12.000Z</published>
    <updated>2020-07-24T12:59:42.809Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收算法</p><a id="more"></a><h2 id="1-CMS"><a href="#1-CMS" class="headerlink" title="1. CMS"></a>1. CMS</h2><p>如果用的 PN + CMS，你的调优目标就是尽量避免 FGC，但从本质上来说是无法避免的。</p><h3 id="1-1-四个阶段"><a href="#1-1-四个阶段" class="headerlink" title="1.1 四个阶段"></a>1.1 四个阶段</h3><p>如果细分，会有六个节点，就是初始标记之前还有一些准备阶段。</p><h3 id="1-1-1-CMS-initial-mark"><a href="#1-1-1-CMS-initial-mark" class="headerlink" title="1.1.1 CMS initial mark"></a>1.1.1 CMS initial mark</h3><p>只标记根对象，所以 <strong>STW</strong> 很短。</p><p><img src="../../images/jvm/10/CMS初始标记.png" alt=""></p><h3 id="1-1-2-CMS-concurrent-mark"><a href="#1-1-2-CMS-concurrent-mark" class="headerlink" title="1.1.2 CMS concurrent mark"></a>1.1.2 CMS concurrent mark</h3><p>并发标记，标记根节点下面的所有对象。是最耗时的阶段，但是并发执行，<strong>不产生 STW</strong>，保证应用程序的响应时间。</p><p><img src="../../images/jvm/10/CMS并发标记.png" alt=""></p><h3 id="1-1-3-CMS-remark"><a href="#1-1-3-CMS-remark" class="headerlink" title="1.1.3 CMS remark"></a>1.1.3 CMS remark</h3><p>重新标记，标记 concurrent mark 过程中新产生的垃圾，或者垃圾变得有用了。由于新的改动一般不是很多，所以虽然该阶段也<strong>有 STW</strong>，但是影响不大。</p><p><img src="../../images/jvm/10/CMS重新标记.png" alt=""></p><h3 id="1-1-4-CMS-concurrent-sweep"><a href="#1-1-4-CMS-concurrent-sweep" class="headerlink" title="1.1.4 CMS concurrent sweep"></a>1.1.4 CMS concurrent sweep</h3><p>并发清理，把标记好的垃圾擦除。</p><p>这个阶段过程中产生的垃圾叫做浮动垃圾，下次回收再做处理。</p><p>ParNew 和 PS 哪一个更快？</p><p>采用何种类型 GC</p><ul><li>如何确定系统使用<strong>吞吐量优先</strong>的 GC 还是 <strong>反应时间优先</strong> 的 GC？</li></ul><p>如果采用 ParNew + CMS </p><ul><li>怎么做才能够让系统基本不产生 FGC？</li></ul><h2 id="2-G1"><a href="#2-G1" class="headerlink" title="2. G1"></a>2. G1</h2><h3 id="2-1-G1-入门"><a href="#2-1-G1-入门" class="headerlink" title="2.1 G1 入门"></a>2.1 G1 入门</h3><p><a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html" target="_blank" rel="external">https://www.oracle.com/technical-resources/articles/java/g1gc.html</a></p><blockquote><p> The <a href="https://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html" target="_blank" rel="external">Garbage First Garbage Collector (G1 GC)</a> is the low-pause, server-style generational garbage collector for Java HotSpot VM. The G1 GC uses concurrent and parallel phases to achieve its target pause time and to maintain good throughput. When G1 GC determines that a garbage collection is necessary, it collects the regions with the least live data first (garbage first). </p></blockquote><p>least live data 最少存活对象，也就是最多垃圾对象，这也是 garbage first（<strong>垃圾优先</strong>） 概念的由来。</p><p>吞吐量和 PS 相比降低了 10%-15%，但是停顿时间能达到 200ms。如果你想要你的应用程序不管怎么样，200ms 内有响应，那么就应该用 G1，如果应用程序追求 throughput，那么用 PS。</p><p>以前的分代模型，在物理上也分代，就是说有两块连续的物理内存，当内存不断增大，怎么处理都会消耗较多时间。</p><p>G1 采用<strong>分而治之</strong>的思想。分而治之和分层是设计架构上的两大思想。</p><p><img src="../../images/jvm/10/G1模型.png" alt=""></p><p><img src="../../images/jvm/10/G1模型2.png" alt=""></p><h3 id="2-2-G1-特点"><a href="#2-2-G1-特点" class="headerlink" title="2.2 G1 特点"></a>2.2 G1 特点</h3><ul><li>并发收集</li><li>压缩空闲空间不会延长 GC 的暂停时间</li><li>更易预测的 GC 暂停时间</li><li>适用于不需要实现很高的吞吐量，但是需要特别快的响应时间的场景</li><li>G1 的内存区域不是固定的 E 或者 O，而是灵活的</li></ul><p>CMS、G1：<strong>三色标记</strong></p><p>​    三色标记是指把对象分为三个不同颜色。每个颜色表示该对象是否标记过、标记一半、完全没有标记。</p><p>ZGC、SHAN：<strong>颜色指针</strong>（colored pointers）</p><p>​    在 JVM 中如果不做压缩，一个指针 64 位，在这 64 位中，拿出 3 位进行标记。当指针从指向一个位置变为指向另外一个位置，这三位随之变化，这样子在进行垃圾回收时，jvm 就知道这个指针变过了，垃圾回收时会<strong>扫描变化过的指针</strong>，所以叫做颜色指针。</p><h3 id="2-3-基本概念"><a href="#2-3-基本概念" class="headerlink" title="2.3 基本概念"></a>2.3 基本概念</h3><ul><li><p>CSet = Collection Set</p><p>一组可被回收的分区的集合，记录哪些 card 需要回收。</p><p>在 CSet 中存活的数据会在 GC 过程中被移动到另一个可用分区，CSet 中的分区可以来自 Eden 空间、Survivor 空间、或者老年代。</p><p>CSet 会占用不到整个堆空间的 1% 大小</p></li><li><p>RSet = RememberedSet。G1 高效回收的关键。</p><p>记录了其他 Region 中的<strong>对象</strong>到本 Region 的引用。即记录有没有其他分区引用了该分区的对象，如果没有直接干掉，如果有，具体引用了哪个对象。</p><p>RSet 的价值在于使得垃圾收集器不需要扫描整个堆来找到谁引用了当前分区中的对象，只需要扫描 RSet 即可。</p><p>由于 RSet 的存在，那么每次给对象赋引用的时候，就得做一些额外的操作。就是在 RSet 中做一些额外的记录。（在 GC 中被称为写屏障，这个写屏障不等于内存屏障）</p></li><li><p>Card table（<strong>GC 算法无关</strong>）</p><p>由于做 YGC 时，需要扫描整个 Old 区，效率非常低，所以 JVM 设计了 CardTable，如果一个 Old 区 CardTable 中有对象指向 Y 区，就将它在<strong>位图</strong>中设置为 Dirty，下次扫描时，只需要扫描 Dirty Card。在结构上，Card Table 用 BitMap 来实现。</p></li></ul><p>阿里的多租户 JVM</p><ul><li><p>每租户单空间</p></li><li><p>session based GC（专门针对 web application）</p><p>随着 session 的结束，对象随着回收。</p></li></ul><h3 id="2-4-Why-G1"><a href="#2-4-Why-G1" class="headerlink" title="2.4 Why G1"></a>2.4 Why G1</h3><ul><li>追求吞吐量<ul><li>100 cpu</li><li>99 app 1GC</li><li>吞吐量 = 99%</li></ul></li><li>追求响应时间<ul><li>XX:MaxGCPauseMillis 200</li><li>对 STW 进行控制</li></ul></li><li>灵活<ul><li>分 Region 回收</li><li>优先回收<strong>花费时间少、垃圾占比高</strong>的 Region</li></ul></li></ul><h3 id="2-5-每个-Region-有多大"><a href="#2-5-每个-Region-有多大" class="headerlink" title="2.5 每个 Region 有多大"></a>2.5 每个 Region 有多大</h3><ul><li>headpRegion.cpp</li><li>取值<ul><li>1 2 4 8 16 32</li></ul></li><li>手工指定<ul><li>XX：G1HeapRegionSize</li></ul></li></ul><h3 id="2-6-新老年代比例"><a href="#2-6-新老年代比例" class="headerlink" title="2.6 新老年代比例"></a>2.6 新老年代比例</h3><ul><li>5%-60% 动态<ul><li>一般不用手工指定</li><li>也不要手工指定，因为这是 G1 预测停顿时间的基准</li></ul></li></ul><h3 id="2-7-humongous-object"><a href="#2-7-humongous-object" class="headerlink" title="2.7 humongous object"></a>2.7 humongous object</h3><ul><li><p>超过单个 region 的 50%。可能跨越多个 region</p><h3 id="2-8-GC-何时触发"><a href="#2-8-GC-何时触发" class="headerlink" title="2.8 GC 何时触发"></a>2.8 GC 何时触发</h3></li><li><p>YGC</p><ul><li>Eden 空间不足</li><li>多线程并行执行</li></ul></li><li><p>FGC</p><ul><li>Old 空间不足</li><li>System.gc()</li></ul><p>G1 产生 FGC 应该做什么</p></li><li><p>扩内存</p></li><li><p>提高 CPU 性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大）</p></li><li><p>降低 MixedGC 触发的阈值，让 MixedGC 提早发生（默认是对象达到整个堆的 45% 是触发）。MixedGC 既会回收年轻代也会回收老年代，哪个满了回收哪个。</p><p>目的是为了让 MixedGC 提早发生，今早回收垃圾，从而尽量减少或者避免 FullGC，G1 的 fullGC 也是 serial 的。</p></li></ul><h3 id="2-9-G1-中的-MixedGC"><a href="#2-9-G1-中的-MixedGC" class="headerlink" title="2.9 G1 中的 MixedGC"></a>2.9 G1 中的 MixedGC</h3><p>相当于 CMS</p><ul><li>XX:InitialtingHeapOccupacyPercent<ul><li>默认值 45%</li><li>当 O 超过这个值时，启动 MixedGC</li></ul></li></ul><p>MixedGC 的过程</p><ul><li><p>初始标记 STW</p></li><li><p>并发标记</p></li><li><p>最终标记 STW（重新标记）</p></li><li><p>帅选回收 STW（并行）</p><p>筛选最需要回收的区域进行回收</p></li></ul><p>G1 也有 FullGC，jdk10 以前是串行 FullGC，之后是并行 FullGC</p><h2 id="3-并发标记算法"><a href="#3-并发标记算法" class="headerlink" title="3. 并发标记算法"></a>3. 并发标记算法</h2><p>难点：在标记对象的过程中，对象引用关系正在发生改变</p><p>在 CMS 和 G1 中用的都是<strong>三色标记算法</strong></p><ul><li>白色：未被标记的对象</li><li>灰色：自身被标记，成员变量未被标记</li><li>黑色：自身和成员变量均已标记完成</li></ul><p>漏标的情况：两个是充分必要条件</p><p><img src="../../images/jvm/10/漏标.png" alt=""></p><p>解决方式有两种：</p><ol><li><p>跟踪 A-&gt;D 的增加</p><p>incremental update – 增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS  用的就是这个算法。</p></li><li><p>跟中 B-&gt;D 的消失 </p><p>SATB snapshot at the beginning –关注引用的删除</p><p>当 B-&gt;D 消失时，要把这个<strong>引用</strong>推到 GC 的堆栈，保证 D 还能被 GC 扫描到。G1 用的就是这个算法。</p></li></ol><p>为什么 G1 用 SATB？</p><p>灰色-&gt;白色引用消失时，如果没有黑色指向白色，引用会被会被 push 到堆栈。下次扫描时拿到这个引用，由于 RSet 的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB 配合 RSet，就可以实现。</p><p>漏标是指，本来是 live object，但是由于没有遍历到，被当成 garbage 回收掉了。没有标记到的就是垃圾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-07-22-Untitled.html"/>
    <id>http://yoursite.com/2020-07-22-Untitled.html</id>
    <published>2020-07-22T11:56:16.365Z</published>
    <updated>2020-07-22T11:56:16.365Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM 学习（八）</title>
    <link href="http://yoursite.com/2020-07-20-jvm/jvm%E5%AD%A6%E4%B9%A08_%E8%B0%83%E4%BC%982.html"/>
    <id>http://yoursite.com/2020-07-20-jvm/jvm学习8_调优2.html</id>
    <published>2020-07-20T14:13:12.000Z</published>
    <updated>2020-07-21T16:16:40.798Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 调优（二）</p><a id="more"></a><h2 id="1-解决-JVM-运行中的问题"><a href="#1-解决-JVM-运行中的问题" class="headerlink" title="1. 解决 JVM 运行中的问题"></a>1. 解决 JVM 运行中的问题</h2><h3 id="1-1-一个案例理解常用工具"><a href="#1-1-一个案例理解常用工具" class="headerlink" title="1.1 一个案例理解常用工具"></a>1.1 一个案例理解常用工具</h3><ol><li>代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-20 23:59</span></div><div class="line"><span class="comment"> * 从数据库中读取信息数据,套用模型,并把结果进行记录和传输</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T15_FullGC_Problem01</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CardInfo</span> </span>&#123;</div><div class="line">       BigDecimal price = <span class="keyword">new</span> BigDecimal(<span class="number">0.0</span>);</div><div class="line">       String name = <span class="string">"张三"</span>;</div><div class="line">       <span class="keyword">int</span> age = <span class="number">5</span>;</div><div class="line">       Date birthdate = <span class="keyword">new</span> Date();</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">50</span>,</div><div class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            modelFit();</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modelFit</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</div><div class="line">        taskList.forEach(info -&gt; &#123;</div><div class="line">            executor.scheduleWithFixedDelay(() -&gt; &#123;</div><div class="line">                info.m();</div><div class="line">            &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title">getAllCardInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            CardInfo ci = <span class="keyword">new</span> CardInfo();</div><div class="line">            taskList.add(ci);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> taskList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><p>java -Xms200M -Xmx200M -XX:+PrintGC T15_FullGC_Problem01</p></li><li><p>一般是运维团队首先收到报警信息（比如 CPU memory 飙高）</p></li><li><p>top 命令观察到问题：内存不断增长，CPU 占用率居高不下</p></li><li><p>top -Hp pid 观察进程中的线程，哪个线程 CPU 和内存占比高</p></li><li><p>jps 定位具体 java 进程</p></li><li><p>jstack pid 观察进程中的线程，可以看到线程的状态，nid=0x10f34</p><p>重点关注：WAITING BLOCKED</p><p>waiting on </p><p>假如有一个进程中 100 个线程，很多线程都在 waiting on <xx>，<strong>一定要找到是哪个线程持有这把锁</strong>。</xx></p><p>怎么找？搜索 jstack dump 的信息，找 <xx>，看哪个线程持有这把锁，一般该线程是 RUNNABLE 状态。</xx></p><p>作业：1. 写一个死锁程序，用 jstack 观察；2. 写一个程序，一个程序持有锁不释放，其他线程等待</p></li><li><p>为什么阿里规范里,线程的名称(尤其是线程池)都要有意义的名称</p><p>怎么样自定义线程池里的线程名称？（自定义 ThreadFactory）</p></li><li><p>jinfo pid 查看进程基础信息</p></li><li><p>jstat -gc pid 500 动态观察 gc 情况</p><p>jconsole：jdk 自带的工具</p><p>jvisualvm：jdk 自带的工具</p><p>如果面试官问你是怎么定位 OOM 问题的？ 如果你回答用图形界面（错误，因为使用图形界面会影响程序主进程的性能，肯定是不对的）</p><p>Jprofiler（最好用、收费）</p><ol><li>已经上线的系统，不用图形界面用什么？（cmdline arthas）</li><li>图形界面到底用在什么地方？测试！测试的时候进行监控（压测观察）。提前定位问题，最大可能避免线上问题。</li></ol></li><li><p>jmap -histo 1236 | head -20 ，查找有多少对象产生</p></li><li><p>jmap -dump:format=b,file=xxx pid(导出堆文件。<strong>线上内存较大时不合适，对线上系统影响很大</strong>)</p><p>线上系统，内存特别大，jmap 执行期间会对进程产生很大影响，甚至卡顿（所以电商系统 jmap 不合适）</p><ol><li>设定了参数 HeapDump，OOM 的时候会自动产生堆转储文件</li><li>很多服务器备份（高可用），停掉这台服务器对其他服务器不影响。即对这台服务器做了隔离，然后再来 jmap</li><li>当堆内存特别大时，真的不能在线上直接执行 jmap，应该需要<strong>在线定位（一般小点儿公司用不到）</strong></li></ol></li><li><p>java -Xms200M -Xmx200M -XX:+PrintGC -XX:+HeapDumpOnOutOfMemoryError T15_FullGC_Problem01</p></li></ol><h3 id="1-2-jconsole-远程连接"><a href="#1-2-jconsole-远程连接" class="headerlink" title="1.2 jconsole 远程连接"></a>1.2 jconsole 远程连接</h3><ol><li><p>程序启动加入参数：</p><blockquote><p>java -Djava.rmi.server.hostname=192.168.238.66 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false xxx</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 调优（二）&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（七）</title>
    <link href="http://yoursite.com/2020-07-20-jvm/jvm%E5%AD%A6%E4%B9%A07_xx.html"/>
    <id>http://yoursite.com/2020-07-20-jvm/jvm学习7_xx.html</id>
    <published>2020-07-20T14:13:12.000Z</published>
    <updated>2020-07-20T15:57:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 调优（一）</p><a id="more"></a><h2 id="1-常见垃圾回收器组合参数设定（1-8）"><a href="#1-常见垃圾回收器组合参数设定（1-8）" class="headerlink" title="1. 常见垃圾回收器组合参数设定（1.8）"></a>1. 常见垃圾回收器组合参数设定（1.8）</h2><ul><li>-XX:+UseSerialGC = Serial New(DefNew) + Serial Old<ul><li>小型程序。默认情况下不会是这种选项，HotSpot 会根据计算及配置和 JDK 版本自动选择收集器。</li></ul></li><li>-XX:+UseParNewGC = ParNew + SerialOld<ul><li>这个组合已经很少用（在某些版本中已经废弃）</li></ul></li><li>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old</li><li>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old(1.8 默认) 【PS + SerialOld】</li><li>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</li><li>-XX:+UseG1GC = G1</li><li>Linux 中没有找到默认 GC 的查看方法，而 Windows 中会打印 UseParallelGC<ul><li>java -XX:+PrintCommandLineFlags -version</li><li>通过 GC 的日志来分辨</li></ul></li><li>Linux 下 1.8 版本默认的垃圾回收器到底是什么？<ul><li>1.8.0——181 默认（看不出来） Copy MarkCompact</li><li>1.8.0_222 默认 PS+PO</li></ul></li></ul><h2 id="2-JVM-调优第一步，了解-JVM-常用命令行参数"><a href="#2-JVM-调优第一步，了解-JVM-常用命令行参数" class="headerlink" title="2. JVM 调优第一步，了解 JVM 常用命令行参数"></a>2. JVM 调优第一步，了解 JVM 常用命令行参数</h2><ul><li><p>JVM 的命令行参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p></li><li><p>HotSpot 参数分类</p><blockquote><p>标准：- 开头，所有 HotSpot 都支持</p><p>非标准： -X 开头，特定版本 HotSpot 支持特定命令</p><p>不稳定：-XX 开头，下个版本可能取消</p></blockquote></li></ul><h3 id="2-1-一个小例子"><a href="#2-1-一个小例子" class="headerlink" title="2.1 一个小例子"></a>2.1 一个小例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello GC"</span>);</div><div class="line">        List list = <span class="keyword">new</span> LinkedList();</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            <span class="comment">// 1M</span></div><div class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">            list.add(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><p>区分概念：内存泄漏 memory leak，内存溢出 out of memory</p></li><li><p>java -XX:+PrintCommandLineFlags HelloGC</p><blockquote><p>初始堆大小 最大堆大小 压缩头指针 压缩普通指针</p><p>-XX:InitialHeapSize=30113152 -XX:MaxHeapSize=481810432 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC<br>Hello GC<br>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p><pre><code>at HelloGC.main(HelloGC.java:8)</code></pre></blockquote></li><li><p>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC</p><p>可以看到自定义了NewSize，初始堆大小，最大堆大小。</p><p>可以看到 GC 执行信息。由于测试程序数据都在一个链表，都不能被回收，最后导致内存溢出。</p><p><img src="../../images/jvm/07/查看GC信息.png" alt=""></p><p>PrintGCDetails PrintGCTimeStamps PrintGCCauses</p></li><li><p>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC</p><p>可以看到 CMS 各个阶段信息</p></li><li><p>java -XX:+PrintFlagsInitial 默认参数值</p></li><li><p>java -XX:+PrintFlagsFinal 最终参数值</p></li><li><p>java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数</p></li><li><p>java -XX:+PrintFlagsFinal -version | grep GC</p></li></ol><h2 id="3-PS-GC-日志详解"><a href="#3-PS-GC-日志详解" class="headerlink" title="3. PS GC 日志详解"></a>3. PS GC 日志详解</h2><p>正常 GC 日志。</p><p><img src="../../images/jvm/07/GC日志.png" alt=""></p><p>GC 产生堆溢出时，会打印当前堆信息。</p><p><img src="../../images/jvm/07/GC日志2.png" alt=""></p><p>total = eden + 1个survivor</p><h2 id="4-调优之前的基础概念"><a href="#4-调优之前的基础概念" class="headerlink" title="4. 调优之前的基础概念"></a>4. 调优之前的基础概念</h2><p><strong>吞吐量</strong> = 用户代码执行时间/(用户代码执行时间+垃圾收集执行时间)</p><p><strong>响应时间</strong>=用户线程停顿的时间短。STW 越短，响应时间越好</p><p>确定调优之前，应该确定到底是哪个优先，是计算型任务还是响应型任务。还是在满足一定的响应时间的情况下，要求达到多大的吞吐量。</p><p>问题：</p><p>吞吐量：科学计算，吞吐量。数据挖掘，throughput。吞吐量优先的一般：PS + PO</p><p>响应时间：网站 GUI API （1.8 选 G1）</p><h2 id="5-什么是调优"><a href="#5-什么是调优" class="headerlink" title="5. 什么是调优"></a>5. 什么是调优</h2><ol><li>根据需求进行 JVM <strong>规划和预调优</strong></li><li>优化运行 JVM 运行环境（慢、卡顿怎么优化）</li><li>解决 JVM 运行过程中出现的各种问题（比如 OOM）</li></ol><h2 id="6-调优，从规划开始"><a href="#6-调优，从规划开始" class="headerlink" title="6. 调优，从规划开始"></a>6. 调优，从规划开始</h2><p>淘宝历年最高并发 54W。12306 号称比淘宝还高。</p><ul><li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓</p></li><li><p>无监控（压测，能看到结果），不调优</p></li><li><p>步骤</p><ol><li>熟悉业务场景（没有最好的垃圾回收器，只有最适合的）<ol><li>响应时间、停顿时间【CMS G1 ZGC】</li><li>吞吐量 【PS】</li></ol></li><li>选择回收器组合</li><li>计算内存需求（其实不好计算，内存小，可能 GC 频繁一些，但是可能也没问题，内存大 GC 频度小一些。经验值 1.5G 16G）</li><li>选定 CPU （越高越好，越好核心数越多，处理更快，GC 就更快，节省内存，两者相辅相成）</li><li>设定年代大小、升级年龄</li><li>设定日志参数<ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause  五个日志文件循环使用</li><li>或者每天产生一个日志文件</li></ol></li><li>观察日志情况</li></ol></li></ul><ul><li><p>预调优案例1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？</p><blockquote><p>这个问题比较业余，因为很多不同的服务器配置都能支撑（1.5G，16G）</p><p>1 小时 360000 订单，集中时间段，100 个订单/秒（找一小时内的高峰期，也有可能是 1000 订单/秒）。即你的架构要要能支撑 1000 个订单每秒。</p><p>即使这样，内存也很难预测，一般都是根据经验值，然后进行压测分析。</p><p>非要计算：一个订单产生需要多少内存？ 512k * 1000 = 500M 内存。所以 500M 就足够，但是也可以设置得更小，只要响应时间够快，比如一秒钟 250 个订单全部进来，不到一秒后台把对象全部回收完了，也是 OK 的。</p><p>所以专业一点儿问法：比如要求响应时间 100ms</p><p>  压测</p></blockquote></li><li><p>案例2：12306 遭遇春节大规模抢票应该如何支撑？</p><blockquote><p>12306 应该是中国并发量最大的秒杀网站：</p><p>号称并发量 100w 最高</p><p>CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器 1W 并发 （单机10K问题）100 台机器</p><p>普通电商订单 -&gt; 下单 -&gt; 订单系统（IO）减库存-&gt;等待用户付款</p><p>12306 的一种可能的模型：下单-&gt;减库存 和订单(redis kafka)同时异步进行-&gt;等付款</p><p>减库存最后还会把压力压到一台服务器上</p><p>可以做分布式本地库存 + 单独服务器做库存均衡</p><p>大流量的处理方法：分而治之</p></blockquote></li><li><p>怎么得到一个事务会消耗多少内存？</p><blockquote><ol><li>弄台机器，看能承受多少 TPS？是不是达到目标？扩容或调优，让它达到</li><li>用压测来确定</li></ol></blockquote></li></ul><h2 id="7-优化环境"><a href="#7-优化环境" class="headerlink" title="7. 优化环境"></a>7. 优化环境</h2><ol><li><p>有一个 50万 PV 的资料类网站（从磁盘提取文档到内存）原服务器 32 位，1.5G 的堆，用户反馈网站比较慢（），因此公司决定升级，新的服务器为 64 位， 16G 的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了</p><ol><li><p>为什么原网站慢？</p><p>很多用户浏览数据，很多数据 load 到内存，内存不足，频繁 GC，STW 长，响应时间慢</p></li><li><p>为什么会更卡顿？</p><p>内存越大，FGC 时间越长。虽然 GC 频率变慢了，但是 STW 更长了。</p></li><li><p>咋办？</p><p>PS -&gt; PN + CMS 或者 G1</p></li></ol></li><li><p>系统 CPU 经常 100%，如何调优？（面试高频）</p><p>CPU100% 那么一定有线程在占用系统资源</p><ol><li>找出哪个进程 CPU 高（top）</li><li>该进程中的哪个线程 CPU 高（top -Hp）</li><li>导出该线程的堆栈(jstack)</li><li>查找哪个方法（栈帧）消耗时间（jstack）</li><li>工作线程占比高、垃圾回收线程占比高</li></ol></li><li><p>系统内存飙高，如何查找问题？（面试高频）</p><ol><li>导出堆内存（jmap）</li><li>分析（jhat jvisualvm mat jprofiler …）</li></ol></li><li><p>如何监控 JVM</p><ol><li>jstat jvisualvm jprofiler arthas top</li></ol></li></ol><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 调优（一）&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
