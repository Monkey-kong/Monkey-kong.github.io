<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-20T12:15:00.769Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>monkey-kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统学习（五）</title>
    <link href="http://yoursite.com/2020-09-20-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E8%AF%BE.html"/>
    <id>http://yoursite.com/2020-09-20-操作系统/第五课.html</id>
    <published>2020-09-20T14:13:12.000Z</published>
    <updated>2020-09-20T12:15:00.769Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统学习（五）</p><p>内存同步机制、汇编实现引导程序</p><a id="more"></a><h2 id="1、内核同步机制"><a href="#1、内核同步机制" class="headerlink" title="1、内核同步机制"></a>1、内核同步机制</h2><h3 id="1-1-同步理论的一些基本概念"><a href="#1-1-同步理论的一些基本概念" class="headerlink" title="1.1 同步理论的一些基本概念"></a>1.1 同步理论的一些基本概念</h3><ul><li>临界区（critical area）：访问或操作共享数据的代码段。简单理解就是 synchronized 大括号中部分</li><li>竞争条件（race conditions）：两个线程同时拥有临界区的执行权</li><li>数据不一致（data disconsistency）：由竞争条件引起的数据破坏</li><li>同步（synchronization）：避免 race conditions</li><li>锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在），上锁解锁必须具备原子性</li><li>原子性：像原子一样不可分割的操作</li><li>有序性：禁止指令重排序</li><li>可见性：一个线程内的修改，另一个线程可见</li><li>互斥锁 排他锁 共享锁 分段锁 </li></ul><h3 id="1-2-内核同步常用方法"><a href="#1-2-内核同步常用方法" class="headerlink" title="1.2 内核同步常用方法"></a>1.2 内核同步常用方法</h3><ol><li><p>原子操作 – 内核中类似于AtomicXXX，位于<linux types.h=""></linux></p></li><li><p>自旋锁 – 内核中通过汇编支持的cas，位于<asm spinlock.h=""></asm></p></li><li><p>读-写自旋 – 类似于ReadWriteLock，可同时读，只能一个写 读的时候是共享锁，写的时候是排他锁</p></li><li><p>信号量 – 类似于Semaphore(PV操作 down up操作 占有和释放） 重量级锁，线程会进入wait，适合长时间持有的锁情况</p></li><li><p>读-写信号量 – downread upread downwrite upwrite （多个写，可以分段写，比较少用）(分段锁）</p></li><li><p>互斥体(mutex) – 特殊的信号量（二值信号量）</p></li><li><p>完成变量 – 特殊的信号量（A发出信号给B，B等待在完成变量上） vfork() 在子进程结束时通过完成变量叫醒父进程 类似于(Latch)</p></li><li><p>BKL：大内核锁（早期，现在已经不用）</p></li><li><p>顺序锁（2.6）：  – 线程可以挂起的读写自旋锁 序列计数器（从0开始，写时增加(+1)，写完释放(+1)，读前发现单数， 说明有写线程，等待，读前读后序列一样，说明没有写线程打断）</p></li><li><p>禁止抢占 – preempt_disable() 单核 CPU 使用。对单核 CPU 多线程的优化。如果确认某个数据只会有一个 CPU 使用，就可以使用禁止抢占，而不用加锁。</p></li><li><p>内存屏障 – 见volatile</p></li></ol><h2 id="2、汇编实现引导程序"><a href="#2、汇编实现引导程序" class="headerlink" title="2、汇编实现引导程序"></a>2、汇编实现引导程序</h2><h3 id="2-1-编写汇编码"><a href="#2-1-编写汇编码" class="headerlink" title="2.1 编写汇编码"></a>2.1 编写汇编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">; 文件名 boot.asm</div><div class="line"> </div><div class="line">org 7c00h                     ; BIOS读入MBR后，从0x7c00h处开始执行</div><div class="line"> </div><div class="line">; 下面部分和10h有关中断，10h中断用来显示字符</div><div class="line">mov ax, cs</div><div class="line">mov es, ax</div><div class="line">mov ax, msg</div><div class="line">mov bp, ax                    ; ES:BP表示显示字符串的地址</div><div class="line">mov cx, msgLen                ; CX存字符长度</div><div class="line">mov ax, 1301h                 ; AH=13h表示向TTY显示字符，AL=01h表示显示方式（字符串是否包含显示属性，01h表示不包含）</div><div class="line">mov bx, 000fh                 ; BH=00h表示页号，BL=0fh表示颜色</div><div class="line">mov dl, 0                     ; 列</div><div class="line">int 10h</div><div class="line">  </div><div class="line">msg: db &quot;hello world, welcome to OS!&quot;</div><div class="line">msgLen: equ $ - msg           ; 字符串长度</div><div class="line">times 510 - ($ - $$) db 0     ; 填充剩余部分</div><div class="line">dw 0aa55h                     ; 魔数，必须有这两个字节BIOS才确认是MBR</div></pre></td></tr></table></figure><h3 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h3><p><code>nasm boot.asm -o boot.bin</code></p><h3 id="2-3-制作启动软盘"><a href="#2-3-制作启动软盘" class="headerlink" title="2.3 制作启动软盘"></a>2.3 制作启动软盘</h3><ol><li>dd if=/dev/zero of=floppy.img bs=1474560 count=1 <strong>生成空白软盘镜像</strong></li><li>dd if=boot.bin of=myos.img bs=512 count=1 <strong>制作包含主引导记录boot.bin的启动镜像文件</strong></li><li>dd if=floppy.img of=myos.img skip=1 seek=1 bs=512 count=2879 <strong>在 bin 生成的镜像文件后补上空白，成为合适大小的软盘镜像，一共2880个扇区，略过第一个</strong></li></ol><h3 id="2-4-用软盘启动系统"><a href="#2-4-用软盘启动系统" class="headerlink" title="2.4 用软盘启动系统"></a>2.4 用软盘启动系统</h3><blockquote><ol><li>将myos.img下载到windows</li><li>VMWare创建空的虚拟机<ol><li>文件 - 创建新的虚拟机 - 典型</li><li>稍后安装操作系统</li><li>其他</li><li>一路next 完成</li><li>虚拟机设置，去掉CD/DVD选项中“启动时连接”</li><li>网络，选择“仅主机模式”，勾选“启动时连接”（好像无所谓）</li><li>添加软盘驱动器 使用软盘映像 找到myos.img</li></ol></li><li>启动虚拟机</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统学习（五）&lt;/p&gt;
&lt;p&gt;内存同步机制、汇编实现引导程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习（四）</title>
    <link href="http://yoursite.com/2020-09-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E8%AF%BE.html"/>
    <id>http://yoursite.com/2020-09-19-操作系统/第四课.html</id>
    <published>2020-09-19T14:13:12.000Z</published>
    <updated>2020-09-19T14:48:41.316Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统学习（四）</p><p>内存管理。</p><a id="more"></a><h2 id="1、内存管理的发展历程"><a href="#1、内存管理的发展历程" class="headerlink" title="1、内存管理的发展历程"></a>1、内存管理的发展历程</h2><p>DOS 时代：同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）</p><p>Windows95：多个进程装入内存</p><ul><li>内存不够用</li><li>互相干扰</li></ul><p><img src="../../images/os/4/早期系统内存管理.png" alt=""></p><p>现在的内存管理系统：虚拟地址 分页装入 软件硬件结合寻址</p><ul><li><p>内存分成一页一页固定大小的页框（page frame）一般都是 4K 大小</p></li><li><p>解决内存撑爆问题，把应用程序（硬盘上）分成 4K 大小的块，用到哪个页就把哪个页装入内存(加载)；加载过程中如果内存满了，通过 <strong>LRU 算法</strong>把最久未使用的页装入交换(swap)分区（交换分区位于硬盘），然后把新的页加载进来。</p></li><li><p>解决互相打扰问题：虚拟地址空间，虚拟内存</p><ul><li>DOS Win31 … 应用程序直接访问物理地址，容易互相打扰</li><li>为了保证互不影响，让进程工作在虚拟空间。程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A 进程永远不可能访问到 B 进程的空间。</li><li>虚拟空间多大呢？就是寻址空间：64 位系统， 2^64 byte，比物理空间大很多。</li><li>站在虚拟的角度，进程是独享整个系统 + CPU</li><li>虚拟内存是分段的，因为每段的作用和权限都不同，段内再分页。</li><li>虚拟内存和物理内存需要映射</li></ul><p><img src="../../images/os/4/虚拟内存.png" alt=""></p></li></ul><p>为什么使用虚拟内存？</p><ul><li>隔离应用程序<ul><li>每个程序都认为自己有连续的可用的内存</li><li>突破物理内存的限制</li><li>应用程序不需要考虑物理内存是否够用，是否能够分配等底层问题</li></ul></li><li>安全<ul><li>保护物理内存，不被恶意程序访问</li></ul></li></ul><p><strong>线性地址</strong></p><p>内存映射：偏移量 + 段的基地址 = 线性地址（还是虚拟地址），线性地址到物理地址的映射是由 操作系统 + 硬件 MMU(Memory Management Unit)来完成的。</p><p><img src="../../images/os/4/内存映射.png" alt=""></p><p><img src="../../images/os/4/内存映射2.png" alt=""></p><p><strong>缺页中断/缺页异常</strong></p><ul><li>需要用的 page 内存中没有，产生缺页异常（中断），由内核处理并加载。</li></ul><h2 id="2、LRU-算法（手撕）"><a href="#2、LRU-算法（手撕）" class="headerlink" title="2、LRU 算法（手撕）"></a>2、LRU 算法（手撕）</h2><p>LRU：Least Recently Used 最不常用</p><p>LFU：</p><h3 id="2-1-数组实现"><a href="#2-1-数组实现" class="headerlink" title="2.1 数组实现"></a>2.1 数组实现</h3><p>找出数组中哪一项最不常用(每一项上记一个时间戳)，需要遍历数组，时间复杂度是 O(N)。</p><h3 id="2-2-链表实现"><a href="#2-2-链表实现" class="headerlink" title="2.2 链表实现"></a>2.2 链表实现</h3><p>链表头永远是最不常用的，链表尾部一定是最近使用的。</p><p>但是如果再次用到中间的一个元素，所以我们需要找到这个元素，然后把这个元素放到尾巴上去。但是链表中查找一个元素的时间复杂度是 O(N)。</p><p><img src="../../images/os/4/LRU-链表.png" alt=""></p><h3 id="2-3-哈希表-链表"><a href="#2-3-哈希表-链表" class="headerlink" title="2.3 哈希表+链表"></a>2.3 哈希表+链表</h3><p><img src="../../images/os/4/LRU-链表加哈希表.png" alt=""></p><p>java 中  LinkdHashMap 就是用来实现缓存的。</p><ul><li><p>哈希表：保证查找操作 O(1)</p></li><li><p>链表：保证排序操作和新增操作 O(1)</p></li></ul><p>命中缓存时，需要把前面的一个元素指向后面一个元素，单链表 O(1) 无法实现，所以必须要用双链表。</p><p>作业：leetcode 146 题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</div><div class="line">    <span class="keyword">private</span> Node head,tail;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheCapacity;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">this</span>.cacheCapacity = capacity;</div><div class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node();</div><div class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node();</div><div class="line">        <span class="keyword">this</span>.head.next = tail;</div><div class="line">        <span class="keyword">this</span>.tail.pre = head;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="comment">// 命中缓存</span></div><div class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</div><div class="line">            Node curNode = map.get(key);</div><div class="line">            <span class="comment">// 把 curNode 从链表删除</span></div><div class="line">            removeNode(curNode);</div><div class="line">            <span class="comment">// 把 curNode 移动到链表头部</span></div><div class="line">            moveToHead(curNode);</div><div class="line">            <span class="keyword">return</span> curNode.value;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</div><div class="line">            Node curNode = map.get(key);</div><div class="line">            <span class="comment">// 把 curNode 从链表删除</span></div><div class="line">            removeNode(curNode);</div><div class="line">            <span class="comment">// 把 curNode 移动到链表头部</span></div><div class="line">            moveToHead(curNode);</div><div class="line">            <span class="comment">// 记得要更新值</span></div><div class="line">            curNode.value = value;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (map.size() == cacheCapacity) &#123;</div><div class="line">                <span class="comment">// 删除 map 数据</span></div><div class="line">                map.remove(tail.pre.key);</div><div class="line">                <span class="comment">// 删除链表尾部数据节点</span></div><div class="line">                removeNode(tail.pre);</div><div class="line">            &#125;</div><div class="line">            Node newNode = <span class="keyword">new</span> Node(key,value);</div><div class="line">            <span class="comment">// 新节点插入链表头部</span></div><div class="line">            moveToHead(newNode);</div><div class="line">            <span class="comment">// 维护 map</span></div><div class="line">            map.put(key,newNode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将节点从链表中移除</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> curNode</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node curNode)</span> </span>&#123;</div><div class="line">        curNode.pre.next = curNode.next;</div><div class="line">        curNode.next.pre = curNode.pre;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将节点插入链表头部</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> curNode</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node curNode)</span> </span>&#123;</div><div class="line">        curNode.next = head.next;</div><div class="line">        curNode.pre = head;</div><div class="line">        head.next.pre = curNode;</div><div class="line">        head.next = curNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 双链表节点</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Node pre;</div><div class="line">        <span class="keyword">private</span> Node next;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</div><div class="line">        Node()&#123;&#125;</div><div class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3、ZGC"><a href="#3、ZGC" class="headerlink" title="3、ZGC"></a>3、ZGC</h2><p>算法：Colored Pointer</p><p>GC 信息记录在指针上，不是记录在头部。作为 ZGC 来说 Immediate menory use 内存立即可用。</p><p>42 位指针，寻址空间 4TB，JDK 13 扩展到 16T（2^44次方）</p><p>颜色指针本质上包含了地址映射的概念。不同状态的对象，在逻辑上位于不同的逻辑空间。</p><p><img src="../../images/os/4/ZGC-颜色指针.png" alt=""></p><h3 id="CPU-如何区分一个立即数和一条指令？"><a href="#CPU-如何区分一个立即数和一条指令？" class="headerlink" title="CPU 如何区分一个立即数和一条指令？"></a>CPU 如何区分一个立即数和一条指令？</h3><p>总线内部分为数据总线、地址总线和控制总线。</p><p>目前地址总线：48 位。所以最大寻址空间为 16T</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统学习（四）&lt;/p&gt;
&lt;p&gt;内存管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习（三）</title>
    <link href="http://yoursite.com/2020-09-18-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E8%AF%BE.html"/>
    <id>http://yoursite.com/2020-09-18-操作系统/第三课.html</id>
    <published>2020-09-18T14:13:12.000Z</published>
    <updated>2020-09-19T04:00:13.909Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统学习（三）</p><ul><li>进程、线程和纤程</li><li>进程调度</li><li>中断</li></ul><a id="more"></a><h2 id="1、进程、线程和纤程"><a href="#1、进程、线程和纤程" class="headerlink" title="1、进程、线程和纤程"></a>1、进程、线程和纤程</h2><h3 id="1-1-进程和线程的区别？"><a href="#1-1-进程和线程的区别？" class="headerlink" title="1.1 进程和线程的区别？"></a>1.1 进程和线程的区别？</h3><p>进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。</p><p>进程是 OS <strong>分配资源</strong>的基本单位，线程是 CPU <strong>执行调度</strong>的基本单位，线程共享进程的内存空间，线程没有自己独立的内存空间。分配资源最重要的就是分配<strong>独立的内存空间</strong>。</p><p><img src="../../images/os/3/进程-线程-纤程.png" alt=""></p><h3 id="1-2-线程在-linux-中的实现"><a href="#1-2-线程在-linux-中的实现" class="headerlink" title="1.2 线程在 linux 中的实现"></a>1.2 线程在 linux 中的实现</h3><p><img src="../../images/os/3/linux中的进程.png" alt=""></p><p>linux 中的线程就是一个普通的进程，只不过这个进程和主进程共享资源（内存空间，全局数据等）。</p><p>不同的操作系统对线程的实现各不相同，其他系统都有各自的所谓 LWP(Light Weight Process)的实现。</p><p>可以把线程理解为一个进程中不同的执行路线。</p><h3 id="1-3-纤程"><a href="#1-3-纤程" class="headerlink" title="1.3 纤程"></a>1.3 纤程</h3><p>线程中的线程，用户空间的线程， 切换和调度不需要经过 OS ，启动一个纤程无需操作系统级别通过系统调用启动一个对应的线程(LWP)。</p><p>OS 启动线程的数量是有限的，如果启动太多，大量时间耗费在线程间的切换。但是纤程是位于用户空间，非常轻量级，<strong>启动、调度和切换</strong>消耗资源都很小。</p><p>OS 线程切换的消耗还是挺大的，需要把 Register 中的数据拿出去，然后把其他线程数据拿进来，相对来说是个比较重量级的操作。</p><p>所有纤程的优势有：</p><ol><li>占有资源少。OS 启动一个线程，大概需要 1M；Fiber 只需 4K</li><li>切换比较简单，因为无需经过 OS，直接在用户态切换</li><li>启动数量多，可以启动 10w+</li></ol><p>目前（202003）支持内置纤程的语言：Kotlin、Scala、Go、Python(lib)、java(open jdk:loom)</p><p><img src="../../images/os/3/纤程.png" alt=""></p><h3 id="1-4-Java-纤程例子"><a href="#1-4-Java-纤程例子" class="headerlink" title="1.4 Java 纤程例子"></a>1.4 Java 纤程例子</h3><p>启动 10000 个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFiber</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> size = <span class="number">10000</span>;</div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</div><div class="line">            threads[i] = <span class="keyword">new</span> Thread(() -&gt; calc());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</div><div class="line">            threads[i].join();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        <span class="comment">// 8462</span></div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟耗时操作</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">10000</span>; m++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) result += i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>利用 Quaser 库实现纤程，启动 10000 个纤程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFiber2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> size = <span class="number">10000</span>;</div><div class="line">        Fiber&lt;Void&gt;[] fibers = <span class="keyword">new</span> Fiber[size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</div><div class="line">            fibers[i] = <span class="keyword">new</span> Fiber&lt;Void&gt;((SuspendableRunnable) () -&gt; calc());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</div><div class="line">            fibers[i].start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</div><div class="line">            fibers[i].join();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        <span class="comment">// 3201</span></div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 模拟耗时操作</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">10000</span>; m++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) result += i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>目前是 10000 个 Fiber 对应 1 个 JVM 线程，想办法提高效率，比如 10000 Fiber 用 10 JVM 线程来执行。这样即充分利用了 CPU 调度能力又利用了 Fiber 的优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFiber3</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> size = <span class="number">10000</span>;</div><div class="line">        <span class="keyword">int</span> threadSize = <span class="number">10</span>;</div><div class="line">        <span class="keyword">int</span> batchSize = size/threadSize;</div><div class="line"></div><div class="line">        Fiber&lt;Void&gt;[] fibers = <span class="keyword">new</span> Fiber[size];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</div><div class="line">            fibers[i] = <span class="keyword">new</span> Fiber&lt;Void&gt;((SuspendableRunnable) () -&gt; calc());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[threadSize];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threads.length; j++) &#123;</div><div class="line">            threads[j] = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</div><div class="line">                        fibers[i].start();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</div><div class="line">                        fibers[i].join();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</div><div class="line">            threads[i].join();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        <span class="comment">// 467</span></div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">10000</span>; m++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) result += i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-5-纤程的应用场景"><a href="#1-5-纤程的应用场景" class="headerlink" title="1.5 纤程的应用场景"></a>1.5 纤程的应用场景</h3><p>线程 vs 线程池：<strong>很短的计算任务</strong>，不需要和内核打交道，适合用纤程；<strong>并发量高</strong>的时候适合用纤程。</p><h3 id="1-6-进程"><a href="#1-6-进程" class="headerlink" title="1.6 进程"></a>1.6 进程</h3><p>linux 中进程也被称为 task，是系统分配资源的基本单位。</p><p>所谓的资源是指独立的地址空间、内核数据结构（进程描述符）、全局变量、数据段。</p><p>进程描述符：PCB(Process Control Block)</p><p>一个进程在 linux 内核使用一个叫做 PCB 的数据结构来描述它跟踪它，每个进程都跟着一个 PCB。内核中维护进程的时候用的是这个 PCB 数据结构，叫做进程描述符。PCB 大小不是固定的，每个进程 PCB 的大小不一样。</p><h3 id="1-7-内核线程"><a href="#1-7-内核线程" class="headerlink" title="1.7 内核线程"></a>1.7 内核线程</h3><p>内核启动之后经常需要做一些<strong>后台操作</strong>，这些后台操作由 Kernel Thread 来完成，只在内核空间运行。</p><h3 id="1-8-进程创建和启动"><a href="#1-8-进程创建和启动" class="headerlink" title="1.8 进程创建和启动"></a>1.8 进程创建和启动</h3><p>系统调用 fork() 创建进程（其实底层还有一个 clone() 调用），exec() 启动进程。</p><p>从 A 中 fork B 的话，A 称之为 B 的父进程。</p><h3 id="1-9-僵尸进程和孤儿进程"><a href="#1-9-僵尸进程和孤儿进程" class="headerlink" title="1.9 僵尸进程和孤儿进程"></a>1.9 僵尸进程和孤儿进程</h3><p><strong>安装 C 语言编译环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 查看是否已经安装 gcc</span></div><div class="line">rpm -qa|grep gcc</div><div class="line"><span class="meta">#</span><span class="bash"> gcc 是 C 语言编译器</span></div><div class="line">yum install gcc</div><div class="line"><span class="meta">#</span><span class="bash"> gcc-c++ 是 c++ 编译器</span></div><div class="line">yum install gcc-c++</div></pre></td></tr></table></figure><p><strong>僵尸进程</strong></p><p>父进程产生子进程后，会维护子进程的一个 PCB 结构，子进程退出，由父进程释放这个 PCB 结构。如果父进程没有释放这个 PCB，那么这个子进程就成为一个僵尸进程。其实影响不大，因为子进程退出，子进程所占用的资源都已经释放，只是一个 PCB 还未释放而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// zombie.c</span></div><div class="line"><span class="comment">// ps 命令可以看到 &lt;defunct&gt; 就表示僵尸进程</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 返回 0 表示子进程</span></div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"child id is %d\n"</span>, getpid());</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"parent id is %d\n"</span>, getppid());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 父进程一直未结束，所以子进程变为了僵尸进程</span></div><div class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译</span></div><div class="line">gcc -o zombie zombie.c</div><div class="line"><span class="comment">// 执行    </span></div><div class="line">./zombie &amp;</div></pre></td></tr></table></figure><p><strong>孤儿进程</strong></p><p>子进程结束之前，父进程已经退出。孤儿进程会成为 init 进程的孩子，由 1 号进程维护。图形界面时不一定是 1 号进程，但是总之都会由一个特殊的进程统一管理。影响不大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// orphan.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"child ppid is %d\n"</span>, getppid());</div><div class="line">        sleep(<span class="number">10</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"parent ppid is %d\n"</span>, getppid()); <span class="comment">// 前后不一致</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"parent id is %d\n"</span>, getpid());</div><div class="line">        sleep(<span class="number">5</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2、进程调度"><a href="#2、进程调度" class="headerlink" title="2、进程调度"></a>2、进程调度</h2><p>内核进程调度器决定现在该哪个进程运行了，何时开始运行，运行多长时间。</p><p>linux 内核中，可以给每个进程<strong>定制专属</strong>的调度方案。</p><p>进程调度的发展从单任务（独占）到多任务（分时）。原则就是最大限度的压榨 CPU 资源。</p><p>DOS 就是单任务独占式的。</p><p><strong>非抢占式（cooperative multitasking）</strong></p><ul><li>除非进程主动认出 CPU（yielding），否则将一直运行</li></ul><p><strong>抢占式（preemptive multitasking）</strong></p><ul><li>由进程调度器强制开始或暂停（抢占）某一进程的执行</li></ul><p>linux2.5 经典 Unix O(1) 调度策略，时间分片挨个执行，偏向服务器，但对交互不友好。</p><p>Linux2.6.23 采用 <strong>CFS</strong> 完全公平调度算法 Completely Fair Scheduler。</p><ul><li>不再采用绝对时间片。使用绝对时间片反而不公平，比如医院看病来了急诊或者是个自处理软件和一个要求实时响应的软件，时间片不应该一样。</li><li>按优先级分配时间片的比例，记录每个进程的执行时间，如果有一个进程执行时间不到他应该分配的比例，某个时刻该进程请求 CPU 时优先执行，相当于补偿。</li></ul><p><strong>进程调度基本概念</strong></p><ul><li>进程类型<ul><li>IO 密集型，大部分时间用于等待 IO</li><li>CPU 密集型，大部分时间用于闷头计算</li></ul></li><li>进程优先级<ul><li>实时进程 &gt; 普通进程（0~99）。实时进程远大于普通进程，有实时进程时，普通进程没有执行机会。</li><li>普通进程 nice 值（-20~19）</li></ul></li><li>时间分配<ul><li>linux 采用按优先级的 CPU <strong>时间比</strong></li><li>其他系统多采用按优先级的时间片</li></ul></li><li>eg. 两个 app 同时运行<ul><li>一个文本处理程序</li><li>一个影视后期程序</li></ul></li></ul><p><strong>Linux 默认的调度策略</strong></p><p>对于实时进程：不同优先级使用 SCHED_FIFO(First In First Out) 和相同优先级使用 SCHED_RR（Round Robin） 两种。</p><p>对于普通进程：使用 CFS</p><p>其中等级最高的是 FIFO，这两种进程除非自己让 CPU 否则 Linux 会一直执行它，除非更高等级的 FIFO 和 RR 抢占它。</p><p>RR 只是这种线程中是同等级别 FIFO 中的平均分配。只有实时进程主动让出，或者执行完毕后，普通进程才有机会执行。</p><h2 id="3、中断"><a href="#3、中断" class="headerlink" title="3、中断"></a>3、中断</h2><h3 id="3-1-中断实现细节"><a href="#3-1-中断实现细节" class="headerlink" title="3.1 中断实现细节"></a>3.1 中断实现细节</h3><p>中断是<strong>硬件、软件和操作系统通讯</strong>的一种方式。</p><p>不管 OS 现在在干嘛，只要是有一些硬件的反应，都是需要优先执行。硬件反应后，软件也应该给出一些反馈。</p><p><img src="../../images/os/3/中断细节.png" alt=""></p><p>键盘按下一个键之后，中断控制器通知 CPU，但是 CPU 如何知道处理哪个应用程序呢？比如我敲下的字母是微信上敲的还是 office 上敲的？这个只有内核知道。CPU 会去固定位置（中断向量表）读取应该处理哪个应用程序。上半场是指内核处理，下半场是指应用程序。</p><p><strong>硬中断</strong></p><p>键盘、鼠标、网络等硬件事件就是硬中断</p><p><strong>软中断</strong></p><p><strong>用户态程序需要请求内核做事情是通过系统调用实现的，做任何系统调用都要打断内核，这就是软中断</strong>。软中断是中断向量表中的一个特殊中断，0x80H，这就是经常说的 80 中断。或者 sysenter 原语(某些新的 CPU 支持)。 </p><p><strong>调用细节</strong></p><p>需要调用哪个应用程序通过 ax 寄存器填入系统调用号或者说函数的编号。</p><p>系统调用函数的参数通过 bx cx dx si di 寄存器传入内核。</p><p>系统调用返回值通过 ax 返回。</p><p>Java 读网络 -&gt; jvm read() -&gt; c 库 read() -&gt; 内核空间 -&gt; system_call()（系统调用处理程序）-&gt; sys_read()</p><h3 id="3-2-从汇编角度理解软中断"><a href="#3-2-从汇编角度理解软中断" class="headerlink" title="3.2 从汇编角度理解软中断"></a>3.2 <strong>从汇编角度理解软中断</strong></h3><p><strong>搭建汇编环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nasm</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">;hello.asm</div><div class="line">;write(int fd, const void *buffer, size_t nbytes) 调用内核的 write 方法</div><div class="line">;fd 文件描述符 file descriptor - linux下一切皆文件。数据传输的一种介质</div><div class="line"></div><div class="line">section data</div><div class="line">    msg db &quot;Hello&quot;, 0xA</div><div class="line">    len equ $ - msg</div><div class="line"></div><div class="line">section .text</div><div class="line">global _start</div><div class="line">_start:</div><div class="line"></div><div class="line">    mov edx, len</div><div class="line">    mov ecx, msg</div><div class="line">    mov ebx, 1 ;文件描述符1 std_out 标准输出；所以 bx 寄存器传 1</div><div class="line">    mov eax, 4 ;write函数系统调用号 4；所以 ax 寄存器传 4</div><div class="line">    int 0x80 ;调用 80 中断。OS 收到这个信号后，会调用 80 的处理程序；从 ax 中拿出 4 来，发现应该调用 write 函数，然后从 bx 中取出 1，发现要以标准输出往外写；然后中 cx、dx 取出数据和长度</div><div class="line"></div><div class="line">    mov ebx, 0</div><div class="line">    mov eax, 1 ;exit函数系统调用号</div><div class="line">    int 0x80</div></pre></td></tr></table></figure><p><strong>编译：</strong><code>nasm -f elf  hello.asm -o hello.o</code></p><p><strong>链接：</strong><code>ld -m elf_i386 -o hello hello.o</code> 是指和原来已经写好的类库进行连接。</p><p> 一个程序的执行过程，要么处于用户态，要么处于内核态 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统学习（三）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程、线程和纤程&lt;/li&gt;
&lt;li&gt;进程调度&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习（二）</title>
    <link href="http://yoursite.com/2020-09-16-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E8%AF%BE.html"/>
    <id>http://yoursite.com/2020-09-16-操作系统/第二课.html</id>
    <published>2020-09-16T14:13:12.000Z</published>
    <updated>2020-09-19T03:15:52.039Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习（二）。</p><a id="more"></a><h2 id="2、NUMA-Non-Uniform-Memory-Access"><a href="#2、NUMA-Non-Uniform-Memory-Access" class="headerlink" title="2、NUMA-Non Uniform Memory Access"></a>2、NUMA-Non Uniform Memory Access</h2><h3 id="2-1-UMA"><a href="#2-1-UMA" class="headerlink" title="2.1 UMA"></a>2.1 UMA</h3><p><strong>多块 CPU 通过主线共享同一个内存。</strong></p><p>UMA 问题：不易扩展，CPU 数量增多后引起内存访问冲突加剧，CPU 的很多资源花在争抢内存地址上面，4 颗 CPU 左右比较合适。</p><p><img src="../../images/os/2/UMA.png" alt=""></p><h3 id="2-2-NUMA"><a href="#2-2-NUMA" class="headerlink" title="2.2 NUMA"></a>2.2 NUMA</h3><p>在主板的插槽上，一组 CPU 和内存放在一起，可以理解为<strong>每一组 CPU 有自己专属的内存</strong>。当然访问其他内存也可以，通过主线访问，只不过效率低一点。</p><p>所以现在程序可以做到 NUMA Aware，即当程序感知到底层架构是 NUMA 时，某个 CPU 要分配一个对象内存时，会优先分配在该线程所在 CPU 中最近的内存中，ZGC 就是这样实现的。</p><p><img src="../../images/os/2/NUMA.png" alt=""></p><h2 id="3、计算机启动过程"><a href="#3、计算机启动过程" class="headerlink" title="3、计算机启动过程"></a>3、计算机启动过程</h2><p><img src="../../images/os/2/启动过程.png" alt=""></p><ul><li>通电</li><li>bios/uefi 芯片开始工作<ul><li>加电自检</li><li>加载 bootloader 到内存，bootloader 位于硬盘固定位置-第一个扇区</li></ul></li><li>bootloader 从 cmos 芯片读取一些可配置的信息。cmos 由主板上的电池给它通电。</li><li>选择操作启动启动</li><li>操作系统启动后，CPU 全权由操作系统掌管</li></ul><p>cmos 存储可配置的信息。主板上有块电池给它通电。如果主板一直不通电，过个几年由于这个电池电量耗尽，信息也就丢失了。</p><h2 id="4、操作系统基础"><a href="#4、操作系统基础" class="headerlink" title="4、操作系统基础"></a>4、操作系统基础</h2><h3 id="4-1-harmony"><a href="#4-1-harmony" class="headerlink" title="4.1 harmony"></a>4.1 harmony</h3><ul><li>微内核<ul><li>针对 5G + IOT</li><li>全场景：手机、PC、平板、车辆、智能穿戴、居家设备</li><li>弹性部署</li><li>开源</li><li>方舟编译器</li><li>混合内核 Linux + LiteOS</li></ul></li></ul><h3 id="4-2-什么是操作系统"><a href="#4-2-什么是操作系统" class="headerlink" title="4.2 什么是操作系统"></a>4.2 什么是操作系统</h3><p>可以理解为一个特殊的软件，<strong>一边管理所有的硬件(CPU、磁盘、内存)，一边对外提供服务管理应用（进程）</strong>。其他所有软件都和操作系统打交道。</p><p><img src="../../images/os/2/什么是操作系统.png" alt=""></p><p><img src="../../images/os/2/操作系统做什么.png" alt=""></p><p><strong>OS 简要结构</strong></p><ul><li>kernel：操作系统最核心结构，内核最主要的就是<strong>管理硬件</strong>。</li><li>外围程序：和应用程序打交道</li></ul><p><img src="../../images/os/2/简要结构.png" alt=""></p><h3 id="4-3-kernel"><a href="#4-3-kernel" class="headerlink" title="4.3 kernel"></a>4.3 kernel</h3><p><img src="../../images/os/2/kernel作用.png" alt=""></p><p><strong>宏内核</strong></p><p>内核相关程序全部装在一起，在一块内存。</p><p><img src="../../images/os/2/宏内核.png" alt=""></p><p><strong>微内核</strong></p><p><strong>有一个最核心的 kernel，只负责进程调度。kernel 相关程序可以放在不同的芯片、内存</strong>。比如应用程序需要读取某个文件，之前宏内核接收到请求后，直接调用文件系统处理请求，但是在微内核中，请求发到内核后，内核再去别的地方找能处理请求的程序来处理请求。优点是部署灵活，弹性部署，部件可插拔。缺点是效率低一点。</p><p><img src="../../images/os/2/微内核.png" alt=""></p><h2 id="5、基础概念"><a href="#5、基础概念" class="headerlink" title="5、基础概念"></a>5、基础概念</h2><h3 id="5-1-用户态内核态"><a href="#5-1-用户态内核态" class="headerlink" title="5.1 用户态内核态"></a>5.1 用户态内核态</h3><p>内核态可以访问 ring 0 级别指令，用户态只能访问 ring 3 级别指令。</p><p><img src="../../images/os/2/用户态内核态.png" alt=""></p><p>CPU 分不同的指令级别。</p><p>linux 内核跑在 ring 0 级，用户程序跑在 ring 3 级，对于系统的关键访问，需要经过 kernel 的同意，保证系统健壮性。</p><p>内核执行的操作：linux 内核操作不算多，200 多个系统调用。sendfile read write。</p><p>JVM 站在 OS 的角度，就是个普通程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习（二）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习（一）</title>
    <link href="http://yoursite.com/2020-09-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E8%AF%BE.html"/>
    <id>http://yoursite.com/2020-09-15-操作系统/第一课.html</id>
    <published>2020-09-15T14:13:12.000Z</published>
    <updated>2020-09-24T14:46:07.129Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习（一）。Linux 基础。</p><p>操作系统学习（一）</p><ul><li>CPU 基本原理</li><li>汇编基本原理</li><li>计算机和 CPU 的基本组成</li><li>存储器层次结构</li><li>程序局部性原理、缓存行、伪共享、缓存行对齐</li><li>缓存一致性协议（缓存锁）</li><li>总线锁</li></ul><a id="more"></a><h2 id="1、相关书籍推荐"><a href="#1、相关书籍推荐" class="headerlink" title="1、相关书籍推荐"></a>1、相关书籍推荐</h2><h3 id="1-1-读书原则"><a href="#1-1-读书原则" class="headerlink" title="1.1 读书原则"></a>1.1 读书原则</h3><p>读书的原则：<strong>不求甚解，观其大略</strong></p><p>你如果进到庐山里头，二话不说，蹲下头来，弯下腰，就对着某棵树某棵小草猛研究而不是说先把庐山的整体脉络跟那研究清楚了，那么你的学习方法肯定效率巨低而且特别痛苦，最重要的还是慢慢地还打击你的积极性，说我的学习怎么那么不happy啊，怎么那么特没劲那，因为你的学习方法错了，大体读明白，先拿来用，用着用着，很多道理你就明白了。</p><h3 id="1-2-书籍推荐"><a href="#1-2-书籍推荐" class="headerlink" title="1.2 书籍推荐"></a>1.2 书籍推荐</h3><p><strong>计算机系统</strong></p><ul><li>《编码：隐匿在计算机软硬件背后的语言》  // 推荐</li><li>《深入理解计算机系统》 </li></ul><p><strong>高级语言</strong></p><ul><li>《C程序设计语言》 // 推荐</li><li>《C Primer Plus》 </li></ul><p><strong>数据结构和算法-毕生的学习 </strong></p><ul><li>《Java数据结构与算法》《算法》 </li><li>《算法导论》《计算机程序设计艺术》//难 </li></ul><p><strong>操作系统</strong></p><ul><li>《Linux内核源码解析》  </li><li>《Linux内核设计与实现》 // 推荐</li><li>《30天自制操作系统》</li><li>《深入理解 Linux 内核》</li></ul><p><strong>网络</strong></p><ul><li>机工《TCP/IP详解》卷一 翻译一般</li></ul><p><strong>编译原理</strong></p><ul><li>机工 龙书 《编译原理》 </li><li>《编程语言实现模式》</li></ul><p><strong>数据库</strong></p><ul><li>《SQLite源码》</li><li>Derby - JDK自带数据库</li></ul><h2 id="2、硬件基础知识"><a href="#2、硬件基础知识" class="headerlink" title="2、硬件基础知识"></a>2、硬件基础知识</h2><h3 id="2-1-CPU-的制作过程"><a href="#2-1-CPU-的制作过程" class="headerlink" title="2.1 CPU 的制作过程"></a>2.1 CPU 的制作过程</h3><p><strong>视频：</strong></p><p> <a href="https://haokan.baidu.com/v?vid=11928468945249380709&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="external">https://haokan.baidu.com/v?vid=11928468945249380709&amp;pd=bjh&amp;fr=bjhauthor&amp;type=</a><a href="https://haokan.baidu.com/v?vid=11928468945249380709&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="external">video</a> </p><p><strong>文字：</strong></p><p><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="external">https</a><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="external">://www.sohu.com/a/255397866_468626</a> </p><p><strong>原料：</strong>一堆沙子+一堆铜 + 一堆胶水 + 特定金属添加 + 特殊工艺</p><p><strong>工艺：</strong>沙子脱氧 -&gt; 石英 -&gt; 二氧化硅 -&gt; 提纯 -&gt; 硅锭 -&gt; 切割 -&gt; 晶圆 -&gt; 涂抹光刻胶 -&gt; 光刻 -&gt; 蚀刻 -&gt; 清除光刻胶 -&gt; 电镀 -&gt; 抛光 -&gt; 铜层 -&gt; 测试  -&gt; 切片 -&gt; 封装</p><h3 id="2-2-CPU-的原理"><a href="#2-2-CPU-的原理" class="headerlink" title="2.2 CPU 的原理"></a>2.2 CPU 的原理</h3><p><strong>如何代表数字？</strong></p><p>计算机需要解决的最根本问题：如何代表数字</p><p><strong>晶体管</strong>是如何工作的：</p><p><a href="https://haokan.baidu.com/v?vid=16026741635006191272&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="external">https://haokan.baidu.com/v?vid=16026741635006191272&amp;pd=bjh&amp;fr=bjhauthor&amp;type=</a><a href="https://haokan.baidu.com/v?vid=16026741635006191272&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="external">video</a></p><p><strong>晶体管</strong>的工作原理：</p><p><a href="https://www.bilibili.com/video/av47388949?p=2" target="_blank" rel="external">https://www.bilibili.com/video/av47388949?p=2</a></p><p>硅 -&gt; 加入特殊元素 -&gt; P半导体 N半导体 -&gt; PN 结 -&gt; 二极管 -&gt; 场效应晶体管 -&gt; 逻辑开关。</p><p>与门、或门、非门、或非门（异或） -&gt; 基础逻辑电路</p><p>加法器 累加器 锁存器</p><p>实现手动计算（通电一次，运行一次位运算）</p><p>加入内存，实现自动运算（每次读取内存指令，（高电低电））</p><p>《编码》17章</p><p><strong>CPU 工作原理：</strong>CPU 有很多针脚，这些针脚就是一些开关，每个针脚可以接收一个电信号，通电表示1，没通电表示0。通过振荡器（<strong>时钟发生器，相当于心脏，每震荡一次 CPU 进行一次计算</strong>）控制每个针脚通电断电，从而告诉 CPU 要做什么样的计算。</p><p><strong>引入内存：</strong>要输入给 CPU 的数据放在哪里呢？放在内存，内存就相当于 CPU 的仓库。所以内存的本质就是存储了一些电信号，通过总线和 CPU 相连接。</p><p>操作系统的位数可以动态控制，和 CPU 有关，CPU 每次读取 64 个数字就是 64 位。64 位 CPU 中每个寄存器大小 64 位，ALU 也是 64 位。</p><p>让计算机看懂计算：01000010 + 00101100</p><p>手工输入：纸带计算机</p><p>助计符：01000010 - mov sub</p><p>高级语言 -&gt; 编译器 -&gt; 机器语言</p><h3 id="2-3-汇编执行过程"><a href="#2-3-汇编执行过程" class="headerlink" title="2.3 汇编执行过程"></a>2.3 汇编执行过程</h3><p>汇编语言的本质就是机器语言的助计符。所以汇编语言就是机器语言。</p><p>计算机通电 -&gt; CPU 读取内存中程序(电信号输入) -&gt; 时钟发生器（目前每秒钟可以震荡 <strong>Ghz，几十亿次</strong>）不断震荡通断电 -&gt; 推动 CPU 内部一步一步执行(执行多少步取决于指令需要的时钟周期) -&gt; 计算完成 -&gt; 写回（电信号）-&gt; 写给显卡输出（sout，或者图形）</p><p><strong>问</strong>：屏幕的频率是啥意思？</p><p><strong>答</strong>：计算机经过计算，把结果从内存通过 DMA 走内存总线、IO 总线发送到显卡。屏幕上是一个一个的像素点，每个像素点对应显卡的一些数据。CPU 只负责把数据发送到显卡。屏幕所谓的频率比如 60HZ、144HZ，是指屏幕从显卡读取数据的频率。</p><p>JVM 本身不跨平台，Java 是通过 JVM 来跨平台。比如 Windows 行 10001000 表示 add，但是 Linux 上 10001001 表示加，但是 Java 统一规定 10001000 表示 add，然后提供两个 JVM 分别处理不同平台的实现，这样就实现了跨平台。</p><h3 id="2-4-量子计算机"><a href="#2-4-量子计算机" class="headerlink" title="2.4 量子计算机"></a>2.4 量子计算机</h3><p>普通比特：1bit 要么1要么0；</p><p>量子比特：可以同时又是1又是0</p><p><img src="../../images/os/1/量子比特.png" alt=""></p><p><img src="../../images/os/1/恐怖.png" alt=""></p><h2 id="3、Java-相关的硬件知识"><a href="#3、Java-相关的硬件知识" class="headerlink" title="3、Java 相关的硬件知识"></a>3、Java 相关的硬件知识</h2><p>CPU 和内存是计算机的核心。</p><h3 id="3-1-计算机和-CPU-的基本组成"><a href="#3-1-计算机和-CPU-的基本组成" class="headerlink" title="3.1 计算机和 CPU 的基本组成"></a>3.1 计算机和 CPU 的基本组成</h3><p><img src="../../images/os/1/计算机的组成.png" alt=""></p><p>1、PC：Program Counter 程序计数器（记录当前指令地址）</p><p>2、Registers：暂时存储 CPU 计算需要用到的数据。有的 CPU 有上百个寄存器。把内存数据拷贝过来，放入寄存器方便 CPU 使用，因为内存离 CPU 太远了。</p><p>3、ALU：Arithmetic &amp; Logic Unit 运算逻辑单元。比如计算 2 + 3</p><ul><li>CPU 把 2、3 读入 CPU 中的两个寄存器假设 AX、BX</li><li>然后从 PC 中读取到的指令是 add，</li><li>然后 ALU 则把 AX、BX 取出来进行一系列电路计算，结果返回到另一个寄存器假设 DX</li><li>最后把 DX 数据返回内存。</li></ul><p>4、CU：Control Unit 控制单元。中断信号控制</p><p>5、MMU：Memory Management Unit 内存管理单元</p><p>6、Cache</p><p><strong>超线程：一个 ALU 对应多个 PC|Registers 组合就是所谓的超线程。</strong></p><p>所谓的四核八线程结构，一个 CPU 核心对应一个 ALU，但是每个核心有两组 PC|Registers，所以正常来说四核对应四个 ALU，只能同时进行四个线程的并行运算，但是这里却可以八个线程并行，这就是超线程了。</p><p><img src="../../images/os/1/四核八线程.png" alt=""></p><h3 id="3-2-存储器层次结构"><a href="#3-2-存储器层次结构" class="headerlink" title="3.2 存储器层次结构"></a>3.2 存储器层次结构</h3><p> 在一个典型操作系统中，可能会有几个缓存（<strong>在多核系统中，每个核心都会有自己的缓存</strong>）共享主存总线，每个相应的 <code>CPU</code> 会发出读写请求，而缓存的目的是为了<strong>减少 CPU 读写共享主存的次数</strong>。 因为 CPU 和物理内存之间的通信速度远慢于 CPU 的处理速度 ，加入多级缓存就是为了解决<strong>处理器于内存速度之间的矛盾</strong>。</p><p><img src="../../images/os/1/存储器的层次结构.png" alt=""></p><p><strong>六级存储结构</strong></p><ul><li>L0：寄存器</li><li>L1：高速缓存（CPU 对应核心内部）</li><li>L2：高速缓存（CPU 对应核心内部）</li><li>L3：高速缓存（CPU 共享）</li><li>L4：主存</li><li>L5：磁盘</li><li>L6：远程文件存储</li></ul><p><strong>CPU 到六级存储结构时间表</strong></p><table><thead><tr><th>从 CPU 到</th><th>大约需要的 CPU 周期</th><th>大约需要的时间</th></tr></thead><tbody><tr><td>Registers</td><td>1 cycle</td><td>&lt; 1ns</td></tr><tr><td>L1 Cache</td><td>3~4 cycle</td><td>约 1ns</td></tr><tr><td>L2 Cache</td><td>10 cycle</td><td>约 3ns</td></tr><tr><td>L3 Cache</td><td>40~50 cycle</td><td>约 15ns</td></tr><tr><td>main memory</td><td></td><td>约 80ns</td></tr></tbody></table><p>从上表看出，CPU 访问 Registers 或者 L1 Cache 的速度大约是访问主存速度的 <strong>100 倍</strong>。</p><p><strong>多核 CPU 的缓存结构</strong></p><p>一块 CPU 有多个核心；每个核心有自己的 Registers、LI、L2 缓存；同一 CPU 的多个核心共享该 CPU 对应的 L3；所有 CPU 共享内存。</p><p><img src="../../images/os/1/多核CPU缓存结构.png" alt=""></p><h3 id="3-3-程序局部性原理"><a href="#3-3-程序局部性原理" class="headerlink" title="3.3 程序局部性原理"></a>3.3 程序局部性原理</h3><p>不管是从缓存读取还是从内存读取还是从磁盘读取都是<strong>按块读取</strong>。程序局部性原理，可以提高效率。充分发挥总线 CPU 针脚等一次性读取更多数据的能力。这个块对于内存来说就是内存页，对于 CPU 来说就是缓存行。</p><p><strong>Cache line 的概念。缓存行对齐、伪共享。</strong></p><p>缓存行：</p><ul><li>缓存行越大，局部性空间效率越高，但读取时间慢</li><li>缓存行越小，局部性空间效率越低，但读取时间快</li><li>取一个折中值，目前多用 64byte，工业实践决定。</li></ul><p><img src="../../images/os/1/缓存行对齐和伪共享.png" alt=""></p><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a><strong>伪共享</strong></h4><p>如何保证两个 CPU L1、L2 数据同步？<strong>缓存一致性协议</strong>。以缓存行为单位。比如 CPU1 修改了 x，缓存一致性协议会通知 CPU2，大哥你这行数据已经过时了，请重新去内存读取。这时 x、y其实就是一个<strong>伪共享</strong>的状态，看似共享，实际上由于其他 CPU 的影响，还是需要不断去内存读数据。</p><p>验证伪共享的存在：</p><h4 id="缓存行对齐"><a href="#缓存行对齐" class="headerlink" title="缓存行对齐"></a><strong>缓存行对齐</strong></h4><p>对于有些特别敏感的数字，会存在线程高竞争的访问，<strong>为了保证不发生伪共享</strong>，可以使用缓存行对齐的编程方式。</p><p>验证使用缓存行对齐的方式提高程序的效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// disruptor</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> p1,p2,p3,p4,p5,p6,p7; <span class="comment">// cache line padding</span></div><div class="line"><span class="comment">// 前后均加上 7 个long，所以 cursor 肯定不会和其他数据在同一个缓存行，所以就不会有伪共享的问题了</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> cursor = INITIAL_CURSOR_VALUE;</div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> p8,p9,p10,p11,p12,p13,p14; <span class="comment">// cache line padding</span></div><div class="line"></div><div class="line"><span class="comment">// JDK7中，很多采用 long padding 提高效率。</span></div><div class="line"><span class="comment">// JDK8中，加入了 @Contended 注解（实验），需要加上JVM 参数：-XX:-RestrictContended  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_Contended</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 需要加上以下 JVM 参数生效。</span></div><div class="line"><span class="comment">     * 增加该注解的原因是，原来前后加 7 个 long 的方式只对 intel CPU 有效</span></div><div class="line"><span class="comment">     * 对于其他 CPU 不一定有效，因为别的 CPU 缓存行不一定 64 字节，比如可能 128 字节</span></div><div class="line"><span class="comment">     * -XX:-RestrictContended</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Contended</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</div><div class="line">    <span class="meta">@Contended</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        T05_Contended t = <span class="keyword">new</span> T05_Contended();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</div><div class="line">                t.x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</div><div class="line">                t.y = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-4-缓存一致性-Cache-Coherence-协议"><a href="#3-4-缓存一致性-Cache-Coherence-协议" class="headerlink" title="3.4 缓存一致性(Cache Coherence)协议"></a>3.4 缓存一致性(Cache Coherence)协议</h3><p>在多路处理器系统中，每个<strong>处理器内部(L1、L2)</strong>都有自己的高速缓存，而它们又共享同一<strong>主内存（Main Memory）</strong>，这种系统称为<strong>共享内存多核系统（Shared Memory Multiprocessors System）</strong>。</p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，从而引发缓存一致性问题。</p><p><img src="../../images/jvm/03/处理器_高速缓存_主内存关系.png" alt=""></p><p>不同 CPU 使用的缓存一致性协议有所不同。MSI、MESI、MOSI、Synapse、Firefly、Dragon 等都是缓存一致性协议。Intel 目前用的缓存一致性协议是 <strong>MESI</strong>。</p><p>JVM 也有自己的内存模型，并且与这里介绍的硬件级别的内存模型有高度的可类比性。</p><p>验证缓存一致性协议对性能的影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_CacheLinePadding</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * long 8字节，数组中两个元素肯定在同一个缓存行</span></div><div class="line"><span class="comment">     * 两个不同线程分别修改数组元素，两个 CPU 去处理，两个 CPU 都会缓存这个缓存行</span></div><div class="line"><span class="comment">     * 缓存一致性协议肯定会不停的互相通知对方去内存取最新的数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10_0000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">0</span>] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10_0000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">1</span>] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_CacheLinePadding</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * long 8字节，0 号和 8 号元素肯定不在一个缓存行</span></div><div class="line"><span class="comment">     * 两个不同线程分别修改数组元素，两个 CPU 去处理</span></div><div class="line"><span class="comment">     * 由于数据在不同的缓存行，互不影响</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">16</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10_0000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">0</span>] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10_0000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">8</span>] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> MESI 协议细节：<a href="https://www.cnblogs.com/z00377750/p/9180644.html" target="_blank" rel="external">https://www.cnblogs.com/z00377750/p/9180644.html</a> </p><p><img src="../../images/os/1/缓存一致性协议.png" alt=""></p><h3 id="3-5-总线锁"><a href="#3-5-总线锁" class="headerlink" title="3.5 总线锁"></a>3.5 <strong>总线锁</strong></h3><p>有些无法被缓存的数据或者跨越多个缓存行的数据，缓存一致性协议无法解决一致性问题，这时需要锁总线。缓存一致性协议有时也被称为缓存锁。一旦总线锁定，这台计算机的其他 CPU 均无法访问内存，所以和缓存锁相比效率更低。</p><p><strong>总结：</strong>为了缓解 cpu 和内存之间速度差异，CPU 和内存之间增加多级高速缓存；为了减少访问内存的次数，引入程序局部性原理，引入缓存行的概念；为了解决多核 CPU 缓存行数据一致性问题，引入缓存锁（缓存一致性协议）的概念；还是为了解决多核 CPU 缓存行数据一致性问题，有些数据跨越多个缓存行或者无法缓存，引入总线锁的概念。</p><h3 id="3-6-CPU-乱序执行"><a href="#3-6-CPU-乱序执行" class="headerlink" title="3.6 CPU 乱序执行"></a>3.6 CPU 乱序执行</h3><p>除了增加高速缓存之外，为了使处理器内部的运算单元(ALU)能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，保证最终结果一样，但不保证执行顺序。</p><p>CPU 为了提高指令执行效率，会在一条指令执行过程中（比如去内存读取数据（慢100倍）），去同时执行另一条指令，前提是<strong>两条指令没有依赖关系</strong>。</p><p>CPU 乱序的根源：CPU 在<strong>读等待</strong>的时候执行其他不影响的指令；CPU 在写的同时可以进行<strong>合并写</strong>。</p><p><img src="../../images/jvm/03/CPU指令重排序问题.png" alt=""></p><p><strong>CPU 乱序执行证明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisOrder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a, b;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x, y;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 假设不会乱序执行</span></div><div class="line"><span class="comment">     * a=1 x=b b=1 y=a ==&gt;x=0,y=1</span></div><div class="line"><span class="comment">     * a=1 b=1 x=b y=a ==&gt;x=1,y=1</span></div><div class="line"><span class="comment">     * a=1 b=1 y=a x=b ==&gt;x=1,y=1</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * b=1 y=a a=1 x=b ==&gt;x=1,y=0</span></div><div class="line"><span class="comment">     * b=1 a=1 x=b y=a ==&gt;x=1,y=1</span></div><div class="line"><span class="comment">     * b=1 a=1 y=a x=b ==&gt;x=1,y=1</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 乱序</span></div><div class="line"><span class="comment">     * x=b y=a a=1 b=1</span></div><div class="line"><span class="comment">     * y=a x=b a=1 b=1</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            i++;</div><div class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</div><div class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</div><div class="line">            Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="comment">// shortWait(100000);</span></div><div class="line">                a = <span class="number">1</span>;</div><div class="line">                x = b;</div><div class="line">            &#125;);</div><div class="line">            Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                b = <span class="number">1</span>;</div><div class="line">                y = a;</div><div class="line">            &#125;);</div><div class="line">            one.start();other.start();</div><div class="line">            one.join();other.join();</div><div class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>;</div><div class="line">            System.out.println(result);</div><div class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</div><div class="line">                System.err.println(result);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>CPU 合并写证明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            System.out.println(i + <span class="string">" singleLoop duration (ns) ="</span> + runCaseOne());</div><div class="line">            System.out.println(i + <span class="string">" singleLoop duration (ns) ="</span> + runCaseTwo());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 直接一次写完速度反而更慢</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">int</span> i = ITERATIONS;</div><div class="line"></div><div class="line">        <span class="comment">// 写完四个字节后,剩下两个还要等待其他两个字节来填充后才提交</span></div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>)  &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</div><div class="line">            arrayA[slot] = b;</div><div class="line">            arrayB[slot] = b;</div><div class="line">            arrayC[slot] = b;</div><div class="line">            arrayD[slot] = b;</div><div class="line">            arrayE[slot] = b;</div><div class="line">            arrayF[slot] = b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.nanoTime() - start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 充分利用合并写技术,速度块一倍</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">int</span> i = ITERATIONS;</div><div class="line">        <span class="comment">// 每次四个字节,直接提交</span></div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</div><div class="line">            arrayA[slot] = b;</div><div class="line">            arrayB[slot] = b;</div><div class="line">            arrayC[slot] = b;</div><div class="line">        &#125;</div><div class="line">        i = ITERATIONS;</div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</div><div class="line">            arrayD[slot] = b;</div><div class="line">            arrayE[slot] = b;</div><div class="line">            arrayF[slot] = b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.nanoTime() - start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CPU 有一个  WC Cache，只有四个字节，速度比一级缓存更快。WC Cache 满了直接写回 L2。所以每次处理四个字节效率更高。</p><h3 id="3-6-CPU-如何保证有序执行"><a href="#3-6-CPU-如何保证有序执行" class="headerlink" title="3.6 CPU 如何保证有序执行"></a>3.6 CPU 如何保证有序执行</h3><h4 id="CPU-内存屏障"><a href="#CPU-内存屏障" class="headerlink" title="CPU 内存屏障"></a>CPU 内存屏障</h4><p>​    sfence（读）：在 sfence（save fence） 指令前的写操作必须在 sfence 指令后的写操作前完成</p><p>​    lfence（写）：在 lfence(load fence) 指令前的读操作必须在 lfence 指令后的读操作前完成</p><p>​    mfence（读写）：在 mfence(mix fence) 指令前的读写操作必须在 mfence 指令后的读写操作前完成</p><p>intel lock 汇编指令(原子指令)？</p><h4 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h4><p>和上面缓存一致性问题中的总线锁是一个概念。即总线锁既可以解决一致性问题又可以解决乱序问题 ，但是是一个重量级操作。</p><h3 id="3-7-JVM-如何保证有序执行"><a href="#3-7-JVM-如何保证有序执行" class="headerlink" title="3.7 JVM 如何保证有序执行"></a>3.7 JVM 如何保证有序执行</h3><h4 id="8-个-hanppens-before-原则"><a href="#8-个-hanppens-before-原则" class="headerlink" title="8 个 hanppens-before 原则"></a>8 个 hanppens-before 原则</h4><p>操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>JMM 定义了一些“天然的”线性发生关系，他们无需任何同步器协助就已经存在。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，<strong>虚拟机可以对它们随意地进行重排序</strong>。</p><p>这只是 Java 的一个规范，具体由各个 JVM 实现。</p><p><img src="../../images/os/1/happens-before.png" alt=""></p><p><strong>时间先后顺序与先行发生原则之间基本没有因果关系</strong></p><ul><li>A 先行 B，但是时间上 A 不一定先于 B。典型的<strong>指令重排序</strong>，看程序次序规则就可理解。</li><li>A 时间顺序先于 B，A 不一定先行于 B。比如线程1时间上先 setValue，线程2紧接着 getValue。上面没有一个规则能证明线程1 set 操作先行于线程2 get 操作，所以如果不做手动同步处理，无法保证线程2 可以获取到正确的线程1 设置的值。</li></ul><h4 id="4-个-JVM-内存屏障"><a href="#4-个-JVM-内存屏障" class="headerlink" title="4 个 JVM 内存屏障"></a>4 个 JVM 内存屏障</h4><p>JVM 内存屏障只是一个规范，不同 CPU 的实现方式可能不同。比如龙芯、x86、arm 等 cpu 实现都不同。</p><p><strong>LoadLoad 屏障：</strong></p><ul><li><strong>对于这样的语句 Load1;</strong> LoadLoad;Load2，在 Load2及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li></ul><p><strong>StoreStore 屏障：</strong></p><ul><li>对于这样的语句 Store1;StoreStore;Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其他处理器可见。</li></ul><p><strong>LoadStore 屏障：</strong></p><ul><li>对于这样的语句 Load1;StoreStore;Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据已经被读取完毕。</li></ul><p><strong>StoreLoad 屏障：</strong></p><ul><li>对于这样的语句 Store1;StoreStore;Load2，在 Load2 及后续读取操作执行前，保证 Store1 的写入对所有处理器可见。</li></ul><p>CPU层面：Intel -&gt; 原语(mfence lfence sfence) 或者锁总线</p><p>JVM层级：8个hanppens-before原则 4个内存屏障 （LL LS SL SS）</p><p>as-if-serial : 不管硬件什么顺序，单线程执行的结果不变，看上去像是serial</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习（一）。Linux 基础。&lt;/p&gt;
&lt;p&gt;操作系统学习（一）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 基本原理&lt;/li&gt;
&lt;li&gt;汇编基本原理&lt;/li&gt;
&lt;li&gt;计算机和 CPU 的基本组成&lt;/li&gt;
&lt;li&gt;存储器层次结构&lt;/li&gt;
&lt;li&gt;程序局部性原理、缓存行、伪共享、缓存行对齐&lt;/li&gt;
&lt;li&gt;缓存一致性协议（缓存锁）&lt;/li&gt;
&lt;li&gt;总线锁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十四) 经典面试题目</title>
    <link href="http://yoursite.com/2020-09-10-mysql/mysql_14_%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-09-10-mysql/mysql_14_经典面试题.html</id>
    <published>2020-09-10T15:13:12.000Z</published>
    <updated>2020-09-13T11:27:14.471Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1、MySQL的复制原理以及流程"><a href="#1、MySQL的复制原理以及流程" class="headerlink" title="1、MySQL的复制原理以及流程"></a>1、<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/mysql" target="_blank" rel="external">MySQL</a>的复制原理以及流程</h2><ul><li>master 必须开启 binlog</li><li>每当 master 数据有更新，数据会记录进入 binlog</li><li>slave 会定时嗅探 master binlog 变化</li><li>一旦有变化，就会启动一个 I/O Thread 请求 master 的数据</li><li>master 启动 dump 线程，向 slave 发送事件日志</li><li>I/O Thread 接收事件日志，然后存入本地的中继日志（relay-log 中）</li><li>启动 SQL Thread 重放 relay-log，从而进行主从数据同步</li></ul><h2 id="2、MyISAM-与-InnoDB-的区别"><a href="#2、MyISAM-与-InnoDB-的区别" class="headerlink" title="2、MyISAM 与 InnoDB 的区别"></a>2、MyISAM 与 InnoDB 的区别</h2><p>1、非聚簇索引、聚簇索引</p><p>2、不支持行锁、支持行锁；都支持表锁</p><p>3、不支持事务、支持事务</p><p>4、不支持外键、支持外键</p><p>5、支持全文索引、5.6 之后支持</p><h3 id="InnoDB-4-大特征"><a href="#InnoDB-4-大特征" class="headerlink" title="InnoDB 4 大特征"></a>InnoDB 4 大特征</h3><h3 id="两者-select-count-那个更快？"><a href="#两者-select-count-那个更快？" class="headerlink" title="两者 select count(*) 那个更快？"></a>两者 select count(*) 那个更快？</h3><ul><li>无 where count(*) MyISAM 很快；无 where count(column(not null)) MyISAM 很快</li><li><p>有 where 并建立了索引 count 很快，否则全表扫描</p><h2 id="3、varchar-与-char-的区别，-varchar-50-中的-50-代表的涵义"><a href="#3、varchar-与-char-的区别，-varchar-50-中的-50-代表的涵义" class="headerlink" title="3、varchar 与 char 的区别， varchar(50) 中的 50 代表的涵义"></a>3、varchar 与 char 的区别， varchar(50) 中的 50 代表的涵义</h2></li></ul><p>区别：</p><ul><li>大小不同，char 255 字符；varchar 65535 字节（换算字符除以 2 或 3）</li><li>一般用 varchar 来存储变长数据，char 存储定长数据比如手机号、身份证号、MD5码等</li></ul><p>50 的含义：</p><p>​    最长不能超过 50 个字符。</p><p> int（20）中 20 的涵义 ：</p><p>​    数字前面展示 0。不代表长度，实际能放多大的数据由 int 字节数限制。int 4 字节。</p><h2 id="4、-innodb-的事务与日志的实现方式"><a href="#4、-innodb-的事务与日志的实现方式" class="headerlink" title="4、 innodb 的事务与日志的实现方式"></a>4、 innodb 的事务与日志的实现方式</h2><p>1、事务的概念（ACID）</p><p>2、I 引出的四种隔离级别</p><p>3、各个隔离级别引发的并发事务问题</p><p>4、锁机制（表锁、行锁）；乐观锁(数据版本记录机制实现)、悲观锁(数据库锁机制实现)</p><p>5、有多少种日志，事务和日志（事务如何通过日志实现），日志先行技术。主从一致问题。</p><h2 id="5、-binlog-的几种日志录入格式以及区别"><a href="#5、-binlog-的几种日志录入格式以及区别" class="headerlink" title="5、 binlog 的几种日志录入格式以及区别"></a>5、 binlog 的几种日志录入格式以及区别</h2><p>binlog-format：row、statement、mixed</p><p>statement 日志量可能更小一点，降低 I/O 消耗，提升主从复制的性能。但并不是所有的语句都可以用 statement 记录，比如一些使用了 sleep()、uuid() 等特殊函数的语句。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1、MySQL的复制原理以及流程&quot;&gt;&lt;a href=&quot;#1、MySQL的复制原理以及流程&quot; class=&quot;headerlink&quot; title=&quot;1、MySQL的复制原理以及流程&quot;&gt;&lt;/a&gt;1、&lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-09-09-%E8%AF%BB%E4%B9%A6/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8.html"/>
    <id>http://yoursite.com/2020-09-09-读书/富爸爸穷爸爸.html</id>
    <published>2020-09-09T15:41:28.570Z</published>
    <updated>2020-09-09T15:44:19.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、富人不为钱工作"><a href="#1、富人不为钱工作" class="headerlink" title="1、富人不为钱工作"></a>1、富人不为钱工作</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、富人不为钱工作&quot;&gt;&lt;a href=&quot;#1、富人不为钱工作&quot; class=&quot;headerlink&quot; title=&quot;1、富人不为钱工作&quot;&gt;&lt;/a&gt;1、富人不为钱工作&lt;/h2&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-09-05-%E7%94%B5%E5%BD%B1/%E8%A7%A6%E4%B8%8D%E5%8F%AF%E5%8F%8A.html"/>
    <id>http://yoursite.com/2020-09-05-电影/触不可及.html</id>
    <published>2020-09-05T12:36:44.875Z</published>
    <updated>2020-09-05T13:22:59.639Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>热爱与批判</strong>：人总要有自己的喜怒哀乐，自己的是非对错。热爱就表现出来，不喜欢就直说。</p></li><li><p><strong>尊重与理解</strong>：“是给他的吗？”，“老弟，别这样，直接问他”。真正尊重别人，就请摘下你的有色眼镜。</p></li><li><p><strong>成熟与成长</strong>：“人人都会犯错，可是我犯的错太多了”。在成熟之后，我也会感叹我犯的错太多了吗？</p></li><li><p><strong>绝境与重生</strong>：当人生走上绝境，我会遇到这样一个挚友吗？或者说我自己会成为自己的挚友吗？</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;热爱与批判&lt;/strong&gt;：人总要有自己的喜怒哀乐，自己的是非对错。热爱就表现出来，不喜欢就直说。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;尊重与理解&lt;/strong&gt;：“是给他的吗？”，“老弟，别这样，直接问他”。真正尊重别人
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySql 调优(十三) Java SPI 机制详解</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_13_JavaSPI%E6%9C%BA%E5%88%B6.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_13_JavaSPI机制.html</id>
    <published>2020-08-29T15:13:12.000Z</published>
    <updated>2020-09-08T15:47:12.436Z</updated>
    
    <content type="html"><![CDATA[<ul><li>case … when + sum + group by 行转列</li></ul><a id="more"></a><h2 id="1、什么是-SPI？"><a href="#1、什么是-SPI？" class="headerlink" title="1、什么是 SPI？"></a>1、什么是 SPI？</h2><p>SPI 全称为 (<strong>Service Provider Interface</strong>) ，是 JDK 内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql 和 postgresql 都有不同的实现提供给用户，而 Java 的 SPI 机制可以为某个接口寻找服务实现。</p><p><img src="../../images/mysql/13/spi.jpg" alt=""></p><p>  如上图所示，接口对应的抽象SPI接口；实现方实现SPI接口；调用方依赖SPI接口。</p><p>SPI 接口的定义在调用方，在概念上更依赖调用方；组织上位于调用方所在的包中，<strong>实现位于独立的包中</strong>。</p><p>当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 <strong>META-INF/services/</strong> 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个 jar 包（一般都是以 jar 包做依赖）的 META-INF/services/ 中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK 中查找服务实现的工具类是：<strong>java.util.ServiceLoader</strong>。</p><h2 id="2、SPI-的用途"><a href="#2、SPI-的用途" class="headerlink" title="2、SPI 的用途"></a>2、SPI 的用途</h2><p>数据库 DriverManager、Spring、ConfigurableBeanFactory 等都用到了 SPI 机制，这里以数据库DriverManager 为例，看一下其实现的内幕。</p><p>DriverManager 是 jdbc 里管理和注册不同数据库 driver 的工具类。针对一个数据库，可能会存在着不同的数据库驱动实现。我们在使用特定的驱动实现时，不希望修改现有的代码，而希望通过一个简单的配置就可以达到效果。 在使用 mysql 驱动的时候，会有一个疑问，DriverManager 是怎么获得某确定驱动类的？我们在运用 Class.forName(“com.mysql.jdbc.Driver”) 加载 mysql 驱动后，就会执行其中的静态代码把 driver 注册到 DriverManager 中，以便后续的使用。</p><h3 id="JDBC-使用-SPI-实现细节"><a href="#JDBC-使用-SPI-实现细节" class="headerlink" title="JDBC 使用 SPI 实现细节"></a>JDBC 使用 SPI 实现细节</h3><p>DriverManager.getConnection 获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/test?"</span> +</div><div class="line">  <span class="string">"useSSL=false&amp;serverTimezone=Hongkong&amp;allowPublicKeyRetrieval=true"</span>, <span class="string">"root"</span>, <span class="string">"Pass9876"</span>);</div><div class="line"></div><div class="line">ensureDriversInitialized();</div></pre></td></tr></table></figure><p>调用 ServiceLoader 的 hasNext 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If the driver is packaged as a Service Provider, load it.</span></div><div class="line"><span class="comment">// Get all the drivers through the classloader</span></div><div class="line"><span class="comment">// exposed as a java.sql.Driver.class service.</span></div><div class="line"><span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></div><div class="line"></div><div class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</div><div class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</div><div class="line"></div><div class="line">        <span class="comment">/* Load these drivers, so that they can be instantiated.</span></div><div class="line"><span class="comment">                     * It may be the case that the driver class may not be there</span></div><div class="line"><span class="comment">                     * i.e. there may be a packaged driver with the service class</span></div><div class="line"><span class="comment">                     * as implementation of java.sql.Driver but the actual class</span></div><div class="line"><span class="comment">                     * may be missing. In that case a java.util.ServiceConfigurationError</span></div><div class="line"><span class="comment">                     * will be thrown at runtime by the VM trying to locate</span></div><div class="line"><span class="comment">                     * and load the service.</span></div><div class="line"><span class="comment">                     *</span></div><div class="line"><span class="comment">                     * Adding a try catch block to catch those runtime errors</span></div><div class="line"><span class="comment">                     * if driver not available in classpath but it's</span></div><div class="line"><span class="comment">                     * packaged as service and that service is there in classpath.</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (driversIterator.hasNext()) &#123;</div><div class="line">                driversIterator.next();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// Do nothing</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>最终调用的是 LazyClassPathLookupIterator 的 hasNextService 方法中的 nextProviderClass 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Loads and returns the next provider class.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Class&lt;?&gt; nextProviderClass() &#123;</div><div class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// static final String PREFIX = "META-INF/services/";</span></div><div class="line">            String fullName = PREFIX + service.getName();</div><div class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</div><div class="line">                configs = ClassLoader.getSystemResources(fullName);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loader == ClassLoaders.platformClassLoader()) &#123;</div><div class="line">                <span class="comment">// The platform classloader doesn't have a class path,</span></div><div class="line">                <span class="comment">// but the boot loader might.</span></div><div class="line">                <span class="keyword">if</span> (BootLoader.hasClassPath()) &#123;</div><div class="line">                    configs = BootLoader.findResources(fullName);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    configs = Collections.emptyEnumeration();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                configs = loader.getResources(fullName);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</div><div class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// META-INF/services/ 下的配置文件</span></div><div class="line">        pending = parse(configs.nextElement());</div><div class="line">    &#125;</div><div class="line">    String cn = pending.next();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 加载配置类</span></div><div class="line">        <span class="keyword">return</span> Class.forName(cn, <span class="keyword">false</span>, loader);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</div><div class="line">        fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Class.forName 加载 Driver 实现类，会执行静态块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        DriverManager.registerDriver(<span class="keyword">new</span> Driver());</div><div class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DriverManager.registerDriver，把 Driver 实现放入 registeredDrivers 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></div><div class="line"><span class="function"><span class="params">                                  DriverAction da)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Register the driver if it has not already been added to our list */</span></div><div class="line">    <span class="keyword">if</span> (driver != <span class="keyword">null</span>) &#123;</div><div class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    println(<span class="string">"registerDriver: "</span> + driver);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>回到 DriverManager.getConnection 方法，循环 registeredDrivers，取出 Driver 进行 connect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123;</div><div class="line">    <span class="comment">// If the caller does not have permission to load the driver then</span></div><div class="line">    <span class="comment">// skip it.</span></div><div class="line">    <span class="keyword">if</span> (isDriverAllowed(aDriver.driver, callerCL)) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</div><div class="line">            Connection con = aDriver.driver.connect(url, info);</div><div class="line">            <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Success!</span></div><div class="line">                println(<span class="string">"getConnection returning "</span> + aDriver.driver.getClass().getName());</div><div class="line">                <span class="keyword">return</span> (con);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</div><div class="line">            <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</div><div class="line">                reason = ex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SPI-demo"><a href="#SPI-demo" class="headerlink" title="SPI demo"></a>SPI demo</h3><p>创建接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShout</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">IShout</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"miao miao"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">IShout</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"wang wang"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 resource 目录下新建 META-INF/services 目录，然后创建配置文件 unit13_jdbc.spi.IShout，文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unit13_jdbc.spi.Dog</div><div class="line">unit13_jdbc.spi.Cat</div></pre></td></tr></table></figure><p>验证是否生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPIMain</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</div><div class="line">        Iterator&lt;IShout&gt; iterator = shouts.iterator();</div><div class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">            IShout s = iterator.next();</div><div class="line">            s.shout();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 控制台输出</span></div><div class="line">wang wang</div><div class="line">miao miao</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;case … when + sum + group by 行转列&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十二) 经典笔试题</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_12_%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_12_经典笔试题.html</id>
    <published>2020-08-29T14:13:12.000Z</published>
    <updated>2020-09-11T13:40:09.076Z</updated>
    
    <content type="html"><![CDATA[<ul><li>case … when + sum + group by 行转列</li><li>case when … 搜索</li><li>if + sum + group by 行转列</li><li>拼接 sql + prepare … from … + execute + deallocate prepare 行转列</li><li>with rollup 汇总行</li><li>union all 汇总行</li><li>group_concat() 分组拼接展示</li><li>union all 列转行</li></ul><a id="more"></a><h2 id="1、第一题"><a href="#1、第一题" class="headerlink" title="1、第一题"></a>1、第一题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 数据准备</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</div><div class="line">   <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</div><div class="line">   <span class="keyword">type</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'1-姓名 2-性别 3-年龄'</span>, </div><div class="line">   t_id <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'userId'</span>,</div><div class="line">   <span class="keyword">value</span> <span class="built_in">varchar</span>(<span class="number">50</span>)</div><div class="line">);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'张三'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">200</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">'男'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">300</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="string">'50'</span>);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">101</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">'刘二'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">201</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">'男'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">301</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="string">'30'</span>);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">102</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">'刘三'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">202</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'女'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">302</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'10'</span>);</div><div class="line"></div><div class="line">+<span class="comment">-----+------+------+--------+</span></div><div class="line">| id  | type | t_id | value  |</div><div class="line">+<span class="comment">-----+------+------+--------+</span></div><div class="line">| 100 |    1 |    1 | 张三   |</div><div class="line">| 101 |    1 |    2 | 刘二   |</div><div class="line">| 102 |    1 |    3 | 刘三   |</div><div class="line">| 200 |    2 |    1 | 男     |</div><div class="line">| 201 |    2 |    2 | 男     |</div><div class="line">| 202 |    2 |    3 | 女     |</div><div class="line">| 300 |    3 |    1 | 50     |</div><div class="line">| 301 |    3 |    2 | 30     |</div><div class="line">| 302 |    3 |    3 | 10     |</div><div class="line">+<span class="comment">-----+------+------+--------+</span></div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>50</td></tr><tr><td>刘二</td><td>男</td><td>30</td></tr><tr><td>刘三</td><td>女</td><td>10</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">case</span> s.type <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> s.value <span class="keyword">end</span>) <span class="string">'姓名'</span>,</div><div class="line">  <span class="keyword">max</span>(<span class="keyword">case</span> s.type <span class="keyword">when</span> <span class="number">2</span> <span class="keyword">then</span> s.value <span class="keyword">end</span>) <span class="string">'性别'</span>,</div><div class="line">  <span class="keyword">max</span>(<span class="keyword">case</span> s.type <span class="keyword">when</span> <span class="number">3</span> <span class="keyword">then</span> s.value <span class="keyword">end</span>) <span class="string">'年龄'</span></div><div class="line"><span class="keyword">from</span> student s</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.t_id</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="2、第二题"><a href="#2、第二题" class="headerlink" title="2、第二题"></a>2、第二题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp(rq <span class="built_in">varchar</span>(<span class="number">20</span>),shengfu <span class="built_in">varchar</span>(<span class="number">20</span>));</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'胜'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'胜'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'负'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-09'</span>,<span class="string">'负'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-10'</span>,<span class="string">'胜'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-10'</span>,<span class="string">'负'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp <span class="keyword">values</span>(<span class="string">'2005-05-10'</span>,<span class="string">'负'</span>);</div></pre></td></tr></table></figure><p>如果要生成下列结果, 该如何写 sql 语句?</p><table><thead><tr><th>日期</th><th>胜场数</th><th>负场数</th></tr></thead><tbody><tr><td>2005-05-09</td><td>2</td><td>2</td></tr><tr><td>2005-05-10</td><td>1</td><td>2</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> rq <span class="string">'日期'</span>, </div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> shengfu <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'胜场数'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> shengfu <span class="keyword">when</span> <span class="string">'胜'</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) <span class="string">'负场数'</span> </div><div class="line">  <span class="keyword">FROM</span> tmp</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> rq</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="3、第三题"><a href="#3、第三题" class="headerlink" title="3、第三题"></a>3、第三题</h2><h3 id="1、case-列-when-列值-then"><a href="#1、case-列-when-列值-then" class="headerlink" title="1、case 列 when 列值 then"></a>1、case 列 when 列值 then</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_score</div><div class="line">(</div><div class="line">  <span class="keyword">name</span>    <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</div><div class="line">  subject <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</div><div class="line">  score   <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>)</div><div class="line">);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="string">'语文'</span>, <span class="number">78.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="string">'数学'</span>, <span class="number">88.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="string">'英语'</span>, <span class="number">98.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'李四'</span>, <span class="string">'语文'</span>, <span class="number">89.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'李四'</span>, <span class="string">'数学'</span>, <span class="number">76.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'李四'</span>, <span class="string">'英语'</span>, <span class="number">90.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'王五'</span>, <span class="string">'语文'</span>, <span class="number">99.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'王五'</span>, <span class="string">'数学'</span>, <span class="number">66.0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_score (<span class="keyword">NAME</span>, SUBJECT, SCORE) <span class="keyword">values</span> (<span class="string">'王五'</span>, <span class="string">'英语'</span>, <span class="number">91.0</span>);</div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>姓名</th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>王五</td><td>99</td><td>66</td><td>91</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="string">'姓名'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'英语'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'英语'</span></div><div class="line"><span class="keyword">from</span> student_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span></div><div class="line">;</div></pre></td></tr></table></figure><h3 id="2、case-when-表达式-then"><a href="#2、case-when-表达式-then" class="headerlink" title="2、case when 表达式 then"></a>2、case when 表达式 then</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_score_result(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),yuwen <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>) ,shuxue <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>),yingyu <span class="built_in">decimal</span>(<span class="number">4</span>,<span class="number">1</span>));</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student_score_result`</span>(<span class="string">`name`</span>, <span class="string">`yuwen`</span>, <span class="string">`shuxue`</span>, <span class="string">`yingyu`</span>) <span class="keyword">VALUES</span> (<span class="string">'张三'</span>, <span class="number">78.0</span>, <span class="number">88.0</span>, <span class="number">98.0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student_score_result`</span>(<span class="string">`name`</span>, <span class="string">`yuwen`</span>, <span class="string">`shuxue`</span>, <span class="string">`yingyu`</span>) <span class="keyword">VALUES</span> (<span class="string">'李四'</span>, <span class="number">89.0</span>, <span class="number">76.0</span>, <span class="number">90.0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student_score_result`</span>(<span class="string">`name`</span>, <span class="string">`yuwen`</span>, <span class="string">`shuxue`</span>, <span class="string">`yingyu`</span>) <span class="keyword">VALUES</span> (<span class="string">'王五'</span>, <span class="number">99.0</span>, <span class="number">66.0</span>, <span class="number">91.0</span>);</div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>及格</td><td>优秀</td><td>不及格</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="string">'姓名'</span>, </div><div class="line">  <span class="keyword">case</span> <span class="keyword">when</span> yuwen &gt;= <span class="number">80</span> <span class="keyword">then</span> <span class="string">'优秀'</span> <span class="keyword">when</span> yuwen &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span> <span class="keyword">else</span> <span class="string">'不及格'</span> <span class="keyword">end</span> <span class="string">'语文'</span>, </div><div class="line">  <span class="keyword">case</span> <span class="keyword">when</span> shuxue &gt;= <span class="number">80</span> <span class="keyword">then</span> <span class="string">'优秀'</span> <span class="keyword">when</span> shuxue &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span> <span class="keyword">else</span> <span class="string">'不及格'</span> <span class="keyword">end</span> <span class="string">'数学'</span>, </div><div class="line">  <span class="keyword">case</span> <span class="keyword">when</span> yingyu &gt;= <span class="number">80</span> <span class="keyword">then</span> <span class="string">'优秀'</span> <span class="keyword">when</span> yingyu &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'及格'</span> <span class="keyword">else</span> <span class="string">'不及格'</span> <span class="keyword">end</span> <span class="string">'英语'</span></div><div class="line"><span class="keyword">from</span> student_score_result</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="4、第四题"><a href="#4、第四题" class="headerlink" title="4、第四题"></a>4、第四题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> yj01(</div><div class="line">       <span class="keyword">month</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</div><div class="line">       deptno <span class="built_in">varchar</span>(<span class="number">10</span>),</div><div class="line">       yj <span class="built_in">decimal</span>(<span class="number">10</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'一月份'</span>,<span class="string">'01'</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'二月份'</span>,<span class="string">'02'</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'二月份'</span>,<span class="string">'03'</span>,<span class="number">5</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'三月份'</span>,<span class="string">'02'</span>,<span class="number">8</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'三月份'</span>,<span class="string">'04'</span>,<span class="number">9</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> yj01(<span class="keyword">month</span>,deptno,yj) <span class="keyword">values</span>(<span class="string">'三月份'</span>,<span class="string">'03'</span>,<span class="number">8</span>);</div></pre></td></tr></table></figure><p>显示格式：</p><table><thead><tr><th>部门</th><th>一月</th><th>二月</th><th>三月</th></tr></thead><tbody><tr><td>01</td><td>10</td><td></td><td></td></tr><tr><td>02</td><td></td><td>10</td><td>8</td></tr><tr><td>03</td><td></td><td>5</td><td>8</td></tr><tr><td>04</td><td></td><td></td><td>9</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> deptno <span class="string">'部门'</span>, </div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">'一月份'</span> <span class="keyword">then</span> yj <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'一月'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">'二月份'</span> <span class="keyword">then</span> yj <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'二月'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">'三月份'</span> <span class="keyword">then</span> yj <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'三月'</span></div><div class="line"><span class="keyword">from</span> yj01</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</div><div class="line">;</div></pre></td></tr></table></figure><h2 id="5、第五题"><a href="#5、第五题" class="headerlink" title="5、第五题"></a>5、第五题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> tb_score;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_score(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</div><div class="line">    userid <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</div><div class="line">    subject <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">COMMENT</span> <span class="string">'科目'</span>,</div><div class="line">    score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'成绩'</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="string">'语文'</span>,<span class="number">90</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="string">'数学'</span>,<span class="number">92</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="string">'英语'</span>,<span class="number">80</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="string">'语文'</span>,<span class="number">88</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="string">'数学'</span>,<span class="number">90</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="string">'英语'</span>,<span class="number">75.5</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'语文'</span>,<span class="number">70</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'数学'</span>,<span class="number">85</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'英语'</span>,<span class="number">90</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score(userid,subject,score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="string">'政治'</span>,<span class="number">82</span>);</div><div class="line"></div><div class="line">+<span class="comment">----+--------+---------+-------+</span></div><div class="line">| id | userid | subject | score |</div><div class="line">+<span class="comment">----+--------+---------+-------+</span></div><div class="line">|  1 | 001    | 语文    |    90 |</div><div class="line">|  2 | 001    | 数学    |    92 |</div><div class="line">|  3 | 001    | 英语    |    80 |</div><div class="line">|  4 | 002    | 语文    |    88 |</div><div class="line">|  5 | 002    | 数学    |    90 |</div><div class="line">|  6 | 002    | 英语    |  75.5 |</div><div class="line">|  7 | 003    | 语文    |    70 |</div><div class="line">|  8 | 003    | 数学    |    85 |</div><div class="line">|  9 | 003    | 英语    |    90 |</div><div class="line">| 10 | 003    | 政治    |    82 |</div><div class="line">+<span class="comment">----+--------+---------+-------+</span></div><div class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</div></pre></td></tr></table></figure><h3 id="1、-case…when…-then-group-by-sum-行转列"><a href="#1、-case…when…-then-group-by-sum-行转列" class="headerlink" title="1、 case…when….then + group by + sum 行转列"></a>1、 <strong>case…when….then + group by + sum 行转列</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> userid, </div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'英语'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'政治'</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="string">'政治'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="2、-IF-group-by-sum-行转列："><a href="#2、-IF-group-by-sum-行转列：" class="headerlink" title="2、 IF() + group by + sum 行转列："></a>2、 <strong>IF() + group by + sum 行转列：</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> userid,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="3、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行"><a href="#3、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行" class="headerlink" title="3、 SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行"></a>3、 SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行</h3><p>with ROLLUP 用法</p><h3 id="4、-SUM-IF-生成列-UNION-生成汇总行"><a href="#4、-SUM-IF-生成列-UNION-生成汇总行" class="headerlink" title="4、 SUM(IF()) 生成列 + UNION 生成汇总行"></a>4、 SUM(IF()) 生成列 + UNION 生成汇总行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> userid,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span>,</div><div class="line"><span class="keyword">sum</span>(score) <span class="string">'总分'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line"><span class="keyword">union</span></div><div class="line"><span class="keyword">select</span> <span class="string">'Total'</span>,<span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span>,</div><div class="line">  <span class="keyword">sum</span>(score)</div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="5、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行"><a href="#5、-SUM-IF-生成列-WITH-ROLLUP-生成汇总行" class="headerlink" title="5、 SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行"></a>5、 <strong>SUM(IF()) 生成列 + WITH ROLLUP 生成汇总行</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">IFNULL</span>(userid,<span class="string">'Total'</span>) userid,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'语文'</span>,score,<span class="number">0</span>)) <span class="string">'语文'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'数学'</span>,score,<span class="number">0</span>)) <span class="string">'数学'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'英语'</span>,score,<span class="number">0</span>)) <span class="string">'英语'</span>,</div><div class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(subject=<span class="string">'政治'</span>,score,<span class="number">0</span>)) <span class="string">'政治'</span>,</div><div class="line"><span class="keyword">sum</span>(score) <span class="string">'总分'</span></div><div class="line"><span class="keyword">from</span> tb_score</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid</div><div class="line"><span class="keyword">with</span> <span class="keyword">rollup</span></div><div class="line">;</div></pre></td></tr></table></figure><h3 id="6、-动态，适用于列不确定情况"><a href="#6、-动态，适用于列不确定情况" class="headerlink" title="6、 动态，适用于列不确定情况"></a>6、 动态，适用于列不确定情况</h3><p>思路就是拼接 sql 语句然后用 <strong>PREPARE name from sqlStr、EXECUTE name 、DEALLOCATE PREPARE name </strong> 预处理、执行、回收资源。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> @EE=<span class="string">''</span>;</div><div class="line"><span class="keyword">select</span> @EE :=<span class="keyword">CONCAT</span>(@EE,<span class="string">'sum(if(subject= \''</span>,subject,<span class="string">'\',score,0)) as '</span>,subject, <span class="string">','</span>) <span class="keyword">AS</span> aa <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> subject <span class="keyword">FROM</span> tb_score) A ;</div><div class="line"><span class="comment">-- select @EE;</span></div><div class="line"></div><div class="line"><span class="keyword">SET</span> @QQ = <span class="keyword">CONCAT</span>(<span class="string">'select ifnull(userid,\'TOTAL\')as userid,'</span>,@EE,<span class="string">' sum(score) as TOTAL from tb_score group by userid WITH ROLLUP'</span>);</div><div class="line"><span class="comment">-- SELECT @QQ;</span></div><div class="line"></div><div class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> @QQ;</div><div class="line"><span class="keyword">EXECUTE</span> stmt;</div><div class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> stmt;</div></pre></td></tr></table></figure><h3 id="7、-合并字段显示：利用group-concat"><a href="#7、-合并字段显示：利用group-concat" class="headerlink" title="7、 合并字段显示：利用group_concat()"></a>7、 <strong>合并字段显示：利用group_concat()</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> userid,<span class="keyword">GROUP_CONCAT</span>(<span class="string">`subject`</span>,<span class="string">":"</span>,score)<span class="keyword">AS</span> 成绩 </div><div class="line"><span class="keyword">FROM</span> tb_score</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userid</div><div class="line">;</div></pre></td></tr></table></figure><h3 id="8、列转行"><a href="#8、列转行" class="headerlink" title="8、列转行"></a>8、列转行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_score1(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</div><div class="line">    userid <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</div><div class="line">    cn_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'语文成绩'</span>,</div><div class="line">    math_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'数学成绩'</span>,</div><div class="line">    en_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'英语成绩'</span>,</div><div class="line">    po_score <span class="keyword">DOUBLE</span> <span class="keyword">COMMENT</span> <span class="string">'政治成绩'</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score1(userid,cn_score,math_score,en_score,po_score) <span class="keyword">VALUES</span> (<span class="string">'001'</span>,<span class="number">90</span>,<span class="number">92</span>,<span class="number">80</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score1(userid,cn_score,math_score,en_score,po_score) <span class="keyword">VALUES</span> (<span class="string">'002'</span>,<span class="number">88</span>,<span class="number">90</span>,<span class="number">75.5</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_score1(userid,cn_score,math_score,en_score,po_score) <span class="keyword">VALUES</span> (<span class="string">'003'</span>,<span class="number">70</span>,<span class="number">85</span>,<span class="number">90</span>,<span class="number">82</span>);</div><div class="line"></div><div class="line">+<span class="comment">----+--------+----------+------------+----------+----------+</span></div><div class="line">| id | userid | cn_score | math_score | en_score | po_score |</div><div class="line">+<span class="comment">----+--------+----------+------------+----------+----------+</span></div><div class="line">|  1 | 001    |       90 |         92 |       80 |        0 |</div><div class="line">|  2 | 002    |       88 |         90 |     75.5 |        0 |</div><div class="line">|  3 | 003    |       70 |         85 |       90 |       82 |</div><div class="line">+<span class="comment">----+--------+----------+------------+----------+----------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><p> 本质是将userid的每个科目分数分散成一条记录显示出来 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 把每一列查询出来拼起来</span></div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'语文'</span> <span class="keyword">AS</span> course,cn_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">union</span> all </div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'数学'</span> <span class="keyword">AS</span> course,math_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">union</span> all </div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'英语'</span> <span class="keyword">AS</span> course,en_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">union</span> all </div><div class="line"><span class="keyword">SELECT</span> userid,<span class="string">'政治'</span> <span class="keyword">AS</span> course,po_score <span class="keyword">AS</span> score <span class="keyword">FROM</span> tb_score1</div><div class="line"><span class="keyword">order</span> <span class="keyword">by</span> userid </div><div class="line">;</div></pre></td></tr></table></figure><h2 id="6、第六题"><a href="#6、第六题" class="headerlink" title="6、第六题"></a>6、第六题</h2><h3 id="更新列的值为行号"><a href="#更新列的值为行号" class="headerlink" title="更新列的值为行号"></a>更新列的值为行号</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> @<span class="keyword">num</span> = <span class="number">0</span>; </div><div class="line"><span class="keyword">UPDATE</span> sys_menu <span class="keyword">SET</span> <span class="keyword">sort</span> = (@<span class="keyword">num</span> := @<span class="keyword">num</span> + <span class="number">1</span>)；</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;case … when + sum + group by 行转列&lt;/li&gt;
&lt;li&gt;case when … 搜索&lt;/li&gt;
&lt;li&gt;if + sum + group by 行转列&lt;/li&gt;
&lt;li&gt;拼接 sql + prepare … from … + execute + deallocate prepare 行转列&lt;/li&gt;
&lt;li&gt;with rollup 汇总行&lt;/li&gt;
&lt;li&gt;union all 汇总行&lt;/li&gt;
&lt;li&gt;group_concat() 分组拼接展示&lt;/li&gt;
&lt;li&gt;union all 列转行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十一) 读写分离</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_11_%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_11_读写分离.html</id>
    <published>2020-08-29T13:13:12.000Z</published>
    <updated>2020-09-08T15:47:02.050Z</updated>
    
    <content type="html"><![CDATA[<ul><li>读写分离的概念和优点</li><li>mysql-proxy 实现读写分离</li><li>amoeba 实现读写分离</li></ul><a id="more"></a><h2 id="1、读写分离介绍"><a href="#1、读写分离介绍" class="headerlink" title="1、读写分离介绍"></a>1、读写分离介绍</h2><p>MySQL 读写分离基本原理是让 master 数据库处理写操作，slave 数据库处理读操作。master 将写操作的变更同步到各个 slave 节点。</p><p>读写分离如何提高性能？</p><p>1、物理服务器增加，机器处理能力提升，拿硬件换性能</p><p>2、主从只负责各自的读和写，极大程度缓解 X 锁和 S 锁的争用</p><p>3、slave 可以配置 MyISAM 存储引擎，提升查询性能以及节约系统开销</p><p>4、master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步的</p><p>5、slave 可以单独设置一些参数来提升其读的性能</p><p>6、增加冗余，提高可用性，多台机器，高可用了</p><h2 id="2、读写分离之-mysql-proxy"><a href="#2、读写分离之-mysql-proxy" class="headerlink" title="2、读写分离之 mysql-proxy"></a>2、读写分离之 mysql-proxy</h2><h3 id="1、硬件配置"><a href="#1、硬件配置" class="headerlink" title="1、硬件配置"></a>1、硬件配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proxy  192.168.238.66</div><div class="line">master 192.168.238.68</div><div class="line">slave  192.168.238.70</div></pre></td></tr></table></figure><h3 id="2、master、slave-配置主从复制"><a href="#2、master、slave-配置主从复制" class="headerlink" title="2、master、slave 配置主从复制"></a>2、master、slave 配置主从复制</h3><p>略过</p><h3 id="3、进行-proxy-的相关配置"><a href="#3、进行-proxy-的相关配置" class="headerlink" title="3、进行 proxy 的相关配置"></a>3、进行 proxy 的相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">1、下载mysql-proxy</span></div><div class="line">https://downloads.mysql.com/archives/proxy/#downloads</div><div class="line"><span class="meta">#</span><span class="bash">2、上传软件到proxy的机器</span></div><div class="line">cd /opt</div><div class="line">直接通过xftp进行上传</div><div class="line"><span class="meta">#</span><span class="bash">3、解压安装包</span></div><div class="line">tar -zxvf mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit.tar.gz</div><div class="line"><span class="meta">#</span><span class="bash">4、创建链接</span></div><div class="line">ln -s mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit mysql-proxy</div><div class="line"><span class="meta">#</span><span class="bash">5、进入mysql-proxy的目录</span></div><div class="line">cd mysql-proxy</div><div class="line"><span class="meta">#</span><span class="bash">6、创建目录</span></div><div class="line">mkdir conf</div><div class="line">mkdir logs</div><div class="line"><span class="meta">#</span><span class="bash">7、添加环境变量</span></div><div class="line"><span class="meta">#</span><span class="bash">打开/etc/profile文件</span></div><div class="line">vi /etc/profile</div><div class="line"><span class="meta">#</span><span class="bash">在文件的最后面添加一下命令</span></div><div class="line">export PATH=$PATH:/opt/mysql-proxy/bin</div><div class="line"><span class="meta">#</span><span class="bash">8、执行命令让环境变量生效</span></div><div class="line">source /etc/profile</div><div class="line"><span class="meta">#</span><span class="bash">9、进入conf目录，创建文件并添加一下内容</span></div><div class="line">vi mysql-proxy.conf</div><div class="line">添加内容</div><div class="line">[mysql-proxy]</div><div class="line">user=root</div><div class="line">proxy-address=192.168.238.66:4040</div><div class="line">proxy-backend-addresses=192.168.238.68:3306</div><div class="line">proxy-read-only-backend-addresses=192.168.238.70:3306</div><div class="line">proxy-lua-script=/opt/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua</div><div class="line">log-file=/opt/mysql-proxy/logs/mysql-proxy.log</div><div class="line">log-level=debug</div><div class="line">daemon=true</div><div class="line"><span class="meta">#</span><span class="bash">10、开启mysql-proxy</span></div><div class="line">mysql-proxy --defaults-file=/root/mysql-proxy/conf/mysql-proxy.conf</div><div class="line"><span class="meta">#</span><span class="bash">11、查看是否安装成功，打开日志文件</span></div><div class="line">cd /opt/mysql-proxy/logs</div><div class="line">tail -100 mysql-proxy.log</div><div class="line"><span class="meta">#</span><span class="bash">内容如下：表示安装成功</span></div><div class="line">2020-08-29 16:00:34: (critical) plugin proxy 0.8.5 started</div><div class="line">2020-08-29 16:00:34: (debug) max open file-descriptors = 1024</div><div class="line">2020-08-29 16:00:34: (message) proxy listening on port 192.168.238.66:4040</div><div class="line">2020-08-29 16:00:34: (message) added read/write backend: 192.168.238.68:3306</div><div class="line">2020-08-29 16:00:34: (message) added read-only backend: 192.168.238.70:3306</div><div class="line">2020-08-29 16:00:34: (debug) now running as user: root (0/0)</div></pre></td></tr></table></figure><h3 id="4、进行连接"><a href="#4、进行连接" class="headerlink" title="4、进行连接"></a>4、进行连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -ppass9876 -h192.168.238.66 -P 4040</div></pre></td></tr></table></figure><h2 id="3、读写分离之-Amoeba"><a href="#3、读写分离之-Amoeba" class="headerlink" title="3、读写分离之 Amoeba"></a>3、读写分离之 Amoeba</h2><h3 id="1、什么是-Amoeba？"><a href="#1、什么是-Amoeba？" class="headerlink" title="1、什么是 Amoeba？"></a>1、什么是 Amoeba？</h3><p>​        Amoeba(变形虫)项目，专注 分布式数据库 proxy 开发。座落于 Client、DB Server(s) 之间。对客户端透明。具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的 query 到目标数据库、可并发请求多台数据库合并结果。</p><p>主要解决：</p><ul><li><p>降低数据切分带来的复杂多数据库结构</p></li><li><p>提供切分规则并降低数据切分规则给应用带来的影响</p></li><li><p>降低 db 与客户端的连接数</p></li><li><p>读写分离</p></li></ul><h3 id="2、为什么要用-Amoeba"><a href="#2、为什么要用-Amoeba" class="headerlink" title="2、为什么要用 Amoeba"></a>2、为什么要用 Amoeba</h3><p>目前要实现 mysql 的主从读写分离，主要有以下几种方案：</p><p>1、 通过程序实现，网上很多现成的代码，比较复杂，如果添加从服务器要更改多台服务器的代码。</p><p>2、通过 mysql-proxy 来实现，由于 mysql-proxy 的主从读写分离是通过 lua 脚本来实现，目前 lua 的脚本的开发跟不上节奏，而写没有完美的现成的脚本，因此导致用于生产环境的话风险比较大，据网上很多人说mysql-proxy 的性能不高。</p><p>3、自己开发接口实现，这种方案门槛高，开发成本高，不是一般的小公司能承担得起。</p><p>4、 利用阿里巴巴的开源项目 Amoeba 来实现，具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的query到目标数据库，并且安装配置非常简单。</p><h3 id="3、安装-Amoeba"><a href="#3、安装-Amoeba" class="headerlink" title="3、安装 Amoeba"></a>3、安装 Amoeba</h3><p>1、安装 jdk</p><p>2、下载 amoeba：<a href="https://sourceforge.net/projects/amoeba/" target="_blank" rel="external">https://sourceforge.net/projects/amoeba/</a> 直接解压即可</p><p>3、修改配置</p><p><strong>dbServers.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">factoryConfig</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.mysql.net.MysqlServerConnectionFactory"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionManager"</span>&gt;</span>$&#123;defaultManager&#125;<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sendBufferSize"</span>&gt;</span>64<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"receiveBufferSize"</span>&gt;</span>128<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- mysql port --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span>&gt;</span>3306<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- mysql schema --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schema"</span>&gt;</span>copy_test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- mysql user --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>pass9876<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">factoryConfig</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dbServer</span> <span class="attr">name</span>=<span class="string">"writedb"</span>  <span class="attr">parent</span>=<span class="string">"abstractServer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">factoryConfig</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- mysql ip --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ipAddress"</span>&gt;</span>192.168.238.68<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">factoryConfig</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dbServer</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dbServer</span> <span class="attr">name</span>=<span class="string">"slave"</span>  <span class="attr">parent</span>=<span class="string">"abstractServer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">factoryConfig</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- mysql ip --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ipAddress"</span>&gt;</span>192.168.238.70<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">factoryConfig</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dbServer</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dbServer</span> <span class="attr">name</span>=<span class="string">"myslave"</span> <span class="attr">virtual</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">poolConfig</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.server.MultipleServerPool"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- Load balancing strategy: 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loadbalance"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="comment">&lt;!-- Separated by commas,such as: server1,server2,server1 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolNames"</span>&gt;</span>slave<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">poolConfig</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dbServer</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>amoeba.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>pass9876<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">queryRouter</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.mysql.parser.MysqlQueryRouter"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ruleLoader"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.meidusa.amoeba.route.TableRuleFileLoader"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ruleFile"</span>&gt;</span>$&#123;amoeba.home&#125;/conf/rule.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"functionFile"</span>&gt;</span>$&#123;amoeba.home&#125;/conf/ruleFunctionMap.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlFunctionFile"</span>&gt;</span>$&#123;amoeba.home&#125;/conf/functionMap.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LRUMapSize"</span>&gt;</span>1500<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultPool"</span>&gt;</span>writedb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"writePool"</span>&gt;</span>writedb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readPool"</span>&gt;</span>myslave<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"needParse"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">queryRouter</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="4、测试-Amoeba"><a href="#4、测试-Amoeba" class="headerlink" title="4、测试 Amoeba"></a>4、测试 Amoeba</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 启动 Amoeba 服务</span></div><div class="line">/opt/amoeba-mysql-3.0.5-RC/bin/launcher</div><div class="line"></div><div class="line"><span class="comment">--在安装amoeba的服务器上登录mysql</span></div><div class="line">mysql -h192.168.238.66 -uroot -ppass9876 -P8066</div><div class="line"><span class="comment">--分别在master、slave、amoeba上登录mysql</span></div><div class="line"><span class="keyword">use</span> msb</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</div><div class="line"><span class="comment">--在amoeba上插入数据</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</div><div class="line"><span class="comment">--在master和slave上分别查看表中的数据</span></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</div><div class="line"><span class="comment">--将master上的mysql服务停止，继续插入数据会发现插入不成功，但是能够查询</span></div><div class="line"><span class="comment">--将master上的msyql服务开启，停止slave上的mysql，发现插入成功，但是不能够查询</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;读写分离的概念和优点&lt;/li&gt;
&lt;li&gt;mysql-proxy 实现读写分离&lt;/li&gt;
&lt;li&gt;amoeba 实现读写分离&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(十)</title>
    <link href="http://yoursite.com/2020-08-29-mysql/mysql_10_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"/>
    <id>http://yoursite.com/2020-08-29-mysql/mysql_10_主从复制.html</id>
    <published>2020-08-29T12:13:12.000Z</published>
    <updated>2020-09-12T02:57:56.044Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主从复制用途</li><li>主从复制原理</li><li>主从复制延时分析和 MTS</li><li>主从复制安装</li></ul><a id="more"></a><h2 id="1-为什么需要主从复制"><a href="#1-为什么需要主从复制" class="headerlink" title="1. 为什么需要主从复制"></a>1. 为什么需要主从复制</h2><p>1、表锁导致其他事务无法读。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、结构的扩展。业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘 I/O 访问的频率，提高单个机器的 I/O 性能。</p><h2 id="2-什么是-MySQL-主从复制"><a href="#2-什么是-MySQL-主从复制" class="headerlink" title="2. 什么是 MySQL 主从复制"></a>2. 什么是 MySQL 主从复制</h2><p>MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用<strong>异步复制</strong>方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h2 id="3-主从复制的原理"><a href="#3-主从复制的原理" class="headerlink" title="3. 主从复制的原理"></a>3. 主从复制的原理</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>1、master 开启 binlog 日志</p><p>2、slave 在一定时间间隔内对 master binlog 日志进行探测，看是否有改变。如果有改变，则开始一个 <strong>I/O Thread</strong> 用于请求 master 二进制事件。</p><p>3、master 为每个 slave I/O Thread启动一个 dump 线程，用于向 slave I/O Thread 发送二进制事件</p><p>4、slave 接收到二进制事件后，将数据保存在 slave 本地的<strong>中继日志</strong>中</p><p>5、slave 启动 <strong>SQL Thread</strong> 从中继日志读取二进制日志，在本地重放，使得数据和 master 保持一致</p><p>6、最后 I/O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒</p><h3 id="3-2-原理解析"><a href="#3-2-原理解析" class="headerlink" title="3.2 原理解析"></a>3.2 原理解析</h3><p>1、slave 会生成两个线程，I/O Thread、SQL Thread</p><p>2、master 会生成一个 log dump 线程，用来给 slave I/O Thread 传 binlog</p><p>3、I/O Thread 请求 master 的 binlog，写入本地的 relay-log</p><p>4、SQL Thread 读取 relay-log，并解析成 sql 语句逐一执行</p><h3 id="3-3-具体步骤"><a href="#3-3-具体步骤" class="headerlink" title="3.3 具体步骤"></a>3.3 具体步骤</h3><p>1、 slave 执行 change master to 语句连接主库，提供连接的用户一切条件（user、password、port、ip），并且让从库知道，二进制日志的起点位置（file、position）；然后 start slave</p><p>2、slave I/O Thread 和 master dump Thread 建立连接</p><p>3、slave T/O Thread 向 slave 发起 binlog 请求</p><p>4、master 将本地 binlog 以 events 的方式发送给 slave 的 I/O Thread</p><p>5、slave I/O Thread 接收 binlog events，并存放到本地 relay-log 中，传送过来的信息会记录到 master.info 中</p><p>6、slave SQL Thread 读取 relay-log，并把读取过的记录存放到 relay-log.info 中。默认情况下，已经应用过的 relay 会自动被清理（purge）。</p><h2 id="4-主从形式"><a href="#4-主从形式" class="headerlink" title="4. 主从形式"></a>4. 主从形式</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><h3 id="多主一丛"><a href="#多主一丛" class="headerlink" title="多主一丛"></a>多主一丛</h3><h3 id="联级复制"><a href="#联级复制" class="headerlink" title="联级复制"></a>联级复制</h3><h2 id="5-主从同步延时分析"><a href="#5-主从同步延时分析" class="headerlink" title="5. 主从同步延时分析"></a>5. 主从同步延时分析</h2><p>MySQL 主从复制都是单线程操作，master 对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写的，所以效率很高，slave 的 SQL Thread 线程将 master 的  DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 I/O 操作是随机的，不是顺序的，所以成本要高很多，另一方面，由于 SQL Thread 也是单线程的，当 master 的并发较高时，产生的 DML 数量超过 slave 的 SQL Thread 所能处理的速度，或者当 slave 中有大型的 query 语句产生了锁等待，那么延时就产生了。</p><p>解决方案：</p><p>1、业务的持久化层的实现采用分库结构，MySQL 服务可平行扩展，分散压力</p><p>2、单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库</p><p>3、服务的基础架构在业务和 MySQL 之间加入 memcache 或者 redis 的 cache 层，降低 MySQL 的读压力。</p><p>4、不同业务的 MySQL 物理上放在不同的机器上，分散压力</p><p>5、使用比主库更好的硬件设备作为 slave，MySQL 压力小，延迟自然会变小</p><p>6、使用更加强劲的硬件设备</p><h2 id="6-MTS-并行复制技术"><a href="#6-MTS-并行复制技术" class="headerlink" title="6. MTS 并行复制技术"></a>6. MTS 并行复制技术</h2><p>支持事务级别的 sql 进行并发回放, 默认是 database 级别(也就是只能并发 database)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 组提交</div><div class="line">## 哪些需要组提交</div><div class="line">1. transaction <span class="keyword">prepare</span></div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span></div><div class="line">## MySQL <span class="number">5.1</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write  # fsync</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>  # fsync</div><div class="line">总结：每个事务都需要三次fsync</div><div class="line">## MySQL <span class="number">5.5</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write         # <span class="keyword">group</span> fsync</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>   # fsync</div><div class="line">总结：<span class="keyword">binlog</span> 可以组提交了</div><div class="line">## MySQL <span class="number">5.6</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write         # <span class="keyword">group</span> fsync</div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>   # 不需要fsync了，因为<span class="number">1</span>，<span class="number">2</span>都fsync，就能保证整个事务提交</div><div class="line">总结：少了最后一步的fsync，性能提升很多</div><div class="line">## MySQL <span class="number">5.7</span></div><div class="line"><span class="number">1.</span> <span class="keyword">transaction</span> <span class="keyword">prepare</span>  # 不fsync</div><div class="line"><span class="number">2.</span> <span class="keyword">binlog</span> write         # 在写入<span class="keyword">binlog</span>之前，去<span class="keyword">group</span> fsync <span class="keyword">prepare</span> <span class="keyword">log</span>。 然后再<span class="keyword">group</span> fsync <span class="keyword">binlog</span></div><div class="line"><span class="number">3.</span> <span class="keyword">transaction</span> <span class="keyword">commit</span>   # 不需要fsync了，因为<span class="number">1</span>，<span class="number">2</span>都fsync，就能保证整个事务提交</div><div class="line">总结：相当于<span class="number">1</span>，<span class="number">2</span> 合在一起组提交，性能提升更多</div></pre></td></tr></table></figure><h3 id="6-1-为什么要用-MTS"><a href="#6-1-为什么要用-MTS" class="headerlink" title="6.1 为什么要用 MTS"></a>6.1 为什么要用 MTS</h3><p> 解决单线程复制的延迟问题 </p><blockquote><p> note1：当master有多个线程在写数据，那么MTS效果会非常好<br>note2：如果master对大表进行DDL，这样的延迟是没办法避免 的</p></blockquote><h3 id="6-2-开启MTS的重要参数"><a href="#6-2-开启MTS的重要参数" class="headerlink" title="6.2 开启MTS的重要参数"></a>6.2 开启MTS的重要参数</h3><table><thead><tr><th>参数</th><th>comment</th><th>默认配置</th><th>推荐配置</th></tr></thead><tbody><tr><td>slave_parallel_workers</td><td>applier threads 数量</td><td>0</td><td>16</td></tr><tr><td>slave_parallel_type</td><td>并行方式</td><td>DATABASE</td><td>LOGICAL_CLOCK</td></tr><tr><td>slave_preserve_commit_order</td><td>并行排序提交</td><td>0</td><td>1</td></tr><tr><td>master_info_repository</td><td>master_info 持久化方式</td><td>FILE</td><td>DATABASE</td></tr><tr><td>relay_log_info_repository</td><td>relay_info持久化方式</td><td>FILE</td><td>DATABASE</td></tr><tr><td>relay_log_recovery</td><td>重新获取 relay log</td><td>0</td><td>1</td></tr></tbody></table><h3 id="6-3-重要组件"><a href="#6-3-重要组件" class="headerlink" title="6.3 重要组件"></a>6.3 重要组件</h3><blockquote><ol><li>IO thread并没有改变</li><li>SQL thread 会变成 Coordinator线程</li><li>会新增很多 work 线程来受 Coordinator调度</li></ol></blockquote><h3 id="6-4-Binlog-和-MTS"><a href="#6-4-Binlog-和-MTS" class="headerlink" title="6.4 Binlog 和 MTS"></a>6.4 Binlog 和 MTS</h3><blockquote><p> 同一个 last_committed 可以并行执行<br>同一个 last_committed 中的 sequence_number 默认是无序的 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#160628 16:29:10 server id 12616406  end_log_pos 259 CRC32 0x9565260a GTIDlast_committed=0sequence_number=1</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 427 CRC32 0xaa1d4add GTIDlast_committed=0sequence_number=2</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 682 CRC32 0x0715f36a GTIDlast_committed=0sequence_number=3</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 937 CRC32 0x2998c5ed GTIDlast_committed=0sequence_number=4</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1192 CRC32 0xd58951f3 GTIDlast_committed=4sequence_number=5</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1447 CRC32 0xbf77ba5f GTIDlast_committed=4sequence_number=6</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1702 CRC32 0x3e74905f GTIDlast_committed=4sequence_number=7</div><div class="line">#160628 16:29:25 server id 12616406  end_log_pos 1957 CRC32 0xc31cbd6d GTIDlast_committed=4sequence_number=8</div></pre></td></tr></table></figure><h3 id="6-5-顺序"><a href="#6-5-顺序" class="headerlink" title="6.5 顺序"></a>6.5 顺序</h3><ul><li><p><strong>当 slave_preserve_commit_order=0时</strong> </p><blockquote><p> 没有办法保证顺序，在恢复的过程中会有问题,到时候你怎么start slave 呢？<br>start slave until SQL_AFTER_MTS_GAPS ; reset slave </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Master执行顺序: last_committed=0,sequence_number=1,2,3,4  </div><div class="line">slave执行顺序： 有可能就是 last_committed=0,sequence_number=1,4,3,2</div></pre></td></tr></table></figure></li><li><p><strong>当slave_preserve_commit_order=1时</strong> </p><blockquote><p> 后一个sequence_number提交的时候，会等待前一个sequence_number完成。<br>Waiting for preceding transaction to commit </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Master执行顺序: last_committed=0,sequence_number=1,2,3,4  </div><div class="line">slave执行顺序： 有可能就是 last_committed=0,sequence_number=1,2,3,4</div></pre></td></tr></table></figure></li></ul><h2 id="7-主从复制安装配置"><a href="#7-主从复制安装配置" class="headerlink" title="7. 主从复制安装配置"></a>7. 主从复制安装配置</h2><h3 id="1、基础设置准备"><a href="#1、基础设置准备" class="headerlink" title="1、基础设置准备"></a>1、基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">操作系统：</span></div><div class="line">centos6.5</div><div class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></div><div class="line">5.7</div><div class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></div><div class="line">node2:192.168.238.68（主）</div><div class="line">node3:192.168.238.70（从）</div></pre></td></tr></table></figure><h3 id="2、安装-MySQL-数据库"><a href="#2、安装-MySQL-数据库" class="headerlink" title="2、安装 MySQL 数据库"></a>2、安装 MySQL 数据库</h3><p>略过</p><h3 id="3、在-node2、node3-分别创建数据库"><a href="#3、在-node2、node3-分别创建数据库" class="headerlink" title="3、在 node2、node3 分别创建数据库"></a>3、在 node2、node3 分别创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--注意两台必须全部执行</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">database</span> copy_test;</div></pre></td></tr></table></figure><h3 id="4、主服务器（node2）配置"><a href="#4、主服务器（node2）配置" class="headerlink" title="4、主服务器（node2）配置"></a>4、主服务器（node2）配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 指定 binlog 路径和名称</div><div class="line">log-bin=/usr/local/mysql/logs/log_bin.log</div><div class="line"># 二进制日志格式，有row、statement、mixed三种格式</div><div class="line"># row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍</div><div class="line"># statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。一定条件下可以节省日志量</div><div class="line"># MySQL默认采用基于语句的复制，效率比较高。</div><div class="line"># mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</div><div class="line">binlog-format=ROW</div><div class="line"># 指定log-bin参数后，无需指定log_bin，log-bin相当于一个快速设置方式。log_bin表示是否启动bin log</div><div class="line"># 注意开启 logbin 后必须指定 server_id，必须要 server_id</div><div class="line">server_id=1</div><div class="line"># 指定哪些数据库需要将更新记录到二进制日志中。</div><div class="line"># 其他所有没有显示指定的数据库将忽略，不记录日志</div><div class="line"># SHOW MASTER STATUS 可以查看binlog源的状态信息</div><div class="line">binlog_do_db=copy_test</div></pre></td></tr></table></figure><h3 id="5、从服务器（node3）配置"><a href="#5、从服务器（node3）配置" class="headerlink" title="5、从服务器（node3）配置"></a>5、从服务器（node3）配置</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--授权操作</span></div><div class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</div><div class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</div><div class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'pass9876'</span>;</div><div class="line"><span class="comment">--刷新权限</span></div><div class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</div><div class="line"></div><div class="line">log-bin=/usr/local/mysql/logs/log_bin.log</div><div class="line">binlog-format=ROW</div><div class="line">server_id=2</div></pre></td></tr></table></figure><h3 id="6、重启主服务器-MySQL-服务"><a href="#6、重启主服务器-MySQL-服务" class="headerlink" title="6、重启主服务器 MySQL 服务"></a>6、重启主服务器 MySQL 服务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service mysql.server restart</div><div class="line">mysql -r root -p</div><div class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</div></pre></td></tr></table></figure><h3 id="7、重启从服务器并进行相关配置"><a href="#7、重启从服务器并进行相关配置" class="headerlink" title="7、重启从服务器并进行相关配置"></a>7、重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></div><div class="line">service mysqld restart</div><div class="line"><span class="meta">#</span><span class="bash">登录mysql</span></div><div class="line">mysql -uroot -p</div><div class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></div><div class="line">change master to master_host='192.168.238.68',master_user='root',master_password='pass9876',master_port=3306,master_log_file='log_bin.000018',master_log_pos=154;</div><div class="line"><span class="meta">#</span><span class="bash">启动slave</span></div><div class="line">start slave</div><div class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></div><div class="line">show slave status\G</div></pre></td></tr></table></figure><h3 id="8、验证"><a href="#8、验证" class="headerlink" title="8、验证"></a>8、验证</h3><p>node2 上操作，查看数据是否同步到 node3</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;主从复制用途&lt;/li&gt;
&lt;li&gt;主从复制原理&lt;/li&gt;
&lt;li&gt;主从复制延时分析和 MTS&lt;/li&gt;
&lt;li&gt;主从复制安装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(九)</title>
    <link href="http://yoursite.com/2020-08-27-mysql/mysql_9_%E4%BA%8B%E5%8A%A1.html"/>
    <id>http://yoursite.com/2020-08-27-mysql/mysql_9_事务.html</id>
    <published>2020-08-27T14:13:12.000Z</published>
    <updated>2020-09-13T09:20:44.902Z</updated>
    
    <content type="html"><![CDATA[<ul><li>事务的 ACID 特性</li><li>并发事务带来的问题</li><li>理解事务的 4 种隔离级别</li><li>演示脏读、不可重复读、幻读</li><li>RR 隔离级别幻读问题</li></ul><p>首先，MyISAM 存储引擎不支持事务，本文讨论均基于 InnoDB 存储引擎。</p><a id="more"></a><h2 id="1、事务目的及其-ACID-特性"><a href="#1、事务目的及其-ACID-特性" class="headerlink" title="1、事务目的及其 ACID 特性"></a>1、事务目的及其 ACID 特性</h2><h3 id="1-1-事务的目的"><a href="#1-1-事务的目的" class="headerlink" title="1.1 事务的目的"></a>1.1 事务的目的</h3><p>数据库事务通常包含了一个序列的对数据库的读/写操作，是数据库执行的逻辑单元。</p><p>事务包含有以下两个目的：</p><ol><li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。即 rollback 和 crash safe 能力（<strong>日志系统实现</strong>）。</li><li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。即并发控制能力（<strong>隔离级别、锁、mvcc 实现</strong>）。</li></ol><h3 id="1-2-事务的-ACID-特性"><a href="#1-2-事务的-ACID-特性" class="headerlink" title="1.2 事务的 ACID 特性"></a>1.2 事务的 ACID 特性</h3><ul><li><strong>Actomicity</strong>：原子性，一个事务是一个整体，要么全部执行要么全部回滚。</li><li><strong>Consistency</strong> ：一致性，一个事务应确保数据库从一个一致状态到另一个一致状态。一致的含义是数据满足完整性约束。</li><li><strong>Isolation</strong>：隔离性，多个事务并发应互不影响。</li><li><strong>Durability</strong> ：持久性，已被提交的事务，事务的修改应该永久的保存在数据库中。</li></ul><h2 id="2、并发事务问题和隔离级别"><a href="#2、并发事务问题和隔离级别" class="headerlink" title="2、并发事务问题和隔离级别"></a>2、并发事务问题和隔离级别</h2><h3 id="2-1-并发事务的好处以及带来的问题"><a href="#2-1-并发事务的好处以及带来的问题" class="headerlink" title="2.1 并发事务的好处以及带来的问题"></a>2.1 并发事务的好处以及带来的问题</h3><p>相对于串行处理来说，<strong>并发事务</strong>处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来以下问题：</p><ul><li>脏读：读出的数据可能是脏数据。</li><li>不可重复读：两次读出的数据不一致，刚刚查询 name 为 alvin，过一会再查变为 monkey 了。</li><li>幻读：明明查询出来没这记录，但是却插入不了，提示数据已存在（RR）；刚刚查出来只有一条记录，等会再查变为两条了（RU、RC）</li></ul><h3 id="2-2-隔离级别"><a href="#2-2-隔离级别" class="headerlink" title="2.2 隔离级别"></a>2.2 隔离级别</h3><p>上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为<strong>事务隔离本质上就是使事务在一定程度上串行化</strong>，需要根据具体的业务需求来决定使用哪种隔离级别。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">read uncommitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">read committed</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">repeatable read</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>在标准的事务隔离级别定义下，REPEATABLE READ 是不能防止幻读产生的。INNODB 使用了<strong>next-key locks</strong> 实现了防止幻读的发生。 </p><h2 id="3、各隔离级别问题演示"><a href="#3、各隔离级别问题演示" class="headerlink" title="3、各隔离级别问题演示"></a>3、各隔离级别问题演示</h2><h3 id="3-1-准备数据"><a href="#3-1-准备数据" class="headerlink" title="3.1 准备数据"></a>3.1 准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--查看是否是自动提交 1表示开启，0表示关闭</span></div><div class="line"><span class="keyword">select</span> @@autocommit;</div><div class="line"><span class="comment">--设置关闭</span></div><div class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">--准备数据</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> psn(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</div><div class="line"><span class="comment">--插入数据</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'lisi'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'wangwu'</span>);</div><div class="line"><span class="keyword">commit</span>;</div></pre></td></tr></table></figure><h3 id="3-2-查看和设置隔离级别"><a href="#3-2-查看和设置隔离级别" class="headerlink" title="3.2 查看和设置隔离级别"></a>3.2 查看和设置隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> @@global.tx_isolation, @@session.tx_isolation;</div><div class="line"></div><div class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</div><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</div></pre></td></tr></table></figure><h3 id="3-3-READ-UNCOMMITED"><a href="#3-3-READ-UNCOMMITED" class="headerlink" title="3.3 READ UNCOMMITED"></a>3.3 READ UNCOMMITED</h3><p>RU 隔离级别存在脏读、不可重复读、幻读问题。</p><ul><li><p>脏读：读到脏数据，别的事务回滚了</p></li><li><p>不可重复读：数据的值不一样，别的事务修改并<strong>提交或者回滚</strong>了</p></li><li><p>幻读：数据条数不一样，别的事务插入并<strong>提交或回滚</strong>了</p></li></ul><p>演示脏读：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div><div class="line">A:<span class="keyword">update</span> psn <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'monkey'</span>;</div><div class="line">A:selecet * from psn</div><div class="line"><span class="comment">--读取的结果msb。产生脏读，因为A事务并没有commit，读取到了不存在的数据</span></div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;  </div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line"><span class="comment">--读取的数据是msb,因为A事务已经commit，数据永久的被修改</span></div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</div></pre></td></tr></table></figure><h3 id="3-4-READ-COMMITED"><a href="#3-4-READ-COMMITED" class="headerlink" title="3.4 READ COMMITED"></a>3.4 READ COMMITED</h3><p>RC 隔离级别存在不可重复读、幻读问题。</p><ul><li>不可重复读：数据的值不一样，别的事务修改并<strong>提交</strong>了</li><li>幻读：数据条数不一样，别的事务插入并<strong>提交</strong>了</li></ul><p>实现原理：</p><ul><li><p>快照读：通过 MVCC 一致性视图实现。查询级别 readview，每次读取更新 readview</p></li><li><p>当前读： <strong>RC隔离级别保证对读取到的记录加锁 (记录锁)</strong>，存在幻读现象。 </p></li></ul><p>演示不可重复读：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> psn;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'alvin'</span>);</div><div class="line"></div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- alvin</span></div><div class="line"><span class="comment">-- 干扰事务</span></div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">update</span> psn <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'monkey'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</div><div class="line">B:<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- alvin 说明没有脏读问题</span></div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line"></div><div class="line">B:<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- monkey 说明有不可重复读问题</span></div><div class="line"><span class="comment">-- 事务 B 第一次读一号同学叫做 alvin，过一会再读名字变为 monkey 了</span></div></pre></td></tr></table></figure><p>演示幻读：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> psn;</div><div class="line"></div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'alvin'</span>;</div><div class="line"><span class="comment">-- 干扰事务</span></div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'alvin'</span>);</div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line"></div><div class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'alvin'</span>;</div><div class="line"><span class="comment">-- 事务 B 第一次读发现没有 alvin 这个人，但是过一会再读又有 alvin 了</span></div></pre></td></tr></table></figure><p>演示<strong>当前读</strong> RC 有幻读问题，RR 无幻读问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</div><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> imageread_test(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>), age <span class="built_in">int</span>);</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> imageread_test <span class="keyword">add</span> <span class="keyword">index</span> idx_age(age);</div><div class="line"><span class="comment">-- 2 6 10 10 11 15</span></div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> imageread_test;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> imageread_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'a'</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="string">'b'</span>,<span class="number">6</span>),(<span class="number">3</span>,<span class="string">'c'</span>,<span class="number">10</span>),(<span class="number">4</span>,<span class="string">'d'</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="string">'e'</span>,<span class="number">11</span>),(<span class="number">6</span>,<span class="string">'f'</span>,<span class="number">15</span>);</div><div class="line"></div><div class="line">A:<span class="keyword">begin</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> imageread_test <span class="keyword">where</span> age=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 2条</span></div><div class="line"><span class="comment">-- 干扰事务</span></div><div class="line">B:<span class="keyword">begin</span>;</div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> imageread_test <span class="keyword">values</span>(<span class="number">44</span>,<span class="string">'dd'</span>,<span class="number">10</span>); <span class="comment">-- RC:成功、RR:阻塞</span></div><div class="line">B:<span class="keyword">commit</span>;</div><div class="line"></div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> imageread_test <span class="keyword">where</span> age=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 3条</span></div></pre></td></tr></table></figure><h3 id="3-5-REPEATABLE-READ"><a href="#3-5-REPEATABLE-READ" class="headerlink" title="3.5 REPEATABLE READ"></a>3.5 REPEATABLE READ</h3><p>RR 隔离级别存在幻读（<strong>快照读存在，当前读不存在</strong>）问题。</p><ul><li>幻读：数据条数不一样（虽然看上去是一样的，但是你没法插入），别的事务插入并<strong>提交</strong>了。</li></ul><p>实现原理：</p><ul><li><p>快照读：通过 MVCC 一致性视图实现，session 级别 readview，session 的 readview 创建后不再变化</p></li><li><p>当前读： <strong>RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)</strong>，不存在幻读现象。 </p></li></ul><p>演示快照读幻读：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> psn;</div><div class="line"></div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; // 无数据，说明应该可以插入才对</div><div class="line"><span class="comment">-- 干扰事务</span></div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>);</div><div class="line">B:<span class="keyword">commit</span>;</div><div class="line"></div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>);<span class="comment">--报错，无法插入数据</span></div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 再查，还是没有</span></div><div class="line"><span class="comment">--A 发现读取不到数据，但是在插入的时候不允许插入，出现了幻读，设置更高级别的隔离级别即可解决</span></div></pre></td></tr></table></figure><p>演示当前读无幻读问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> psn;</div><div class="line"></div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line"><span class="comment">-- lock in share mode 也可以</span></div><div class="line"><span class="comment">-- SERIALIZABLE 底层实现就是给 select 也加锁</span></div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 无数据，说明应该可以插入才对</span></div><div class="line"><span class="comment">-- 干扰事务</span></div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>); <span class="comment">-- 阻塞，干扰失效</span></div><div class="line"></div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>); <span class="comment">-- 成功</span></div></pre></td></tr></table></figure><p>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。 </p><h3 id="3-6-SERIALIZABLE"><a href="#3-6-SERIALIZABLE" class="headerlink" title="3.6 SERIALIZABLE"></a>3.6 SERIALIZABLE</h3><p>从 MVCC 并发控制退化为基于锁的并发控制。不再区别快照都和当前读， 所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。 </p><p> Serializable 隔离级别下，<strong>读写冲突</strong>，因此并发度急剧下降，在 MySQL/InnoDB 下不建议使用。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> psn;</div><div class="line"></div><div class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 加锁了</span></div><div class="line"></div><div class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>); <span class="comment">-- 阻塞，干扰失效</span></div><div class="line"></div><div class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>); <span class="comment">-- 成功</span></div><div class="line">A:<span class="keyword">commit</span>;</div></pre></td></tr></table></figure><p>总结：</p><p>​    现在学习的是数据库级别的事务，需要掌握的就是事务的隔离级别和产生的数据不一致的情况</p><p>后续会学习声明式事务及事务的传播特性以及分布式事务</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;事务的 ACID 特性&lt;/li&gt;
&lt;li&gt;并发事务带来的问题&lt;/li&gt;
&lt;li&gt;理解事务的 4 种隔离级别&lt;/li&gt;
&lt;li&gt;演示脏读、不可重复读、幻读&lt;/li&gt;
&lt;li&gt;RR 隔离级别幻读问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，MyISAM 存储引擎不支持事务，本文讨论均基于 InnoDB 存储引擎。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(八)</title>
    <link href="http://yoursite.com/2020-08-26-mysql/mysql_8_%E9%94%81%E6%9C%BA%E5%88%B6.html"/>
    <id>http://yoursite.com/2020-08-26-mysql/mysql_8_锁机制.html</id>
    <published>2020-08-26T14:13:12.000Z</published>
    <updated>2020-09-13T10:47:39.451Z</updated>
    
    <content type="html"><![CDATA[<ul><li>MyISAM 表锁</li><li>InnoDB 行锁/表锁</li></ul><a id="more"></a><h2 id="1、锁的介绍和分类"><a href="#1、锁的介绍和分类" class="headerlink" title="1、锁的介绍和分类"></a>1、锁的介绍和分类</h2><h3 id="1-1-锁介绍"><a href="#1-1-锁介绍" class="headerlink" title="1.1 锁介绍"></a>1.1 锁介绍</h3><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据<strong>并发访问的一致性</strong>、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的<strong>存储引擎</strong>支持不同的锁机制。比如，MyISAM 和 Memory 存储引擎采用的是表级锁（table-level locking）；InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 </p><p>经典并发问题：</p><p>比如 A、B <strong>同时</strong>读取一余额为 1000 元的账户，A 操作员为该账户增加 100 元，B 操作员同时为该账户扣除 50元，A先提交，B后提交。最后实际账户余额为1000-50=950元，但本该为1000+100-50=1050。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> lock_test1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, balance <span class="built_in">int</span>);</div><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> lock_test1;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> lock_test1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1000</span>);</div><div class="line"></div><div class="line">A:<span class="keyword">begin</span>;</div><div class="line">A:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> lock_test1 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line"></div><div class="line">B:<span class="keyword">begin</span>;</div><div class="line">B:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> lock_test1 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line"></div><div class="line">A:<span class="keyword">update</span> lock_test1 <span class="keyword">set</span> balance = balance + <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line">A:<span class="keyword">commit</span>;</div><div class="line"></div><div class="line">B:<span class="keyword">update</span> lock_test1 <span class="keyword">set</span> balance = balance - <span class="number">50</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line">B:<span class="keyword">commit</span>;</div></pre></td></tr></table></figure><h3 id="1-2-锁分类"><a href="#1-2-锁分类" class="headerlink" title="1.2 锁分类"></a>1.2 锁分类</h3><ul><li>乐观锁<ul><li>version 字段实现</li><li>条件限制实现。适合库存模型，扣份额和回滚份额，性能更高</li></ul></li><li>悲观锁<ul><li>共享锁<ul><li>行锁。开销小，加锁块，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发度低</li><li>表锁。开销大，加锁慢，会出现死锁；锁粒度小，发生锁冲突的概率小，并发度高</li></ul></li><li>排他锁<ul><li>行锁</li><li>表锁</li></ul></li><li>gap 锁</li><li>next-key lock = gap 锁 + 行锁</li></ul></li></ul><p>gap 锁或者 next-key lock 只有在 RR 或 SERAILIZABLE 特定情况下才会有。</p><p>仅从锁的角度 来说：表级锁更适合于以<strong>查询</strong>为主，只有少量按索引条件更新数据的应用，如 Web 应用；而行级锁则更适合于有大量<strong>按索引条件并发更新少量不同数据</strong>，同时又有 <strong>并发查询</strong>的应用，如一些在线事务处理（OLTP）系统。</p><h3 id="1-3-两阶段锁-2PL"><a href="#1-3-两阶段锁-2PL" class="headerlink" title="1.3 两阶段锁(2PL)"></a>1.3 两阶段锁(2PL)</h3><p>加锁阶段：只加锁不放锁。读操作加 S 锁，写操作加 X 锁</p><p>解锁阶段：只放锁不加锁。commit</p><p>2PL 虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候） 。</p><h2 id="2-MyISAM-表锁"><a href="#2-MyISAM-表锁" class="headerlink" title="2. MyISAM 表锁"></a>2. MyISAM 表锁</h2><p>MySQL的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 测试数据</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`NAME`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'a'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'b'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'c'</span>);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'d'</span>);</div></pre></td></tr></table></figure><h3 id="2-1-表共享读锁"><a href="#2-1-表共享读锁" class="headerlink" title="2.1 表共享读锁"></a>2.1 表共享读锁</h3><p>读锁阻塞写。</p><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>lock table mylock read;</td><td></td></tr><tr><td>select <em> from person;<br>【报错】<em>*非锁定表：不可读不可写</em></em><br>Table ‘person’ was not locked with LOCK TABLES</td><td>select <em> from person;<br>delete from person where id = 3;<br>【成功】<em>*非锁定表：可读可写</em></em></td></tr><tr><td>select <em> from mylock;<br>【成功】<em>*锁定表：可读</em></em></td><td>select <em> from mylock;<br>【成功】<em>*锁定表：可读</em></em></td></tr><tr><td>delete from mylock where id = 6;<br>【报错】<strong>锁定表：不可写</strong><br>Table ‘mylock’ was locked with a READ lock</td><td>delete from mylock where id = 6;<br>【阻塞】<strong>锁定表：不可写</strong><br></td></tr><tr><td>unlock tables;</td><td>session1 释放锁，查询成功</td></tr></tbody></table><p>总结：</p><p>当前 session：非锁定表不可读不可写，锁定表可读不可写（报错）</p><p>其他 session：非锁定表可读可写，锁定表可读不可写（阻塞）</p><h3 id="2-2-表独占写锁"><a href="#2-2-表独占写锁" class="headerlink" title="2.2 表独占写锁"></a>2.2 表独占写锁</h3><p>写锁阻塞读写。</p><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>lock table mylock write;</td><td></td></tr><tr><td>select <em> from person;<br>【报错】<em>*非锁定表：不可读不可写</em></em><br>Table ‘person’ was not locked with LOCK TABLES</td><td>select <em> from person;<br>delete from person where id = 3;<br>【成功】<em>*非锁定表：可读可写</em></em></td></tr><tr><td>select <em> from mylock;<br>【成功】<em>*锁定表：可读</em></em></td><td>select <em> from mylock;<br>【阻塞】<em>*锁定表：不可读</em></em></td></tr><tr><td>delete from mylock where id = 6;<br>【成功】<strong>锁定表：可写</strong></td><td>delete from mylock where id = 6;<br>【阻塞】<strong>锁定表：不可写</strong></td></tr><tr><td>unlock tables;</td><td>session1 释放锁，查询、删除均成功</td></tr></tbody></table><p>总结：</p><p>当前 session：非锁定表不可读不可写，锁定表可读可写</p><p>其他 session：非锁定表可读可写，锁定表不可读不可写</p><p>可以看出，MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！ </p><h3 id="2-3-read-local-实现并发插入"><a href="#2-3-read-local-实现并发插入" class="headerlink" title="2.3 read local 实现并发插入"></a>2.3 read local 实现并发插入</h3><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>lock table mylock read local;</td><td></td></tr><tr><td>select <em> from person;<br>【报错】<em>*非锁定表：不可读不可写</em></em><br>Table ‘person’ was not locked with LOCK TABLES</td><td>select <em> from person;<br>delete from person where id = 3;<br>【成功】<em>*非锁定表：可读可写</em></em></td></tr><tr><td>select <em> from mylock;<br>【成功】<em>*锁定表：可读</em></em></td><td>select <em> from mylock;<br>【成功】<em>*锁定表：可读</em></em></td></tr><tr><td>insert into mylock values(6, ‘f’);<br>【失败】<strong>锁定表：不可插入</strong><br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td>insert into mylock values(6, ‘f’);<br>【成功】<strong>锁定表：可插入</strong></td></tr><tr><td>delete from mylock where id = 6;<br>【失败】<strong>锁定表：不可写（delete、update）</strong><br>错误同上</td><td>delete from mylock where id = 6;<br>【阻塞】<strong>锁定表：不可写（delete、update）</strong></td></tr><tr><td>unlock tables;</td><td>session1 释放锁，删除均成功</td></tr></tbody></table><p>总结：</p><p>当前 session：非锁定表不可读不可写，锁定表可读不可写</p><p>其他 session：非锁定表可读可写，锁定表<strong>可读可插入不可更新删除</strong></p><p>我们可以利用这一点来解决应用中对同一表<strong>查询和插入的锁争用</strong>问题。 </p><h3 id="2-4-加锁时机"><a href="#2-4-加锁时机" class="headerlink" title="2.4 加锁时机"></a>2.4 加锁时机</h3><ul><li>读锁：MyISAM 在执行查询前，涉及的所有表加读锁；lock table tablename read。</li><li>写锁：MyISAM 在执行更新操作前，涉及的所有表加写锁；lock table tablename write。</li></ul><h3 id="2-5-检查表锁争夺情况"><a href="#2-5-检查表锁争夺情况" class="headerlink" title="2.5 检查表锁争夺情况"></a>2.5 检查表锁争夺情况</h3><p> 可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁定争夺：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_%'</span>;</div><div class="line">+<span class="comment">----------------------------+-------+</span></div><div class="line">| Variable_name              | Value |</div><div class="line">+<span class="comment">----------------------------+-------+</span></div><div class="line">| Table_locks_immediate      | 136   |</div><div class="line">| Table_locks_waited         | 5     |</div></pre></td></tr></table></figure><h2 id="3-InnoDB-行锁和表锁"><a href="#3-InnoDB-行锁和表锁" class="headerlink" title="3. InnoDB 行锁和表锁"></a>3. InnoDB 行锁和表锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_no_index</div><div class="line">( <span class="keyword">id</span> <span class="built_in">int</span>,</div><div class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</div><div class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_no_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_with_index</div><div class="line">( <span class="keyword">id</span> <span class="built_in">int</span>,</div><div class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</div><div class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">id</span>(<span class="keyword">id</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</div></pre></td></tr></table></figure><h3 id="3-1-行-表共享锁-读锁-s"><a href="#3-1-行-表共享锁-读锁-s" class="headerlink" title="3.1 行/表共享锁-读锁(s)"></a>3.1 行/表共享锁-读锁(s)</h3><p>指定行/表加了读锁：</p><ul><li>其他事务可以获取该行/表的读锁（<strong>所以可能发生死锁</strong>）</li><li>其他事务不可获取该行/表的写锁</li></ul><p>读锁阻塞写锁：</p><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>set autocommit = 0;</td><td>set autocommit = 0;</td></tr><tr><td>select * from tab_no_index lock in share mode;<br>加读锁</td><td>select * from tab_no_index lock in share mode;<br>【成功】可以获取读锁</td></tr><tr><td></td><td>delete from tab_no_index where id = 1;<br>【阻塞】不可获取写锁</td></tr><tr><td>commit;</td><td>session1 释放锁，获取写锁成功</td></tr></tbody></table><h3 id="3-2-行-表排他锁-写锁-x"><a href="#3-2-行-表排他锁-写锁-x" class="headerlink" title="3.2 行/表排他锁-写锁(x)"></a>3.2 行/表排他锁-写锁(x)</h3><p>指定行/表加了写锁：</p><ul><li>其他事务不可获取该行/表的读锁和写锁</li></ul><p>写锁阻塞读锁、写锁：</p><table><thead><tr><th>session1</th><th>session2</th><th>session3</th></tr></thead><tbody><tr><td>set autocommit = 0;</td><td>set autocommit = 0;</td><td>set autocommit = 0;</td></tr><tr><td>delete from tab_no_index where id = 1 ;<br>加写锁</td><td>select * from tab_no_index lock in share mode;<br>【阻塞】不可获取读锁</td><td>delete from tab_no_index where id = 1;<br>【阻塞】不可获取写锁</td></tr><tr><td></td><td>select * from tab_no_index;<br>【成功】select … 没有任何锁机制</td><td></td></tr><tr><td>commit;</td><td>session1 释放锁，获取读锁成功</td><td></td></tr><tr><td></td><td>commit;</td><td>session2 释放锁，获取写锁成功</td></tr></tbody></table><h3 id="3-3-加锁时机"><a href="#3-3-加锁时机" class="headerlink" title="3.3 加锁时机"></a>3.3 加锁时机</h3><p><strong>加共享锁时机</strong>：select … lock in share mode（注意 select 不会加任何锁。）</p><p><strong>加排他锁时机</strong>：update、delete、insert 给涉及到的数据加排他锁；select … for update</p><h3 id="3-4-表锁还是行锁？"><a href="#3-4-表锁还是行锁？" class="headerlink" title="3.4 表锁还是行锁？"></a>3.4 表锁还是行锁？</h3><p>InnoDB 行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p><h4 id="无索引，表锁"><a href="#无索引，表锁" class="headerlink" title="无索引，表锁"></a>无索引，表锁</h4><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">set autocommit=0</td><td style="text-align:center">set autocommit=0</td></tr><tr><td style="text-align:center">select * from tab_no_index where id = 1 for update<br>加写锁，由于没有索引，锁定的是整个表</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select * from tab_no_index where id = 2 for update;<br>【阻塞】整表被锁，获取写锁失败</td></tr><tr><td style="text-align:center">commit;</td><td style="text-align:center">session1 释放锁，获取写锁成功</td></tr></tbody></table><h4 id="有索引，行锁"><a href="#有索引，行锁" class="headerlink" title="有索引，行锁"></a>有索引，行锁</h4><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">set autocommit=0</td><td style="text-align:center">set autocommit=0</td></tr><tr><td style="text-align:center">select * from tab_with_index where id = 1 for update<br>加写锁，有索引，只锁定 id=1 的行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select * from tab_with_indexwhere id = 2 for update;<br>【成功】获取写锁成功</td></tr></tbody></table><h3 id="3-5-索引冲突导致获取锁失败"><a href="#3-5-索引冲突导致获取锁失败" class="headerlink" title="3.5 索引冲突导致获取锁失败"></a>3.5 索引冲突导致获取锁失败</h3><p>由于 mysql 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是<strong>如果是使用相同的索引键，是会出现冲突的。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'4'</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>);</div></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">session1</th><th style="text-align:center">session2</th></tr></thead><tbody><tr><td style="text-align:center">set autocommit=0</td><td style="text-align:center">set autocommit=0</td></tr><tr><td style="text-align:center">select * from tab_with_index where id = 1 and name=’1’ for update<br>获取写锁，锁定了 id=1 对应的索引</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">select * from tab_with_index where id = 1 and name=’4’ for update<br>【阻塞】虽然是不同行，但是走的同一个索引，获取写锁失败</td></tr></tbody></table><h3 id="3-6-检查行锁争夺情况"><a href="#3-6-检查行锁争夺情况" class="headerlink" title="3.6 检查行锁争夺情况"></a>3.6 检查行锁争夺情况</h3><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%innodb_row_lock%'</span>;</div><div class="line">+<span class="comment">-------------------------------+--------+</span></div><div class="line">| Variable_name                 | Value  |</div><div class="line">+<span class="comment">-------------------------------+--------+</span></div><div class="line">| Innodb_row_lock_current_waits | 0      |</div><div class="line">| Innodb_row_lock_time          | 212240 |</div><div class="line">| Innodb_row_lock_time_avg      | 21224  |</div><div class="line">| Innodb_row_lock_time_max      | 50761  |</div><div class="line">| Innodb_row_lock_waits         | 10     |</div><div class="line">+<span class="comment">-------------------------------+--------+</span></div></pre></td></tr></table></figure><p>如果发现锁争用比较严重，如 InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值比较高。</p><h3 id="3-7-如何减少锁冲突和死锁？"><a href="#3-7-如何减少锁冲突和死锁？" class="headerlink" title="3.7 如何减少锁冲突和死锁？"></a>3.7 如何减少锁冲突和死锁？</h3><p>1、低隔离级别设计索引：尽量使用较低的<strong>隔离级别</strong>； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</p><p>2、小事务：选择合理的事务大小，小事务发生锁冲突的几率也更小；</p><p>3、显示加锁级别给够：给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</p><p>4、多表访问顺序相同：不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</p><p>5、尽量用相等条件访问数据，这样可以避免<strong>间隙锁</strong>对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；？？？</p><p>6、对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p><h2 id="4-多版本并发控制-MVCC"><a href="#4-多版本并发控制-MVCC" class="headerlink" title="4. 多版本并发控制-MVCC"></a>4. 多版本并发控制-MVCC</h2><h3 id="4-1-主要特点"><a href="#4-1-主要特点" class="headerlink" title="4.1 主要特点"></a>4.1 主要特点</h3><ul><li><p>实现无锁并发，快照读不加锁，读写不冲突</p></li><li><p>InnoDB 支持，只在 RC、RR 隔离级别下工作。RU 总是读取的最新行，而不是符合当前事务版本的数据行。Serializable 则会对所有读取的行都加锁。</p></li><li>对于高并发事务，MVCC 比行锁开销更小</li><li>MVCC 可以使用乐观和悲观锁来实现？</li></ul><h3 id="4-2-快照读和当前读"><a href="#4-2-快照读和当前读" class="headerlink" title="4.2 快照读和当前读"></a>4.2 快照读和当前读</h3><p>MVCC 并发控制中，读操作可以分为两类： <strong>快照读 (snapshot read)与当前读 (current read)</strong> 。</p><p><strong>快照读</strong>：读取的是记录的可见版本（有可能是历史版本），不用加锁。</p><ul><li>select * from table where ?;</li></ul><p><strong>当前读</strong>：读取的是记录的<strong>最新版本</strong>，当前读返回的记录都会加上锁，<strong>保证其他事务不会再并发修改这条记录</strong>。</p><ul><li>select <em> from table where ? lock in share mode; <em>*加 S锁（共享锁），其他都是 X锁（排他锁）</em></em></li><li>select * from table where ? for update;</li><li>insert</li><li>update</li><li>delete</li></ul><p>目的：是为了提升并发的性能。虽然需要额外的存储空间和维护工作，但减少了锁的使用。</p><p>理解：可以认为是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p><p>实现：通过保存数据在某个时间点的快照来实现。根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>细节：每个存储引擎不尽相同，以 InnoDB 为例。每行记录后面保存两个隐藏的列（行的创建时间、行的过期时间），实际上存储的是系统版本号。每开始一个新事务，<strong>系统版本号</strong>会自动递增。</p><p>RR 隔离级别下 MVCC 具体操作如下：</p><p><img src="../../images/mysql/8/mvcc.png" alt=""></p><p><img src="../../images/mysql/8/版本记录链.png" alt=""></p><p>select：满足下面两个条件的数据才会返回。</p><ul><li>当前行事务版本号 &gt;= 行的系统版本号。即事务读取的行，要么是事务开始前已经存在的，要么是事务自身插入或修改过的</li><li>当前行事务版本号 &lt; 行的删除版本号。即确保事务读取到的行，在事务开始之前未被删除。</li></ul><p>insert：</p><ul><li>新插入的行保存当前系统版本号作为行版本号</li></ul><p>delete：</p><ul><li>删除的行保存当前系统版本号作为删除标识</li></ul><p>update：</p><ul><li>新插入行保存当前系统版本号作为行版本号，原来行用当前系统版本号作为删除标识</li></ul><h2 id="5、加锁过程分析"><a href="#5、加锁过程分析" class="headerlink" title="5、加锁过程分析"></a>5、加锁过程分析</h2><p>分析以下两个 sql 加什么锁？</p><ul><li><strong>SQL1：</strong>select * from t1 where id = 10;</li><li><strong>SQL2：</strong>delete from t1 where id = 10;</li></ul><p>前提条件，前提不同答案不同：</p><ul><li><p><strong>前提一：</strong>id列是不是主键？</p></li><li><p><strong>前提二：</strong>当前系统的隔离级别是什么？</p></li><li><p><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</p></li><li><p><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</p></li><li><p><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描</p><p><strong>注：</strong>下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。 </p></li></ul><p>前面 8 个组合，也就是 RC、RR 隔离级别下，<strong>SQL1：select操作均不加锁，采用的是快照读</strong> ，下面主要讨论 SQL2 的加锁情况。</p><ul><li><p><strong>组合一：</strong>RC隔离级别，id列是主键 </p><p>聚簇索引，id为10对应的行加 X 锁。</p></li><li><p><strong>组合二：</strong>RC隔离级别，id列是二级唯一索引</p><p>唯一索引，id为10对应的索引节点上 X 锁。聚簇索引，id为10对应的行加 X 锁。</p><p>问：为何聚簇索引也要加 X 锁？</p><p>答：并发 sql 可能直接走聚簇索引更新，不加锁违反<strong>同一记录上的更新/删除需要串行执行</strong>的约束 </p></li><li><p><strong>组合三：</strong>RC隔离级别，id列是二级非唯一索引</p><p>二级索引，所有id为10对应的节点加 X 锁。聚簇索引，锁定的二级索引对应的聚簇索引加 X 锁。</p></li><li><p><strong>组合四：</strong>RC隔离级别，id列上没有索引</p><p> 由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。所以整个聚簇索引上所有记录加 X 锁。</p><p><strong>问</strong>： 为什么不是只在满足条件的记录上加锁呢？ </p><p><strong>答</strong>： 这是由于 MySQL 的实现决定的。如果一个条件无法通过索引快速过滤，那么<strong>存储引擎层面</strong>就会将所有记录加锁后返回，然后由 <strong>MySQL Server 层</strong>进行过滤。因此也就把所有的记录，都锁上了。 </p><p> <strong>注</strong>：在实际的实现中，MySQL 有一些改进，在 MySQL Server 过滤条件，发现不满足后，会调用<strong>unlock_row</strong> 方法，把不满足条件的记录放锁 (<strong>违背了2PL的约束</strong>)。这样做，保证了最后只会持有满足条件记录上的锁，但是<strong>每条记录的加锁操作还是不能省略的</strong>。 </p></li><li><p><strong>组合五：</strong>id列是主键，RR隔离级别</p><p>和组合一一致。</p></li><li><p><strong>组合六：</strong>id列是二级唯一索引，RR隔离级别</p><p>和组合二一致。</p></li><li><p><strong>组合七：</strong>id列是二级非唯一索引，RR隔离级别</p><p>在组合三 基础上，二级索引锁定节点之间的 gap 加上 gap 锁。</p><p><strong>问</strong>： 既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？ </p><p><strong>答</strong>： GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。 </p><p><strong>问</strong>：针对组合5、6， select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？ </p><p><strong>答</strong>：不可省略，需要锁住 10 所在的整个 gap。</p><p><strong>问</strong>： 什么时候会取得gap lock或nextkey lock</p><p><strong>答</strong>： 这和隔离级别有关,只在 REPEATABLE READ 或以上的隔离级别下的<strong>特定操作</strong>才会取得 gap lock 或nextkey lock。</p></li><li><p><strong>组合八：</strong>id列上没有索引，RR隔离级别</p><p>整个聚簇索引上所有记录加 X 锁。所有 gap 加上 gap 锁。</p><p>这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。 </p><p><strong>问</strong>：semi-consistent read 何时触发？</p><p><strong>答</strong>： 要么是 RC 隔离级别；要么是 RR 隔离级别，同时设置了 innodb_locks_unsafe_for_binlog 参数 </p></li><li><p><strong>组合九：</strong>Serializable隔离级别</p><p>SQL2 和组合 RR 一致。 但是 SQL1 会加读锁，也就是说快照读不复存在，MVCC 并发控制降级为 Lock-Based CC。 </p></li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><h3 id="6-1-MyISAM的表锁"><a href="#6-1-MyISAM的表锁" class="headerlink" title="6.1 MyISAM的表锁"></a>6.1 MyISAM的表锁</h3><p>1、共享读锁和共享读锁之间兼容；共享读锁和排他写锁之间，排他写锁和排他写锁之间互斥；就是说同一张表读写是串行的。</p><p>2、允许查询和插入并发执行，可以利用这一点来解决应用中对同一表<strong>查询和插入的锁争用</strong>问题。</p><p>3、表锁粒度大，读写之间串行，所以如果更新操作比较多，可能会出现严重的锁等待，这是可以考虑使用 InnoDB 存储引擎来减小锁粒度，从而减少锁冲突。</p><p>4、默认写的优先级更高，设置LOW_PRIORITY_UPDATES 参数或者在 insert、update、delete 语句中指定 LOW_PRIORITY 选项来降低写锁的争用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> <span class="keyword">low_priority</span> <span class="keyword">from</span> mylock <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</div></pre></td></tr></table></figure><h3 id="6-2-InnoDB-表-行锁"><a href="#6-2-InnoDB-表-行锁" class="headerlink" title="6.2 InnoDB 表/行锁"></a>6.2 InnoDB 表/行锁</h3><p>1、行锁基于索引实现，如果不通过索引访问数据，使用的仍然是表锁</p><p>2、隔离级别不同，锁机制和一致性读策略不同？</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;MyISAM 表锁&lt;/li&gt;
&lt;li&gt;InnoDB 行锁/表锁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(七)</title>
    <link href="http://yoursite.com/2020-08-16-mysql/mysql_7_%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E5%92%8C%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://yoursite.com/2020-08-16-mysql/mysql_7_系统参数和日志系统.html</id>
    <published>2020-08-16T14:13:12.000Z</published>
    <updated>2020-09-11T14:05:33.436Z</updated>
    
    <content type="html"><![CDATA[<ul><li>服务器参数设置。</li><li>日志系统</li></ul><a id="more"></a><h2 id="1-MySQL-系统参数"><a href="#1-MySQL-系统参数" class="headerlink" title="1. MySQL 系统参数"></a>1. MySQL 系统参数</h2><h3 id="1-1-参数说明"><a href="#1-1-参数说明" class="headerlink" title="1.1 参数说明"></a>1.1 参数说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">## general 参数</div><div class="line"># mysql 安装目录</div><div class="line">basedir=/usr/local/mysql</div><div class="line"># 数据文件目录</div><div class="line">datadir=/usr/local/mysql/data</div><div class="line"># mysql.socket表示server和client在同一台服务器，并且使用localhost进行连接，就会使用socket进行连接</div><div class="line"># socket=/usr/local/mysql/mysql.sock</div><div class="line"># pid 文件目录</div><div class="line">#pid_file=/usr/local/mysql/mysql.pid</div><div class="line"># 端口</div><div class="line">port=3306</div><div class="line"># 默认存储引擎</div><div class="line">default_storage_engine=InnoDB</div><div class="line"># 跳过密码登录</div><div class="line">#skip-grant-tables=ON</div><div class="line"># 用户</div><div class="line">user=mysql</div><div class="line"></div><div class="line">## 字符集相关参数</div><div class="line"># server 端字符集</div><div class="line">character_set_server=utf8</div><div class="line"># client 端字符集</div><div class="line"># character_set_client=utf8</div><div class="line"># 数据库默认字符集</div><div class="line"># character_set_database=utf8</div><div class="line"># mysql 发送给客户端的结果集所用的字符集</div><div class="line"># character_set_results=utf8</div><div class="line"># mysql处理客户端发来的信息时，会把这些数据转换成连接的字符集格式</div><div class="line"># character_set_connection=utf8</div><div class="line"># character_set_system=utf8</div><div class="line"></div><div class="line"></div><div class="line">## connection 相关参数</div><div class="line"># mysql 的最大连接数,如果数据库的并发连接请求比较大,应该调高该值</div><div class="line">max_connections=200</div><div class="line"># 限制每个用户的连接个数</div><div class="line">max_user_connections=10</div><div class="line"># mysql 能够暂存的连接数,当mysql的线程在一个很短时间内得到非常多的连接请求时就会起作用</div><div class="line"># 如果mysql的连接数量达到max_connections时,新的请求会放入一个堆栈中,以等待某一个连接的释放</div><div class="line"># 如果等待连接的数量超过back_log,则不再接收连接资源</div><div class="line">back_log=50</div><div class="line"># mysql在关闭一个非交互(noninteractive connection)的连接之前需要等待的时长。短连接。比如jdbc 默认 28800（8小时）</div><div class="line">wait_timeout=43200</div><div class="line"># mysql在关闭一个交互连接之前需要等待的时长。长连接。比如连接池、命令行。</div><div class="line"># 但是连接池中的连接有时长限制，连接池会定时关闭长期没用到的连接。</div><div class="line"># 所以这个定时关闭连接的间隔最好小于 wait_timeout</div><div class="line">interactive_timeout=43200</div><div class="line"></div><div class="line"></div><div class="line">## log相关参数</div><div class="line"># 错误日志，用于记录当mysqld启动和停止时</div><div class="line"># 以及服务器在运行中发生任何严重错误的相关信息</div><div class="line">log_error=/usr/local/mysql/logs/log_error.log</div><div class="line"></div><div class="line">### binlog 设置</div><div class="line"># 指定 binlog 路径和名称</div><div class="line">log-bin=/usr/local/mysql/logs/log_bin.log</div><div class="line"># 指定log-bin参数后，无需指定log_bin，log-bin相当于一个快速设置方式。log_bin表示是否启动bin log</div><div class="line"># 神坑，必须要 server_id</div><div class="line"># If you specify the --log-bin option without also specifying the server_id system variable, the server</div><div class="line"># is not allowed to start. (Bug #11763963, Bug #56739) </div><div class="line">server_id=1</div><div class="line"># 指定哪些数据库需要将更新记录到二进制日志中。</div><div class="line"># 其他所有没有显示指定的数据库将忽略，不记录日志</div><div class="line"># SHOW MASTER STATUS 可以查看binlog源的状态信息</div><div class="line">binlog_do_db=sakila</div><div class="line"># 指定哪些数据库不需要记录日志</div><div class="line"># binlog_ignore_db=</div><div class="line"># binlog 刷盘机制</div><div class="line"># 0-不控制,让OS控制刷盘</div><div class="line"># 1-每次提交事务,刷盘</div><div class="line"># N-指定多少次提交事务后同步磁盘</div><div class="line">sync_binlog=2</div><div class="line"></div><div class="line">### redo log 设置</div><div class="line"># redo log 日志文件大小(64M)，默认（50331648-&gt;48M）</div><div class="line">innodb_log_file_size=67108864</div><div class="line"># redo log 日志个数</div><div class="line">innodb_log_files_in_group=3</div><div class="line"># redo log 日志路径</div><div class="line">innodb_log_group_home_dir=/usr/local/mysql/logs/</div><div class="line"># redo log 刷盘机制,刷盘系统调用:fsync</div><div class="line"># 0-事务提交数据写入InnoDB LogBuffer,然后每秒写入OS cache page并刷盘</div><div class="line"># 1-事务提交立即刷盘</div><div class="line"># 2-事务提交数据写入OS cache page,每秒刷盘</div><div class="line">innodb_flush_log_at_trx_commit=1</div><div class="line"></div><div class="line">### undo log 设置</div><div class="line"># 回滚日志位置一般设置到不同的存储设备</div><div class="line">innodb_undo_directory=/usr/local/mysql/logs/</div><div class="line"># 回滚段的数量</div><div class="line">innodb_rollback_segments=256</div><div class="line"># undo tablespaces 的数量,初始化后不可修改,否则会导致服务无法启动</div><div class="line"># innodb_undo_tablespaces=2</div><div class="line"></div><div class="line">### general log 设置</div><div class="line"># 是否开启查询日志记录</div><div class="line">general_log=ON</div><div class="line">general_log_file=/usr/local/mysql/logs/general_log.log</div><div class="line"></div><div class="line">### slow log 设置</div><div class="line"># 是否开启慢日志</div><div class="line">slow_query_log=ON</div><div class="line">slow_query_log_file=/usr/local/mysql/logs/slow_query_log.log</div><div class="line">long_query_time=2</div><div class="line">log_slow_admin_statements=ON</div><div class="line"></div><div class="line">## 缓存相关参数</div><div class="line"># 索引缓冲区的大小(只对 MyISAM 表起作用),默认(8M=&gt;16M)</div><div class="line">key_buffer_size=16777216</div><div class="line"></div><div class="line">### 查询缓存 5.7.20 被弃用,8 被移除</div><div class="line"># 查询缓存的大小,默认(1M=&gt;4M)</div><div class="line">query_cache_size=4194304</div><div class="line"># 缓存类型</div><div class="line"># 0-禁用</div><div class="line"># 1-缓存所有查询结果,除非显示指定 sql_no_cache</div><div class="line"># 2-只缓存 sql_cache 指定的查询</div><div class="line">query_cache_type=2</div><div class="line"># 缓存块最小大小(默认 4K=&gt;0.25K)</div><div class="line">query_cache_min_res_unit=256</div><div class="line"># 超过此大小的查询不缓存(默认 1M=&gt;2M)</div><div class="line">query_cache_limit=2097152</div><div class="line"></div><div class="line"># 每个需要排序的线程分派缓冲区的大小(默认 256K=&gt;1M)</div><div class="line"># 可根据引擎设置:innodb_sort_buffer_size、myisam_sort_buffer_size</div><div class="line">sort_buffer_size=1048576</div><div class="line"># MySQL server 接收的最大数据包大小(4M=&gt;32M)</div><div class="line">max_allowed_packet=33554432</div><div class="line"># 设置关联缓冲的大小(256K=&gt;2M)</div><div class="line">join_buffer_size=2097152</div><div class="line"># 服务器线程缓存数量，当断开连接时，客户端的线程被放到缓存中以响应下一个客户而不是销毁</div><div class="line"># 如果线程重新被请求，那么请求将从缓存中读取</div><div class="line"># 如果缓存中是空的或者是新的请求，这个线程将被重新请求和创建</div><div class="line"># 如果有很多新的线程，增加这个值即可（10=&gt;5）</div><div class="line">thread_cache_size=5</div><div class="line"></div><div class="line">## InnoDB 相关参数</div><div class="line"># 缓存数据和索引的内存大小，最大可设置物理内存的 80%（128M=&gt;64M）</div><div class="line">innodb_buffer_pool_size=67108864</div><div class="line"># 设置 InnoDB 线程的并发数，0 表示不限制</div><div class="line"># 如果设置一般为服务器的核心数或者核心数的两倍(0=&gt;8)</div><div class="line">innodb_thread_concurrency=8</div><div class="line"># (16M=&gt;64M)</div><div class="line">innodb_log_buffer_size=67108864</div><div class="line"># 读入缓冲区大小(128K=&gt;256K)</div><div class="line"># 对表进行顺序扫描的请求将分配到一个读入缓冲区</div><div class="line">read_buffer_size=262144</div><div class="line"># MySQL 随机读缓冲区大小（256K=&gt;512K）</div><div class="line">read_rnd_buffer_size=524288</div><div class="line"># 是否为每张表分配一个新的文件</div><div class="line">innodb_file_per_table=ON</div><div class="line"></div><div class="line">[mysqld_safe]</div><div class="line">#log_error=/usr/local/mysql/logs/log_error.log</div><div class="line">#pid-file=/var/run/mysqld/mysqld.pid</div><div class="line"></div><div class="line">[client]</div><div class="line">default-character-set=utf8</div><div class="line"># client 端字符集</div><div class="line">#character_set_client=utf8</div></pre></td></tr></table></figure><h3 id="1-2-查看查询缓存状态"><a href="#1-2-查看查询缓存状态" class="headerlink" title="1.2 查看查询缓存状态"></a>1.2 查看查询缓存状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%Qcache%'</span>;</div></pre></td></tr></table></figure><ul><li>Qcache_free_blocks：缓存中相邻内存块的个数，如果值比较大说明查询缓存中碎片比较多</li><li>Qcache_free_memory：查询缓存中剩余的内存大小</li><li>Qcache_hits：表示有多少查询命中缓存</li><li>Qcache_inserts：多少次未命中而插入</li><li>Qcache_lowmem_prunes：多少条查询因为内存不足而被移除 cache</li><li>Qcache_queries_in_cache：当前 cache 中缓存的查询条数</li><li>Qcache_total_blocks：当前 cache 中 block 的数量</li></ul><h3 id="1-3-查看线程缓存状态"><a href="#1-3-查看线程缓存状态" class="headerlink" title="1.3 查看线程缓存状态"></a>1.3 查看线程缓存状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%Threads%'</span>;</div></pre></td></tr></table></figure><ul><li>Threads_cached：当前线程缓存中有多少空闲线程</li><li>Threads_connected：当前已建立连接的数量</li><li>Threads_created：最近一次启动服务，已创建线程的数量</li><li>Threads_running：当前激活的线程数</li></ul><h2 id="2-MySQL-日志"><a href="#2-MySQL-日志" class="headerlink" title="2. MySQL 日志"></a>2. MySQL 日志</h2><h3 id="2-1-日志的作用"><a href="#2-1-日志的作用" class="headerlink" title="2.1 日志的作用"></a>2.1 日志的作用</h3><p>保证数据不丢失，主要体现在两个方面</p><ol><li>能够恢复到任何时间点的状态。通过 binlog 实现</li><li>任何时候 MySQL 突然崩溃,重启之后之前已经提交的记录不会丢失。redolog undolog 实现。<ul><li>已提交的数据不会丢失</li><li>未提交完整的数据自动回滚</li></ul></li></ol><h3 id="2-2-WAL-机制"><a href="#2-2-WAL-机制" class="headerlink" title="2.2 WAL 机制"></a>2.2 WAL 机制</h3><p>为什么不直接更改磁盘中的数据，而要在内存中更改，然后还需要写日志，最后再落盘这么复杂？</p><p>主要是性能问题。直接写磁盘是<strong>随机写</strong>，开销很大，没办法满足 MySQL 性能要求。所以设计成先在内存中对数据进行更改，再异步落盘。但是内存总是不可靠，万一断电重启，还没来得及落盘的内存数据就会丢失，所以还需要加上写日志这个步骤。虽然写日志也是写磁盘，但是写日志是<strong>顺序写</strong>。</p><h3 id="2-3-核心日志模块"><a href="#2-3-核心日志模块" class="headerlink" title="2.3 核心日志模块"></a>2.3 核心日志模块</h3><h4 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志 redo log"></a>重做日志 redo log</h4><p>InnoDB 存储引擎产生，记录数据库中每个页的修改，而不是某一行或者某几行修改成怎样，可以用来恢复提交后的物理数据页（所以只能恢复到最后一次提交的位置）。</p><p>redo log 就是 WAL 的典型应用，MySQL 在有事务提交时，只会在内存中修改对应的数据页和记录 redo log 日志，完成后即表示事务提交成功，至于磁盘数据文件的更新则由后台线程异步处理。</p><p>redo log 保证了 MySQL 数据<strong>一致性和持久性</strong>（MySQL 崩溃了，重启后仍然可以通过 redo log 里的记录进行重放，重新刷盘）。</p><p>redo log 大小固定，循环写入，相当于一个环形，所以是顺序写。当 redo log 满了，就需要对旧的记录进行擦除，擦除之前必须确保被擦除的记录在内存中的数据页都已刷到磁盘中了。在 redo log 满了到擦除旧记录之前，是不能再接收新的更新请求的，所以有可能导致 MySQL 卡顿。所以针对并发量大的系统，<strong>适当设置 redo log 的文件大小</strong>非常重要。</p><h4 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志 undo log"></a>回滚日志 undo log</h4><p>主要提供回滚的作用，另外一个作用就是多个行版本控制（MVCC），保证事务的<strong>原子性</strong>。在数据修改的流程中，会记录一条与当前操作相反的逻辑日志到 undo log 中。</p><h4 id="归档日志-binlog"><a href="#归档日志-binlog" class="headerlink" title="归档日志 binlog"></a>归档日志 binlog</h4><p>binlog 在 MySQL 的 server 产生，不属于任何引擎，主要记录用户对数据库操作的 SQL 语句（除了查询语句）。之所以叫做归档日志，因为 binlog 不会像 redo log 一样擦除旧日志，而是追加，操作 <code>max_binlog_size</code>  就新起一个文件。</p><p>日志可能是基于事务来记录的（如 InnoDB），而事务是绝对不可能也不应该跨文件记录的，所以 <code>max_binlog_size</code> 和实际的 binlog 日志大小不一定相等。</p><h4 id="binlog-和-redo-log-的区别"><a href="#binlog-和-redo-log-的区别" class="headerlink" title="binlog 和 redo log 的区别"></a>binlog 和 redo log 的区别</h4><ul><li>redolog 是 innodb 独有的，binlog 是所有 engine 都可以使用的</li><li>redolog 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑。物理日志：记录内存地址上存的啥；逻辑日志：记录 sql 语句。</li><li>redolog 是循环写的，空间会用完（存在内存的缓冲区中，肯定小）；binlog 是可以追加的，不会覆盖之前的日志信息。</li></ul><h3 id="2-4-三个日志都必须开启吗？"><a href="#2-4-三个日志都必须开启吗？" class="headerlink" title="2.4 三个日志都必须开启吗？"></a>2.4 三个日志都必须开启吗？</h3><ul><li>redo log 保证数据的持久性，必不可少。如果没有 MySQL 肯定不能认为修改了内存数据就表示操作成功。</li><li>undo log 保证事务原子性，必不可少。为啥必不可少？如果我知道哪个事务有问题，我把这个事务的 redo log 做一遍相反的操作不也可以实现吗？</li><li>binlog <ul><li>主从模式必不可少，因为从库的数据同步依赖的就是 binlog</li><li>单机模式如果不考虑数据库基于某个时间点还原，那么 binlog 就不是必须的。redo log 就可以保证 crash-safe 了。</li></ul></li></ul><h3 id="2-5-两阶段提交"><a href="#2-5-两阶段提交" class="headerlink" title="2.5 两阶段提交"></a>2.5 两阶段提交</h3><p>问题：为什么 redo log 要分两步写，中间再穿插写 binlog 呢？</p><p>redo log 影响主库数据，binlog 影响从库数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致，这个是需要两阶段提交的前提。</p><p>redo log 和 binlog 其实就是很典型的分布式事务场景，因为两者本身就是两个独立的个体，要想保持一致，就必须使用分布式事务解决方案来处理。而将 redo log 分成两步，其实就是使用了两阶段提交协议（2PC）。</p><p><img src="../../images/mysql/7/两阶段提交.png" alt=""></p><p>所以将 redo log 分成两步写，中间插入 binlog 才能保证 redo log 和 binlog 内容一致，从而保证主从数据一致。</p><h3 id="2-6-组提交"><a href="#2-6-组提交" class="headerlink" title="2.6 组提交"></a>2.6 组提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">T1 (--prepare--binlog---------------------commit)</div><div class="line">T2 (-----prepare-----binlog----commit)</div><div class="line">T3 (--------prepare-------binlog------commit)</div><div class="line"> </div><div class="line">解析：</div><div class="line">    redo log prepare的顺序：T1 --》T2 --》T3</div><div class="line">    binlog的写入顺序：T1 --》 T2 --》T3</div><div class="line">    redo log commit的顺序：T2 --》 T3 --》T1</div><div class="line"> </div><div class="line">结论：由于binlog写入的顺序和redo log提交结束的顺序不一致，导致binlog和redo log所记录的事务提交结束的顺序不一样，最终导致的结果就是主从数据不一致。binlog 记录的是：i=1;i=2;i=3;redo log 记录的是：i=2;i=3;i=1</div></pre></td></tr></table></figure><ul><li>两阶段提交没法保证多个事务的提交顺序，所以还需要再加一个锁来保证提交的原子性，从而保证多事务情况下，两个日志的提交顺序一致。 prepare_commit_mutex 锁保证一个事务获取到锁后才能进入 prepare，一直到 commit 结束才能释放锁。并发量大时，会导致锁争用，性能不好。</li><li>两阶段提交还有一个问题就是每个事务提交都会进行两次 fsync（写磁盘）</li></ul><p>MySQL 5.6 引入了 binlog 组提交，即 BLGC。基本思想是引入队列机制保证 InnoDB commit 顺序 binlog 落盘顺序一致，并将事务分组，组内的 binlog 刷盘动作交给一个事务进行，实现组提交的目的。</p><p>组提交图</p><h4 id="第一阶段（prepare-阶段）"><a href="#第一阶段（prepare-阶段）" class="headerlink" title="第一阶段（prepare 阶段）"></a>第一阶段（prepare 阶段）</h4><p>持有 prepare_commit_mutex，并且 write/fsync redo log 到磁盘，设置为 prepared 状态，完成后就释放 prepare_commit_mutex，binlog 不做任何操作。</p><h4 id="第二阶段（commit-阶段）"><a href="#第二阶段（commit-阶段）" class="headerlink" title="第二阶段（commit 阶段）"></a>第二阶段（commit 阶段）</h4><ol><li>Flush Stage（写入 binlog 缓存）<ul><li>持有 Lock_log mutex（leader 持有，follower 等待）</li><li>获取队列中的一组 binlog（队列中的所有事务）</li><li>写入 binlog 缓存</li></ul></li><li>Sync Stage（将 binlog 落盘）<ul><li>释放 Lock_log mutex，持有 Lock_sync mutex（leader 持有，follower 等待）</li><li>将一组 binlog 落盘（fsync 动作，最耗时，假设 sync_binlog 为 1</li></ul></li><li>Commit Stage（InnoDB commit，清除 undo 信息）<ul><li>释放 Lock_sync mutex，持有 Lock_commit mutex（leader 持有，follower 等待）</li><li>遍历队列中的事务，逐一进行 InnoDB commit</li><li>释放 Lock_commit mutex</li></ul></li></ol><p>每个队列各自有 mutex 保护，同一个组队列之间是顺序的（flush-&gt;sync-&gt;commit）</p><p>组之间队列可以并发执行，即当一组事务在进行 commit 阶段时，其他新事务可以进行 flush 阶段，实现真正意义上的组提交，大幅度降低磁盘的 IOPS 消耗。（没太懂。。。）</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>锁粒度更小，2PC 锁 prepare 到 commit 整个事务流程，组提交拆分为四个小阶段上锁</li><li>组提交是批量刷盘，相比之前的单条记录都要刷盘，能大幅降低磁盘的 IO 消耗</li></ul><h3 id="2-7-数据恢复流程"><a href="#2-7-数据恢复流程" class="headerlink" title="2.7 数据恢复流程"></a>2.7 数据恢复流程</h3><p>MySQL 重启后，提供服务前会先做的事 – 数据恢复流程：</p><p><img src="../../images/mysql/7/Mysql数据恢复流程.png" alt=""></p><h3 id="2-7-两个参数"><a href="#2-7-两个参数" class="headerlink" title="2.7 两个参数"></a>2.7 两个参数</h3><h4 id="sync-binlog，控制-binlog-刷盘，默认1"><a href="#sync-binlog，控制-binlog-刷盘，默认1" class="headerlink" title="sync_binlog，控制 binlog 刷盘，默认1"></a>sync_binlog，控制 binlog 刷盘，默认1</h4><ul><li>0：MySQL 不控制，让操作系统控制。性能最好，但是最可能丢失 binlog</li><li>1：每次事务提交前，刷盘。性能最差，只有 prepared 状态的事务会丢失，这可以借助 undo log 自动回滚，所以不会丢失任何事务</li><li>N：提交 N 次事务组后，刷盘。该值越高，性能越好，风险也越大。</li></ul><h4 id="innodb-flush-log-at-trx-commit，控制-redo-log-刷盘，默认-1"><a href="#innodb-flush-log-at-trx-commit，控制-redo-log-刷盘，默认-1" class="headerlink" title="innodb_flush_log_at_trx_commit，控制 redo log 刷盘，默认 1"></a>innodb_flush_log_at_trx_commit，控制 redo log 刷盘，默认 1</h4><p>ACID 特性和性能之间的一个权衡。</p><ul><li>0：每次事务提交，先写入 log buffer，然后每秒写入 OS cache page，然后刷盘</li><li>1：每次事务提交，日志刷盘</li><li>2：每次事务提交，写入 OS cache page，然后每秒刷盘</li></ul><p><img src="../../images/mysql/7/redolog.png" alt=""></p><p>reference： <a href="https://blog.csdn.net/wenyiCodeDog/article/details/106581741" target="_blank" rel="external">https://blog.csdn.net/wenyiCodeDog/article/details/106581741</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;服务器参数设置。&lt;/li&gt;
&lt;li&gt;日志系统&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(六)</title>
    <link href="http://yoursite.com/2020-08-14-mysql/mysql_6_%E5%88%86%E5%8C%BA.html"/>
    <id>http://yoursite.com/2020-08-14-mysql/mysql_6_分区.html</id>
    <published>2020-08-14T14:13:12.000Z</published>
    <updated>2020-09-09T15:40:41.564Z</updated>
    
    <content type="html"><![CDATA[<ul><li>分区表场景</li><li>分区表限制</li><li>分区表原理</li><li>分区表类型</li><li>如何使用分区</li></ul><a id="more"></a><h2 id="1-分区表的应用场景"><a href="#1-分区表的应用场景" class="headerlink" title="1. 分区表的应用场景"></a>1. 分区表的应用场景</h2><ul><li>表非常大以至于无法全部都放在内存中</li><li>表只在最后的部分有热点数据，其他均是历史数据</li><li>分区表的数据更容易维护<ul><li>批量删除大量数据可以使用清除整个分区的方式</li><li>对一个独立分区进行优化、检查、修复等操作</li></ul></li><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>可以使用分区表来避免某些特殊的瓶颈<ul><li>innodb 的单个索引的互斥访问</li><li>ext3 文件系统的 inode 锁竞争</li></ul></li><li>可以备份和恢复独立的分区</li></ul><p>分区表适用于一些日志记录表。这类表的特点是数据量大、并且有冷热数据区分，可以按照时间维度来进行数据归档。这类表是比较适合使用分区表的，因为分区表可以对单独的分区进行维护，对于数据归档更方便。 </p><h2 id="2-分区表的限制"><a href="#2-分区表的限制" class="headerlink" title="2. 分区表的限制"></a>2. 分区表的限制</h2><ul><li>分区数量限制：一个表最多 1024 个分区，5.7 的时候可以支持 8196 个分区</li><li>分区字段限制：如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>若查询不走分区键，则可能会扫描所有分区，效率不会提升。</li><li>若数据分布不均，分区大小差别较大，可能性能提升也有限。</li><li>普通表改造成分区表比较繁琐。</li><li>需要持续对分区进行维护，比如到了 6 月份前就要新增 6 月份的分区。</li></ul><ul><li>null 值会使分区过滤无效</li><li>分区列和索引列不匹配，会导致查询无法进行分区过滤</li><li>打开并锁住所有底层表的成本可能很高</li><li>维护分区的成本可能很高</li><li>最好不要 update 分区键</li></ul><h2 id="3-分区表的原理"><a href="#3-分区表的原理" class="headerlink" title="3. 分区表的原理"></a>3. 分区表的原理</h2><ul><li>由多个相关的底层表实现</li><li>存储引擎管理分区的各个底层表和管理普通表一样</li><li>分区表的索引只是在各个底层表上各自加上一个完全相同的索引</li></ul><h3 id="3-1-select-查询"><a href="#3-1-select-查询" class="headerlink" title="3.1 select 查询"></a>3.1 select 查询</h3><p>当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据。</p><h3 id="3-2-insert-操作"><a href="#3-2-insert-操作" class="headerlink" title="3.2 insert 操作"></a>3.2 insert 操作</h3><p>分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表。</p><h3 id="3-3-delete-操作"><a href="#3-3-delete-操作" class="headerlink" title="3.3 delete 操作"></a>3.3 delete 操作</h3><p>分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作。</p><h3 id="3-4-update-操作"><a href="#3-4-update-操作" class="headerlink" title="3.4 update 操作"></a>3.4 update 操作</h3><p>分区层先打开并锁住所有的底层表，确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该在哪个分区，最后对底层表进行写入操作，并对源数据进行删除。</p><h3 id="3-5-支持过滤"><a href="#3-5-支持过滤" class="headerlink" title="3.5 支持过滤"></a>3.5 支持过滤</h3><p>如果 where 条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉。</p><h3 id="3-6-支持行锁"><a href="#3-6-支持行锁" class="headerlink" title="3.6 支持行锁"></a>3.6 支持行锁</h3><p>虽然每个操作都会分区层先打开并锁住所有的底层表，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，例如 InnoDB，则会在分区层释放对应的表锁。</p><h2 id="4-分区表的类型"><a href="#4-分区表的类型" class="headerlink" title="4. 分区表的类型"></a>4. 分区表的类型</h2><h3 id="4-1-范围分区"><a href="#4-1-范围分区" class="headerlink" title="4.1 范围分区"></a>4.1 范围分区</h3><p>根据列值在给定范围内将行分配给分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    store_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (store_id) (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">6</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">11</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">16</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</div><div class="line">);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>,fname,job_code,store_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>,<span class="number">1</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>,fname,job_code,store_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'alvin'</span>,<span class="number">1</span>,<span class="number">33</span>);</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employeees;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> quarterly_report_status (</div><div class="line">    report_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    report_status <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    report_updated <span class="keyword">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(report_updated) ) (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-01-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-04-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-07-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-10-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-01-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-04-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p6 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-07-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p7 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2009-10-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p8 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> ( <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2010-01-01 00:00:00'</span>) ),</div><div class="line">    <span class="keyword">PARTITION</span> p9 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE)</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="4-2-列表分区"><a href="#4-2-列表分区" class="headerlink" title="4.2 列表分区"></a>4.2 列表分区</h3><p>和 range 分区类似。只是匹配一个列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span>,</div><div class="line">    store_id <span class="built_in">INT</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span>(store_id) (</div><div class="line">    <span class="keyword">PARTITION</span> pNorth <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">17</span>),</div><div class="line">    <span class="keyword">PARTITION</span> pEast <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">20</span>),</div><div class="line">    <span class="keyword">PARTITION</span> pWest <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">4</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">18</span>),</div><div class="line">    <span class="keyword">PARTITION</span> pCentral <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>, fname, store_id) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'alvin'</span>, <span class="number">17</span>);</div><div class="line"><span class="comment">-- ERROR 1526 (HY000): Table has no partition for value 88</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employees(<span class="keyword">id</span>, fname, store_id) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'alvin'</span>, <span class="number">88</span>);</div></pre></td></tr></table></figure><h3 id="4-3-列分区"><a href="#4-3-列分区" class="headerlink" title="4.3 列分区"></a>4.3 列分区</h3><p>5.5 开始支持 column 分区，可以认为是 range 和 list 分区的升级版。</p><p>5.5 之后可以使用 column 分区代替他们，但是 column 分区只接收普通列不接受表达式。</p><p>允许多列分区。</p><p>支持非整型类型分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rc1 (</div><div class="line">    a <span class="built_in">INT</span>,</div><div class="line">    b <span class="built_in">INT</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> <span class="keyword">COLUMNS</span>(a, b) (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">5</span>, <span class="number">12</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE, MAXVALUE)</div><div class="line">);</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> rc1 <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">10</span>), (<span class="number">5</span>,<span class="number">11</span>), (<span class="number">5</span>,<span class="number">12</span>);</div><div class="line"><span class="keyword">SELECT</span> (<span class="number">5</span>,<span class="number">10</span>) &lt; (<span class="number">5</span>,<span class="number">12</span>), (<span class="number">5</span>,<span class="number">11</span>) &lt; (<span class="number">5</span>,<span class="number">12</span>), (<span class="number">5</span>,<span class="number">12</span>) &lt; (<span class="number">5</span>,<span class="number">12</span>);</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">10</span>) &lt; <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>), <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">11</span>) &lt; <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>), <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>) &lt; <span class="keyword">ROW</span>(<span class="number">5</span>,<span class="number">12</span>);</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees_by_lname (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    store_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> <span class="keyword">COLUMNS</span> (lname)  (</div><div class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'g'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'m'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="string">'t'</span>),</div><div class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (MAXVALUE)</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="4-4-hash-分区"><a href="#4-4-hash-分区" class="headerlink" title="4.4 hash 分区"></a>4.4 hash 分区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    fname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    lname <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</div><div class="line">    hired <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01'</span>,</div><div class="line">    separated <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'9999-12-31'</span>,</div><div class="line">    job_code <span class="built_in">INT</span>,</div><div class="line">    store_id <span class="built_in">INT</span></div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>( <span class="keyword">YEAR</span>(hired) )</div><div class="line"><span class="comment">-- liner hash。hash 算法不同</span></div><div class="line"><span class="comment">-- PARTITION BY LINEAR HASH( YEAR(hired) )</span></div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">4</span>;</div></pre></td></tr></table></figure><h3 id="4-5-key-分区"><a href="#4-5-key-分区" class="headerlink" title="4.5 key 分区"></a>4.5 key 分区</h3><p>和 hash 类似，key 分区可以指定多列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k1 (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>()</div><div class="line"><span class="comment">-- 也有 liner key</span></div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">-- ERROR 1503 (HY000): A UNIQUE INDEX must include all columns in the table's partitioning function</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k2 (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (<span class="keyword">name</span>)</div><div class="line">)</div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>(<span class="keyword">id</span>)</div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k2 (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    primary <span class="keyword">KEY</span> (<span class="keyword">id</span>,<span class="keyword">name</span>) </div><div class="line">) </div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) </div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">2</span></div><div class="line">;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k2 (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    nickname <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">unique</span> <span class="keyword">key</span> (nickname),</div><div class="line">    primary <span class="keyword">KEY</span> (<span class="keyword">id</span>,<span class="keyword">name</span>) </div><div class="line">) </div><div class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">KEY</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) </div><div class="line"><span class="keyword">PARTITIONS</span> <span class="number">2</span></div><div class="line">;</div></pre></td></tr></table></figure><h3 id="4-6-子分区"><a href="#4-6-子分区" class="headerlink" title="4.6 子分区"></a>4.6 子分区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts (<span class="keyword">id</span> <span class="built_in">INT</span>, purchased <span class="built_in">DATE</span>)</div><div class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(purchased) )</div><div class="line">    <span class="keyword">SUBPARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>( <span class="keyword">TO_DAYS</span>(purchased) )</div><div class="line">    <span class="keyword">SUBPARTITIONS</span> <span class="number">2</span> (</div><div class="line">        <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1990</span>),</div><div class="line">        <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2000</span>),</div><div class="line">        <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</div><div class="line">    );</div></pre></td></tr></table></figure><h2 id="5-如何使用分区"><a href="#5-如何使用分区" class="headerlink" title="5. 如何使用分区"></a>5. 如何使用分区</h2><p>如果需要从非常大的表中查询出某一段时间的记录，而这张表中包含很多年的历史数据，数据是按照时间排序的，此时应该如何查询数据呢？</p><p>因为数据量较大，肯定不能在每次查询的时候都全表扫描。考虑到索引在空间和维护上的消耗，也不希望使用索引，即使使用索引，会发现会产生大量的碎片，还会产生大量的随机 IO。当数据量超大的时候，索引的效果也不是很好，此时可以考虑使用分区来解决。</p><h3 id="5-1-全量扫描，不要任何索引"><a href="#5-1-全量扫描，不要任何索引" class="headerlink" title="5.1 全量扫描，不要任何索引"></a>5.1 全量扫描，不要任何索引</h3><p>使用简单的分区方式存放表，不要任何索引，根据分区规则大致定位需要的数据为止，通过 where 条件将需要的数据限制在少数分区中，这种策略适用于以正常的方式访问大量数据。</p><h3 id="5-2-索引数据，并分离热点"><a href="#5-2-索引数据，并分离热点" class="headerlink" title="5.2 索引数据，并分离热点"></a>5.2 索引数据，并分离热点</h3><p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中，这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存。</p><h2 id="6-问题"><a href="#6-问题" class="headerlink" title="6. 问题"></a>6. 问题</h2><p>1、如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</p><p>2、普通表改造成分区表比较繁琐，怎么改造？</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;分区表场景&lt;/li&gt;
&lt;li&gt;分区表限制&lt;/li&gt;
&lt;li&gt;分区表原理&lt;/li&gt;
&lt;li&gt;分区表类型&lt;/li&gt;
&lt;li&gt;如何使用分区&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(五)</title>
    <link href="http://yoursite.com/2020-08-13-mysql/mysql_5_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html"/>
    <id>http://yoursite.com/2020-08-13-mysql/mysql_5_查询优化.html</id>
    <published>2020-08-13T14:13:12.000Z</published>
    <updated>2020-09-12T02:16:13.575Z</updated>
    
    <content type="html"><![CDATA[<ul><li>查询慢的原因</li><li>优化数据访问</li><li><p>优化执行过程</p></li><li><p>特定类型的查询</p></li><li>使用自定义变量</li></ul><a id="more"></a><h2 id="1-查询慢的原因"><a href="#1-查询慢的原因" class="headerlink" title="1. 查询慢的原因"></a>1. 查询慢的原因</h2><ul><li>网络</li><li>CPU</li><li>IO</li><li>上下文切换</li><li>系统调用</li><li>生成统计信息</li><li>锁等待时间</li></ul><h2 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2. 优化数据访问"></a>2. 优化数据访问</h2><p>查询性能低下的原因主要是访问的数据太多，所以应该在达到目的的前提下尽可能检索更少的数据。</p><ul><li>确认应用程序是否在检索大量超过需要的数据<ul><li>不要查询不需要的数据，如果只要指定行数的数据，可以用 limit 优化</li><li>需要哪些字段就查询哪些字段，禁止 <code>select *</code></li><li>如果需要不断的执行相同的查询，并且每次返回的数据完全相同，应该把这部分数据缓存起来。比如配置信息等</li></ul></li><li>确认 mysql 服务器是否在分析大量超过需要的数据行</li></ul><h2 id="3-优化执行过程"><a href="#3-优化执行过程" class="headerlink" title="3. 优化执行过程"></a>3. 优化执行过程</h2><h3 id="3-1-查询缓存"><a href="#3-1-查询缓存" class="headerlink" title="3.1 查询缓存"></a>3.1 查询缓存</h3><p>解析查询语句之前，如果查询缓存是开启的，会优先检查该查询是否命中缓存，如果命中并且用户权限没有问题则会直接返回缓存结果。</p><h3 id="3-2-语法解析器和预处理"><a href="#3-2-语法解析器和预处理" class="headerlink" title="3.2 语法解析器和预处理"></a>3.2 语法解析器和预处理</h3><p>MySQL 语法解析器通过关键字解析 sql 语句，校验 sql 语法是否正确，生成一个语法树。预处理进一步检查语法树是否合法，例如表名和列名是否存在，是否有歧义，用户是否有权限等。</p><h3 id="3-3-查询优化器"><a href="#3-3-查询优化器" class="headerlink" title="3.3 查询优化器"></a>3.3 查询优化器</h3><h4 id="计算查询代价"><a href="#计算查询代价" class="headerlink" title="计算查询代价"></a>计算查询代价</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> film_actor;</div><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'last_query_cost'</span>;</div></pre></td></tr></table></figure><p><code>last_query_cost</code> 上次查询 sql 的代价，这是 mysql 经过一系列的统计信息计算出来的。</p><ul><li>每个表或索引的页面个数</li><li>索引的基础</li><li>索引和数据行的长度</li><li>索引的分布情况</li></ul><h4 id="有时可能选择错误的执行计划"><a href="#有时可能选择错误的执行计划" class="headerlink" title="有时可能选择错误的执行计划"></a>有时可能选择错误的执行计划</h4><ul><li>统计信息不准确<ul><li>InnoDB 基于 mvcc 架构，并不能维护一个数据表行数的精确统计信息</li></ul></li><li>估算的成本不等于实际执行的成本<ul><li>顺序读、内存读等影响。mysql 不知道哪些页面在内存中哪些在磁盘中，所以实际执行过程中到底需要多少次 IO 是无法得知的。</li></ul></li><li>MySQL 的最优可能跟你想的不一样。MySQL 的优化是基于成本模型的优化，但是有可能不是最快的优化。</li><li>MySQL 不考虑其他并发执行的查询</li><li>MySQL 不会考虑不受其控制的操作成本。比如存储过程或者用户自定义的函数</li></ul><h4 id="优化器的优化策略"><a href="#优化器的优化策略" class="headerlink" title="优化器的优化策略"></a>优化器的优化策略</h4><ul><li>静态优化，直接对解析树进行分析并优化，只需一次</li><li>动态优化，与查询的上下文有关，也可能和取值、索引对应的行数有关。动态优化每次执行时都需要重新评估。</li></ul><p><img src="../../images/mysql/5/数据量大可能不走索引.png" alt=""></p><p>查询的数据量较大时，可能不走索引。理论上没问题，但是 mysql 中有自己的优化器。</p><h4 id="优化器的优化类型"><a href="#优化器的优化类型" class="headerlink" title="优化器的优化类型"></a>优化器的优化类型</h4><ul><li><p>重新定义关联表的顺序，并不是按照 sql 写的顺序关联。可以使用 <strong><code>select straight_join</code></strong> 强制使用 sql 顺序。</p></li><li><p>将外连接转化为内连接，内连接效率更好</p></li><li><p>等价变换，简化表达式</p></li><li><p>优化 count()，min()，max()，通过索引 B+ 树查找，无需全表扫描。索引列是否可以为空通常可以帮助 MySQL 优化这类表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> min_test(a <span class="built_in">varchar</span>(<span class="number">20</span>), b <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>);</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> min_test <span class="keyword">add</span> <span class="keyword">index</span> idx_a(a);</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> min_test <span class="keyword">add</span> <span class="keyword">index</span> idx_b(b);</div><div class="line"><span class="comment">-- 没有验证出来</span></div></pre></td></tr></table></figure></li><li><p>预估并转化为常数表达式</p></li><li><p>索引覆盖扫描</p></li><li><p>子查询优化 </p></li><li><p>等值传播。关联字段，一个表加过滤就行。</p></li></ul><h4 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h4><ul><li>Simple Nested-Loop Join，就是嵌套循环遍历，笛卡尔集。主表为驱动表，从表为匹配表。</li><li>Index Nested-Loop Join，如果<strong>非驱动表</strong>有索引会走索引，这样不用每次扫描整个表。如果是主键索引速度更快，否则还有回表查询。</li><li>Block Nested-Loop Join，如果有 join 列有索引会走第二种的索引方式，如果没有会建一个 join buffer，<strong>一次取出驱动表中的多条数据</strong>到 join_buffer 中，取出的数据只去所有 join 相关的列，然后批量与匹配表进行匹配，将第一种方法中的<strong>多次比较合并为一次</strong>，<strong>降低了非驱动表的访问频率</strong>。N 个表 join，会产生 N-1 个 join_buffer<ul><li>join buffer 会缓存所有参与查询的列而不只是 join 列</li><li>join_buffer_size 大小可以调整</li><li>join_buffer_size 默认值 256k，最大值 5.1.22 版本之前是 4G-1，之后 64 位系统可以申请更大空间</li><li>需要开启 <strong><code>block_nested_loop</code></strong> 为 on，默认为 on。<ul><li>show variables like ‘%optimizer_switch%’</li></ul></li></ul></li></ul><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p>排序是一个成本很高的操作，从性能角度看应该尽量避免或者说尽量避免对大量数据进行排序。尽量使用索引进行排序。</p><p>非索引排序规则（<strong>filesort</strong>）：</p><ul><li>数据量小于 <strong><code>sort_buffer_size</code></strong> 则内存中快速排序；</li><li>如果 buffer 不够，先将树分块，每个独立的块使用快速排序进行排序，并将各个块的排序结果放到磁盘上，然后将各个块的排序结果合并返回最终排序结果；</li></ul><p>两次传输排序，效率较低，因为第二次读取数据更多的是随机 IO，读取数据成本较高。当排序列的总大小超过 <strong><code>max_length_for_sort_data</code></strong> 时两次排序，否则单次排序。</p><ul><li><p>第一次：将需要排序的字段读取出来，进行排序</p></li><li><p>第二次：将排好序的结果按照需要去读取数据行</p></li></ul><p>单次传输排序，只需一次顺序 IO 读取所有数据，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据</p><ul><li>第一次：读取查询所需要的所有列，进行排序，排序后直接返回需要查询的列</li></ul><h2 id="4-优化特定类型的查询"><a href="#4-优化特定类型的查询" class="headerlink" title="4. 优化特定类型的查询"></a>4. 优化特定类型的查询</h2><h3 id="4-1-优化-count-查询"><a href="#4-1-优化-count-查询" class="headerlink" title="4.1 优化 count() 查询"></a>4.1 优化 count() 查询</h3><ul><li>MySIAM 的 count 函数比较快是有条件的，只有没有 where 条件的 count(*) 才块；count(column) column 不为 null 并且无 where 条件时才快，否则全表扫描。</li><li>InnoDB count(*),count(column(not null)),count(column(may be null))，无 where 时，全表扫描，有 where 时可能走索引。</li><li>使用近似值代替，有些场景不需要完全精确的值，比如可以使用 explain 来获取近似的值。很多 OLAP 应用中，需要计算够一个列值的基数，hyperloglog 是一个计算近似值的算法。</li><li>count 需要扫描大量行才能获取精确值，本身很难优化，可以考虑增加<strong>汇总表</strong>或者增加<strong>外部缓存系统</strong>。</li></ul><h3 id="4-2-优化关联查询"><a href="#4-2-优化关联查询" class="headerlink" title="4.2 优化关联查询"></a>4.2 优化关联查询</h3><ul><li><p>确保 on 或者 using 字句中的列上有索引</p><p>创建索引时要考虑关联的顺序。关联顺序是 B、A，则只需要在 A 表上建立索引即可，没有用到的索引只会带来额外的负担。</p></li><li><p>确保 group by 和 order by 中的表达式只涉及到一个表中的列</p><p>这样 MySQL 才可能用索引来优化</p></li></ul><h3 id="4-3-优化子查询"><a href="#4-3-优化子查询" class="headerlink" title="4.3 优化子查询"></a>4.3 优化子查询</h3><p>使用关联查询代替。</p><h3 id="4-4-优化-limit-分页"><a href="#4-4-优化-limit-分页" class="headerlink" title="4.4 优化 limit 分页"></a>4.4 优化 limit 分页</h3><p>尽可能使用覆盖索引，而不是查询所有列。但是通常需求一般都是要查询很多列的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- filesort、没有覆盖索引导致每行数据都需要回表</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>;</div><div class="line"><span class="comment">-- 索引排序、覆盖索引无需回表</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film.film_id,film.description <span class="keyword">from</span> film <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>) <span class="keyword">as</span> lim <span class="keyword">using</span>(film_id);</div></pre></td></tr></table></figure><ol><li><code>select film_id from film order by title limit 50,5</code> 覆盖索引无需回表，并且使用索引排序</li><li><code>using(film_id)</code> 关联查询，主键索引</li></ol><h3 id="4-5-优化-union-查询"><a href="#4-5-优化-union-查询" class="headerlink" title="4.5 优化 union 查询"></a>4.5 优化 union 查询</h3><p>mysql 通过创建并填充临时表的方式来执行 union 查询，因此很多优化策略在 union 查询中没法很好使用。经常需要手工将 where、limit、order by 等字句下推到各个子查询中，以便优化器进行优化。</p><p>尽量使用 <code>union all</code>，否则会自动加上 distinct，这个操作代价很高。</p><h2 id="5-推荐使用自定义变量"><a href="#5-推荐使用自定义变量" class="headerlink" title="5. 推荐使用自定义变量"></a>5. 推荐使用自定义变量</h2><h3 id="5-1-自定义变量的使用"><a href="#5-1-自定义变量的使用" class="headerlink" title="5.1 自定义变量的使用"></a>5.1 自定义变量的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> @one := <span class="number">1</span>;</div><div class="line"><span class="keyword">set</span> @min_actor := (<span class="keyword">select</span> <span class="keyword">min</span>(actor_id) <span class="keyword">from</span> actor);</div><div class="line"><span class="keyword">set</span> @last_week := <span class="keyword">current_date</span> - <span class="built_in">interval</span> <span class="number">1</span> <span class="keyword">week</span>;</div><div class="line"><span class="keyword">select</span> @last_week;</div></pre></td></tr></table></figure><h3 id="5-2-自定义变量的限制"><a href="#5-2-自定义变量的限制" class="headerlink" title="5.2 自定义变量的限制"></a>5.2 自定义变量的限制</h3><ol><li>无法使用查询缓存</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者 limit 子句</li><li>自定义变量的生命周期在一个连接中有效，所以不能用来做连接之间的通信</li><li>不能显示的声明自定义变量的类型</li><li>mysql 优化器可能会将这些变量优化掉，可能导致代码不按照预想的方式运行</li><li>赋值符号<code>:=</code>优先级非常低，尽量明确使用括号</li><li>使用未定义变量不会产生任何错误</li></ol><h3 id="5-3-自定义变量的使用案例"><a href="#5-3-自定义变量的使用案例" class="headerlink" title="5.3 自定义变量的使用案例"></a>5.3 自定义变量的使用案例</h3><h4 id="优化排名语句"><a href="#优化排名语句" class="headerlink" title="优化排名语句"></a>优化排名语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 在给一个变量赋值的同时使用这个变量</span></div><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">rownum</span> <span class="keyword">from</span> actor <span class="keyword">limit</span> <span class="number">10</span>;</div></pre></td></tr></table></figure><h4 id="避免重新查询刚刚更新的数据"><a href="#避免重新查询刚刚更新的数据" class="headerlink" title="避免重新查询刚刚更新的数据"></a>避免重新查询刚刚更新的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么</span></div><div class="line"><span class="keyword">update</span> var_test <span class="keyword">set</span> updtime = <span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> @updtime := <span class="keyword">now</span>();</div><div class="line"><span class="keyword">select</span> @updtime;</div></pre></td></tr></table></figure><h4 id="使用时注意取值的顺序"><a href="#使用时注意取值的顺序" class="headerlink" title="使用时注意取值的顺序"></a>使用时注意取值的顺序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">-- 全部查询出来了？</span></div><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> first_name;</div><div class="line"></div><div class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span>+<span class="number">1</span>) &lt;= <span class="number">1</span>;</div></pre></td></tr></table></figure><h2 id="8-sql-汇总"><a href="#8-sql-汇总" class="headerlink" title="8. sql 汇总"></a>8. sql 汇总</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> film_actor;</div><div class="line"><span class="comment">-- 查看执行代价（需要扫描多少页）</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'last_query_cost'</span>;</div><div class="line"><span class="comment">-- 默认 256k，用于 blocked nested_loop join</span></div><div class="line">join_buffer_size </div><div class="line"><span class="comment">-- 开启、关闭 block_nested_loop</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%optimizer_switch%'</span>;</div><div class="line"><span class="comment">-- filesort 的内存排序缓冲区大小，超过此大小要分块排序，默认 256k。innodb(1024k=1m) myisam(8m)</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%sort_buffer_size%'</span>;</div><div class="line"><span class="comment">-- 决定排序方式，大于此值则两次传输，默认 1k</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_length_for_sort_data%'</span>;</div></pre></td></tr></table></figure><h2 id="9-问题"><a href="#9-问题" class="headerlink" title="9. 问题"></a>9. 问题</h2><ol><li><p>MySAM count 快的问题</p></li><li><p>子查询优化，到底子查询有何不妥？具体要怎么优化？</p></li><li><p>max_length_for_sort_data 默认才 1k？这个具体指什么大小？</p></li><li><p>hyperloglog  算法？</p></li><li><p>两个表关联，只需要一个表建立索引即可？</p></li><li><p>开窗函数</p></li></ol><p>CBU RBU</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;查询慢的原因&lt;/li&gt;
&lt;li&gt;优化数据访问&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化执行过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特定类型的查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;使用自定义变量&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(三)</title>
    <link href="http://yoursite.com/2020-08-10-mysql/mysql_3_%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%9B%91%E6%8E%A7.html"/>
    <id>http://yoursite.com/2020-08-10-mysql/mysql_3_索引匹配和索引优化监控.html</id>
    <published>2020-08-10T14:13:12.000Z</published>
    <updated>2020-09-13T11:28:44.509Z</updated>
    
    <content type="html"><![CDATA[<ul><li>聚簇索引和非聚簇索引</li><li>索引匹配方式</li><li>索引优化细节</li><li>索引监控</li></ul><a id="more"></a><h2 id="1-聚簇索引和非聚簇索引"><a href="#1-聚簇索引和非聚簇索引" class="headerlink" title="1. 聚簇索引和非聚簇索引"></a>1. 聚簇索引和非聚簇索引</h2><h3 id="1-1-聚簇索引"><a href="#1-1-聚簇索引" class="headerlink" title="1.1 聚簇索引"></a>1.1 聚簇索引</h3><p>不是索引类型，而是一种数据的存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。</p><p>优点：</p><ol><li>可以把相关的数据保存在一起</li><li>数据访问更快，因为索引和数据保存在同一个树中</li><li>覆盖索引的查询可以直接使用页节点中的主键值</li></ol><p>缺点：</p><ol><li>聚簇数据最大限度的提高了 IO 密集型应用的性能，但是如果数据全部放在内存中，本来就不需要太多的 IO，那么聚簇索引就没有什么优势</li><li>插入的速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式</li><li>更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置</li><li>在插入新行、主键被更新导致需要移动行的时候，可能面临<strong>页分裂</strong>问题。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于<strong>页分裂</strong>导致数据存储不连续的时候。</li></ol><h3 id="1-2-非聚簇索引"><a href="#1-2-非聚簇索引" class="headerlink" title="1.2 非聚簇索引"></a>1.2 非聚簇索引</h3><p>将数据文件和索引文件分开存放。</p><h2 id="2-索引匹配方式"><a href="#2-索引匹配方式" class="headerlink" title="2. 索引匹配方式"></a>2. 索引匹配方式</h2><h3 id="2-1-全值匹配"><a href="#2-1-全值匹配" class="headerlink" title="2.1 全值匹配"></a>2.1 全值匹配</h3><p>可以和组合索引中所有列进行匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> staffs(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">24</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span> <span class="keyword">comment</span> <span class="string">'姓名'</span>,</div><div class="line">    age <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">comment</span> <span class="string">'年龄'</span>,</div><div class="line">    pos <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span> <span class="keyword">comment</span> <span class="string">'职位'</span>,</div><div class="line">    add_time <span class="keyword">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'入职时间'</span></div><div class="line">  ) <span class="keyword">charset</span> utf8 <span class="keyword">comment</span> <span class="string">'员工记录表'</span>;</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> staffs <span class="keyword">add</span> <span class="keyword">index</span> idx_nap(<span class="keyword">name</span>, age, pos);</div><div class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> staffs;</div><div class="line"><span class="comment">-- 匹配索引</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="string">'23'</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span>;</div><div class="line"></div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: staffs</div><div class="line">   partitions: NULL</div><div class="line">         type: ref</div><div class="line">possible_keys: idx_nap</div><div class="line">          key: idx_nap</div><div class="line">      key_len: 140</div><div class="line">          ref: const,const,const</div><div class="line">         rows: 1</div><div class="line">     filtered: 100.00</div><div class="line">        Extra: NULL</div></pre></td></tr></table></figure><h3 id="2-2-匹配最左前缀"><a href="#2-2-匹配最左前缀" class="headerlink" title="2.2 匹配最左前缀"></a>2.2 匹配最左前缀</h3><p>可以只匹配的组合索引的前面几列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引 type=ref</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="string">'23'</span>;</div><div class="line"><span class="comment">-- 匹配索引 type=ref</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span>;</div><div class="line"><span class="comment">-- 全表扫描 type=all</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> age = <span class="string">'23'</span>;</div></pre></td></tr></table></figure><h3 id="2-3-匹配列前缀"><a href="#2-3-匹配列前缀" class="headerlink" title="2.3 匹配列前缀"></a>2.3 匹配列前缀</h3><p>可以匹配某一列的值的开头部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引 type=range</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'J%'</span>;</div><div class="line"><span class="comment">-- 匹配索引 type=range</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'J%'</span> <span class="keyword">and</span> age = <span class="number">23</span>;</div><div class="line"><span class="comment">-- 全表扫描 type=1all</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%y'</span>;</div></pre></td></tr></table></figure><h3 id="2-4-匹配范围值"><a href="#2-4-匹配范围值" class="headerlink" title="2.4 匹配范围值"></a>2.4 匹配范围值</h3><p>范围查询也可以匹配索引，但是会中断组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引 type=range</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span>;</div><div class="line"><span class="comment">-- age 未走索引 type=range</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span> <span class="keyword">and</span> age = <span class="number">23</span>;</div></pre></td></tr></table></figure><h3 id="2-5-精确匹配某一列并范围匹配另外一列"><a href="#2-5-精确匹配某一列并范围匹配另外一列" class="headerlink" title="2.5 精确匹配某一列并范围匹配另外一列"></a>2.5 精确匹配某一列并范围匹配另外一列</h3><p>可以查询第一列的全部和第二列的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 匹配索引 type=range</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age &gt; <span class="number">25</span>;</div></pre></td></tr></table></figure><h3 id="2-6-只访问索引查询-覆盖索引"><a href="#2-6-只访问索引查询-覆盖索引" class="headerlink" title="2.6 只访问索引查询-覆盖索引"></a>2.6 只访问索引查询-覆盖索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age,pos <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">25</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span>;</div><div class="line"></div><div class="line">*************************** 1. row ***************************</div><div class="line">           id: 1</div><div class="line">  select_type: SIMPLE</div><div class="line">        table: staffs</div><div class="line">   partitions: NULL</div><div class="line">         type: ref</div><div class="line">possible_keys: idx_nap</div><div class="line">          key: idx_nap</div><div class="line">      key_len: 140</div><div class="line">          ref: const,const,const</div><div class="line">         rows: 1</div><div class="line">     filtered: 100.00</div><div class="line">        Extra: Using index</div></pre></td></tr></table></figure><h2 id="3-索引优化细节"><a href="#3-索引优化细节" class="headerlink" title="3. 索引优化细节"></a>3. 索引优化细节</h2><h3 id="3-1-索引列不要使用表达式"><a href="#3-1-索引列不要使用表达式" class="headerlink" title="3.1 索引列不要使用表达式"></a>3.1 索引列不要使用表达式</h3><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id=<span class="number">4</span>;</div><div class="line"><span class="comment">-- possible_keys:null key:idx_actor_last_name ?</span></div><div class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id+<span class="number">1</span>=<span class="number">5</span>;</div></pre></td></tr></table></figure><h3 id="3-2-尽量使用主键查询"><a href="#3-2-尽量使用主键查询" class="headerlink" title="3.2 尽量使用主键查询"></a>3.2 尽量使用主键查询</h3><p>尽量使用主键查询，而不是其他索引，因为主键查询不会触发<strong>回表查询</strong>。</p><h3 id="3-3-使用前缀索引"><a href="#3-3-使用前缀索引" class="headerlink" title="3.3 使用前缀索引"></a>3.3 使用前缀索引</h3><p>有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性更高的索引可以让       mysql 在查找的时候过滤掉更多的行。</p><p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，对应 BLOB,TEXT,VARCHAR 类型的列，必须要使用前缀索引，因为 mysql 不允许索引这些列的完整长度，使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，通过又不能太长。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 查询不同长度前缀的选择性</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">3</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel3,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">4</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel4,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">5</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel5,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">6</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel6,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">7</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel7,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city,<span class="number">8</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sel8 </div><div class="line"><span class="keyword">from</span> citydemo;</div><div class="line"></div><div class="line"><span class="comment">-- 选择合适的长度创建前缀索引</span></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> citydemo <span class="keyword">add</span> <span class="keyword">key</span>(city(<span class="number">7</span>));</div></pre></td></tr></table></figure><p>注意：前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：<strong>mysql无法使用前缀索引做order by 和 group by</strong>。 </p><h3 id="3-4-使用索引扫描来排序"><a href="#3-4-使用索引扫描来排序" class="headerlink" title="3.4 使用索引扫描来排序"></a>3.4 使用索引扫描来排序</h3><p>mysql有两种方式可以生成有序的结果：</p><ol><li><p>通过排序操作</p></li><li><p>通过索引顺序扫描</p><p>如果 explain 出来的 type 列的值为 index，则说明mysql使用了索引扫描来做排序。extra：Using filesort 表示没有用索引排序。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--sakila数据库中rental表在rental_date,inventory_id,customer_id上有rental_date的索引</span></div><div class="line"><span class="comment">--使用rental_date索引为下面的查询做排序</span></div><div class="line"><span class="comment">-- 索引排序</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id,customer_id\G</div><div class="line"><span class="comment">-- 索引排序</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>\G</div><div class="line"><span class="comment">-- Using filesort 不符合索引匹配规则</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date&gt;<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> rental_date,inventory_id\G</div><div class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: rental</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: ALL</div><div class="line">possible_keys: rental_date</div><div class="line">          <span class="keyword">key</span>: <span class="literal">NULL</span></div><div class="line">      key_len: <span class="literal">NULL</span></div><div class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">rows</span>: <span class="number">16005</span></div><div class="line">     filtered: <span class="number">50.00</span></div><div class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; Using filesort</div><div class="line"><span class="comment">-- Using filesort 两个字段排序不一样</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>,customer_id <span class="keyword">asc</span>\G</div><div class="line"><span class="comment">-- Using filesort 使用了非索引列排序</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date=<span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id,staff_id\G</div></pre></td></tr></table></figure><h3 id="3-5-union-all-in-or-都能够使用索引，但是推荐使用in"><a href="#3-5-union-all-in-or-都能够使用索引，但是推荐使用in" class="headerlink" title="3.5 union all,in,or 都能够使用索引，但是推荐使用in"></a>3.5 union all,in,or 都能够使用索引，但是推荐使用in</h3><h3 id="3-6-范围列可以用到索引"><a href="#3-6-范围列可以用到索引" class="headerlink" title="3.6 范围列可以用到索引"></a>3.6 范围列可以用到索引</h3><p>范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列</p><h3 id="3-7-强制类型转换会全表扫描"><a href="#3-7-强制类型转换会全表扫描" class="headerlink" title="3.7 强制类型转换会全表扫描"></a>3.7 强制类型转换会全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> typecast_test(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, phone <span class="built_in">varchar</span>(<span class="number">11</span>));</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> typecast_test <span class="keyword">add</span> <span class="keyword">index</span> idx_phone(phone);</div><div class="line"><span class="comment">-- 查看表状态</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%typecast%'</span>\G</div><div class="line"><span class="keyword">alter</span> talbe typecast <span class="keyword">engine</span>=<span class="string">'innodb'</span>;</div><div class="line"><span class="comment">-- type:index</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> typecast_test <span class="keyword">where</span> phone = <span class="number">1</span>;</div><div class="line"><span class="comment">-- type:ref</span></div><div class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> typecast_test <span class="keyword">where</span> phone = <span class="string">'1'</span>;</div><div class="line"><span class="comment">-- 再加上一个 name varchar(20) 字段</span></div><div class="line"><span class="comment">-- type:all type:ref</span></div><div class="line"><span class="comment">-- 查看 mysql 数据文件位置</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">`%datadir%`</span>;</div></pre></td></tr></table></figure><p>index 和 ref 区别？</p><p>index：只是用到了覆盖索引，并没有用索引过滤数据</p><p>ref：用索引来过滤数据了</p><h3 id="3-8-更新频繁、区分度不高字段不建索引"><a href="#3-8-更新频繁、区分度不高字段不建索引" class="headerlink" title="3.8 更新频繁、区分度不高字段不建索引"></a>3.8 更新频繁、区分度不高字段不建索引</h3><p>更新可能会变更 B+ 树，可能导致页分裂、页合并等问题。</p><p>区分度不高，即使建立了索引页不能有效的过滤数据。</p><p>一般区分度在 80% 以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算。</p><h3 id="3-9-索引列不为-null"><a href="#3-9-索引列不为-null" class="headerlink" title="3.9 索引列不为 null"></a>3.9 索引列不为 null</h3><p>创建索引的列，不允许为null，否则可能会得到不符合预期的结果。</p><h3 id="3-10-表连接不超过-3-张"><a href="#3-10-表连接不超过-3-张" class="headerlink" title="3.10 表连接不超过 3 张"></a>3.10 表连接不超过 3 张</h3><p>当需要进行表连接的时候，最好不要超过三张表，因为需要 join 的字段，数据类型必须一致。</p><h3 id="3-11-尽量使用-limit"><a href="#3-11-尽量使用-limit" class="headerlink" title="3.11 尽量使用 limit"></a>3.11 尽量使用 limit</h3><p>能使用limit的时候尽量使用limit。这个索引有啥关系？</p><h3 id="3-12-单表索引建议控制在-5-个以内"><a href="#3-12-单表索引建议控制在-5-个以内" class="headerlink" title="3.12 单表索引建议控制在 5 个以内"></a>3.12 单表索引建议控制在 5 个以内</h3><h3 id="3-13-单索引字段数不允许超过-5-个"><a href="#3-13-单索引字段数不允许超过-5-个" class="headerlink" title="3.13 单索引字段数不允许超过 5 个"></a>3.13 单索引字段数不允许超过 5 个</h3><h3 id="3-14-错误的概念"><a href="#3-14-错误的概念" class="headerlink" title="3.14 错误的概念"></a>3.14 错误的概念</h3><ul><li>索引越多越好</li><li>过早优化，在不了解系统的情况下进行优化</li></ul><h2 id="4-索引监控"><a href="#4-索引监控" class="headerlink" title="4. 索引监控"></a>4. 索引监控</h2><p><code>show status like &#39;Handler_read%&#39;;</code></p><ul><li>Handler_read_first：读取索引第一个条目的次数</li><li>Handler_read_key：通过 index 获取数据的次数</li><li>Handler_read_last：读取索引最后一个条目的次数</li><li>Handler_read_next：通过索引读取下一条数据的次数</li><li>Handler_read_prev：通过索引读取上一条数据的次数</li><li>Handler_read_rnd：从固定位置读取数据的次数</li><li>Handler_read_rnd_next：从数据节点读取下一条数据的次数</li></ul><h2 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h2><p>1、插入的速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式</p><p>2、mysql无法使用前缀索引做order by 和 group by</p><p>导入大量数据时，可以先把创建索引属性关掉，先把数据文件拷贝过来，然后再打开索引。</p><p>OLAP 联机分析系统。对历史数据进行分析，以确定未来规划等。</p><p>Cardinality：基数。count(distinct city) 近似值。常用于确定关联哪一个列。</p><p>hyperloglog：<a href="https://www.jianshu.com/p/55defda6dcd2" target="_blank" rel="external">https://www.jianshu.com/p/55defda6dcd2</a> </p><p>join 内部实现方式</p><p>A join B 不一定是先读 A 再读 B，MySQL 会进行优化。可以关闭。</p><p>最好 小表 join 大表。</p><p>下面两个 sql 区别</p><p>select  * from t1 join t2 on t1.id =  t2.id and t1.name = ‘aa’</p><p>select  * from t1 join t2 on t1.id =  t2.id  where t1.name = ‘aa’</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;聚簇索引和非聚簇索引&lt;/li&gt;
&lt;li&gt;索引匹配方式&lt;/li&gt;
&lt;li&gt;索引优化细节&lt;/li&gt;
&lt;li&gt;索引监控&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(二)</title>
    <link href="http://yoursite.com/2020-08-09-mysql/mysql_2_%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%92%8C%E5%85%B3%E9%94%AE%E5%90%8D%E8%AF%8D.html"/>
    <id>http://yoursite.com/2020-08-09-mysql/mysql_2_执行计划和关键名词.html</id>
    <published>2020-08-09T14:13:12.000Z</published>
    <updated>2020-09-11T13:07:48.403Z</updated>
    
    <content type="html"><![CDATA[<ul><li>执行计划</li><li>索引的数据结构和基本概念</li></ul><a id="more"></a><h2 id="1-执行计划"><a href="#1-执行计划" class="headerlink" title="1. 执行计划"></a>1. 执行计划</h2><p>官网地址： <a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.6/en/explain-output.html</a> </p><table><thead><tr><th style="text-align:center">Column</th><th style="text-align:center">Meaning</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">The <code>SELECT</code> identifier</td></tr><tr><td style="text-align:center">select_type</td><td style="text-align:center">The <code>SELECT</code> type</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">The table for the output row</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:center">The matching partitions</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">The join type</td></tr><tr><td style="text-align:center">possible_keys</td><td style="text-align:center">The possible indexes to choose</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">The index actually chosen</td></tr><tr><td style="text-align:center">key_len</td><td style="text-align:center">The length of the chosen key</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center">The columns compared to the index</td></tr><tr><td style="text-align:center">rows</td><td style="text-align:center">Estimate of rows to be examined</td></tr><tr><td style="text-align:center">filtered</td><td style="text-align:center">Percentage of rows filtered by table condition</td></tr><tr><td style="text-align:center">extra</td><td style="text-align:center">Additional information</td></tr></tbody></table><h3 id="1-1-id"><a href="#1-1-id" class="headerlink" title="1.1 id"></a>1.1 id</h3><p>1、id 相同，从上到下，依次执行</p><p>2、id 不同，id 越大优先级越高</p><p>​    <code>explain select * from ip_test where id in (select max(id) from ip_test);</code></p><h3 id="1-2-select-type"><a href="#1-2-select-type" class="headerlink" title="1.2 select_type"></a>1.2 select_type</h3><ul><li>SIMPLE：简单查询</li><li>primary：最外层查询</li><li>union</li><li>dependent union</li><li>union result</li><li>subquery</li><li>dependent subquery</li><li>derived</li><li>uncachable subquery</li></ul><h3 id="1-3-table"><a href="#1-3-table" class="headerlink" title="1.3 table"></a>1.3 table</h3><p>对应行正在访问哪一个表，表名或者别名。</p><h3 id="1-4-type"><a href="#1-4-type" class="headerlink" title="1.4 type"></a>1.4 type</h3><p><strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> </p><p>一般情况下，<strong>得保证查询至少达到range级别，最好能达到ref</strong></p><ul><li><p>all：全表扫描</p></li><li><p>index：全索引扫描。查询时覆盖索引；使用了索引进行排序。其实也是全表扫描，只是可能用到覆盖索引。</p></li><li><p>range：利用索引查询的时候限制了范围，避免了 index 的全索引扫描。<code>=,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;=, is null,between,like,in()</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</div></pre></td></tr></table></figure></li><li><p>index_subquery：利用索引来关联子查询，不再扫描全表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</div></pre></td></tr></table></figure></li><li><p>unique_subquery：和 index_subquery 类似，使用的是唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</div></pre></td></tr></table></figure></li><li><p>index_merge：多个索引组合使用</p></li><li><p>ref_or_null：既需要关联条件，也需要 null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table</div><div class="line"><span class="keyword">WHERE</span> key_column=expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></li><li><p>ref：使用了<strong>非唯一索引</strong>进行数据的查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</div></pre></td></tr></table></figure></li><li><p>eq_ref：使用唯一索引进行数据查找（primary kye 或者 unique not null index）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</div><div class="line"><span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</div><div class="line"><span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</div><div class="line"><span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</div></pre></td></tr></table></figure></li><li><p>const：这个表至多有一个匹配行（主键索引或者唯一索引加了等于条件）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</div><div class="line"><span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</div></pre></td></tr></table></figure></li><li><p>system：表只有一行记录</p></li></ul><p>all -&gt; index -&gt; range -&gt; ref -&gt;const</p><h3 id="1-5-possible-keys"><a href="#1-5-possible-keys" class="headerlink" title="1.5 possible_keys"></a>1.5 possible_keys</h3><p>显示可能应用在这张表中的索引，一个或多个；查询涉及到的字段上若存在索引，则该索引将被列出，但是不一定被查询实际使用。</p><h3 id="1-6-key"><a href="#1-6-key" class="headerlink" title="1.6 key"></a>1.6 key</h3><p>实际使用的索引，如果为 null，则没有使用索引。</p><h3 id="1-7-key-len"><a href="#1-7-key-len" class="headerlink" title="1.7 key_len"></a>1.7 key_len</h3><p>索引中使用的字节数，在不损失精度的情况下，<strong>长度越短越好</strong></p><h3 id="1-8-ref"><a href="#1-8-ref" class="headerlink" title="1.8 ref"></a>1.8 ref</h3><p>显示索引的哪一列被使用了？</p><h3 id="1-9-rows"><a href="#1-9-rows" class="headerlink" title="1.9 rows"></a>1.9 rows</h3><p>大致估算找出所需记录需要读取的行数。不影响结果的情况下，越少越好。</p><h3 id="1-10-extra"><a href="#1-10-extra" class="headerlink" title="1.10 extra"></a>1.10 extra</h3><ul><li>using filesort：无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</li><li>using temporary：建立临时表来保存中间结果，查询完成之后把临时表删除</li><li>using index：当前查询走<strong>覆盖索引</strong>，不用回表。</li><li>using where：使用 where 进行条件过滤</li></ul><h2 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h2><h3 id="2-1-索引优点"><a href="#2-1-索引优点" class="headerlink" title="2.1 索引优点"></a>2.1 索引优点</h3><ol><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机 IO 变成顺序 IO？</li></ol><h3 id="2-2-索引的用处"><a href="#2-2-索引的用处" class="headerlink" title="2.2 索引的用处"></a>2.2 索引的用处</h3><ol><li>快速查找匹配 where 子句的行</li><li>如果可以在多个索引中进行选择，会自动选择扫描最少行的索引</li><li>如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行</li><li>当有表连接的时候，从其他表检索行数据？</li><li>查找特定索引列的 min 或 max 值</li><li>如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组？</li><li>在某些情况下，可以优化查询以检索值而无需查询数据行。覆盖索引。</li></ol><h3 id="2-3-索引的分类"><a href="#2-3-索引的分类" class="headerlink" title="2.3 索引的分类"></a>2.3 索引的分类</h3><ol><li><p>主键索引</p><p>如果没有特殊需求，尽量选择自增主键(自增锁实现)。因为自增主键，插入数据维护索引时，一直往后添加元素就行，但是如果不是自增，可能会在中间插入元素，如果要插入的位置所在的页刚好满了，就会产生<strong>页分裂</strong>问题，一来可能浪费空间，二来会产生不必要的磁盘 I/O。</p></li><li><p>唯一索引：索引列的所有值都只能出现一次，即必须唯一，值可以为空。不需要回表？</p></li><li><p>普通索引：不走覆盖索引(两遍遍历B+树优化为一次)的话会回表。</p></li><li><p>全文索引：倒排索引。索引类型为 fulltext。全文索引可以在 varchar、char、text 类型的列上创建。</p></li><li><p>组合索引（不是一种类型）：最左匹配</p><p>注意索引的顺序会影响查询，同时需要考虑如何更好的满足排序和分组。</p><p>使用范围查询，可以走索引，但是范围查询后面的字段索引失效。</p><p>name,age、age 和 age,name、name 好。结合工作来说明。</p></li></ol><h3 id="2-4-索引采用的数据结构"><a href="#2-4-索引采用的数据结构" class="headerlink" title="2.4 索引采用的数据结构"></a>2.4 索引采用的数据结构</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><ul><li>基于哈希表实现的索引，只有精确匹配索引所有列的查询才有效果</li><li>在 MySQL 中，只有 memory 的存储引擎显示支持哈希索引</li><li>哈希索引自身只需存储对应的 hash 值，所以所有结构十分紧凑，所以查找速度非常快</li></ul><p>哈希索引的限制：</p><ol><li><strong>无法覆盖索引：</strong>哈希索引中只包含哈希值和行指针，不存储字段值，索引肯定会回表，无法覆盖索引。</li><li><strong>无法排序：</strong>哈希索引数据不是按照索引值顺序存储的，无法进行排序</li><li><strong>无法部分列匹配查找：</strong>哈希索引不支持部分列匹配查找，哈希索引使用索引列的全部内容来计算哈希值</li><li><strong>无法范围查询：</strong>哈希索引支持等值比较查询。不支持任何范围查询</li><li><strong>哈希冲突问题：</strong>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有行指针，逐行进行比较，直到找到所有符合条件的行</li><li><strong>哈希冲突问题：</strong>哈希冲突比较多的话，维护的成本也会很高，因为链表很长。</li></ol><p><strong>如何避免 hash 冲突？</strong></p><ul><li>扰动函数</li><li>不要直接用 %（取模）</li></ul><h4 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+ 树"></a>2. B+ 树</h4><p>二叉树</p><ul><li>不平衡</li><li>节点深</li></ul><p>二叉搜索树</p><p>平衡二叉树(AVL)</p><ul><li>真正意义上的平衡树，最高子树和最低子树高度之差不能超过 1</li><li><p>所以插入时会进行一次至多次旋转，严重影响性能</p></li><li><p>查询速度块，修改、删除慢</p></li></ul><p>红黑树</p><ul><li>基于 AVL 树的一个升级，损失了部分查询的性能，来提升插入的性能</li><li>最低子树跟最高子树只差小于 2 倍即可</li><li><p>在插入时旋转次数变少而且加入了变色的特性，来满足插入和查询性能的平衡</p></li><li><p>平衡修改、删除效率</p></li></ul><p>这些二叉树，最终都会由<strong>于节点过深导致 IO 次数过多</strong>，影响数据读取的效率，所以不合适。</p><p>B 树（多叉树）：</p><ol><li><p>所有键值分布在整棵树中</p></li><li><p>搜索有可能在非叶子节点结束</p></li><li><p>每个节点最多拥有 m 个子树</p></li><li><p>根节点至少有 2 个子树   </p></li><li><p>分支节点至少拥有 m/2 棵子树(除掉根节点和叶子节点都是分支节点)</p></li><li><p>所有<strong>叶子节点都在同一层</strong>，每个节点最多可以有 m-1 个 key，并且以<strong>升序</strong>排列</p><p>每个节点都有 key，同时和包含 data，而每个页存储的空间是有限的，如果 data 比较大的话，会导致每个节点存储的 key 数量变小。大量空间用来存 data 了，三层的 B 数只能存 4096 kb 数据。</p><p><img src="../../images/mysql/2/B树.png" alt=""></p></li></ol><p><strong>B+ 树</strong>：</p><p>对 B 树进行优化</p><ol><li>每个节点可以包含更多的元素，这样可以降低树的高度；将数据的范围变为多个区间，区间越多，数据检索越快</li><li>非叶子节点存储 key，叶子节点存储 key 和数据</li><li>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高</li></ol><p><img src="../../images/mysql/2/B+树.png" alt=""></p><p>B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点之间是一种链式环结构。因此可以对 B+ 树进行两种查询运算：</p><ol><li>对于主键的范围查找和分页查找；</li><li>从根节点开始，进行随机查找。</li></ol><p>InnoDB 是通过 B+ 树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键。</p><p><img src="../../images/mysql/2/InnoDB叶子节点直接放置数据.png" alt=""></p><p><strong>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后通过主键索引找到对应的记录，叫做回表。</strong></p><p><img src="../../images/mysql/2/普通字段索引.png" alt=""></p><p>MyISAM 索引文件和数据文件分开存放（非聚簇索引）。</p><h3 id="2-5-索引相关名词"><a href="#2-5-索引相关名词" class="headerlink" title="2.5 索引相关名词"></a>2.5 索引相关名词</h3><h4 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h4><p>普通索引叶子节点没有存行记录，存储的是主键。所以需要回去再找<strong>主键索引树</strong>，这就是回表。</p><h4 id="2-覆盖索引"><a href="#2-覆盖索引" class="headerlink" title="2. 覆盖索引"></a>2. 覆盖索引</h4><p>基本介绍：</p><ol><li><p>当查询的列在叶子节点已经有了，就不需要再查询一遍主键索引树了，这就是覆盖索引。</p></li><li><p>不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值。</p></li><li><p>不同的存储引擎实现覆盖索引的方式不同，Innodb 是叶子节点存了行数据，MyISam 叶子节点存的是内存地址。</p></li><li><p>不是所有的搜索引擎都支持覆盖索引，memory 不支持覆盖索引。</p></li></ol><p>优势：</p><ol><li>索引条目通常远小于数据行大小，覆盖索引只需要读取索引，所以可以极大减少数据的访问量，极大的减少 IO 访问。</li><li>一些存储引擎比如 MYISAM 在内存中只缓存索引，数组依赖操作系统来缓存，如果不走覆盖索引，访问数据需要调用系统调用，可能会导致严重性能问题。</li><li>InnoDB 为聚簇索引，覆盖索引对 InnoDB 的支持特别有用</li></ol><p>实际操作：</p><ol><li>explain 的 extra 的值为 <code>using index</code> 时表示使用了覆盖索引。</li></ol><h4 id="3-最左匹配原则"><a href="#3-最左匹配原则" class="headerlink" title="3. 最左匹配原则"></a>3. 最左匹配原则</h4><p>根据 name、age 建立组合索引。<code>where name = ? and age = ?</code> 可以匹配索引，但是 <code>where age = ？</code> 不会走索引。可以在建立组合索引时，name、age 互换。如果单独建立 name、age 两个索引，会涉及到索引合并优化。</p><h4 id="4-索引下推-index-condition-pushdown"><a href="#4-索引下推-index-condition-pushdown" class="headerlink" title="4. 索引下推( index condition pushdown  )"></a>4. 索引下推( index condition pushdown  )</h4><p>过滤二级索引的同时，<strong>判断是否可以先进行 where 条件过滤再进行索引回表查询，如果条件中包含了组合索引中的列，就可以索引下推</strong>，也就是说提前执行 where 的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。 和 sql 查询的<strong>谓词下推</strong>类似， <strong>始终将过滤表达式尽可能移至靠近数据源的位置。</strong></p><p>执行计划 extra 提示 Using index condition</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 关闭索引下推</div><div class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'index_condition_pushdown=off'</span>;</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> icp_test(</div><div class="line">  <span class="keyword">id</span> <span class="built_in">int</span>,</div><div class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</div><div class="line">  age <span class="built_in">int</span>(<span class="number">2</span>),</div><div class="line">  address <span class="built_in">varchar</span>(<span class="number">40</span>)  </div><div class="line">) <span class="keyword">engine</span> <span class="keyword">innodb</span>;</div><div class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_name_age(<span class="keyword">name</span>, age);</div><div class="line"><span class="keyword">explain</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> icp_test <span class="keyword">where</span>  <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'陈%'</span> <span class="keyword">and</span> age=<span class="number">20</span>;</div></pre></td></tr></table></figure><p> 1、innodb 引擎的表，索引下推只能用于二级索引（除了聚簇索引之外的索引都是二级索引(辅助索引)，每一个二级的记录中除了索引列的值之外，还包含主健值。通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键/聚簇索引找到相应的数据块。）。innodb的主键索引(聚簇索引)树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。<br>2、索引下推一般可用于所求查询字段（select列）不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。 </p><h2 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h2><p>1、一、二、三四范式？</p><p>2、另一个从父表冗余数据到子表的理由是<strong>排序</strong>的需要？索引排序？</p><p>3、通用的主键策略？：减少需要编写的源码数量？减少系统的总体拥有成本？</p><p>4、索引将随机 IO 变成顺序 IO？</p><p>5、当有表连接的时候，从其他表检索行数据？</p><p>6、如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组？</p><p>7、InnoDB 为聚簇索引，覆盖索引对 InnoDB 的支持特别有用？</p><p>8、B+树、哈希表</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;执行计划&lt;/li&gt;
&lt;li&gt;索引的数据结构和基本概念&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(一)</title>
    <link href="http://yoursite.com/2020-08-05-mysql/mysql_1_%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96.html"/>
    <id>http://yoursite.com/2020-08-05-mysql/mysql_1_性能监控和数据类型优化.html</id>
    <published>2020-08-05T14:13:12.000Z</published>
    <updated>2020-09-13T11:34:55.010Z</updated>
    
    <content type="html"><![CDATA[<ul><li>MySQL 基本架构</li><li>性能监控</li><li>数据类型的优化</li></ul><a id="more"></a><h2 id="0-MySQL-的基本架构"><a href="#0-MySQL-的基本架构" class="headerlink" title="0. MySQL 的基本架构"></a>0. MySQL 的基本架构</h2><p><img src="../../images/mysql/1/mysql架构.png" alt=""></p><h2 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h2><h3 id="1-1-profiles、profile"><a href="#1-1-profiles、profile" class="headerlink" title="1.1 profiles、profile"></a>1.1 profiles、profile</h3><p>查看 sql 消耗的时间、cpu、io 等信息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 设置后，show profiles 才有显示</div><div class="line"><span class="keyword">set</span> profiling = <span class="number">1</span>;</div><div class="line"># 业务查询语句</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mylock;</div><div class="line"># 查看 sql 查询总耗时</div><div class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</div><div class="line"># 查看详细耗时</div><div class="line"><span class="keyword">show</span> profile;</div><div class="line"># 查看指定 sql</div><div class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">2</span>;</div><div class="line"># cpu 信息也展示出来</div><div class="line"><span class="keyword">show</span> profile cpu;</div><div class="line"># 展示所有</div><div class="line"><span class="keyword">show</span> profile all;</div><div class="line"># 官网地址：SQL Statements -&gt; Database Administration Statements -&gt; SHOW Statements</div></pre></td></tr></table></figure><p>问题：java 执行的 sql 好像监控不到</p><h3 id="1-2-performance-schema"><a href="#1-2-performance-schema" class="headerlink" title="1.2 performance_schema"></a>1.2 performance_schema</h3><p>数据不会持久化。每次重启 mysql 服务后会清空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 查看是否开启</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'performance_schema'</span>;</div><div class="line"></div><div class="line"># 语句事件记录表。当前语句、历史语句、聚合信息</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%statement%'</span>;</div><div class="line"></div><div class="line"># 等待事件记录表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%wait%'</span>;</div><div class="line"></div><div class="line"># 事务事件记录表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%transaction%'</span>;</div><div class="line"></div><div class="line"># 监控文件系统层调用</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%file%'</span>;</div><div class="line"></div><div class="line"># 配置表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%setup%'</span>;</div><div class="line"></div><div class="line"># 有些 instruments 和 consumers 默认没有启动，需要手动开启</div><div class="line">## 比如，开启等待事件监控功能</div><div class="line"><span class="keyword">UPDATE</span> setup_instruments <span class="keyword">SET</span> ENABLED = <span class="string">'YES'</span>, TIMED = <span class="string">'YES'</span><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'wait%'</span>;</div><div class="line"><span class="keyword">UPDATE</span> setup_consumers <span class="keyword">SET</span> ENABLED = <span class="string">'YES'</span><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%wait%'</span>;</div><div class="line"></div><div class="line"># 查看相关的一些系统变量</div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%performance_schema%'</span>;</div></pre></td></tr></table></figure><h3 id="1-3-show-processlist"><a href="#1-3-show-processlist" class="headerlink" title="1.3 show processlist"></a>1.3 show processlist</h3><p>查看连接的线程个数，观察是否有大量线程处于不正常的状态或者其他不正常的特征。</p><h2 id="2-schema-与数据类型优化"><a href="#2-schema-与数据类型优化" class="headerlink" title="2. schema 与数据类型优化"></a>2. schema 与数据类型优化</h2><h3 id="2-1-数据类型的优化"><a href="#2-1-数据类型的优化" class="headerlink" title="2.1 数据类型的优化"></a>2.1 数据类型的优化</h3><h4 id="长度越小越好"><a href="#长度越小越好" class="headerlink" title="长度越小越好"></a>长度越小越好</h4><p>尽量使用可以正确存储数据的最小数据类型，越小的数据类型占用更少的磁盘空间、内存和 CPU 缓存，并且处理时需要的 CPU 周期更少。</p><h4 id="类型越简单越好"><a href="#类型越简单越好" class="headerlink" title="类型越简单越好"></a>类型越简单越好</h4><ol><li>整型比字符操作代价更低</li><li>使用自建类型来存储日期和时间，而不是字符串</li><li>使用整型来存储 IP 地址，而不是字符串</li></ol><h4 id="尽量避免-null"><a href="#尽量避免-null" class="headerlink" title="尽量避免 null"></a>尽量避免 null</h4><p>​    null 列对 mysql 来说很难优化，因为可为 null 的列使得索引、索引统计和值比较都更加复杂。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li><p>整数类型： TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。  尽量使用满足需求的最小数据类型 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 1 2 3 4 8 = 18 字节</span></div><div class="line"><span class="comment">-- 长度没有限制作用</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> int_test(a tinyint(<span class="number">2</span>), b <span class="built_in">smallint</span>(<span class="number">2</span>), c mediumint, d <span class="built_in">int</span>, e <span class="built_in">bigint</span>);</div><div class="line">tinyint:-128(10000000)~127(01111111)</div></pre></td></tr></table></figure></li><li><p>字符和字符串类型</p><ul><li>char：长度固定；最长 255 字符；适用于身份证号、手机号、摘要算法等定长字符串。字符和字节的关系：gbk-1个字符2个字节；utf8-1个字符3个字节</li><li>varchar：长度可变；可以设置最大长度；最大空间 65535 个字节，因为 MySQL 要求一个行定义长度不能超多 65535 字节（不包含 text、blob）；适用于长度变化频繁、多字节字符（汉字、特殊字符）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- char、varchar 指定长度后，不能超过该长度</span></div><div class="line"><span class="comment">-- char 不指定长度，默认为 1</span></div><div class="line"><span class="comment">-- varchar 必须指定长度，否则建表失败</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> char_test(a <span class="built_in">char</span>(<span class="number">4</span>), b <span class="built_in">char</span>, c <span class="built_in">varchar</span>(<span class="number">4</span>), d <span class="built_in">varchar</span>(<span class="number">20</span>));</div></pre></td></tr></table></figure><ul><li>varchar 到底可以定义多长？</li></ul><p>最大 65535 字节，字符集为 utf8，每个字符 3 字节，所以最大 21845 字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table varchar_test(name varchar(65536));</div><div class="line">ERROR 1074 (42000): Column length too big for column 'name' (max = 21845); <span class="keyword">use</span> <span class="built_in">BLOB</span> <span class="keyword">or</span> <span class="built_in">TEXT</span> instead</div><div class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%char%'</span>;</div><div class="line">+<span class="comment">--------------------------+--------------------------------------------------+</span></div><div class="line">| Variable_name            | Value                                            |</div><div class="line">+<span class="comment">--------------------------+--------------------------------------------------+</span></div><div class="line">| character_set_client     | utf8                    |</div><div class="line">| character_set_connection | utf8                    |</div><div class="line">| character_set_database   | utf8                    |</div><div class="line">| character_set_filesystem | binary                  |</div><div class="line">| character_set_results    | utf8                    |</div><div class="line">| character_set_server     | utf8                    |</div><div class="line">| character_set_system     | utf8</div><div class="line">+<span class="comment">--------------------------+--------------------------------------------------+</span></div></pre></td></tr></table></figure></li><li><p>datetime 和 timestamp</p><ul><li>datetime：占用 8 个字节；存储方式与时区无关；时间范围（100000101-99991231）精确到毫秒；</li><li>timestamp：占用 4 个字节；存储方式依赖数据库时区，时区变化，数据会变；时间范围（19700101-20380119）；精确到毫秒；更适合于 跨时区的业务。</li></ul></li><li><p>date：占用 3 个字节；时间范围（10000101-99991231）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> date_test(a datetime, a1 datetime(<span class="number">6</span>),b <span class="keyword">timestamp</span>, b1 <span class="keyword">timestamp</span>(<span class="number">3</span>) <span class="literal">null</span> <span class="keyword">default</span> <span class="literal">null</span>,c <span class="built_in">date</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> date_test <span class="keyword">values</span>(<span class="keyword">now</span>(),<span class="keyword">now</span>(<span class="number">6</span>),<span class="keyword">now</span>(),<span class="string">'20200808121212.123'</span>,<span class="keyword">now</span>());</div><div class="line"></div><div class="line">mysql&gt; select * from date_test\G</div><div class="line">*************************** 1. row ***************************</div><div class="line"> a: 2020-08-29 21:45:55</div><div class="line">a1: 2020-08-29 21:45:55.862122</div><div class="line"> b: 2020-08-29 21:45:55</div><div class="line">b1: 2020-08-08 12:12:12.123</div><div class="line"> c: 2020-08-29</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">- 使用枚举代替字符串类型</div><div class="line"></div><div class="line">  - mysql 会根据枚举值把数据压缩到一个或两个字节中，内部会将每个值在列表中的位置保存为**整数**。并且在表的 `.frm` 文件中保存“数字-字符串”映射关系的查找表。</div><div class="line"></div><div class="line">  ```sql</div><div class="line">  CREATE TABLE `enum_test`  (</div><div class="line">    `id` int(6) NOT NULL AUTO_INCREMENT,</div><div class="line">    `e` enum(&apos;男&apos;,&apos;女&apos;) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</div><div class="line">    PRIMARY KEY (`id`) USING BTREE</div><div class="line">  );</div><div class="line">  </div><div class="line">  INSERT INTO `enum_test`(e) VALUES(1),(2);</div><div class="line">  INSERT INTO `enum_test`(e) VALUES(&apos;男&apos;),(&apos;女&apos;);</div><div class="line">  INSERT INTO `enum_test`(e) VALUES(1),(&apos;1&apos;),(&apos;女&apos;);</div><div class="line">  </div><div class="line">  select * from enum_test;</div><div class="line">  select e+1 from enum_test;</div></pre></td></tr></table></figure><ul><li>使用 <code>int(32) unsigned</code> 来存 ip 地址，因为 ip 地址本来就是 32 位<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> ip_test(host <span class="built_in">int</span>(<span class="number">32</span>) <span class="keyword">unsigned</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ip_test <span class="keyword">values</span>(<span class="keyword">inet_aton</span>(<span class="string">'192.168.238.68'</span>));</div><div class="line"><span class="keyword">select</span> <span class="keyword">inet_ntoa</span>(host) <span class="keyword">from</span> ip_test;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-合理使用范式和反范式"><a href="#2-2-合理使用范式和反范式" class="headerlink" title="2.2 合理使用范式和反范式"></a>2.2 合理使用范式和反范式</h3><h4 id="范式优点"><a href="#范式优点" class="headerlink" title="范式优点"></a>范式优点</h4><ul><li>更新通常比反范式快</li><li>很少或者没有冗余数据</li><li>范式化的数据比较小，可以放在内存中，操作比较快</li></ul><h4 id="范式缺点"><a href="#范式缺点" class="headerlink" title="范式缺点"></a>范式缺点</h4><ul><li>通常需要进行关联</li></ul><h4 id="反范式优点"><a href="#反范式优点" class="headerlink" title="反范式优点"></a>反范式优点</h4><ul><li>所有的数据都在同一张表中，可以避免关联</li><li>可以设计有效的索引</li><li>空间换时间的思想</li></ul><h4 id="反范式缺点"><a href="#反范式缺点" class="headerlink" title="反范式缺点"></a>反范式缺点</h4><ul><li>数据冗余较多</li><li>删除数据时会造成表有些有用的信息丢失，完全反范式所有内容存在一张表，删除用户消息导致用户信息都丢了，所以一般混合使用，user 表和 message 表都存用户类型字段。</li><li>需要确保数据的一致性不会被破坏，确保更新时冗余字段也被更新</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>在企业上很难做到严格意义上的范式或者反范式，一般混合使用。</p><ul><li>比如用户表和用户信息表均冗余用户类型字段。这样既方便了消息的查询也避免了没有消息时，用户类型信息的丢失</li><li>另一个从父表冗余数据到子表的理由是<strong>排序</strong>的需要</li><li><strong>缓存衍生值</strong>也是有用的。比如维护一个 num_messages 字段到 user 表，记录每个用户发了多少消息。或者说订单表存一个订单价格字段，而不用每次从订单商品中去计算价格</li></ul></li></ul><h3 id="2-3-主键的选择"><a href="#2-3-主键的选择" class="headerlink" title="2.3 主键的选择"></a>2.3 主键的选择</h3><ol><li>代理主键：与业务无关，无意义的数字序列</li><li>自然主键：事物属性中的自然唯一标识</li></ol><p>推荐使用代理主键</p><ul><li>不与业务耦合，更容易维护</li><li>通用的主键策略：减少需要编写的源码数量，减少系统的总体拥有成本</li></ul><h3 id="2-4-字符集的选择"><a href="#2-4-字符集的选择" class="headerlink" title="2.4 字符集的选择"></a>2.4 字符集的选择</h3><p>字符集直接决定了数据在 MySQL 中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少 IO 操作次数。 </p><ol><li>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间</li><li>如果可以确定不需要存放多种语言，就没必要使用 utf8 或者其他 unicode 字符类型，造成大量的存储空间浪费</li><li>MySQL 的字符集类型可以精确到字段</li></ol><h3 id="2-5-存储引擎的选择"><a href="#2-5-存储引擎的选择" class="headerlink" title="2.5 存储引擎的选择"></a>2.5 存储引擎的选择</h3><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td></tr><tr><td>支持事务</td><td>否</td><td>是</td></tr><tr><td>支持表锁</td><td>是</td><td>是</td></tr><tr><td>支持行锁</td><td>否</td><td>是</td></tr><tr><td>支持外键</td><td>否</td><td>是</td></tr><tr><td>支持全文索引</td><td>是</td><td>是（5.6之后）</td></tr><tr><td>适合操作类型</td><td>大量 select</td><td>大量 insert、delete、update</td></tr></tbody></table><h3 id="2-6-适当的数据冗余"><a href="#2-6-适当的数据冗余" class="headerlink" title="2.6 适当的数据冗余"></a>2.6 适当的数据冗余</h3><p>即适当的反范式。</p><ul><li>被频繁引用，且只能通过 join 2张（或者更多）大表2的方式才能得到的独立小字段。</li><li>这样的场景由于每次 join 仅仅只是为了取得某个小字段的值，join 到的记录又大，会造成大量不必要的 IO，完全可以通过空间换时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</li></ul><h3 id="2-7-适当的拆分"><a href="#2-7-适当的拆分" class="headerlink" title="2.7 适当的拆分"></a>2.7 适当的拆分</h3><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其<strong>拆分到另外的独立表</strong>中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是<strong>每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</strong> </p><h2 id="3-二进制"><a href="#3-二进制" class="headerlink" title="3. 二进制"></a>3. 二进制</h2><p>1、byte 占用一个字节， 8 位，对于计算机来说表数范围为 0000 0000 ~ 1111 1111</p><p>2、最高位表示符号位</p><p>3、计算机用补码表数</p><p>4、正数和 0 的补码 = 源码</p><p>5、负数的补码 = 其对应正数按位取反 + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binVal4 =<span class="number">0B10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>  <span class="comment">// 的值为？</span></div><div class="line"><span class="comment">// 1. int 类型 32 位，高位为 1，所以是个负数</span></div><div class="line"><span class="comment">// 2. 该负数对应正数按位取反的值 = 0B10000000 00000000 00000000 00000011 - 1</span></div><div class="line">    = <span class="number">0B10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000010</span></div><div class="line"><span class="comment">// 3. 该负数对应正数 = OB01111111 11111111 11111111 11111101      </span></div><div class="line"><span class="comment">// 4. 该负数 = OB11111111 11111111 11111111 11111101</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// byte 类型，-127 的补码？</span></div><div class="line"><span class="comment">// 1. 127 的源码 = 0111 1111</span></div><div class="line"><span class="comment">// 2. 127 的源码按位取反 = 1000 0000</span></div><div class="line"><span class="comment">// 3. 127 的源码按位取反 + 1 = 1000 0001</span></div><div class="line"></div><div class="line"><span class="comment">// byte 类型，-128 的补码？</span></div><div class="line"><span class="comment">// 1. 128 的源码 = 1000 0000</span></div><div class="line"><span class="comment">// 2. 128 的源码按位取反 = 0111 1111</span></div><div class="line"><span class="comment">// 3. 128 的源码按位取反 + 1 = 1000 0000</span></div><div class="line"></div><div class="line"><span class="comment">// byte 类型，-129 的补码？</span></div><div class="line"><span class="comment">// 1. 129 的源码 = 1000 0001</span></div><div class="line"><span class="comment">// 2. 129 的源码按位取反 = 0111 1110</span></div><div class="line"><span class="comment">// 3. 129 的源码按位取反 + 1 = 0111 1111</span></div></pre></td></tr></table></figure><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h2><p>1、说说 MySQL 基本架构</p><p>2、如何监控数据库性能？</p><p>3、MySQL 优化之数据类型优化有哪些点？</p><p>​    为何要尽量避免 null？</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;MySQL 基本架构&lt;/li&gt;
&lt;li&gt;性能监控&lt;/li&gt;
&lt;li&gt;数据类型的优化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
</feed>
