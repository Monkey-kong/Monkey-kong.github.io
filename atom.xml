<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-09T14:25:17.881Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>monkey-kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql 调优(二)</title>
    <link href="http://yoursite.com/2020-08-09-mysql/mysql_2.html"/>
    <id>http://yoursite.com/2020-08-09-mysql/mysql_2.html</id>
    <published>2020-08-09T14:13:12.000Z</published>
    <updated>2020-08-09T14:25:17.881Z</updated>
    
    <content type="html"><![CDATA[<ul><li>范式、主键、字符集、存储引擎、拆分的选择</li><li>执行计划</li><li>索引的数据结构和基本概念</li></ul><a id="more"></a><h2 id="1-schema-与数据类型优化"><a href="#1-schema-与数据类型优化" class="headerlink" title="1. schema 与数据类型优化"></a>1. schema 与数据类型优化</h2><h3 id="1-1-何理使用范式和反范式"><a href="#1-1-何理使用范式和反范式" class="headerlink" title="1.1 何理使用范式和反范式"></a>1.1 何理使用范式和反范式</h3><h4 id="范式优点"><a href="#范式优点" class="headerlink" title="范式优点"></a>范式优点</h4><ul><li>更新通常比反范式快</li><li>很少胡哦和没有冗余数据</li><li>范式化的数据比较小，可以放在内存中，操作比较快</li></ul><h4 id="范式缺点"><a href="#范式缺点" class="headerlink" title="范式缺点"></a>范式缺点</h4><ul><li>通常需要进行关联</li></ul><h4 id="反范式优点"><a href="#反范式优点" class="headerlink" title="反范式优点"></a>反范式优点</h4><ul><li>所有的数据都在同一张表中，可以避免关联</li><li>可以设计有效的索引</li><li>空间换时间的思想</li></ul><h4 id="反范式缺点"><a href="#反范式缺点" class="headerlink" title="反范式缺点"></a>反范式缺点</h4><ul><li>数据冗余较多</li><li>删除数据时会造成表有些有用的信息丢失</li><li>需要确保数据的一致性不会被破坏，确保更新时冗余字段也被更新</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>在企业上很难做到严格意义上的范式或者反范式，一般混合使用。</p><ul><li>比如用户表和用户信息表均冗余用户类型字段。这样既方便了消息的查询也避免了没有消息时，用户类型信息的丢失</li><li>另一个从父表冗余数据到子表的理由是<strong>排序</strong>的需要</li><li>缓存衍生值也是有用的。比如维护一个 num_messages 字段到 user 表，记录每个用户发了多少消息。或者说订单表存一个订单价格字段，而不用每次从订单商品中去计算价格</li></ul></li></ul><h3 id="1-2-主键的选择"><a href="#1-2-主键的选择" class="headerlink" title="1.2 主键的选择"></a>1.2 主键的选择</h3><ol><li>代理主键</li><li>自然主键</li></ol><p>推荐使用代理主键</p><ul><li>不与业务耦合，更容易维护</li><li>通用的主键策略？</li></ul><h3 id="1-3-字符集的选择"><a href="#1-3-字符集的选择" class="headerlink" title="1.3 字符集的选择"></a>1.3 字符集的选择</h3><p>字符集直接决定了数据在 MySQL 中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少 IO 操作次数。 </p><ol><li>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间</li><li>如果可以确定不需要存放多种语言，就没必要使用 utf8 或者其他 unicode 字符类型，造成大量的存储空间浪费</li><li>MySQL 的字符集类型可以精确到字段</li></ol><h3 id="1-4-存储引擎的选择"><a href="#1-4-存储引擎的选择" class="headerlink" title="1.4 存储引擎的选择"></a>1.4 存储引擎的选择</h3><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td><td></td><td></td><td></td></tr><tr><td>支持事务</td><td>否</td><td>是</td><td></td><td></td><td></td></tr><tr><td>支持表锁</td><td>是</td><td>是</td><td></td><td></td><td></td></tr><tr><td>支持行锁</td><td>否</td><td>是</td><td></td><td></td><td></td></tr><tr><td>支持外键</td><td>否</td><td>是</td><td></td><td></td><td></td></tr><tr><td>支持全文索引</td><td>是</td><td>是（5.6之后）</td><td></td><td></td><td></td></tr><tr><td>适合操作类型</td><td>大量 select</td><td>大量 insert、delete、update</td><td></td><td></td></tr></tbody></table><h3 id="1-5-适当的数据冗余"><a href="#1-5-适当的数据冗余" class="headerlink" title="1.5 适当的数据冗余"></a>1.5 适当的数据冗余</h3><p>即适当的反范式。</p><h3 id="1-6-适当的拆分"><a href="#1-6-适当的拆分" class="headerlink" title="1.6 适当的拆分"></a>1.6 适当的拆分</h3><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其<strong>拆分到另外的独立表</strong>中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。 </p><h2 id="2-执行计划"><a href="#2-执行计划" class="headerlink" title="2. 执行计划"></a>2. 执行计划</h2><p>官网地址： <a href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.6/en/explain-output.html</a> </p><table><thead><tr><th style="text-align:center">Column</th><th style="text-align:center">Meaning</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">The <code>SELECT</code> identifier</td></tr><tr><td style="text-align:center">select_type</td><td style="text-align:center">The <code>SELECT</code> type</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">The table for the output row</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:center">The matching partitions</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">The join type</td></tr><tr><td style="text-align:center">possible_keys</td><td style="text-align:center">The possible indexes to choose</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">The index actually chosen</td></tr><tr><td style="text-align:center">key_len</td><td style="text-align:center">The length of the chosen key</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center">The columns compared to the index</td></tr><tr><td style="text-align:center">rows</td><td style="text-align:center">Estimate of rows to be examined</td></tr><tr><td style="text-align:center">filtered</td><td style="text-align:center">Percentage of rows filtered by table condition</td></tr><tr><td style="text-align:center">extra</td><td style="text-align:center">Additional information</td></tr></tbody></table><h3 id="2-1-id"><a href="#2-1-id" class="headerlink" title="2.1 id"></a>2.1 id</h3><h4 id="id-相同，从上到下，依次执行"><a href="#id-相同，从上到下，依次执行" class="headerlink" title="id 相同，从上到下，依次执行"></a>id 相同，从上到下，依次执行</h4><h4 id="id-不同，id-越大优先级越高"><a href="#id-不同，id-越大优先级越高" class="headerlink" title="id 不同，id 越大优先级越高"></a>id 不同，id 越大优先级越高</h4><p>​    <code>explain select * from ip_test where id in (select max(id) from ip_test);</code></p><h3 id="2-2-type"><a href="#2-2-type" class="headerlink" title="2.2 type"></a>2.2 type</h3><p><strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> </p><p>一般情况下，<strong>得保证查询至少达到range级别，最好能达到ref</strong></p><h3 id="2-3-key-len"><a href="#2-3-key-len" class="headerlink" title="2.3 key_len"></a>2.3 key_len</h3><p>索引中使用的字节数，在不损失精度的情况下，<strong>长度越短越好</strong></p><h3 id="2-4-ref"><a href="#2-4-ref" class="headerlink" title="2.4 ref"></a>2.4 ref</h3><p>显示索引的哪一列被使用了？</p><h3 id="2-5-rows"><a href="#2-5-rows" class="headerlink" title="2.5 rows"></a>2.5 rows</h3><p>大致估算找出所需记录需要读取的行数。不影响结果的情况下，越少越好。</p><h3 id="2-6-extra"><a href="#2-6-extra" class="headerlink" title="2.6 extra"></a>2.6 extra</h3><ul><li>using filesort：无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</li><li>using temporary：建立临时表来保存中间结果，查询完成之后把临时表删除</li><li>using index：当前查询走<strong>覆盖索引</strong>，不用回表。</li><li>using where：使用 where 进行条件过滤</li></ul><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><h3 id="3-1-索引优点"><a href="#3-1-索引优点" class="headerlink" title="3.1 索引优点"></a>3.1 索引优点</h3><ol><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机 IO 变成顺序 IO</li></ol><h3 id="3-2-索引的用处"><a href="#3-2-索引的用处" class="headerlink" title="3.2 索引的用处"></a>3.2 索引的用处</h3><ol><li>快速查找匹配 where 字句的行</li><li>如果可以在多个索引中进行选择，会自动选择扫描最少行的索引</li><li>如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行</li><li>当有表连接的时候，从其他表检索行数据？</li><li>查找特定索引列的 min 或 max 值</li><li>如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组？</li><li>在某些情况下，可以优化查询以检索值而无需查询数据行。覆盖索引。</li></ol><h3 id="3-3-索引的分类"><a href="#3-3-索引的分类" class="headerlink" title="3.3 索引的分类"></a>3.3 索引的分类</h3><ol><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>全文索引</li><li>组合索引</li></ol><h3 id="3-4-索引采用的数据结构"><a href="#3-4-索引采用的数据结构" class="headerlink" title="3.4 索引采用的数据结构"></a>3.4 索引采用的数据结构</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><ul><li>基于哈希表实现的索引，只有精确匹配索引所有列的查询才有效果</li><li>在 MySQL 中，只有 memory 的存储引擎显示支持哈希索引</li><li>哈希索引自身只需存储对应的 hash 值，所以所有结构十分紧凑，所以查找速度非常快</li></ul><p>哈希索引的限制：</p><ol><li>哈希索引中只包含哈希值和行指针，不存储字段值，索引肯定会回表，无法覆盖索引。</li><li>哈希索引数据不是按照索引值顺序存储的，无法进行排序</li><li><p>哈希索引不支持部分列匹配查找，哈希索引使用索引列的全部内容来计算哈希值</p></li><li><p>哈希索引支持等值比较查询？不支持任何范围查询</p></li><li><p>访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有行指针，逐行进行比较，直到找到所有符合条件的行</p></li><li><p>哈希冲突比较多的话，维护的成本也会很高</p></li></ol><h4 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+ 树"></a>2. B+ 树</h4><p>二叉树</p><ul><li>不平衡</li><li>节点深</li></ul><p>二叉搜索树</p><p>平衡二叉树(AVL)</p><ul><li>查询速度块，修改、删除慢</li></ul><p>红黑树</p><ul><li>平衡修改、删除效率</li></ul><p>这些二叉树，最终都会由<strong>于节点过深导致 IO 次数过多</strong>，影响数据读取的效率，所以不合适。</p><p>B 树：</p><ol><li><p>所有键值分布在整棵树中</p></li><li><p>搜索有可能在非叶子节点结束</p></li><li><p>每个节点最多拥有 m 个子树</p></li><li><p>根节点至少有 2 个子树</p></li><li><p>分支节点至少拥有 m/2 棵子树</p></li><li><p>所有叶子节点都在同一层，每个节点最多可以有 m-1 个 key，并且以<strong>升序</strong>排列</p><p>每个节点都有 key，同时和包含 data，而每个页存储的空间是有限的，如果 data 比较大的话，会导致每个节点存储的 key 数量变小。大量空间用来存 data 了，三层的 B 数只能存 4096 kb 数据。</p></li></ol><p><strong>B+ 树</strong>：</p><p>对 B 树进行优化</p><ol><li>每个节点可以包含更多的节点，这样可以降低树的高度；将数据的范围变为多个区间，区间越多，数据检索越快</li><li>非叶子节点存储 key，叶子节点存储 key 和数据</li><li>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高</li></ol><p>B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点之间是一种链式环结构。因此可以对 B+ 树进行两种查询运算：1. 对于主键的范围查找和分页查找；2. 从根节点开始，进行随机查找。</p><p>InnoDB 是通过 B+ 树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键。</p><p>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后通过主键索引找到对应的记录，叫做回表。</p><h3 id="3-5-索引相关名词"><a href="#3-5-索引相关名词" class="headerlink" title="3.5 索引相关名词"></a>3.5 索引相关名词</h3><h4 id="1-回表"><a href="#1-回表" class="headerlink" title="1. 回表"></a>1. 回表</h4><p>普通索引叶子节点没有存行记录，存储的是主键。所以需要回去再找主键索引树，这就是回表。</p><h4 id="2-覆盖索引"><a href="#2-覆盖索引" class="headerlink" title="2. 覆盖索引"></a>2. 覆盖索引</h4><p>当查询的列在叶子节点已经有了，就不需要再查询一遍主键索引树了，这就是覆盖索引。</p><h4 id="3-最左匹配"><a href="#3-最左匹配" class="headerlink" title="3. 最左匹配"></a>3. 最左匹配</h4><p>根据 name、age 建立组合索引。<code>where name = ? and age = ?</code> 可以匹配索引，但是 <code>where age = ？</code> 不会走索引。可以在建立组合索引时，name、age 互换。如果单独建立 name、age 两个索引，会涉及到索引合并优化。</p><h4 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4. 索引下推"></a>4. 索引下推</h4><p>取出索引的同时，<strong>判断是否可以进行where条件过滤再进行索引查询</strong>，也就是说提前执行 where 的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。 和 sql 查询的<strong>谓词下推</strong>类似， 始终将过滤表达式尽可能移至靠近数据源的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;范式、主键、字符集、存储引擎、拆分的选择&lt;/li&gt;
&lt;li&gt;执行计划&lt;/li&gt;
&lt;li&gt;索引的数据结构和基本概念&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql 调优(一)</title>
    <link href="http://yoursite.com/2020-08-05-mysql/mysql_1.html"/>
    <id>http://yoursite.com/2020-08-05-mysql/mysql_1.html</id>
    <published>2020-08-05T14:13:12.000Z</published>
    <updated>2020-08-09T14:23:54.627Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Mysql 基本架构</li><li>性能监控</li><li>数据类型的优化</li></ul><a id="more"></a><h2 id="0-MySql-的基本架构"><a href="#0-MySql-的基本架构" class="headerlink" title="0. MySql 的基本架构"></a>0. MySql 的基本架构</h2><p><img src="../../images/mysql/1/mysql架构.png" alt=""></p><h2 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h2><h3 id="1-1-profiles、profile"><a href="#1-1-profiles、profile" class="headerlink" title="1.1 profiles、profile"></a>1.1 profiles、profile</h3><p>查看 sql 消耗的时间、cpu、io 等信息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 设置后，show profiles 才有显示</div><div class="line"><span class="keyword">set</span> profiling = <span class="number">1</span>;</div><div class="line"># 业务查询语句</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mylock;</div><div class="line"># 查看 sql 查询总耗时</div><div class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</div><div class="line"># 查看详细耗时</div><div class="line"><span class="keyword">show</span> profile;</div><div class="line"># 查看指定 sql</div><div class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">2</span>;</div><div class="line"># cpu 信息也展示出来</div><div class="line"><span class="keyword">show</span> profile cpu;</div><div class="line"># 展示所有</div><div class="line"><span class="keyword">show</span> profile all;</div><div class="line"># 官网地址：SQL Statements -&gt; Database Administration Statements -&gt; SHOW Statements</div></pre></td></tr></table></figure><p>问题：java 执行的 sql 好像监控不到</p><h3 id="1-2-performance-schema"><a href="#1-2-performance-schema" class="headerlink" title="1.2 performance_schema"></a>1.2 performance_schema</h3><p>数据不会持久化。每次重启 mysql 服务后会清空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 查看是否开启</div><div class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'performance_schema'</span>;</div><div class="line"></div><div class="line"># 语句事件记录表。当前语句、历史语句、聚合信息</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%statement%'</span>;</div><div class="line"></div><div class="line"># 等待事件记录表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%wait%'</span>;</div><div class="line"></div><div class="line"># 事务事件记录表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%transaction%'</span>;</div><div class="line"></div><div class="line"># 监控文件系统层调用</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%file%'</span>;</div><div class="line"></div><div class="line"># 配置表</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">like</span> <span class="string">'%setup%'</span>;</div><div class="line"></div><div class="line"># 有些 instruments 和 consumers 默认没有启动，需要手动开启</div><div class="line">## 比如，开启等待事件监控功能</div><div class="line"><span class="keyword">UPDATE</span> setup_instruments <span class="keyword">SET</span> ENABLED = <span class="string">'YES'</span>, TIMED = <span class="string">'YES'</span><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'wait%'</span>;</div><div class="line"><span class="keyword">UPDATE</span> setup_consumers <span class="keyword">SET</span> ENABLED = <span class="string">'YES'</span><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%wait%'</span>;</div><div class="line"></div><div class="line"># 查看相关的一些系统变量</div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%performance_schema%'</span>;</div></pre></td></tr></table></figure><h3 id="1-3-show-processlist"><a href="#1-3-show-processlist" class="headerlink" title="1.3 show processlist"></a>1.3 show processlist</h3><p>查看连接的线程个数，观察是否有大量线程处于不正常的状态或者其他不正常的特征。</p><h2 id="2-schema-与数据类型优化"><a href="#2-schema-与数据类型优化" class="headerlink" title="2. schema 与数据类型优化"></a>2. schema 与数据类型优化</h2><h3 id="2-1-数据类型的优化"><a href="#2-1-数据类型的优化" class="headerlink" title="2.1 数据类型的优化"></a>2.1 数据类型的优化</h3><h4 id="长度越小越好"><a href="#长度越小越好" class="headerlink" title="长度越小越好"></a>长度越小越好</h4><p>尽量使用可以正确存储数据的最小数据类型，越小的数据类型占用更少的磁盘空间、内存和 CPU 缓存，并且处理时需要的 CPU 周期更少。</p><h4 id="类型越简单越好"><a href="#类型越简单越好" class="headerlink" title="类型越简单越好"></a>类型越简单越好</h4><ol><li>整型比字符操作代价更低</li><li>使用自建类型来存储日期和时间，而不是字符串</li><li>使用整型来存储 IP 地址，而不是字符串</li></ol><h4 id="尽量避免-null"><a href="#尽量避免-null" class="headerlink" title="尽量避免 null"></a>尽量避免 null</h4><p>​    null 列对 mysql 来说很难优化，因为可为 null 的列使得索引、索引统计和值比较都更加复杂。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul><li>整数类型： TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。  尽量使用满足需求的最小数据类型 。</li><li><p>字符和字符串类型</p><ul><li>char：长度固定；最长 255 字符；适用于身份证号、手机号、摘要算法等定长字符串</li><li>varchar：长度可变；可以设置最大长度；最大空间 65535 个字节；适用于长度变化频繁、多字节字符（汉字、特殊字符）</li></ul></li><li>datetime 和 timestamp<ul><li>datetime：占用 8 个字节；与时区无关；精确到毫秒；</li><li>timestamp：占用 4 个字节；依赖数据库时区；时间范围（19700101-20380119）；精确到秒；</li><li>date：占用 3 个字节；时间范围（10000101-99991231）</li></ul></li><li>使用枚举代替字符串类型<ul><li>mysql 会根据枚举值把数据压缩到一个或两个字节中，内部会将每个值在列表中的位置保存为<strong>整数</strong>。并且在表的 <code>.frm</code> 文件中保存“数字-字符串”映射关系的查找表。</li></ul></li><li>使用 <code>int(32) unsigned</code> 来存 ip 地址<ul><li>INET_ATON(‘192.168.85.111’)</li><li>INET_NTOA(3232257391)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Mysql 基本架构&lt;/li&gt;
&lt;li&gt;性能监控&lt;/li&gt;
&lt;li&gt;数据类型的优化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-07-26-jvm/jvm%E5%AD%A6%E4%B9%A011_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-07-26-jvm/jvm学习11_面试问题.html</id>
    <published>2020-07-26T12:22:06.288Z</published>
    <updated>2020-08-05T12:16:09.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-命令汇总"><a href="#1-命令汇总" class="headerlink" title="1. 命令汇总"></a>1. 命令汇总</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 设定 GC 日志参数(只记录 GC 的)</span></div><div class="line">java -Xms200M -Xmx200M -Xloggc:/root/testJvm/logs/T15_FullGC_Problem01-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails T15_FullGC_Problem01</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程</span></div><div class="line">top</div><div class="line"><span class="meta">#</span><span class="bash"> 定位具体程序</span></div><div class="line">jps</div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程中哪个线程</span></div><div class="line">top -Hp 2234</div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程所有线程详细信息</span></div><div class="line">jstack -l 2234</div><div class="line"><span class="meta">#</span><span class="bash"> 进程号转 16 进制</span></div><div class="line">printf "%x\n" 2407</div><div class="line">jstack 2234|grep 967 -A 3</div><div class="line"><span class="meta">#</span><span class="bash"> 查看进程中线程个数</span></div><div class="line">jstack -l 2539 | grep "java.lang.Thread.State" | wc -l</div><div class="line">jstat -gc 2599 500</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-命令汇总&quot;&gt;&lt;a href=&quot;#1-命令汇总&quot; class=&quot;headerlink&quot; title=&quot;1. 命令汇总&quot;&gt;&lt;/a&gt;1. 命令汇总&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM 学习（十一）</title>
    <link href="http://yoursite.com/2020-07-24-jvm/jvm%E5%AD%A6%E4%B9%A011_jvm%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93.html"/>
    <id>http://yoursite.com/2020-07-24-jvm/jvm学习11_jvm常见参数总结.html</id>
    <published>2020-07-24T14:13:12.000Z</published>
    <updated>2020-07-24T16:53:25.400Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 常见参数总结。</p><a id="more"></a><h2 id="1-CMS-的日志格式"><a href="#1-CMS-的日志格式" class="headerlink" title="1. CMS 的日志格式"></a>1. CMS 的日志格式</h2><p><code>java -Xms20M -Xms20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC T15_FullGC_Problem01</code></p><p>[GC (Allocation Failure) [ParNew: 5504K-&gt;640K(6144K), 0.0361611 secs] 5504K-&gt;1085K(19840K), 0.0362611 secs] [Times: user=0.01 sys=0.02, real=0.03 secs] </p><blockquote><p>ParNew：年轻代收集器</p><p>5504K-&gt;640K：收集前后的对比</p><p>(6144K)：整个年轻代容量</p><p>5504K-&gt;1085K：整个堆情况</p><p>(19840K)：整个堆大小</p></blockquote><p>[GC (CMS Initial Mark) [1 CMS-initial-mark: 8362K(13696K)] 9696K(19840K), 0.0223401 secs] [Times: user=0.00 sys=0.03, real=0.02 secs] </p><blockquote><p>8362K(13696K)：老年代已经使用（老年代最大空间）</p><p>9696K(19840K)：整个堆使用（最大）</p></blockquote><p>[CMS-concurrent-mark-start]<br>[CMS-concurrent-mark: 0.037/0.037 secs] [Times: user=0.01 sys=0.02, real=0.04 secs] </p><blockquote><p>这里的时间意义不大，因为是并发执行</p></blockquote><p>[CMS-concurrent-preclean-start]<br>[CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </p><blockquote><p>标记 Card 为 Dirty，也称为 Card Marking</p></blockquote><p>[GC (CMS Final Remark)  [YG occupancy: 1653 K (6144 K)] [Rescan (parallel) , 0.0036149 secs] [weak refs processing, 0.0000216 secs] [class unloading, 0.0023396 secs] [scrub symbol table, 0.0005398 secs]  [scrub string table, 0.0008483 secs] [1 CMS-remark: 8362K(13696K)] 10016K(19840K), 0.0080645 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </p><blockquote><p>最终（重新）标记</p><p>STW  阶段。YG occupancy：年轻代占用及容量</p><p>Rescan (parallel) ：STW 下的存活对象标记</p><p>weak refs processing：弱引用处理</p><p>class unloading：卸载用不到的 class（对  metaspace、pengrem 的回收）</p><p>scrub symbol table：</p><p>​    由于前面有一些 class 卸载了，有一些指向这些 class 的常量也可以处理掉</p><p>CMS-remark: 8362K(13696K)：阶段过后的老年代占用容量</p><p>10016K(19840K)：阶段过后的堆占用以及容量</p></blockquote><p>[CMS-concurrent-sweep-start]<br>[CMS-concurrent-sweep: 0.005/0.005 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </p><blockquote><p>标记已经完成了，开始进行并发清理</p></blockquote><p>[CMS-concurrent-reset-start]<br>[CMS-concurrent-reset: 0.019/0.019 secs] [Times: user=0.00 sys=0.02, real=0.02 secs] </p><blockquote><p>重置内部结构，为下次 GC 做准备</p></blockquote><h2 id="2-G1-的日志格式（1-8-开始基本成熟）"><a href="#2-G1-的日志格式（1-8-开始基本成熟）" class="headerlink" title="2. G1 的日志格式（1.8 开始基本成熟）"></a>2. G1 的日志格式（1.8 开始基本成熟）</h2><p>PS+PO、PN+CMS 都要指定 young 区大小（-xmn），不指定也会有一个默认比例。但是 G1 不推荐指定 young 区大小，因为 G1 会进行动态调整（可以设定范围区间），调整的依据就是 YGC STW 时间。</p><p><code>java -Xms20M -Xms20M -XX:+PrintGCDetails -XX:+UseG1GC T15_FullGC_Problem01</code></p><p>G1 调优目标：不要 FullGC(SerialOld）</p><p>CMS目标：不要 FullGC(SerialOld）</p><p>[GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0247906 secs]<br>   [Parallel Time: 24.4 ms, GC Workers: 1]<br>      [GC Worker Start (ms):  59371.3]<br>      [Ext Root Scanning (ms):  0.9]<br>      [Update RS (ms):  10.8]<br>         [Processed Buffers:  55]<br>      [Scan RS (ms):  0.5]<br>      [Code Root Scanning (ms):  0.0]<br>      [Object Copy (ms):  12.1]<br>      [Termination (ms):  0.0]<br>         [Termination Attempts:  1]<br>      [GC Worker Other (ms):  0.0]<br>      [GC Worker Total (ms):  24.4]<br>      [GC Worker End (ms):  59395.7]<br>   [Code Root Fixup: 0.0 ms]<br>   [Code Root Purge: 0.0 ms]<br>   [Clear CT: 0.0 ms]<br>   [Other: 0.4 ms]<br>      [Choose CSet: 0.0 ms]<br>      [Ref Proc: 0.0 ms]<br>      [Ref Enq: 0.0 ms]<br>      [Redirty Cards: 0.0 ms]<br>      [Humongous Register: 0.0 ms]<br>      [Humongous Reclaim: 0.0 ms]<br>      [Free CSet: 0.0 ms]<br>   [Eden: 3072.0K(3072.0K)-&gt;0.0B(2048.0K) Survivors: 1024.0K-&gt;1024.0K Heap: 15.5M(20.0M)-&gt;14.0M(20.0M)]<br> [Times: user=0.03 sys=0.00, real=0.02 secs]</p><blockquote><p>young：年轻代 </p><p>Evacuation：复制存活对象</p><p>initial-mark：混合回收的阶段，这里是 YGC 混合老年代回收（MixedGC）</p></blockquote><p>[GC concurrent-root-region-scan-start]<br>[GC concurrent-root-region-scan-end, 0.0253766 secs]<br>[GC concurrent-mark-start]</p><blockquote><p>混合回收的其他阶段</p><p>无法进行  evacuation，进行 FGC</p><p>G1 中如果出现 FGC 是很可怕的事情，应该要排查问题了，很可能存在内存泄漏了。</p></blockquote><h2 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3. 常用参数"></a>3. 常用参数</h2><h3 id="3-1-通用参数"><a href="#3-1-通用参数" class="headerlink" title="3.1 通用参数"></a>3.1 通用参数</h3><ul><li><p>-Xmn -Xms -Xmx -Xss</p><p>年轻代 最小堆 最大堆 栈空间</p></li><li><p>-XX:+UseTLAB</p><p>使用 TLAB，默认打开</p></li><li><p>-XX:+PrintTLAB</p><p>打印 TLAB 的使用情况</p></li><li><p>-XX:TLABSize</p><p>设置 TLAB 大小</p></li><li><p>-XX:+DisableExplictGC</p><p>System.gc() 不管用(FGC)</p></li><li><p>-XX:+PrintGC</p></li><li><p>-XX:+PrintGCDetails</p></li><li><p>-XX:+PrintHeapAtGC</p></li><li><p>-XX:+PrintGCTimeStamps</p></li><li><p>-XX:+PrintGCApplicationConcurrentTime(低)</p><p>打印应用程序时间</p></li><li><p>-XX:+PrintGCApplicationStoppedTime（低）</p><p>打印暂停时长</p></li><li><p>-XX:+PrintReferenceGC(重要性低)</p><p>记录回收了多少种不同引用类型的引用</p></li><li><p>-verbose:class</p><p>类加载详细过程</p></li><li><p>-XX:+PrintVMOptions</p></li><li><p>-XX:+PrintFlagsFinal  -XX:+PrintFlagsInitial</p><p><strong>必须会用</strong>。比如查看 G1 相关参数</p><p>java -XX:+PrintFlagsFinal -version | grep G1</p></li><li><p>-Xloggc:/opt/log/gc.log</p></li><li><p>-XX:MaxTenuringThreshold</p><p>GC 升代年龄，最大值 15。CMS 默认 6，其他默认 15</p></li><li><p>锁自旋次数 -XX:PreBlockSpin 热点代码检测参数 -XX:CompileThreshold 逃逸分析 标量替换</p><p>这些不建议设置</p></li></ul><h3 id="3-2-Parallel-常用参数"><a href="#3-2-Parallel-常用参数" class="headerlink" title="3.2 Parallel 常用参数"></a>3.2 Parallel 常用参数</h3><ul><li><p>-XX:SurvivorRatio：survivor 区比例。默认 8:1:1</p></li><li><p>-XX:PreTenureSizeThreshold</p><p>大对象到底多大。超过这个参数，直接分配到 old 区</p></li><li><p>-XX:MaxTenuringThresholdd</p></li><li><p>-XX:+ParallelGCThreads</p><p>并行收集器 的线程数，同样 适用于 CMS，一般设置为和 CPU 核数相同</p></li><li><p>-XX:+UseAdaptiveSizePolicy</p><p>自动选择各区大小比例</p></li></ul><h3 id="3-3-CMS-常用参数"><a href="#3-3-CMS-常用参数" class="headerlink" title="3.3 CMS 常用参数"></a>3.3 CMS 常用参数</h3><ul><li><p>-XX:+UseConcMarkSweepGC</p></li><li><p>-XX:ParallelCMSThreads</p><p>CMS 线程数量，一般为线程的一半。不能设置太大把 CPU 全部占用了，那就相当于 STW 了。</p></li><li><p>-XX:CMSInitiatingOccupancyFaction</p><p>使用多少比例的老年代后开始 CMS 收集，默认是 68%（近似值）。如果频繁发生 SerialOld 卡顿，应该调小这个参数（调小后会频繁 CMS 回收，但也没办法）。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection</p><p>在 FGC 时进行压缩</p></li><li><p>-XX:CMSFullGCsBeforeCompaction</p><p>多少次 FGC 之后进行压缩</p></li><li><p>-XX:+CMSClassUnloadingEnabled （1.8 之前）</p><p>回收 metaspace、perm</p></li><li><p>-XX:+CMSInitiatingPermOccupancyFraction（1.8 之前）</p><p>达到什么比例时进行 Perm 回收</p></li><li><p>GCTimeRatio</p><p>设置 GC 时间占用程序运行时间的百分比</p></li><li><p>-XX:MaxGCPauseMillis</p><p>停顿时间，是一个建议时间，GC 会尝试用各种手段达到这个时间，比如减小年轻代空间</p></li></ul><h3 id="3-4-G1-常用参数"><a href="#3-4-G1-常用参数" class="headerlink" title="3.4 G1 常用参数"></a>3.4 G1 常用参数</h3><ul><li><p>-XX:+UseG1GC</p></li><li><p>-XX:MaxGCPauseMillis</p><p>建议值，G1 会尝试调整 young 区的块数来达到这个值</p></li><li><p>-XX:GCPauseIntervalMillis</p><p>? GC 的间隔时间</p></li><li><p>-XX:+G1HeapRegionSize</p><p>分区大小，建议逐渐增大该值，1 2 4 8 16 32，需要实际调整，看多大适合。</p><p>随着 size 增加，垃圾存活时间更长，GC 间隔更长，但每次 GC 的时间也会更长。</p><p>ZGC 做了改进（动态区块大小）</p></li><li><p>G1NewSizePercent</p><p>新生代最小比例，默认为 5%</p></li><li><p>G1MaxNewSizePercent</p><p>新生代最小比例，默认为60%</p></li><li><p>GCTimeRatio</p><p>GC 时间建议比例，G1 会根据这个值调整堆空间比例</p></li><li><p>ConcGCThreads</p><p>线程数量</p></li><li><p>InitiatingHeapOccupancyPercent</p><p>启动 G1 的堆空间占用比例</p></li></ul><h2 id="4-作业"><a href="#4-作业" class="headerlink" title="4. 作业"></a>4. 作业</h2><h2 id="5-纤程-协程"><a href="#5-纤程-协程" class="headerlink" title="5. 纤程/协程"></a>5. 纤程/协程</h2><p>程序 进程 线程 纤程</p><p>一个线程内部分多条路径，就是纤程。</p><p>栈的记录和切换。</p><p>线程启动需要调用内核，线程的并发比较重量级，线程间切换消耗的资源也比较多。</p><p>纤程和线程类似，也是栈结构切换，操作也会调用内核，但是纤程之间的切换是在用户空间完成。</p><p>启动一个线程大概需要 1m 内存，所以操作系统支撑不了多少线程。</p><p>纤程的数量可以比线程多很多。</p><p>-javaagent:D:\maven-rep\co\paralleluniverse\quasar-core\0.8.0\quasar-core-0.8.0.jar</p><p>目前 java 不持支，适用 agent 代理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 常见参数总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（十）</title>
    <link href="http://yoursite.com/2020-07-23-jvm/jvm%E5%AD%A6%E4%B9%A0%2010_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.html"/>
    <id>http://yoursite.com/2020-07-23-jvm/jvm学习 10_垃圾回收算法.html</id>
    <published>2020-07-23T14:13:12.000Z</published>
    <updated>2020-07-24T12:59:42.809Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收算法</p><a id="more"></a><h2 id="1-CMS"><a href="#1-CMS" class="headerlink" title="1. CMS"></a>1. CMS</h2><p>如果用的 PN + CMS，你的调优目标就是尽量避免 FGC，但从本质上来说是无法避免的。</p><h3 id="1-1-四个阶段"><a href="#1-1-四个阶段" class="headerlink" title="1.1 四个阶段"></a>1.1 四个阶段</h3><p>如果细分，会有六个节点，就是初始标记之前还有一些准备阶段。</p><h3 id="1-1-1-CMS-initial-mark"><a href="#1-1-1-CMS-initial-mark" class="headerlink" title="1.1.1 CMS initial mark"></a>1.1.1 CMS initial mark</h3><p>只标记根对象，所以 <strong>STW</strong> 很短。</p><p><img src="../../images/jvm/10/CMS初始标记.png" alt=""></p><h3 id="1-1-2-CMS-concurrent-mark"><a href="#1-1-2-CMS-concurrent-mark" class="headerlink" title="1.1.2 CMS concurrent mark"></a>1.1.2 CMS concurrent mark</h3><p>并发标记，标记根节点下面的所有对象。是最耗时的阶段，但是并发执行，<strong>不产生 STW</strong>，保证应用程序的响应时间。</p><p><img src="../../images/jvm/10/CMS并发标记.png" alt=""></p><h3 id="1-1-3-CMS-remark"><a href="#1-1-3-CMS-remark" class="headerlink" title="1.1.3 CMS remark"></a>1.1.3 CMS remark</h3><p>重新标记，标记 concurrent mark 过程中新产生的垃圾，或者垃圾变得有用了。由于新的改动一般不是很多，所以虽然该阶段也<strong>有 STW</strong>，但是影响不大。</p><p><img src="../../images/jvm/10/CMS重新标记.png" alt=""></p><h3 id="1-1-4-CMS-concurrent-sweep"><a href="#1-1-4-CMS-concurrent-sweep" class="headerlink" title="1.1.4 CMS concurrent sweep"></a>1.1.4 CMS concurrent sweep</h3><p>并发清理，把标记好的垃圾擦除。</p><p>这个阶段过程中产生的垃圾叫做浮动垃圾，下次回收再做处理。</p><p>ParNew 和 PS 哪一个更快？</p><p>采用何种类型 GC</p><ul><li>如何确定系统使用<strong>吞吐量优先</strong>的 GC 还是 <strong>反应时间优先</strong> 的 GC？</li></ul><p>如果采用 ParNew + CMS </p><ul><li>怎么做才能够让系统基本不产生 FGC？</li></ul><h2 id="2-G1"><a href="#2-G1" class="headerlink" title="2. G1"></a>2. G1</h2><h3 id="2-1-G1-入门"><a href="#2-1-G1-入门" class="headerlink" title="2.1 G1 入门"></a>2.1 G1 入门</h3><p><a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html" target="_blank" rel="external">https://www.oracle.com/technical-resources/articles/java/g1gc.html</a></p><blockquote><p> The <a href="https://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html" target="_blank" rel="external">Garbage First Garbage Collector (G1 GC)</a> is the low-pause, server-style generational garbage collector for Java HotSpot VM. The G1 GC uses concurrent and parallel phases to achieve its target pause time and to maintain good throughput. When G1 GC determines that a garbage collection is necessary, it collects the regions with the least live data first (garbage first). </p></blockquote><p>least live data 最少存活对象，也就是最多垃圾对象，这也是 garbage first（<strong>垃圾优先</strong>） 概念的由来。</p><p>吞吐量和 PS 相比降低了 10%-15%，但是停顿时间能达到 200ms。如果你想要你的应用程序不管怎么样，200ms 内有响应，那么就应该用 G1，如果应用程序追求 throughput，那么用 PS。</p><p>以前的分代模型，在物理上也分代，就是说有两块连续的物理内存，当内存不断增大，怎么处理都会消耗较多时间。</p><p>G1 采用<strong>分而治之</strong>的思想。分而治之和分层是设计架构上的两大思想。</p><p><img src="../../images/jvm/10/G1模型.png" alt=""></p><p><img src="../../images/jvm/10/G1模型2.png" alt=""></p><h3 id="2-2-G1-特点"><a href="#2-2-G1-特点" class="headerlink" title="2.2 G1 特点"></a>2.2 G1 特点</h3><ul><li>并发收集</li><li>压缩空闲空间不会延长 GC 的暂停时间</li><li>更易预测的 GC 暂停时间</li><li>适用于不需要实现很高的吞吐量，但是需要特别快的响应时间的场景</li><li>G1 的内存区域不是固定的 E 或者 O，而是灵活的</li></ul><p>CMS、G1：<strong>三色标记</strong></p><p>​    三色标记是指把对象分为三个不同颜色。每个颜色表示该对象是否标记过、标记一半、完全没有标记。</p><p>ZGC、SHAN：<strong>颜色指针</strong>（colored pointers）</p><p>​    在 JVM 中如果不做压缩，一个指针 64 位，在这 64 位中，拿出 3 位进行标记。当指针从指向一个位置变为指向另外一个位置，这三位随之变化，这样子在进行垃圾回收时，jvm 就知道这个指针变过了，垃圾回收时会<strong>扫描变化过的指针</strong>，所以叫做颜色指针。</p><h3 id="2-3-基本概念"><a href="#2-3-基本概念" class="headerlink" title="2.3 基本概念"></a>2.3 基本概念</h3><ul><li><p>CSet = Collection Set</p><p>一组可被回收的分区的集合，记录哪些 card 需要回收。</p><p>在 CSet 中存活的数据会在 GC 过程中被移动到另一个可用分区，CSet 中的分区可以来自 Eden 空间、Survivor 空间、或者老年代。</p><p>CSet 会占用不到整个堆空间的 1% 大小</p></li><li><p>RSet = RememberedSet。G1 高效回收的关键。</p><p>记录了其他 Region 中的<strong>对象</strong>到本 Region 的引用。即记录有没有其他分区引用了该分区的对象，如果没有直接干掉，如果有，具体引用了哪个对象。</p><p>RSet 的价值在于使得垃圾收集器不需要扫描整个堆来找到谁引用了当前分区中的对象，只需要扫描 RSet 即可。</p><p>由于 RSet 的存在，那么每次给对象赋引用的时候，就得做一些额外的操作。就是在 RSet 中做一些额外的记录。（在 GC 中被称为写屏障，这个写屏障不等于内存屏障）</p></li><li><p>Card table（<strong>GC 算法无关</strong>）</p><p>由于做 YGC 时，需要扫描整个 Old 区，效率非常低，所以 JVM 设计了 CardTable，如果一个 Old 区 CardTable 中有对象指向 Y 区，就将它在<strong>位图</strong>中设置为 Dirty，下次扫描时，只需要扫描 Dirty Card。在结构上，Card Table 用 BitMap 来实现。</p></li></ul><p>阿里的多租户 JVM</p><ul><li><p>每租户单空间</p></li><li><p>session based GC（专门针对 web application）</p><p>随着 session 的结束，对象随着回收。</p></li></ul><h3 id="2-4-Why-G1"><a href="#2-4-Why-G1" class="headerlink" title="2.4 Why G1"></a>2.4 Why G1</h3><ul><li>追求吞吐量<ul><li>100 cpu</li><li>99 app 1GC</li><li>吞吐量 = 99%</li></ul></li><li>追求响应时间<ul><li>XX:MaxGCPauseMillis 200</li><li>对 STW 进行控制</li></ul></li><li>灵活<ul><li>分 Region 回收</li><li>优先回收<strong>花费时间少、垃圾占比高</strong>的 Region</li></ul></li></ul><h3 id="2-5-每个-Region-有多大"><a href="#2-5-每个-Region-有多大" class="headerlink" title="2.5 每个 Region 有多大"></a>2.5 每个 Region 有多大</h3><ul><li>headpRegion.cpp</li><li>取值<ul><li>1 2 4 8 16 32</li></ul></li><li>手工指定<ul><li>XX：G1HeapRegionSize</li></ul></li></ul><h3 id="2-6-新老年代比例"><a href="#2-6-新老年代比例" class="headerlink" title="2.6 新老年代比例"></a>2.6 新老年代比例</h3><ul><li>5%-60% 动态<ul><li>一般不用手工指定</li><li>也不要手工指定，因为这是 G1 预测停顿时间的基准</li></ul></li></ul><h3 id="2-7-humongous-object"><a href="#2-7-humongous-object" class="headerlink" title="2.7 humongous object"></a>2.7 humongous object</h3><ul><li><p>超过单个 region 的 50%。可能跨越多个 region</p><h3 id="2-8-GC-何时触发"><a href="#2-8-GC-何时触发" class="headerlink" title="2.8 GC 何时触发"></a>2.8 GC 何时触发</h3></li><li><p>YGC</p><ul><li>Eden 空间不足</li><li>多线程并行执行</li></ul></li><li><p>FGC</p><ul><li>Old 空间不足</li><li>System.gc()</li></ul><p>G1 产生 FGC 应该做什么</p></li><li><p>扩内存</p></li><li><p>提高 CPU 性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大）</p></li><li><p>降低 MixedGC 触发的阈值，让 MixedGC 提早发生（默认是对象达到整个堆的 45% 是触发）。MixedGC 既会回收年轻代也会回收老年代，哪个满了回收哪个。</p><p>目的是为了让 MixedGC 提早发生，今早回收垃圾，从而尽量减少或者避免 FullGC，G1 的 fullGC 也是 serial 的。</p></li></ul><h3 id="2-9-G1-中的-MixedGC"><a href="#2-9-G1-中的-MixedGC" class="headerlink" title="2.9 G1 中的 MixedGC"></a>2.9 G1 中的 MixedGC</h3><p>相当于 CMS</p><ul><li>XX:InitialtingHeapOccupacyPercent<ul><li>默认值 45%</li><li>当 O 超过这个值时，启动 MixedGC</li></ul></li></ul><p>MixedGC 的过程</p><ul><li><p>初始标记 STW</p></li><li><p>并发标记</p></li><li><p>最终标记 STW（重新标记）</p></li><li><p>帅选回收 STW（并行）</p><p>筛选最需要回收的区域进行回收</p></li></ul><p>G1 也有 FullGC，jdk10 以前是串行 FullGC，之后是并行 FullGC</p><h2 id="3-并发标记算法"><a href="#3-并发标记算法" class="headerlink" title="3. 并发标记算法"></a>3. 并发标记算法</h2><p>难点：在标记对象的过程中，对象引用关系正在发生改变</p><p>在 CMS 和 G1 中用的都是<strong>三色标记算法</strong></p><ul><li>白色：未被标记的对象</li><li>灰色：自身被标记，成员变量未被标记</li><li>黑色：自身和成员变量均已标记完成</li></ul><p>漏标的情况：两个是充分必要条件</p><p><img src="../../images/jvm/10/漏标.png" alt=""></p><p>解决方式有两种：</p><ol><li><p>跟踪 A-&gt;D 的增加</p><p>incremental update – 增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS  用的就是这个算法。</p></li><li><p>跟中 B-&gt;D 的消失 </p><p>SATB snapshot at the beginning –关注引用的删除</p><p>当 B-&gt;D 消失时，要把这个<strong>引用</strong>推到 GC 的堆栈，保证 D 还能被 GC 扫描到。G1 用的就是这个算法。</p></li></ol><p>为什么 G1 用 SATB？</p><p>灰色-&gt;白色引用消失时，如果没有黑色指向白色，引用会被会被 push 到堆栈。下次扫描时拿到这个引用，由于 RSet 的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB 配合 RSet，就可以实现。</p><p>漏标是指，本来是 live object，但是由于没有遍历到，被当成 garbage 回收掉了。没有标记到的就是垃圾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-07-22-Untitled.html"/>
    <id>http://yoursite.com/2020-07-22-Untitled.html</id>
    <published>2020-07-22T11:56:16.365Z</published>
    <updated>2020-07-22T11:56:16.365Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM 学习（八）</title>
    <link href="http://yoursite.com/2020-07-20-jvm/jvm%E5%AD%A6%E4%B9%A08_%E8%B0%83%E4%BC%982.html"/>
    <id>http://yoursite.com/2020-07-20-jvm/jvm学习8_调优2.html</id>
    <published>2020-07-20T14:13:12.000Z</published>
    <updated>2020-07-21T16:16:40.798Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 调优（二）</p><a id="more"></a><h2 id="1-解决-JVM-运行中的问题"><a href="#1-解决-JVM-运行中的问题" class="headerlink" title="1. 解决 JVM 运行中的问题"></a>1. 解决 JVM 运行中的问题</h2><h3 id="1-1-一个案例理解常用工具"><a href="#1-1-一个案例理解常用工具" class="headerlink" title="1.1 一个案例理解常用工具"></a>1.1 一个案例理解常用工具</h3><ol><li>代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-20 23:59</span></div><div class="line"><span class="comment"> * 从数据库中读取信息数据,套用模型,并把结果进行记录和传输</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T15_FullGC_Problem01</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CardInfo</span> </span>&#123;</div><div class="line">       BigDecimal price = <span class="keyword">new</span> BigDecimal(<span class="number">0.0</span>);</div><div class="line">       String name = <span class="string">"张三"</span>;</div><div class="line">       <span class="keyword">int</span> age = <span class="number">5</span>;</div><div class="line">       Date birthdate = <span class="keyword">new</span> Date();</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">50</span>,</div><div class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            modelFit();</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modelFit</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</div><div class="line">        taskList.forEach(info -&gt; &#123;</div><div class="line">            executor.scheduleWithFixedDelay(() -&gt; &#123;</div><div class="line">                info.m();</div><div class="line">            &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title">getAllCardInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            CardInfo ci = <span class="keyword">new</span> CardInfo();</div><div class="line">            taskList.add(ci);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> taskList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><p>java -Xms200M -Xmx200M -XX:+PrintGC T15_FullGC_Problem01</p></li><li><p>一般是运维团队首先收到报警信息（比如 CPU memory 飙高）</p></li><li><p>top 命令观察到问题：内存不断增长，CPU 占用率居高不下</p></li><li><p>top -Hp pid 观察进程中的线程，哪个线程 CPU 和内存占比高</p></li><li><p>jps 定位具体 java 进程</p></li><li><p>jstack pid 观察进程中的线程，可以看到线程的状态，nid=0x10f34</p><p>重点关注：WAITING BLOCKED</p><p>waiting on </p><p>假如有一个进程中 100 个线程，很多线程都在 waiting on <xx>，<strong>一定要找到是哪个线程持有这把锁</strong>。</xx></p><p>怎么找？搜索 jstack dump 的信息，找 <xx>，看哪个线程持有这把锁，一般该线程是 RUNNABLE 状态。</xx></p><p>作业：1. 写一个死锁程序，用 jstack 观察；2. 写一个程序，一个程序持有锁不释放，其他线程等待</p></li><li><p>为什么阿里规范里,线程的名称(尤其是线程池)都要有意义的名称</p><p>怎么样自定义线程池里的线程名称？（自定义 ThreadFactory）</p></li><li><p>jinfo pid 查看进程基础信息</p></li><li><p>jstat -gc pid 500 动态观察 gc 情况</p><p>jconsole：jdk 自带的工具</p><p>jvisualvm：jdk 自带的工具</p><p>如果面试官问你是怎么定位 OOM 问题的？ 如果你回答用图形界面（错误，因为使用图形界面会影响程序主进程的性能，肯定是不对的）</p><p>Jprofiler（最好用、收费）</p><ol><li>已经上线的系统，不用图形界面用什么？（cmdline arthas）</li><li>图形界面到底用在什么地方？测试！测试的时候进行监控（压测观察）。提前定位问题，最大可能避免线上问题。</li></ol></li><li><p>jmap -histo 1236 | head -20 ，查找有多少对象产生</p></li><li><p>jmap -dump:format=b,file=xxx pid(导出堆文件。<strong>线上内存较大时不合适，对线上系统影响很大</strong>)</p><p>线上系统，内存特别大，jmap 执行期间会对进程产生很大影响，甚至卡顿（所以电商系统 jmap 不合适）</p><ol><li>设定了参数 HeapDump，OOM 的时候会自动产生堆转储文件</li><li>很多服务器备份（高可用），停掉这台服务器对其他服务器不影响。即对这台服务器做了隔离，然后再来 jmap</li><li>当堆内存特别大时，真的不能在线上直接执行 jmap，应该需要<strong>在线定位（一般小点儿公司用不到）</strong></li></ol></li><li><p>java -Xms200M -Xmx200M -XX:+PrintGC -XX:+HeapDumpOnOutOfMemoryError T15_FullGC_Problem01</p></li></ol><h3 id="1-2-jconsole-远程连接"><a href="#1-2-jconsole-远程连接" class="headerlink" title="1.2 jconsole 远程连接"></a>1.2 jconsole 远程连接</h3><ol><li><p>程序启动加入参数：</p><blockquote><p>java -Djava.rmi.server.hostname=192.168.238.66 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false xxx</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 调优（二）&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（七）</title>
    <link href="http://yoursite.com/2020-07-20-jvm/jvm%E5%AD%A6%E4%B9%A07_xx.html"/>
    <id>http://yoursite.com/2020-07-20-jvm/jvm学习7_xx.html</id>
    <published>2020-07-20T14:13:12.000Z</published>
    <updated>2020-07-20T15:57:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 调优（一）</p><a id="more"></a><h2 id="1-常见垃圾回收器组合参数设定（1-8）"><a href="#1-常见垃圾回收器组合参数设定（1-8）" class="headerlink" title="1. 常见垃圾回收器组合参数设定（1.8）"></a>1. 常见垃圾回收器组合参数设定（1.8）</h2><ul><li>-XX:+UseSerialGC = Serial New(DefNew) + Serial Old<ul><li>小型程序。默认情况下不会是这种选项，HotSpot 会根据计算及配置和 JDK 版本自动选择收集器。</li></ul></li><li>-XX:+UseParNewGC = ParNew + SerialOld<ul><li>这个组合已经很少用（在某些版本中已经废弃）</li></ul></li><li>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old</li><li>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old(1.8 默认) 【PS + SerialOld】</li><li>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</li><li>-XX:+UseG1GC = G1</li><li>Linux 中没有找到默认 GC 的查看方法，而 Windows 中会打印 UseParallelGC<ul><li>java -XX:+PrintCommandLineFlags -version</li><li>通过 GC 的日志来分辨</li></ul></li><li>Linux 下 1.8 版本默认的垃圾回收器到底是什么？<ul><li>1.8.0——181 默认（看不出来） Copy MarkCompact</li><li>1.8.0_222 默认 PS+PO</li></ul></li></ul><h2 id="2-JVM-调优第一步，了解-JVM-常用命令行参数"><a href="#2-JVM-调优第一步，了解-JVM-常用命令行参数" class="headerlink" title="2. JVM 调优第一步，了解 JVM 常用命令行参数"></a>2. JVM 调优第一步，了解 JVM 常用命令行参数</h2><ul><li><p>JVM 的命令行参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p></li><li><p>HotSpot 参数分类</p><blockquote><p>标准：- 开头，所有 HotSpot 都支持</p><p>非标准： -X 开头，特定版本 HotSpot 支持特定命令</p><p>不稳定：-XX 开头，下个版本可能取消</p></blockquote></li></ul><h3 id="2-1-一个小例子"><a href="#2-1-一个小例子" class="headerlink" title="2.1 一个小例子"></a>2.1 一个小例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello GC"</span>);</div><div class="line">        List list = <span class="keyword">new</span> LinkedList();</div><div class="line">        <span class="keyword">for</span>(;;) &#123;</div><div class="line">            <span class="comment">// 1M</span></div><div class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">            list.add(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><p>区分概念：内存泄漏 memory leak，内存溢出 out of memory</p></li><li><p>java -XX:+PrintCommandLineFlags HelloGC</p><blockquote><p>初始堆大小 最大堆大小 压缩头指针 压缩普通指针</p><p>-XX:InitialHeapSize=30113152 -XX:MaxHeapSize=481810432 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC<br>Hello GC<br>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p><pre><code>at HelloGC.main(HelloGC.java:8)</code></pre></blockquote></li><li><p>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC</p><p>可以看到自定义了NewSize，初始堆大小，最大堆大小。</p><p>可以看到 GC 执行信息。由于测试程序数据都在一个链表，都不能被回收，最后导致内存溢出。</p><p><img src="../../images/jvm/07/查看GC信息.png" alt=""></p><p>PrintGCDetails PrintGCTimeStamps PrintGCCauses</p></li><li><p>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC</p><p>可以看到 CMS 各个阶段信息</p></li><li><p>java -XX:+PrintFlagsInitial 默认参数值</p></li><li><p>java -XX:+PrintFlagsFinal 最终参数值</p></li><li><p>java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数</p></li><li><p>java -XX:+PrintFlagsFinal -version | grep GC</p></li></ol><h2 id="3-PS-GC-日志详解"><a href="#3-PS-GC-日志详解" class="headerlink" title="3. PS GC 日志详解"></a>3. PS GC 日志详解</h2><p>正常 GC 日志。</p><p><img src="../../images/jvm/07/GC日志.png" alt=""></p><p>GC 产生堆溢出时，会打印当前堆信息。</p><p><img src="../../images/jvm/07/GC日志2.png" alt=""></p><p>total = eden + 1个survivor</p><h2 id="4-调优之前的基础概念"><a href="#4-调优之前的基础概念" class="headerlink" title="4. 调优之前的基础概念"></a>4. 调优之前的基础概念</h2><p><strong>吞吐量</strong> = 用户代码执行时间/(用户代码执行时间+垃圾收集执行时间)</p><p><strong>响应时间</strong>=用户线程停顿的时间短。STW 越短，响应时间越好</p><p>确定调优之前，应该确定到底是哪个优先，是计算型任务还是响应型任务。还是在满足一定的响应时间的情况下，要求达到多大的吞吐量。</p><p>问题：</p><p>吞吐量：科学计算，吞吐量。数据挖掘，throughput。吞吐量优先的一般：PS + PO</p><p>响应时间：网站 GUI API （1.8 选 G1）</p><h2 id="5-什么是调优"><a href="#5-什么是调优" class="headerlink" title="5. 什么是调优"></a>5. 什么是调优</h2><ol><li>根据需求进行 JVM <strong>规划和预调优</strong></li><li>优化运行 JVM 运行环境（慢、卡顿怎么优化）</li><li>解决 JVM 运行过程中出现的各种问题（比如 OOM）</li></ol><h2 id="6-调优，从规划开始"><a href="#6-调优，从规划开始" class="headerlink" title="6. 调优，从规划开始"></a>6. 调优，从规划开始</h2><p>淘宝历年最高并发 54W。12306 号称比淘宝还高。</p><ul><li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓</p></li><li><p>无监控（压测，能看到结果），不调优</p></li><li><p>步骤</p><ol><li>熟悉业务场景（没有最好的垃圾回收器，只有最适合的）<ol><li>响应时间、停顿时间【CMS G1 ZGC】</li><li>吞吐量 【PS】</li></ol></li><li>选择回收器组合</li><li>计算内存需求（其实不好计算，内存小，可能 GC 频繁一些，但是可能也没问题，内存大 GC 频度小一些。经验值 1.5G 16G）</li><li>选定 CPU （越高越好，越好核心数越多，处理更快，GC 就更快，节省内存，两者相辅相成）</li><li>设定年代大小、升级年龄</li><li>设定日志参数<ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause  五个日志文件循环使用</li><li>或者每天产生一个日志文件</li></ol></li><li>观察日志情况</li></ol></li></ul><ul><li><p>预调优案例1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？</p><blockquote><p>这个问题比较业余，因为很多不同的服务器配置都能支撑（1.5G，16G）</p><p>1 小时 360000 订单，集中时间段，100 个订单/秒（找一小时内的高峰期，也有可能是 1000 订单/秒）。即你的架构要要能支撑 1000 个订单每秒。</p><p>即使这样，内存也很难预测，一般都是根据经验值，然后进行压测分析。</p><p>非要计算：一个订单产生需要多少内存？ 512k * 1000 = 500M 内存。所以 500M 就足够，但是也可以设置得更小，只要响应时间够快，比如一秒钟 250 个订单全部进来，不到一秒后台把对象全部回收完了，也是 OK 的。</p><p>所以专业一点儿问法：比如要求响应时间 100ms</p><p>  压测</p></blockquote></li><li><p>案例2：12306 遭遇春节大规模抢票应该如何支撑？</p><blockquote><p>12306 应该是中国并发量最大的秒杀网站：</p><p>号称并发量 100w 最高</p><p>CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器 1W 并发 （单机10K问题）100 台机器</p><p>普通电商订单 -&gt; 下单 -&gt; 订单系统（IO）减库存-&gt;等待用户付款</p><p>12306 的一种可能的模型：下单-&gt;减库存 和订单(redis kafka)同时异步进行-&gt;等付款</p><p>减库存最后还会把压力压到一台服务器上</p><p>可以做分布式本地库存 + 单独服务器做库存均衡</p><p>大流量的处理方法：分而治之</p></blockquote></li><li><p>怎么得到一个事务会消耗多少内存？</p><blockquote><ol><li>弄台机器，看能承受多少 TPS？是不是达到目标？扩容或调优，让它达到</li><li>用压测来确定</li></ol></blockquote></li></ul><h2 id="7-优化环境"><a href="#7-优化环境" class="headerlink" title="7. 优化环境"></a>7. 优化环境</h2><ol><li><p>有一个 50万 PV 的资料类网站（从磁盘提取文档到内存）原服务器 32 位，1.5G 的堆，用户反馈网站比较慢（），因此公司决定升级，新的服务器为 64 位， 16G 的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了</p><ol><li><p>为什么原网站慢？</p><p>很多用户浏览数据，很多数据 load 到内存，内存不足，频繁 GC，STW 长，响应时间慢</p></li><li><p>为什么会更卡顿？</p><p>内存越大，FGC 时间越长。虽然 GC 频率变慢了，但是 STW 更长了。</p></li><li><p>咋办？</p><p>PS -&gt; PN + CMS 或者 G1</p></li></ol></li><li><p>系统 CPU 经常 100%，如何调优？（面试高频）</p><p>CPU100% 那么一定有线程在占用系统资源</p><ol><li>找出哪个进程 CPU 高（top）</li><li>该进程中的哪个线程 CPU 高（top -Hp）</li><li>导出该线程的堆栈(jstack)</li><li>查找哪个方法（栈帧）消耗时间（jstack）</li><li>工作线程占比高、垃圾回收线程占比高</li></ol></li><li><p>系统内存飙高，如何查找问题？（面试高频）</p><ol><li>导出堆内存（jmap）</li><li>分析（jhat jvisualvm mat jprofiler …）</li></ol></li><li><p>如何监控 JVM</p><ol><li>jstat jvisualvm jprofiler arthas top</li></ol></li></ol><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 调优（一）&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（九）</title>
    <link href="http://yoursite.com/2020-07-20-jvm/jvm%E5%AD%A6%E4%B9%A09_%E8%B0%83%E4%BC%983.html"/>
    <id>http://yoursite.com/2020-07-20-jvm/jvm学习9_调优3.html</id>
    <published>2020-07-20T14:13:12.000Z</published>
    <updated>2020-07-22T14:35:25.556Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 调优（三）</p><a id="more"></a><h2 id="1-arthas-在线排查工具"><a href="#1-arthas-在线排查工具" class="headerlink" title="1. arthas 在线排查工具"></a>1. arthas 在线排查工具</h2><ul><li><p>为什么需要在线排查?</p><p>在生产上我们经常会碰到一些不好排查的问题，比如线程安全问题，用最简单的 threaddump 或者 headdump 不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参数，，然后重新打包发布，如果打了日志还是没有找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题的排查进度。</p></li></ul><ul><li><p>help</p></li><li><p>JVM(相当于之前的 jinfo)，观察 jvm 信息</p></li><li><p>thread(相当于之前的 jstack)，定位线程问题。thread 54</p></li><li><p>dashboard 观察系统情况（和之前 top 类似）</p></li><li><p>heapdump 导出堆。heapdump /root/20200722.hprof 能不导就不导，最好在线定位，因为对主进程有影响。</p></li><li><p>jhat/MAT/jvisualvm 进行 dump 文件分析</p><p>jhat -J-mx512M 20200722.hprof</p><p>jhat 服务启动后，可以进入控制台查看  <a href="http://192.168.238.66:7000/" target="_blank" rel="external">http://192.168.238.66:7000/</a> </p><p>OQL 语句：select s from java.lang.String s</p></li><li><p>jad T15_FullGC_Problem01 直接反编译</p><p>动态代理生成类的问题定位</p><p>第三方的类（观察代码）</p><p>版本问题（确定自己最新提交的版本是不是被使用）</p></li><li><p>redefine 热替换</p><p>目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名称，不能改属性</p><p>可以在不停止程序的情况下修改代码。</p><p>redefine /root/testJvm/TT.class</p></li><li><p>sc - search class</p></li><li><p>watch - watch method</p></li><li><p>没有包含的功能：jmap -histo 4655 | head -20</p></li></ul><h2 id="2-案例汇总"><a href="#2-案例汇总" class="headerlink" title="2. 案例汇总"></a>2. 案例汇总</h2><p>OOM 产生的原因多种多样，有些程序未必产生 OOM，但是不断 FGC（CPU 飙高，但内存回收特别少）（上面案例）</p><ol><li><p>硬件升级系统反而卡顿问题（见前面）</p></li><li><p>线程池运用不当产生 OOM 问题（见前面）<strong>吃透</strong></p><p>不断的往 List 里加对象（实在是太 LOW）</p></li><li><p>smile jira 问题</p><p>一开始不断重启解决</p><p>最后换为 G1 垃圾回收器，扩大内存，一个月没有卡顿了。</p><p>真正问题在哪儿？不知道</p></li><li><p>tomcat http-header-size 过大问题</p></li><li><p>lambda 表达式导致<strong>方法区（Methos Area）</strong>溢出问题</p><p>LambdaGC.java -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails</p></li><li><p>直接内存溢出问题（少见）</p><p>《深入理解 Java 虚拟机》p59，使用 Unsafe 分配直接内存，或者使用 NIO 问题。</p></li><li><p>栈溢出问题（因为一个方法会产生一个 栈帧）</p><p>-Xss 设定太小</p></li><li><p>比较一下这两段程序的异同，分析哪一个是更优的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</div><div class="line">    Object o = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        o = <span class="keyword">new</span> Object();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        <span class="comment">// 循环没结束，对象一直有引用指向，方法没结束，对象不会被回收</span></div><div class="line">        Object o = <span class="keyword">new</span> Object();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>重写 finalize 引发频繁 GC</p><p>小米云，HBase 同步系统，系统通过 nginx 访问超时报警，最后排查，C++程序员重写 finalize 引发频繁 GC 问题。</p><p>为什么 C++ 程序员会重写 finalize？（new构造函数 delete 析构函数）</p><p>finalize 耗时比较长（200ms）</p></li><li><p>有一个系统，内存一直消耗不超过 10%，但是观察 GC 日志，发现 FGC 总是频繁产生，会是什么引起的？</p><p>System.gc()(这个比较low)</p></li><li><p>Distuptor 有个可以设置链的长度，如果过大，然后对象大，消费完不主动释放，会溢出</p></li><li><p>用 jvm 都会溢出，mycat 用崩过，1.6.5某个临时版本解析 sql 子查询算法有问题，9 个 exists 的联合 sql 就导致生成几百万的对象</p></li><li><p>new 大量线程，会产生 native thread OOM，（low）应该用线程池</p><p>解决方案：减少堆空间（太low了），预留更多内存产生 native thread</p><p>JVM 内存占物理内存比例 50%-80%</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 调优（三）&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（六）</title>
    <link href="http://yoursite.com/2020-07-19-jvm/jvm%E5%AD%A6%E4%B9%A06_GC.html"/>
    <id>http://yoursite.com/2020-07-19-jvm/jvm学习6_GC.html</id>
    <published>2020-07-19T14:13:12.000Z</published>
    <updated>2020-07-28T13:31:37.965Z</updated>
    
    <content type="html"><![CDATA[<p>Garbage Collector、GC tuning</p><p>目标：熟悉 GC 常用算法，熟悉常见垃圾收集器，熟悉 JVM 调优，具有实际 JVM 调优实战经验。</p><ul><li>what is garbage</li><li>how to find it</li><li>GC algorithms</li><li>available collectors</li><li>tuning</li></ul><a id="more"></a><h2 id="1-what-is-garbage"><a href="#1-what-is-garbage" class="headerlink" title="1. what is garbage?"></a>1. what is garbage?</h2><p>没有任何引用指向的一个对象或者多个对象(循环引用)就是垃圾。</p><h3 id="1-1-java-vs-C"><a href="#1-1-java-vs-C" class="headerlink" title="1.1 java vs C++"></a>1.1 java vs C++</h3><p>java</p><ul><li>GC 处理垃圾</li><li>开发效率高，执行效率低</li></ul><p>C++</p><ul><li>手工处理垃圾</li><li>忘记回收<ul><li>内存泄漏</li></ul></li><li>回收多次<ul><li>非法访问</li></ul></li><li>开发效率低，执行效率高</li></ul><h2 id="2-how-to-find-it"><a href="#2-how-to-find-it" class="headerlink" title="2. how to find it?"></a>2. how to find it?</h2><p>reference count：引用计数（即记录有多少指针指向它）。但是这种方式无法解决<strong>循环引用</strong>问题（即无法解决一团垃圾的问题）。</p><p>Root Searching：根可达算法。</p><p><img src="../../images/jvm/06/根可达算法.png" alt=""></p><h2 id="3-GC-Algorithms"><a href="#3-GC-Algorithms" class="headerlink" title="3. GC Algorithms"></a>3. GC Algorithms</h2><h3 id="3-1-Mark-Sweep-标记清除"><a href="#3-1-Mark-Sweep-标记清除" class="headerlink" title="3.1 Mark-Sweep(标记清除)"></a>3.1 Mark-Sweep(标记清除)</h3><p>标记可回收的对象，然后回收。</p><p><img src="../../images/jvm/06/标记清除算法.png" alt=""></p><p>适用情况：存活对象比较多的情况下效率较高</p><p>算法问题：两遍（第一次标记，第二次清除）扫描，效率偏低。容易产生碎片。</p><h3 id="3-2-Copying-拷贝"><a href="#3-2-Copying-拷贝" class="headerlink" title="3.2 Copying(拷贝)"></a>3.2 Copying(拷贝)</h3><p>把存活对象拷贝到另一块内存区域，然后把原来整块区域清除。</p><p><img src="../../images/jvm/06/拷贝算法.png" alt=""></p><p><img src="../../images/jvm/06/拷贝算法问题和适用场景.png" alt=""></p><p>适用场景：存活对象少。</p><p>优势：只扫描一次，效率提高，没有碎片</p><p>算法问题：空间浪费。移动复制对象，需要调整对象引用</p><h3 id="3-3-Mark-Compact-标记压缩"><a href="#3-3-Mark-Compact-标记压缩" class="headerlink" title="3.3 Mark-Compact(标记压缩)"></a>3.3 Mark-Compact(标记压缩)</h3><p>扫描同时整理存活对象，放到指定区域。</p><p><img src="../../images/jvm/06/标记压缩.png" alt=""></p><p><img src="../../images/jvm/06/标记压缩分析.png" alt=""></p><p>适用场景：</p><p>优势：不会产生碎片，方便对象分配，不会产生内存减半</p><p>算法问题：扫描两次，需要移动对象，<strong>效率偏低</strong></p><h2 id="4-JVM-内存分代模型（用于分代垃圾回收算法）"><a href="#4-JVM-内存分代模型（用于分代垃圾回收算法）" class="headerlink" title="4. JVM 内存分代模型（用于分代垃圾回收算法）"></a>4. JVM 内存分代模型（用于分代垃圾回收算法）</h2><h3 id="4-1-部分垃圾回收器使用的模型"><a href="#4-1-部分垃圾回收器使用的模型" class="headerlink" title="4.1 部分垃圾回收器使用的模型"></a>4.1 部分垃圾回收器使用的模型</h3><p>除了 Epsilon ZGC Shenandoah 之外的 GC 都是使用<strong>逻辑分代模型</strong>。</p><p>G1 是逻辑分代，物理不分代，除此之外不仅逻辑分代，而且物理分代。</p><h3 id="4-2-堆内存逻辑分区"><a href="#4-2-堆内存逻辑分区" class="headerlink" title="4.2 堆内存逻辑分区"></a>4.2 堆内存逻辑分区</h3><p>新生代+老年代+永久代(1.7) Perm Generation/元数据(1.8) Metaspace</p><ol><li>永久代 元数都存储了 Class 元信息、代码编译信息、各种层次信息、JIT</li><li>永久代必须指定大小限制，但是指定后无法修改，可能产生溢出；元数据可以设置，也可以不设置，无上限（受限于物理内存）</li><li>字符串常量 1.7 存在于<strong>永久代</strong>，但是 1.8 之后存在<strong>堆</strong>中了</li><li>MethodArea 是一个逻辑概念，永久代、元数据是其实现方式。</li><li>新生代、老年代是堆；永久代、元数据是堆之外的东西是 MethodArea</li></ol><p>新生代 = Eden + 2 个 survivor 区</p><ol><li>YGC 回收之后，大多数对象会被回收，活着的对象进入 s0</li><li>再次 YGC，eden、s0 中活着的对象进入 s1</li><li>再次 YGC，eden、s1 中活着的对象进入 s0</li><li>年龄足够，进入老年代（CMS 是 6，其他 15）</li><li>s 区装不下，进入老年代</li></ol><p>老年代</p><ol><li>顽固分子</li><li>老年代满了触发 FGC(Full GC)</li></ol><p>GC Tuning（Generation）</p><ol><li>尽量减少 FGC</li><li>MinorGC = YGC</li><li>MajorGC = FGC</li></ol><p><img src="../../images/jvm/06/堆内存逻辑分区.png" alt=""></p><p>上图 old 应该是 2。<strong>java -XX:+PrintFlagsFinal -version | grep NewRatio</strong></p><p>一个对象从出生到消亡：尝试栈上分配-&gt;分配不下则进入 Eden-&gt; 进行垃圾回收后<strong>还存活</strong>进入 s1 -&gt; s2 -&gt; 到达年龄后进入 Old。</p><p><img src="../../images/jvm/06/对象从出生到消亡.png" alt=""></p><p>栈上分配：</p><ul><li>线程私有小对象</li><li>无逃逸（只在某一段代码中使用）</li><li>支持标量替换（可以用普通类型来代替整个对象）</li><li>无需调整</li></ul><p>线程本地分配 TLAB（Thread Local Allocation Buffer）</p><ul><li>占用 eden，默认 1%。这样不会和其他线程产生争用。</li><li>多线程的时候不用竞争 eden 就可以申请空间，提高效率</li><li>小对象</li><li>无需调整</li></ul><p>老年代</p><ul><li>大对象</li></ul><p>eden</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-19 21:55</span></div><div class="line"><span class="comment"> * -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:-UseTLAB</span></div><div class="line"><span class="comment"> * 不进行逃逸分析 不进行标量替换 不进行线程专有对象分配</span></div><div class="line"><span class="comment"> * 加上上面参数后，效率明显变低。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTLAB</span> </span>&#123;</div><div class="line">    <span class="comment">// User u;</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> id;</div><div class="line">        String name;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.id = id;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> User(i, <span class="string">"name"</span> + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TestTLAB t = <span class="keyword">new</span> TestTLAB();</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000_0000</span>; i++) t.alloc(i);</div><div class="line">        System.out.println(System.currentTimeMillis() - start);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-3-GC-概念"><a href="#4-3-GC-概念" class="headerlink" title="4.3 GC 概念"></a>4.3 GC 概念</h3><p>MinoGC/YGC</p><p>MajorGC/FullGC</p><p><img src="../../images/jvm/06/GC概念.png" alt=""></p><h3 id="4-4-对象何时进入老年代"><a href="#4-4-对象何时进入老年代" class="headerlink" title="4.4 对象何时进入老年代"></a>4.4 对象何时进入老年代</h3><p>超过 <strong>XX:MaxTenuringThreshold</strong> 指定次数（YGC）</p><ul><li>Parallel Scavenge 15</li><li>CMS 6</li><li>G1 15</li></ul><p>动态年龄</p><ul><li>eden + s1 -&gt; s2 超过 50%</li><li>把年龄最大的放入 O</li><li><a href="https://www.jianshu.com/p/989d3b06a49d" target="_blank" rel="external">https://www.jianshu.com/p/989d3b06a49d</a></li></ul><p>分配担保：YGC 期间 survivor 区空间不够了，空间担保直接进入老年代</p><p><img src="../../images/jvm/06/总结.png" alt=""></p><h2 id="5-常见垃圾回收器"><a href="#5-常见垃圾回收器" class="headerlink" title="5. 常见垃圾回收器"></a>5. 常见垃圾回收器</h2><p>图要背过。</p><p><img src="../../images/jvm/06/场景垃圾回收器.png" alt=""></p><p>JDK 诞生时是 Serial 追随；为了提高效率诞生了 PS；为了配合 CMS，诞生了 PN；CMS 是 1.4 版本后期引入的，CMS 是里程碑式的 GC，它开启了并发回收的过程，但是 CMS 毛病较多，因此目前没有一个 JDK 版本默认是 CMS。</p><p>并发垃圾回收是因为无法忍受 STW。</p><p>垃圾收集器根内存大小的关系</p><ul><li>Serial 几十兆</li><li>PS 上百兆-几个G</li><li>CMS - 20G</li><li>G1 - 上百G</li><li>ZGC - 4T - 16T（JDK13）</li></ul><p>可以看出，垃圾回收器的关系和内存的大小也是息息相关的。</p><h3 id="1-Serial"><a href="#1-Serial" class="headerlink" title="1. Serial"></a>1. Serial</h3><p><img src="../../images/jvm/06/Serial.png" alt=""></p><p>stop-the-world=STW，以前内存小时用的多，对于现在系统不再适用，因为 STW 时间(<strong>停顿时间</strong>)会太长。</p><h3 id="2-serialold"><a href="#2-serialold" class="headerlink" title="2. serialold"></a>2. serialold</h3><p><img src="../../images/jvm/06/serialold.png" alt=""></p><p>和 serial 类似也是单线程回收。只是回收算法有所不同。</p><h3 id="3-Parallel-Scavenge-PS-PO"><a href="#3-Parallel-Scavenge-PS-PO" class="headerlink" title="3. Parallel Scavenge(PS + PO)"></a>3. Parallel Scavenge(PS + PO)</h3><p>如果不做特殊设置，默认就是 PS + PO 组合。</p><p><img src="../../images/jvm/06/parallelScavenge.png" alt=""></p><p>和 serial 区别时，多个回收线程。</p><h3 id="4-parallelOld"><a href="#4-parallelOld" class="headerlink" title="4. parallelOld"></a>4. parallelOld</h3><p><img src="../../images/jvm/06/parallelOld.png" alt=""></p><p>加密算法不同。</p><h3 id="5-ParNew"><a href="#5-ParNew" class="headerlink" title="5. ParNew"></a>5. ParNew</h3><p>和 Parallel Scavenge 类似，做了关于 CMS 的增强。</p><p><img src="../../images/jvm/06/ParNew.png" alt=""></p><p>和 Parallel Scavenge 区别</p><p>PN 响应时间优先</p><ul><li>配合 SMS</li></ul><p>PS 吞吐量优先</p><p><a href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html" target="_blank" rel="external">https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html</a></p><h3 id="6-CMS"><a href="#6-CMS" class="headerlink" title="6. CMS"></a>6. CMS</h3><p>老年代、并发的算法。垃圾回收和应用程序同时运行，降低 STW 的时间（200ms）</p><h4 id="6-1-CMS-原理和四个阶段"><a href="#6-1-CMS-原理和四个阶段" class="headerlink" title="6.1 CMS 原理和四个阶段"></a>6.1 CMS 原理和四个阶段</h4><ul><li>concurrent mark sweep</li><li>a mostly concuurrent,low-pause collector.</li><li>4 phases<ul><li>initial mark(标记 root 指向的对象)</li><li>concurrent mark（标记其他对象）</li><li>remark（第二个阶段过程中产生的对象）</li><li>concurrent sweep</li></ul></li></ul><p><img src="../../images/jvm/06/CMS.png" alt=""></p><h4 id="6-2-CMS-concurrent-mark-阶段的算法"><a href="#6-2-CMS-concurrent-mark-阶段的算法" class="headerlink" title="6.2 CMS concurrent mark 阶段的算法"></a>6.2 CMS concurrent mark 阶段的算法</h4><p>三色扫描算法</p><p>SATB</p><p>Incremental Update</p><h4 id="6-3-CMS-问题"><a href="#6-3-CMS-问题" class="headerlink" title="6.3 CMS 问题"></a>6.3 CMS 问题</h4><p>CMS 既然是 MarkSweep，就一定会有碎片化问题，碎片达到一定程度，CMS 的老年代对象分配不下的时候，使用 Serial Old 进行老年代回收。</p><p>PS+PO-&gt; 加内存 换垃圾回收器-&gt; PN+CMS+SerialOld(几小时-几天的STW)</p><h5 id="Memory-Fragmentation"><a href="#Memory-Fragmentation" class="headerlink" title="Memory Fragmentation"></a>Memory Fragmentation</h5><blockquote><p>-XX:+UseCMSCompactAtFullCollection</p><p>-XX:CMSFullGCsBeforeCompaction 默认为 0，指的是经过多少次 FGC 才进行压缩</p></blockquote><h5 id="Floating-Garbage"><a href="#Floating-Garbage" class="headerlink" title="Floating Garbage"></a>Floating Garbage</h5><blockquote><p>Concurrent Mode Failure</p><p>产生：</p><p>解决方案：降低触发 CMS 的阈值。 </p><p>PromotionFailed。CMS 会使用 Serial Old，单线程标记压缩，所以会有问题。</p><p>解决方案类似，保持老年代有足够的空间</p><p>-XX:CMSInitiatingOccupancyFraction 92% 可以降低这个值，让 CMS 保持老年代足够的空间。</p></blockquote><p>所以 CMS 设计的初衷就是缩短 STW 时间，但是一旦 CMS 出现上面问题，STW 反而更大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Garbage Collector、GC tuning&lt;/p&gt;
&lt;p&gt;目标：熟悉 GC 常用算法，熟悉常见垃圾收集器，熟悉 JVM 调优，具有实际 JVM 调优实战经验。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what is garbage&lt;/li&gt;
&lt;li&gt;how to find it&lt;/li&gt;
&lt;li&gt;GC algorithms&lt;/li&gt;
&lt;li&gt;available collectors&lt;/li&gt;
&lt;li&gt;tuning&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（五）</title>
    <link href="http://yoursite.com/2020-07-19-jvm/jvm%E5%AD%A6%E4%B9%A05_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html"/>
    <id>http://yoursite.com/2020-07-19-jvm/jvm学习5_运行时数据区.html</id>
    <published>2020-07-19T14:13:12.000Z</published>
    <updated>2020-07-27T14:25:11.600Z</updated>
    
    <content type="html"><![CDATA[<p>JVM Runtime Data Area and JVM Instructions<br><a id="more"></a></p><h2 id="1-指令集分类"><a href="#1-指令集分类" class="headerlink" title="1. 指令集分类"></a>1. 指令集分类</h2><ul><li>基于栈的指令集（hotspot 是基于栈的，但是它的 local variable table 类似于寄存器）</li><li>基于寄存器的指令集</li></ul><h2 id="2-Run-Time-Data-Areas"><a href="#2-Run-Time-Data-Areas" class="headerlink" title="2.  Run-Time Data Areas"></a>2.  Run-Time Data Areas</h2><p>class 加载到 JVM 后，通过运行时引擎运行，那么class 运行时在内存中是一个什么情况呢？</p><p><img src="../../images/jvm/05/classlifecycle.png" alt=""></p><h3 id="2-1-运行时内存区域有哪些？"><a href="#2-1-运行时内存区域有哪些？" class="headerlink" title="2.1 运行时内存区域有哪些？"></a>2.1 运行时内存区域有哪些？</h3><p><img src="../../images/jvm/05/runtime_data_areas.png" alt=""></p><h3 id="2-2-Program-Counter-Register（程序计数器）"><a href="#2-2-Program-Counter-Register（程序计数器）" class="headerlink" title="2.2 Program Counter Register（程序计数器）"></a>2.2 Program Counter Register（程序计数器）</h3><p><img src="../../images/jvm/05/PC.png" alt=""></p><p>每个虚拟机线程有一个自己的 PC。</p><blockquote><p>存放指令位置</p><p>虚拟机的运行，类似这样的循环：</p><p>while(not end) {</p><p>  取 PC 中的位置，找到对应位置的指令；</p><p>  执行该指令；</p><p>  PC++；</p><p>}</p></blockquote><h3 id="2-3-Direct-Memory"><a href="#2-3-Direct-Memory" class="headerlink" title="2.3 Direct Memory"></a>2.3 Direct Memory</h3><blockquote><p>JVM 可以直接访问的内核空间的内存（OS 管理的内存）</p><p>NIO，提高效率，实现 zero copy</p></blockquote><h3 id="2-4-JVM-Stacks"><a href="#2-4-JVM-Stacks" class="headerlink" title="2.4 JVM Stacks"></a>2.4 JVM Stacks</h3><p><img src="../../images/jvm/05/JVM_Stacks.png" alt=""></p><p>每个线程有自己的栈，栈中存放 frames。Frame 组成如下：</p><p><img src="../../images/jvm/05/栈帧.png" alt=""></p><ol><li><p>Frame - <strong>每个方法对应一个栈帧</strong></p><ol><li><p>Local Variable Table：局部变量表，相当于寄存器</p></li><li><p>Operand Stack：操作栈</p><p>对于 long 的处理（sotre and load），多数虚拟机的实现都是原子的</p><p>jls 17.7，没必要加 volatile</p></li><li><p>Dynamic Linking：动态连接</p><p><a href="https://blog.csdn.net/qq_41813060/article/details/88379473" target="_blank" rel="external">https://blog.csdn.net/qq_41813060/article/details/88379473</a></p><p>jvms 2.5.3</p></li><li><p>return address</p><p>a() -&gt; b()，方法 a 调用了方法 b，b 方法的返回值放在什么地方。</p></li></ol></li></ol><h3 id="2-5-Heap"><a href="#2-5-Heap" class="headerlink" title="2.5 Heap"></a>2.5 Heap</h3><p><img src="../../images/jvm/05/Heap.png" alt=""></p><p>heap 是 JVM 线程共享的。</p><h3 id="2-6-Method-Area"><a href="#2-6-Method-Area" class="headerlink" title="2.6 Method Area"></a>2.6 Method Area</h3><p><img src="../../images/jvm/05/Method_area.png" alt=""></p><p>所有 JVM 线程共享方法区。方法区存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><blockquote><p>It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and interface initialization and in instance initialization</p></blockquote><p>Method Area 的两个具体实现：</p><ol><li><p>Permanent Generation 永久代(&lt;1.8)</p><p>使用永久代来实现方法区。使得垃圾收集器能够像管理 Java 堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。</p><p>大小启动的时候指定，不能变(XX:MaxPermSize)，即使不指定也会有默认值，导致程序容易内存溢出。</p><p>字符串池常量位于 Permanent Generation</p><p>FGC 不会清理</p></li></ol><ol><li><p>Meta-space 元空间(&gt;=1.8)</p><p>在本地内存中构建元空间来实现方法区</p><p>大小不设定的话，最大就是物理内存</p><p>字符串常量池位于堆</p><p>会触发 FGC 清理</p></li></ol><p>思考：</p><blockquote><p>如何证明 1.7 字符串常量位与 Perm，而 1.8 位与 Heap？</p><p>提示：结合 GC，一直创建字符串常量，观察堆和 MetaSpace</p></blockquote><h3 id="2-7-Native-method-stacks"><a href="#2-7-Native-method-stacks" class="headerlink" title="2.7 Native method stacks"></a>2.7 Native method stacks</h3><p><img src="../../images/jvm/05/native_method_stacks.png" alt=""></p><p>是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。所以定义 -Xmx 等信息时要考虑 Direct Memory 的用量，总和不能超过物理内存。</p><h3 id="2-8-多个线程区域示意图"><a href="#2-8-多个线程区域示意图" class="headerlink" title="2.8 多个线程区域示意图"></a>2.8 多个线程区域示意图</h3><p><img src="../../images/jvm/05/总体结构.png" alt=""></p><h2 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h2><p>通过该面试题理解 <strong>JVM Stack</strong></p><ul><li>栈帧<ul><li>Local Variable Table</li><li>Operand Stack</li><li>Dynamic Linking</li><li>return address</li></ul></li></ul><h3 id="3-1-理解局部变量表和操作数栈"><a href="#3-1-理解局部变量表和操作数栈" class="headerlink" title="3.1 理解局部变量表和操作数栈"></a>3.1 理解局部变量表和操作数栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIPlusPlus</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">8</span>;</div><div class="line">        i = i++;</div><div class="line"><span class="comment">//        i = ++i;</span></div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// i = i++;</span></div><div class="line"><span class="comment">// Operand Stack 压栈 </span></div><div class="line"><span class="number">0</span> bipush <span class="number">8</span></div><div class="line"><span class="comment">// Operand Stack 出栈，并赋值给局部变量表（Local Variable Table）中一号元素    </span></div><div class="line"> <span class="number">2</span> istore_1</div><div class="line"><span class="comment">// 从局部变量表取出一号元素，Operand Stack 压栈（8）     </span></div><div class="line"> <span class="number">3</span> iload_1</div><div class="line"><span class="comment">// 局部变量表一号元素加一， Operand Stack 不变。（此时，局部变量表一号为9，Operand stack 为8）   </span></div><div class="line"> <span class="number">4</span> iinc <span class="number">1</span> by <span class="number">1</span></div><div class="line"><span class="comment">// Operand Stack 出栈，并赋值给局部变量表（Local Variable Table）中一号元素</span></div><div class="line"><span class="comment">// 因此局部变量表中一号元素又变回 8    </span></div><div class="line"> <span class="number">7</span> istore_1</div><div class="line"> 8 getstatic #2 &lt;java/lang/System.out&gt;</div><div class="line"><span class="number">11</span> iload_1</div><div class="line">12 invokevirtual #3 &lt;java/io/PrintStream.println&gt;</div><div class="line"><span class="number">15</span> <span class="keyword">return</span></div><div class="line">    </div><div class="line"><span class="comment">// i = ++i;</span></div><div class="line"><span class="comment">// 压栈    </span></div><div class="line"> <span class="number">0</span> bipush <span class="number">8</span></div><div class="line"><span class="comment">// 出栈，局部变量赋值    </span></div><div class="line"> <span class="number">2</span> istore_1</div><div class="line"><span class="comment">// 局部变量+1    </span></div><div class="line"> <span class="number">3</span> iinc <span class="number">1</span> by <span class="number">1</span></div><div class="line"><span class="comment">// 压栈（9）    </span></div><div class="line"> <span class="number">6</span> iload_1</div><div class="line"><span class="comment">// 出栈，局部变量赋值    </span></div><div class="line"> <span class="number">7</span> istore_1</div><div class="line"> 8 getstatic #2 &lt;java/lang/System.out&gt;</div><div class="line"><span class="number">11</span> iload_1</div><div class="line">12 invokevirtual #3 &lt;java/io/PrintStream.println&gt;</div><div class="line"><span class="number">15</span> <span class="keyword">return</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello_01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">0</span> bipush <span class="number">100</span></div><div class="line"><span class="number">2</span> istore_1</div><div class="line"><span class="number">3</span> <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello_02</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Hello_02 h = <span class="keyword">new</span> Hello_02();</div><div class="line">        h.m1();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">200</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// main 方法栈帧</span></div><div class="line"><span class="comment">// 对象半初始化，只是赋了默认值，对象引用入操作数栈</span></div><div class="line"> 0 new #2 &lt;com/monkeykong/c5_jvmdataareaandinstrunctions/Hello_02&gt;</div><div class="line"><span class="comment">// 复制栈顶     </span></div><div class="line"> <span class="number">3</span> dup</div><div class="line"><span class="comment">// 出栈并初始化     </span></div><div class="line"> 4 invokespecial #3 &lt;com/monkeykong/c5_jvmdataareaandinstrunctions/Hello_02.&lt;init&gt;&gt;</div><div class="line"><span class="comment">// 出栈并赋值给 h(一号局部变量)     </span></div><div class="line"> <span class="number">7</span> astore_1</div><div class="line"><span class="comment">// 一号局部变量 h 压栈     </span></div><div class="line"> <span class="number">8</span> aload_1</div><div class="line"><span class="comment">// 调用 m1 方法     </span></div><div class="line"> 9 invokevirtual #4 &lt;com/monkeykong/c5_jvmdataareaandinstrunctions/Hello_02.m1&gt;</div><div class="line"><span class="number">12</span> <span class="keyword">return</span>     </div><div class="line"><span class="comment">// m1 方法栈帧     </span></div><div class="line"><span class="comment">// s:short    </span></div><div class="line"><span class="number">0</span> sipush <span class="number">200</span></div><div class="line"><span class="number">3</span> istore_1</div><div class="line"><span class="number">4</span> <span class="keyword">return</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">300</span>;</div><div class="line">    &#125;</div><div class="line"><span class="number">0</span> sipush <span class="number">300</span></div><div class="line"><span class="comment">// 思考为什么i的变量号为 2    </span></div><div class="line"><span class="number">3</span> istore_2</div><div class="line"><span class="number">4</span> <span class="keyword">return</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> c = a + b;</div><div class="line">    &#125;</div><div class="line"><span class="number">0</span> iload_1</div><div class="line"><span class="number">1</span> iload_2</div><div class="line"><span class="number">2</span> iadd</div><div class="line"><span class="number">3</span> istore_3</div><div class="line"><span class="number">4</span> <span class="keyword">return</span></div></pre></td></tr></table></figure><p>有返回值的情况：</p><p><img src="../../images/jvm/05/基本指令.png" alt=""></p><p>递归的情况：</p><p><img src="../../images/jvm/05/递归.png" alt=""></p><h2 id="4-常用-JVM-字节码指令总结"><a href="#4-常用-JVM-字节码指令总结" class="headerlink" title="4. 常用 JVM 字节码指令总结"></a>4. 常用 JVM 字节码指令总结</h2><ul><li>bipush：将单字节的整型常量值（-128～127）推入操作数栈顶</li><li>istore_1：将操作数栈顶的整型值出栈并存放到第 1 个局部变量槽中</li><li>iload_1：将局部变量表第 1 个变量槽中的整型值复制到操作数栈顶。</li><li>iinc 1 by 1：将局部变量表第 1 个变量加 1</li><li>new：创建新对象，并把对象引用压入操作数栈栈顶</li><li><p>dup：复制操作数栈顶部值</p></li><li><p><code>&lt;clinit&gt;</code>：静态语句块</p></li><li><code>&lt;init&gt;</code>：构造函数</li><li>invoke_xxx<ul><li>InvokeStatic</li><li>InvokeVirtual：自带多态，就是 new 的是哪个对象，调用的就是哪个对象的方法</li><li>InvokeInterface：通过接口调用</li><li>InvokeSpecial：可以直接定位，不需要多态的方法 private 方法、构造方法</li><li>InvokeDynamic：JVM 最难的一条指令。lambda 表达式或者反射或者其他动态语言 scala、kotlin 或者 CGLib、ASM 动态产生的 class，会用到该指令</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM Runtime Data Area and JVM Instructions&lt;br&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（三、四）</title>
    <link href="http://yoursite.com/2020-07-16-jvm/jvm%E5%AD%A6%E4%B9%A03_4_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://yoursite.com/2020-07-16-jvm/jvm学习3_4_java内存模型.html</id>
    <published>2020-07-16T14:13:12.000Z</published>
    <updated>2020-07-27T12:08:57.930Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-CPU-内存模型"><a href="#1-CPU-内存模型" class="headerlink" title="1. CPU 内存模型"></a>1. CPU 内存模型</h2><p>硬件层的内存模型。</p><h3 id="1-1-存储器的层次结构"><a href="#1-1-存储器的层次结构" class="headerlink" title="1.1 存储器的层次结构"></a>1.1 存储器的层次结构</h3><p> 在一个典型操作系统中，可能会有几个缓存（<strong>在多核系统中，每个核心都会有自己的缓存</strong>）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了<strong>减少<code>CPU</code>读写共享主存的次数</strong>。 因为 CPU 和物理内存之间的通信速度远慢于 CPU 的处理速度 ，加入多级缓存就是为了解决<strong>处理器于内存速度之间的矛盾</strong>。</p><p><img src="../../images/jvm/03/存储器层次结构.png" alt=""></p><p>离 cpu 越近，容量更小，但是速度更快。</p><p>各个层次的速度对比：</p><p><img src="../../images/jvm/03/存储器速度.png" alt=""></p><h3 id="1-2-缓存一致性-Cache-Coherence-问题"><a href="#1-2-缓存一致性-Cache-Coherence-问题" class="headerlink" title="1.2 缓存一致性(Cache Coherence)问题"></a>1.2 缓存一致性(Cache Coherence)问题</h3><p>在多路处理器系统中，每个<strong>处理器内部(L1、L2)</strong>都有自己的高速缓存，而它们又共享同一<strong>主内存（Main Memory）</strong>，这种系统称为<strong>共享内存多核系统（Shared Memory Multiprocessors System）</strong>。</p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存时该以谁的缓存数据为准呢？从而引发缓存一致性问题。</p><p><img src="../../images/jvm/03/处理器_高速缓存_主内存关系.png" alt=""></p><p>为了解决缓存一致性问题，需要各个处理器读写高速缓存时都遵循一定的协议。这类协议有：MSI、<strong>MESI（Illinois Protocol）</strong>、MOSI、Synapse、Firefly 及 Dragon Protocol 等</p><p>Java虚拟机也有自己的内存模型，并且与这里介绍的硬件级别的内存模型有高度的可类比性。</p><h3 id="1-3-CPU-乱序执行"><a href="#1-3-CPU-乱序执行" class="headerlink" title="1.3 CPU 乱序执行"></a>1.3 CPU 乱序执行</h3><p>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，保证最终结果一样，但不保证执行顺序。</p><p>CPU 为了提高指令执行效率，会在一条指令执行过程中（比如去内存读取数据（慢100倍）），去同时执行另一条指令，前提是<strong>两条指令没有依赖关系</strong>。</p><p><img src="../../images/jvm/03/CPU指令重排序问题.png" alt=""></p><p>读可以乱序,写也可以合并。</p><p>合并写：CPU 有一个  WC cache，只有四个字节，速度比一级缓存更快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            System.out.println(i + <span class="string">" singleLoop duration (ns) ="</span> + runCaseOne());</div><div class="line">            System.out.println(i + <span class="string">" singleLoop duration (ns) ="</span> + runCaseTwo());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 直接一次写完速度反而更慢</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">int</span> i = ITERATIONS;</div><div class="line"></div><div class="line">        <span class="comment">// 写完四个字节后,剩下两个还要等待其他两个字节来填充后才提交</span></div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>)  &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</div><div class="line">            arrayA[slot] = b;</div><div class="line">            arrayB[slot] = b;</div><div class="line">            arrayC[slot] = b;</div><div class="line">            arrayD[slot] = b;</div><div class="line">            arrayE[slot] = b;</div><div class="line">            arrayF[slot] = b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.nanoTime() - start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 充分利用合并写技术,速度块一倍</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">int</span> i = ITERATIONS;</div><div class="line">        <span class="comment">// 每次四个字节,直接提交</span></div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</div><div class="line">            arrayA[slot] = b;</div><div class="line">            arrayB[slot] = b;</div><div class="line">            arrayC[slot] = b;</div><div class="line">        &#125;</div><div class="line">        i = ITERATIONS;</div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</div><div class="line">            arrayD[slot] = b;</div><div class="line">            arrayE[slot] = b;</div><div class="line">            arrayF[slot] = b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.nanoTime() - start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如何证明存在乱序执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        i++;</div><div class="line">        x = <span class="number">0</span>; y = <span class="number">0</span>;</div><div class="line">        a = <span class="number">0</span>; b = <span class="number">0</span>;</div><div class="line">        Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            shortWait(<span class="number">100000</span>);</div><div class="line">            a = <span class="number">1</span>;</div><div class="line">            x = b;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            b = <span class="number">1</span>;</div><div class="line">            y = a;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        one.start();other.start();</div><div class="line">        one.join();other.join();</div><div class="line">        String result = <span class="string">"第"</span> + i + <span class="string">"次("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>;</div><div class="line">        System.out.println(result);</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</div><div class="line">            System.err.println(result);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与处理器的乱序执行优化类似，Java虚拟机的<strong>即时编译器</strong>中也有<strong>指令重排序（Instruction Reorder）优化</strong>。</p><h3 id="1-4-保证-CPU-有序执行-内存屏障"><a href="#1-4-保证-CPU-有序执行-内存屏障" class="headerlink" title="1.4 保证 CPU 有序执行-内存屏障"></a>1.4 保证 CPU 有序执行-内存屏障</h3><p>​    sfence（读）：在 sfence（save fence） 指令前的写操作必须在 sfence 指令后的写操作前完成</p><p>​    lfence（写）：在 lfence(load fence) 指令前的读操作必须在 lfence 指令后的读操作前完成</p><p>​    mfence（读写）：在 mfence(mix fence) 指令前的读写操作必须在 mfence 指令后的读写操作前完成</p><p>intel lock 汇编指令(原子指令)</p><p>同样 JVM 也有定义自己的 JVM 内存屏障，但是底层还是靠硬件级别 CPU 内存屏障来实现的。</p><p><img src="../../images/jvm/03/数据不一致问题.png" alt=""></p><p>从上面模型看，<strong>L1、L2 是在 CPU 内部</strong>的，所以如果存在多个 CPU，就会有数据同步或者说数据不一致问题。比如：内存（主存）中有 x、y 两个变量，加入都被加载到 L1、L2，cpu1 修改了 x，在数据被写回主存之前，cpu2 是不知道数据改变了的。</p><h3 id="1-5-解决处理器数据一致性问题"><a href="#1-5-解决处理器数据一致性问题" class="headerlink" title="1.5 解决处理器数据一致性问题"></a>1.5 解决处理器数据一致性问题</h3><h4 id="1-5-1-L3-总线锁。"><a href="#1-5-1-L3-总线锁。" class="headerlink" title="1.5.1 L3 总线锁。"></a>1.5.1 L3 总线锁。</h4><p>但是这样子效率比较低，老的 CPU 才用这种方式。比如，CPU1 修改 x，就将整条总线锁住（ <strong>其他处理器就不能操作缓存了该共享变量内存地址的缓存</strong> ），导致另外一个 CPU 想访问 y 也只能等着。</p><h4 id="1-5-2-缓存-一致性协议之-MESI"><a href="#1-5-2-缓存-一致性协议之-MESI" class="headerlink" title="1.5.2 缓存 一致性协议之 MESI"></a>1.5.2 缓存 一致性协议之 MESI</h4><p>intel 使用的是 MESI，但是还有其他很多协议</p><ol><li><strong>M: 被修改（Modified)</strong> ：缓存行只被该 cpu 缓存，并且被修改过(<strong>dirty</strong>)，即与主存数据不一致。该缓存行需要在未来某个时间点<strong>写回（write back）</strong>主存。写回之前不允许其他 cpu 读取该缓存行。</li><li><strong>E: 独享的（Exclusive)</strong> ：缓存行只被该 cpu 缓存，并且数据和<strong>主存</strong>一致</li><li><strong>S: 共享的（Shared)</strong> ：缓存行被多个 cpu 缓存，并且数据都和<strong>主存</strong>一致</li><li><strong>I: 无效的（Invalid）</strong> :缓存行无效，可能被其他 cpu 修改了</li></ol><p><a href="https://www.cnblogs.com/z00377750/p/9180644.html" target="_blank" rel="external">https://www.cnblogs.com/z00377750/p/9180644.html</a> </p><p><img src="../../images/jvm/03/MESI缓存锁.png" alt=""></p><ol><li><p>现代 CPU 的缓存一致性实现是使用<strong>总线锁和缓存锁</strong>一起实现。因为有些无法被缓存的数据或者跨越多个缓存行的数据依然必须使用总线锁。</p></li><li><p>缓存行概念：cache line。cpu 读取缓存时，一般是读取一块内容，即以缓存行为基本单位，而不是申请读四个字节就只读四个字节。这一块内容就是一个基本读取单元也称为一个缓存行。现在大多数缓存行大小为 64 字节。这样会导致一个问题，CPU1 本来只想用 x，但是由于 x、y 在同一个缓存行，所以会一同读取进来；CPU2 本来只想用 y，也同样把 x、y 都读取进来了。所以当 CPU1 修改 x，会导致 CPU2 也要重新读取 x、y，这就是伪共享</p></li><li><p>伪共享：位于同一缓存行的两个不同数据，被两个不同 CPU 锁定，产生互相影响的<strong>伪共享</strong>问题。使用<strong>缓存行对齐</strong>来解决和提交效率。需要评估牺牲的空间是否值得。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_CacheLinePadding</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T[] arr= <span class="keyword">new</span> T[<span class="number">2</span>];</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</div><div class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">0</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">1</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();;</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">1000000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</div><div class="line">        <span class="comment">// 占用 56 字节,所以两个 T 对象肯定不在一个缓存行</span></div><div class="line">        <span class="comment">// 缓存行对齐</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1,p2,p3,p4,p5,p6,p7;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T[] arr= <span class="keyword">new</span> T[<span class="number">2</span>];</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</div><div class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">0</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">1</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();;</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">1000000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>很多开源软件中已经使用该方式来提高效率：</p><p><img src="../../images/jvm/03/缓存行对齐.png" alt=""></p><h2 id="2-JMM"><a href="#2-JMM" class="headerlink" title="2. JMM"></a>2. JMM</h2><h3 id="2-1-主内存与工作内存"><a href="#2-1-主内存与工作内存" class="headerlink" title="2.1 主内存与工作内存"></a>2.1 主内存与工作内存</h3><p>Java内存模型的主要目的是<strong>定义程序中各种变量的访问规则</strong>，即关注在虚拟机中把变量值存储到<br>内存和从内存中取出变量值这样的底层细节。</p><p>此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了<strong>实例字段、静态字段和构成数组对象的元素</strong>，但是<strong>不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p><ol><li><p>主内存</p><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理<br>硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）</p></li><li><p>工作内存</p><p>每条<strong>线程</strong>还有自己的<strong>工作内存</strong>（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本。</p><p><strong>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行</strong>，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p></li></ol><p><img src="../../images/jvm/03/jmm.png" alt=""></p><h3 id="2-2-主内存、工作内存交互"><a href="#2-2-主内存、工作内存交互" class="headerlink" title="2.2 主内存、工作内存交互"></a>2.2 主内存、工作内存交互</h3><p>一个变量如何从主内存拷贝到工作内存？如何从工作内存同步回主内存？</p><h4 id="JMM-定义了八大原子操作"><a href="#JMM-定义了八大原子操作" class="headerlink" title="JMM 定义了八大原子操作"></a>JMM 定义了八大原子操作</h4><p>最新的 JSR-133 已经放弃这种描述，了解即可，但是 JMM 没有变化。</p><p>《深入理解 Java 虚拟机》P364</p><ul><li><strong>lock</strong>：主内存，标识变量为线程独占</li><li><strong>unlock</strong>：主内存，解锁线程独占变量</li><li><strong>read</strong>：主内存，把变量的值从主内存传输到线程的工作内存中，以备 load 使用</li><li>load：工作内存，read 后的值放入线程本地变量副本（工作内存的变量副本）</li><li>use：工作内存，传值给执行引擎</li><li>assign：工作内存，执行引擎结果赋值给工作内存变量</li><li>store：工作内存，存值到主内存给 write 备用</li><li><strong>write</strong>：主内存，写变量值</li></ul><h3 id="2-3-对于-volatile-变量的特殊规则"><a href="#2-3-对于-volatile-变量的特殊规则" class="headerlink" title="2.3 对于 volatile 变量的特殊规则"></a>2.3 对于 volatile 变量的特殊规则</h3><h4 id="语义1：线程可见性"><a href="#语义1：线程可见性" class="headerlink" title="语义1：线程可见性"></a>语义1：线程可见性</h4><p>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以<strong>立即得知</strong>的。</p><p>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p><p><strong>错误的结论</strong>：基于volatile变量的运算在并发下是线程安全的</p><p>volatile 变量在工作内存中是不存在一致性问题的（从物理存储的角度看，可能存在不一致；但是从<strong>执行引擎</strong>角度看是不存在的，因为每次使用之前都要刷新）。但是 Java 里面的运算操作符<strong>并非原子操作</strong>，这导致 volatile 变量的运算在<strong>并发</strong>下一样是不安全的。例如 i++，可以分为三步：读取 i，i +1，写回 i，volatile 只能保证第一步是对的。</p><h4 id="语义2：禁止指令重排序"><a href="#语义2：禁止指令重排序" class="headerlink" title="语义2：禁止指令重排序"></a>语义2：禁止指令重排序</h4><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而<strong>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</strong>。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（<strong>Within-Thread As-If-Serial Semantics</strong>）。</p><p>典型的指令重排序可能导致的问题：DCL 单例。</p><h4 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h4><p>使用 HSDIS 查看 volatile 赋值操作的汇编码。</p><p>有 volatile 修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便是赋值操作）多执行了一个“<strong>lock</strong> addl$0x0，(%esp)”操作，这个操作的作用相当于一个<strong>内存屏障</strong>。</p><p>这里的关键在于 lock 前缀，查询<strong>IA32</strong>手册可知，它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核<strong>无效化（Invalidate）其缓存</strong>，这种操作相当于对缓存中的变量做了一次前面<br>介绍Java内存模式中所说的<strong>“store和write”</strong>（<strong>写回主内存</strong>）操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见。<strong>说白了就是 volatile 变量修改后立即写回主内存。</strong></p><p>lock addl$0x0，(%esp)指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“<strong>指令重排序无法越过内存屏障</strong>”的效果。</p><h4 id="JMM-对-volatile-变量的特殊规则定义"><a href="#JMM-对-volatile-变量的特殊规则定义" class="headerlink" title="JMM 对 volatile 变量的特殊规则定义"></a>JMM 对 volatile 变量的特殊规则定义</h4><p>假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：这里规则没必要细看了，理解就行。</p><ul><li>在工作内存中，每次使用V前都必须先<strong>从主内存刷新最新的值</strong>，用于保证能看见其他线程对变量V所做的修改。</li><li>在工作内存中，每次修改V后都必须<strong>立刻同步回主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。</li><li>要求volatile修饰的变量不会被指令<strong>重排序优化</strong>，从而保证代码的执行顺序与程序的顺序相同。</li></ul><h4 id="适合使用-volatile-的场景"><a href="#适合使用-volatile-的场景" class="headerlink" title="适合使用 volatile 的场景"></a>适合使用 volatile 的场景</h4><ul><li>运算结果不依赖变量的当前值，或者能保证只有单一的线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul><h3 id="2-4-针对-long-和-double-型变量的特殊规则"><a href="#2-4-针对-long-和-double-型变量的特殊规则" class="headerlink" title="2.4 针对 long 和 double 型变量的特殊规则"></a>2.4 针对 long 和 double 型变量的特殊规则</h3><p>JMM 要求 lock、unlock、read、load、assign、use、store、write 这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没<strong>有被 volatile 修饰</strong>的64 位数据的读写操作划分为<strong>两次 32 位的操作</strong>来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“<strong>long和double的非原子性协定</strong>”（Non-Atomic Treatment of double and long Variables）。</p><p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个<strong>既不是原值，也不是其他线程修改值</strong>的代表了“半个变量”的数值。不过这种读取到“半个变量”的情况是非常罕见的。</p><p><code>-XX：+AlwaysAtomicAccesses</code> JDK 9 开始，增加了这个实验性参数来约束虚拟机对所有数据类型进行原子性访问。</p><h3 id="2-5-原子性、可见性与有序性"><a href="#2-5-原子性、可见性与有序性" class="headerlink" title="2.5 原子性、可见性与有序性"></a>2.5 原子性、可见性与有序性</h3><p>JMM 是围绕着在<strong>并发</strong>过程中如何处理<strong>原子性、可见性和有序性</strong>这三个特征来建立的</p><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>由 JMM 来直接保证的原子性变量操作包括 read、load、assign、use、store和write 这六个，<br>我们大致可以认为，<strong>基本数据类型的访问、读写都是具备原子性的</strong>（long、double 例外，知道就好）</p><p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机<strong>未把 lock 和 unlock 操作直接开放给用户使用</strong>，但是却提供了更高层次的字节码指令 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块 <strong>synchronized</strong> 关键字，<strong>因此在synchronized块之间的操作也具备原子性</strong>。</p><h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>一个线程修改了共享变量，其他线程立即得知这个修改。</p><p>JMM 是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。</p><p>普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了<strong>新值能立即同步到主内存</strong>，以及每次使用前<strong>立即从主内存刷新</strong>。因此我们可以说 volatile 保证了<strong>多线程操作时变量的可见性</strong>，而普通变量则不能保证这一点。</p><p>除了 volatile 之外，<strong>synchronized 和 final</strong> 也能实现可见性。</p><ul><li>synchronized：对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li><li>final：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</li></ul><h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>如果在本线程内观察，所有的操作都是有序的；</p><p>如果在一个线程中观察另一个线程，所有的操作都是无序的。</p><p>前半句是指“<strong>线程内表现为串行的语义</strong>”（Within-Thread As-If-SerialSemantics）。</p><p>后半句是指“<strong>指令重排序</strong>”现象和“<strong>工作内存与主内存同步延迟</strong>”现象。</p><p>如何保证<strong>线程之间</strong>的操作有序性呢？</p><ul><li>volatile：本身有禁止指令重排序语义</li><li>synchronized：一个变量在同一个时刻只允许一条线程对其进行lock操作</li></ul><p>可以发现 上面三个特性都可以使用 synchronized 作为解决方案。</p><h3 id="2-6-hanppens-before-原则"><a href="#2-6-hanppens-before-原则" class="headerlink" title="2.6 hanppens-before 原则"></a>2.6 hanppens-before 原则</h3><p>操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>JMM 定义了一些“天然的”线性发生关系，他们无需任何同步器协助就已经存在。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，<strong>虚拟机可以对它们随意地进行重排序</strong>。</p><p>这只是 Java 的一个规范，具体由各个 JVM 实现。</p><p><img src="../../images/jvm/03/hanppens-before.png" alt=""></p><p><strong>时间先后顺序与先行发生原则之间基本没有因果关系</strong></p><ul><li>A 先行 B，但是时间上 A 不一定先于 B。典型的<strong>指令重排序</strong></li><li>A 时间顺序先于 B，A 不一定先行于 B。比如线程1时间上先 setValue，线程2紧接着 getValue。上面没有一个规则能证明线程1 set 操作先行于线程2 get 操作，所以如果不做手动同步处理，无法保证线程2 可以获取到正确的线程1 设置的值。</li></ul><h3 id="2-7-JVM-内存屏障"><a href="#2-7-JVM-内存屏障" class="headerlink" title="2.7 JVM 内存屏障"></a>2.7 JVM 内存屏障</h3><p>JVM 级别如何规范（JSR133）</p><p>JVM 只是一个规范，不同 CPU 的实现方式可能不同。比如龙芯、x86、arm 等 cpu 实现都不同。</p><p>LoadLoad 屏障：</p><ul><li>对于这样的语句 Load1; LoadLoad;Load2，在 Load2及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li></ul><p>StoreStore 屏障：</p><ul><li>对于这样的语句 Store1;StoreStore;Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其他处理器可见。</li></ul><p>LoadStore 屏障：</p><ul><li>对于这样的语句 Load1;StoreStore;Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据已经被读取完毕。</li></ul><p>StoreLoad 屏障：</p><ul><li>对于这样的语句 Store1;StoreStore;Load2，在 Load2 及后续读取操作执行前，保证 Store1 的写入对所有处理器可见。</li></ul><h2 id="3-volatile-的实现细节"><a href="#3-volatile-的实现细节" class="headerlink" title="3. volatile 的实现细节"></a>3. volatile 的实现细节</h2><ol><li><p>字节码层面</p><ol><li>只是增加 ACC_VOLATILE 标记</li></ol></li><li><p>JVM 层面</p><ol><li>StoreStoreBarrier;volatile 写操作;StoreLoadBarrier</li><li>LoadLoadBarrier;volatile 读操作;LoadStoreBarrier</li></ol></li><li><p>OS 和硬件层面</p><ol><li><p>使用 hsdis 观察汇编码</p></li><li><p>lock 指令 xxx 执行 xxx 指令的时候保证对内存区域加锁。</p><p>windows <strong>lock</strong> <strong>前缀</strong> 指令实现。</p><ol><li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存 </li><li>lock后的写操作会回写已修改的数据，同时让其它 CPU 相关缓存行失效，从而重新从主存中加载最新的数据 </li><li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两边的指令重排序 </li></ol></li></ol><p><a href="https://blog.csdn.net/qq_26222859/article/details/52235930" target="_blank" rel="external">https://blog.csdn.net/qq_26222859/article/details/52235930</a></p></li></ol><h2 id="4-synchronized-的实现细节"><a href="#4-synchronized-的实现细节" class="headerlink" title="4. synchronized 的实现细节"></a>4. synchronized 的实现细节</h2><ol><li>字节码层面<ol><li>同步方法：ACC_SYNCHRONIZED</li><li>同步块：jvm monitorenter monitorexit 指令</li></ol></li><li>JVM 层面<ol><li>C C++ 调用了操作系统提供的同步机制</li></ol></li><li>OS 和硬件层面<ol><li>x86:<strong>处理器</strong> lock 指令实现(lock cmpxchg/xxx)，在指令前加 lock，表示在该只能执行过程中，锁定该指令要访问的内存区域，只有这条只能能修改，其他指令无法修改。</li></ol></li></ol><p><a href="https://blog.csdn.net/21aspnet/article/details/88571740" target="_blank" rel="external">https://blog.csdn.net/21aspnet/article/details/88571740</a></p><h2 id="5-对象内存布局"><a href="#5-对象内存布局" class="headerlink" title="5. 对象内存布局"></a>5. 对象内存布局</h2><h4 id="1-请解释一些下象的创建过程？"><a href="#1-请解释一些下象的创建过程？" class="headerlink" title="1. 请解释一些下象的创建过程？"></a>1. 请解释一些下象的创建过程？</h4><ol><li>class loading</li><li>class linking（verification,preparation,resolution）</li><li>class initializing</li><li>申请对象内存</li><li>成员变量赋默认值</li><li>调用构造方法<code>&lt;init&gt;</code><ol><li>成员变量顺序赋初始值</li><li>执行构造方法语句（先调用 super 构造方法）</li></ol></li></ol><h4 id="2-对象在内存中的存储布局？"><a href="#2-对象在内存中的存储布局？" class="headerlink" title="2. 对象在内存中的存储布局？"></a>2. 对象在内存中的存储布局？</h4><ol><li>观察虚拟机配置：java -XX:+PrintCommandLineFlags -version</li></ol><p><img src="../../images/jvm/03/JVM配置.png" alt=""></p><p>可以看出 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops 默认都是开启的。</p><ol><li><p>对象大小分析</p><p>普通对象：</p><ol><li>对象头：markword 8</li><li>ClassPointer 指针（指向 T.class 对象）：-XX:+UserCompressedClassPointers 为 4 字节，不开启为 8 字节</li><li>实例数据<ol><li>引用类型：-XX:+ UseCompressedOops 为 4 字节，不开启为 8 字节。Oops Ordinary Object Pointers</li></ol></li><li>Padding 对齐，8 的倍数（比如15个字节，实际上会读取 16 个字节）</li></ol><p>数组对象：</p><ol><li>对象头</li><li>ClassPointer 指针，同上</li><li><strong>数组长度：4 字节</strong></li><li>数组数据</li><li>Padding 对齐，8 的倍数</li></ol></li><li><p>验证分析</p></li></ol><p>新建 java agent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeAgent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation inst;</div><div class="line"></div><div class="line">    <span class="comment">// 格式固定和 main 方法一样, JVM 自动调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation _inst)</span> </span>&#123;</div><div class="line">        inst = _inst;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> inst.getObjectSize(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>新建 META-INF/MANIFEST.MF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Manifest-Version: 1.0</div><div class="line">Created-By: monkeykong.com</div><div class="line">Premain-Class: com.monkeykong.jvm.agent.ObjectSizeAgent</div></pre></td></tr></table></figure><p>使用 idea -&gt; project structor -&gt; artifacts -&gt; add jar -&gt; build artifacts 打成 jar 包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-18 21:39</span></div><div class="line"><span class="comment"> * 运行时需要 Agent Jar 的类,加入参数:</span></div><div class="line"><span class="comment"> *   -javaagent:D:\01_code\01_javasebasic\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar</span></div><div class="line"><span class="comment"> * 关闭压缩 class pointer 压缩：-XX:-UseCompressedClassPointers</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SizeOfAnObject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 16:8(头 mark word)+4(class pointer 压缩)+4(padding)</span></div><div class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> Object()));</div><div class="line">        <span class="comment">// 32:8(头 mark word)+4(class pointer 压缩)+4(数组长度)+9(数组数据)+7(padding)</span></div><div class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;));</div><div class="line">        <span class="comment">// 32</span></div><div class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> P()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 一个 Object 占多少个字节</span></div><div class="line">    <span class="comment">//  -XX:+UseCompressedClassPointers -XX:+UseCompressedOops</span></div><div class="line">    <span class="comment">// Oops = ordinary object pointers 是否压缩普通对象指针</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</div><div class="line">                        <span class="comment">// 8 _markword</span></div><div class="line">                        <span class="comment">// 4 _class pointer</span></div><div class="line">        <span class="keyword">int</span> id;         <span class="comment">// 4</span></div><div class="line">        String name;    <span class="comment">// 4 因为是 64 位机器，默认为 8，但是 UseCompressedOops 开启了，所以为 4</span></div><div class="line">        <span class="keyword">int</span> age;        <span class="comment">// 4</span></div><div class="line"></div><div class="line">        <span class="keyword">byte</span> b1;        <span class="comment">// 1</span></div><div class="line">        <span class="keyword">byte</span> b2;        <span class="comment">// 1</span></div><div class="line"></div><div class="line">        Object o;       <span class="comment">// 4</span></div><div class="line">        <span class="keyword">byte</span> b3;        <span class="comment">// 1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-对象头包括什么？"><a href="#3-对象头包括什么？" class="headerlink" title="3. 对象头包括什么？"></a>3. 对象头包括什么？</h4><p>hosspot 源码，分为 32 位和 64 位。</p><p><img src="../../images/jvm/03/markword结构.png" alt=""></p><p>具体内容（32 位）：</p><p><img src="../../images/jvm/03/markword具体内容.png" alt=""></p><p>对象状态不同，大小分配也不同。主要记住三个锁标志位和 GC 标记和分代年龄。</p><p>当 Java 处在偏向锁、重量级锁状态时，hashcode 值存储在哪？</p><p><img src="../../images/jvm/03/markword相关问题.png" alt=""></p><h4 id="4-对象怎么定位？"><a href="#4-对象怎么定位？" class="headerlink" title="4. 对象怎么定位？"></a>4. 对象怎么定位？</h4><p>对象的引用怎么访问到 Java 堆中的对象的具体位置？</p><ol><li><p>句柄池</p><p> Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。 而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p>使用句柄方式最大的好处就是reference中存储的是<strong><em>稳定</em></strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时<strong>只会改变句柄中的实例数据指针</strong>，而 reference本身不需要被修改。 </p></li><li><p>直接指针</p><p> reference中直接存储的就是对象地址。使用直接指针方式最大的好处就是<strong><em>速度更快</em></strong>，他<strong><em>节省了一次指针定位的时间开销</em></strong>。 </p></li></ol><p>HotSpot 使用的是直接指针访问方式。</p><p><a href="https://blog.csdn.net/clover_lily/article/details/80095580" target="_blank" rel="external">https://blog.csdn.net/clover_lily/article/details/80095580</a></p><h4 id="5-对象怎么分配？"><a href="#5-对象怎么分配？" class="headerlink" title="5. 对象怎么分配？"></a>5. 对象怎么分配？</h4><p>GC 相关内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-CPU-内存模型&quot;&gt;&lt;a href=&quot;#1-CPU-内存模型&quot; class=&quot;headerlink&quot; title=&quot;1. CPU 内存模型&quot;&gt;&lt;/a&gt;1. CPU 内存模型&lt;/h2&gt;&lt;p&gt;硬件层的内存模型。&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习(一)</title>
    <link href="http://yoursite.com/2020-07-08-kafka/kafka%E5%AD%A6%E4%B9%A01.html"/>
    <id>http://yoursite.com/2020-07-08-kafka/kafka学习1.html</id>
    <published>2020-07-08T14:13:12.000Z</published>
    <updated>2020-08-05T12:18:03.880Z</updated>
    
    <content type="html"><![CDATA[<p>kafka 关键概念理解也演示；kafka 安装和部署；kafka 监控。<br><a id="more"></a></p><h2 id="1-什么是-kafka？"><a href="#1-什么是-kafka？" class="headerlink" title="1. 什么是 kafka？"></a>1. 什么是 kafka？</h2><h3 id="1-1-Kafka-amp-MQ-场景"><a href="#1-1-Kafka-amp-MQ-场景" class="headerlink" title="1.1 Kafka &amp; MQ 场景"></a>1.1 Kafka &amp; MQ 场景</h3><p>Apache 软件基金会开发的一个开源<strong>流处理平台</strong>，由 Scala 和 Java 编写。是一种高吞吐量的分布式发布订阅消息系统。</p><p>MQ 特性：</p><ul><li>订阅、发布</li><li>系统间解耦</li><li>异步通信</li><li>削峰填谷</li></ul><p>功能：</p><ul><li>消息队列 Message Queue</li><li>Kafka Streaming 流处理（运行在应用端）</li></ul><p>例子：用户注册和发送短信。中间可以增加消息队列，用户注册成功后，注册服务器发送一个消息后直接返回成功。</p><p><img src="../../images/kafka/异步通信_系统解耦_削峰填谷.png" alt=""></p><p><strong>问题：</strong>削峰填谷怎么实现的？大批量数据打入 mq 后，怎么实现平缓消费？背压？</p><h3 id="1-2-Kafka-架构刨析"><a href="#1-2-Kafka-架构刨析" class="headerlink" title="1.2 Kafka 架构刨析"></a>1.2 Kafka 架构刨析</h3><h4 id="常见消息队列模式"><a href="#常见消息队列模式" class="headerlink" title="常见消息队列模式"></a>常见消息队列模式</h4><ol><li>至多一次：消息确认被消费后，消息服务器主动删除队列中的数据</li><li>没有限制：消息可以被多个消费者消费。消息可以被消费多次。</li></ol><h4 id="Record、Topic、Broker、Leader-、-Fllower-和分区"><a href="#Record、Topic、Broker、Leader-、-Fllower-和分区" class="headerlink" title="Record、Topic、Broker、Leader 、 Fllower 和分区"></a>Record、Topic、Broker、Leader 、 Fllower 和分区</h4><p><strong>Record</strong>：一个 Record 属于一个 Topic</p><p><strong>Topic</strong>：每个 topic 都会对应<strong>一组</strong>分区。即一个 topic 可以有多个分区，不同分区的 leader 位于不同的 broker 机器。增打了吞吐量。</p><p><strong>Broker</strong>：Topic 的每一个日志的分区都一定会由一个 Broker 担当该分区的 Leader，其他 Broker 担当该分区的 follower。</p><p><strong>Leader</strong>：针对分区，指的是分区的 leader，leader 负责分区数据的<strong>读写</strong>操作。例如 分区 0，位与三个 broker，只会有一个 broker 担任分区 0 的 leader。</p><p><strong>Follower</strong>： 针对分区，负责同步该分区的数据。Leader 宕机，该分区的其他 Follower 会选取出新的 Leader。</p><p><strong>zookeeper</strong>：集群中的 Leader 的<strong>监控</strong>和 Topic <strong>部分元数据</strong>存储在 zookeeper。</p><p><img src="../../images/kafka/kafka集群.png" alt=""></p><p><strong>数据分发</strong>：生产者生产指定 topic 数据后，如果 record 指定了 key，会使用 hash 函数计算后取模，决定 record 存入哪个分区。hash 函数的特征是<strong>相同的内容返回相同的 hash 值，不同的内容，尽量返回不同的 hash</strong>。使得数据均匀分散在各个分区中；相同的 key 肯定在相同的分区，因为相同的 key 进行 hash 计算肯定相同。</p><p><strong>副本因子</strong>：数据一共有多少份。副本因子应该小于 broker 数量，因为同一台机器存放多个副本没有什么意义。</p><p><strong>默认持久化时间</strong>：指定 kafka 数据过多久删除，由<code>log.retention.hours=168</code> 配置指定。默认 168 小时即 7 天。</p><p><strong>分区</strong>：kafka 只能保证<strong>分区内部有序</strong>，不保证分区之间的消息的顺序。也就是说同一个 topic 如果发送消息的 key 不同，则数据可能分布在不同的分区，这样即使是同一个 topic 的数据也无法保证有序。解决方案是用户自己保证相同的 topic 的消息 key 相同？这样貌似也是有问题的，有些热点 topic 数据可能极大，如果同一个 topic key 相同，这样可能会造成分区数据倾斜，这怎么办呢？</p><p>kafka 为什么要分区？</p><ul><li>打破单机存储的容量，实现海量数据存储</li><li>提升 kafka 高并发写入性能</li></ul><h3 id="1-3-kafka-特性"><a href="#1-3-kafka-特性" class="headerlink" title="1.3 kafka 特性"></a>1.3 kafka 特性</h3><h4 id="顺序写-amp-mmap-针对生产者"><a href="#顺序写-amp-mmap-针对生产者" class="headerlink" title="顺序写&amp;mmap-针对生产者"></a>顺序写&amp;mmap-针对生产者</h4><p>Kafka 的特性之一就是<strong>高吞吐量</strong>，但是 Kafka 的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，但是 Kafka 即使是普通的服务器，Kafka 也可以轻松支持每秒百万级别的写入请求，超过了大部分的消息中间件。Kafka 会把收到的消息都写入到硬盘中，防止丢失数据，为了优化写入速度，采用了<strong>顺序写入和 MMFile</strong>。</p><p>应为硬盘是机械结构，每次读写都会寻址然后写入，其中寻址是一个机械动作，它是最耗时的，所以硬盘最讨厌随机 I/O，最喜欢顺序 I/O，为了提高读写硬盘的速度，Kafka 就是使用的<strong>顺序 I/O</strong>，这样省去了大量的内存开销以及节省了 I/O 寻址的时间，但是单纯的使用顺序写入，Kafka 的写入性能也不可能和内存进行对比，因此 Kafka 的数据并不是实时的写入硬盘中。</p><p>Kafka 充分利用了现代操作系统<strong>分页存储</strong>来利用内存，提高 I/O 效率。Memory Mapped Files（mmap）也称内存映射文件，在 64 位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的 Page 实现文件到物理内存的直接映射，完成 mmap 映射后，用户对内存的所有操作会被操作系统系统的刷新到磁盘上，极大地降低了 IO 使用率。</p><p><img src="../../images/kafka/顺序写_mmap.png" alt=""></p><h4 id="Zero-Copy-针对消费者"><a href="#Zero-Copy-针对消费者" class="headerlink" title="Zero Copy-针对消费者"></a>Zero Copy-针对消费者</h4><p>Kafka 服务器在响应客户端读取的时候，底层使用 Zero Copy 技术，无需将磁盘文件拷贝到用户空间，而是直接将数据通过内核空间传递输出，数据并没有抵达用户空间。</p><p>传统 IO 操作</p><ol><li>用户进程调用 read 等系统调用向操作系统发出 IO 请求，请求读取数据到自己的内存缓冲区中，自己进入阻塞状态。</li><li>操作系统收到请求后，进一步将 IO 请求发送磁盘</li><li>磁盘驱动器收到内核 IO 请求，把数据从磁盘读取到驱动器的缓存中，此时不占用 CPU。当驱动器的缓冲区被读满后，向内核发起<strong>中断信号</strong>，告知自己的缓冲区已满。</li><li>内核收到中断，使用 CPU 时间将磁盘驱动器缓存中的数据拷贝到内核缓冲区中。</li><li>如果内核缓冲区的数据少于用户申请读的数据，重复步骤 3 和 4，直到内核缓冲区的数据足够多为止</li><li>将数据从内核缓冲区拷贝到用户缓冲区，同时从系统调用中返回，完成任务</li></ol><p><img src="../../images/kafka/常规io.png" alt=""></p><p>DMA：<strong>提升 CPU 效率</strong>，但对用户来说没有变化</p><p><img src="../../images/kafka/DMA.png" alt=""></p><p>零拷贝：<strong>将两次用户态内核态的拷贝优化为一次内核态的拷贝</strong></p><p><img src="../../images/kafka/零拷贝.png" alt=""></p><h2 id="2-安装-amp-部署"><a href="#2-安装-amp-部署" class="headerlink" title="2. 安装&amp;部署"></a>2. 安装&amp;部署</h2><h3 id="2-1-单机-集群环境搭建"><a href="#2-1-单机-集群环境搭建" class="headerlink" title="2.1 单机/集群环境搭建"></a>2.1 单机/集群环境搭建</h3><ul><li>安装 JDK 1.8+，配置 JAVA_HOME</li><li>配置主机名和 IP 映射</li><li>关闭防火墙&amp;防火墙开机自启动</li><li>同步时钟（集群时）</li><li>安装&amp;启动 Zookeeper</li><li>安装&amp;启动|关闭 Kafka</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 查看 jdk 是否已经安装</span></div><div class="line">rpm -qa| jdk</div><div class="line"><span class="meta">#</span><span class="bash"> 安装 jdk</span></div><div class="line">rpm -ivh jdk...rpm</div><div class="line"><span class="meta">#</span><span class="bash"> 卸载</span></div><div class="line">rpm -e `rpm -qa | grep jdk`</div><div class="line"><span class="meta">#</span><span class="bash"> 查看 jdk</span></div><div class="line">ls /usr/</div><div class="line"><span class="meta">#</span><span class="bash"> 验证 jdk_home 是否配置成功</span></div><div class="line">echo $JAVA_HOME</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 修改主机名</span></div><div class="line">vim /etc/sysconfig/network</div><div class="line">  HOSTNAME=node01</div><div class="line"><span class="meta">#</span><span class="bash"> 配置主机名和IP 映射</span></div><div class="line">vim /etc/hosts</div><div class="line">  192.168.238.66 node01</div><div class="line">  192.168.238.68 node02</div><div class="line">  192.168.238.70 node03</div><div class="line">  192.168.238.72 node04</div><div class="line">ping node01</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙</span></div><div class="line">service iptables status</div><div class="line">service iptables stop</div><div class="line"><span class="meta">#</span><span class="bash"> 把防火墙服务从开机自启中删除</span></div><div class="line">chkconfig iptables off</div><div class="line">chkconfig --list</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 安装单机 zookeeper</span></div><div class="line"><span class="meta">#</span><span class="bash"> 见 zookeeper 教程</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 安装 kafka</span></div><div class="line">cd /opt</div><div class="line">tar -zxf /root/soft/kafka_2.12-2.3.1.tgz</div><div class="line">vim config/server.properties</div><div class="line"><span class="meta">  #</span><span class="bash"> broker id</span></div><div class="line">  broker.id=0</div><div class="line"><span class="meta">  #</span><span class="bash"> 监听端口号 node01 为主机名称</span></div><div class="line">  listeners=PLAINTEXT://node01:9092</div><div class="line"><span class="meta">  #</span><span class="bash"> 日志地址</span></div><div class="line">  log.dirs=/var/alvin/kafka-logs</div><div class="line"><span class="meta">  #</span><span class="bash"> zookeeper 地址</span></div><div class="line">  zookeeper.connect=node01:2181</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 启动 kafka</span></div><div class="line">./bin/kafka-server-start.sh -daemon config/server.properties</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 创建 topic</span></div><div class="line">./bin/kafka-topics.sh --help</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 报错。Replication factor: 3 larger than available brokers: 1.</span></span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092 --create --topic topic01 --partitions 2 --replication-factor 3</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 正常</span></span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092 --create --topic topic01 --partitions 3 --replication-factor 1</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 创建消费者</span></div><div class="line">./bin/kafka-console-consumer.sh --bootstrap-server node01:9092 --topic topic01 --group group1</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 创建生产者</span></div><div class="line">./bin/kafka-console-producer.sh --broker-list node01:9092 --topic topic01</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 消费组内轮询效果（组内均分效果）。</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 再为 group1 创建两个消费者，然后生产数据发现三个消费者轮询消费</span></span></div><div class="line">./bin/kafka-console-consumer.sh --bootstrap-server node01:9092 --topic topic01 --group group1</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 组间广播效果</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建一个 group2 的消费者</span></span></div><div class="line">./bin/kafka-console-consumer.sh --bootstrap-server node01:9092 --topic topic01 --group group2</div></pre></td></tr></table></figure><h3 id="2-2-kafka-集群环境搭建"><a href="#2-2-kafka-集群环境搭建" class="headerlink" title="2.2 kafka 集群环境搭建"></a>2.2 kafka 集群环境搭建</h3><h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 时钟同步</span></div><div class="line">yun install ntp -y</div><div class="line">ntpdate ntp[1-7].aliyun.com</div><div class="line">clock -w</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> zookeeper 集群</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 配置 server</span></span></div><div class="line">server.1=192.168.238.66:2888:3888</div><div class="line">server.2=192.168.238.68:2888:3888</div><div class="line">server.3=192.168.238.70:2888:3888</div><div class="line">server.4=192.168.238.72:2888:3888</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2. dataDir=/var/alvin/zookeeper 目录下增加 mypid 文件</span></span></div><div class="line">echo 1 &gt; /var/alvin/zookeeper/mypid</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> kafka 集群</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 修改 broker id</span></span></div><div class="line">broker.id=0</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2. 配置 zookeeper 连接</span></span></div><div class="line">zookeeper.connect=node01:2181,node02:2181,node03:2181</div></pre></td></tr></table></figure><h4 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建 topic02</span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --create --topic topic02 --partitions 3 --replication-factor 2</div><div class="line"><span class="meta">#</span><span class="bash"> 查看 topic 列表</span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --list</div><div class="line"><span class="meta">#</span><span class="bash"> 查看 topic 详情</span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092 --describe --topic topic02</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 创建 topic03</span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --create --topic topic03 --partitions 2 --replication-factor 3</div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092 --describe --topic topic03</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 修改 topic03 </span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 报错，分区数只能增不能减</span></span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --alter --topic topic03 --partitions 1</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 正常</span></span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --alter --topic topic03 --partitions 2</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 删除 topic</span></div><div class="line">./bin/kafka-topics.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --delete --topic topic03</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 订阅 topic01</span></div><div class="line">./bin/kafka-console-consumer.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --topic topic01 --group g1 --property print.key=true --property print.value=true --property key.separator=,</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 发布</span></div><div class="line">./bin/kafka-console-consumer.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --topic topic01 --group g1 --property print.key=true --property print.value=true --property key.separator=,</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 消费者组</span></div><div class="line">./bin/kafka-consumer-groups.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --list</div><div class="line"></div><div class="line">./bin/kafka-consumer-groups.sh --bootstrap-server node01:9092,node02:9092,node03:9092 --describe --group g1</div></pre></td></tr></table></figure><p><img src="../../images/kafka/kafka集群_me.png" alt=""></p><p>如果消息没有 key，则轮询。有 key 则根据 key hash。</p><h2 id="3-Kafka-基础-API"><a href="#3-Kafka-基础-API" class="headerlink" title="3. Kafka 基础 API"></a>3. Kafka 基础 API</h2><h3 id="3-1-topic-的基本操作"><a href="#3-1-topic-的基本操作" class="headerlink" title="3.1 topic 的基本操作"></a>3.1 topic 的基本操作</h3><p>创建、删除、列表、查看详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaTopicDml</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建 KafkaAdminClient</span></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        KafkaAdminClient adminClient = (KafkaAdminClient) KafkaAdminClient.create(props);</div><div class="line"></div><div class="line">        <span class="comment">// 创建 Topic 信息</span></div><div class="line">        CreateTopicsResult createTopicsResult = adminClient.createTopics(Arrays.asList(<span class="keyword">new</span> NewTopic(<span class="string">"topic03"</span>, <span class="number">3</span>, (<span class="keyword">short</span>) <span class="number">3</span>)));</div><div class="line">        createTopicsResult.all().get(); <span class="comment">// 修改为同步创建</span></div><div class="line"></div><div class="line">        <span class="comment">// 删除 Topic</span></div><div class="line"><span class="comment">//        DeleteTopicsResult deleteTopicsResult = adminClient.deleteTopics(Arrays.asList("topic02", "topic03"));</span></div><div class="line"><span class="comment">//        deleteTopicsResult.all().get();</span></div><div class="line"></div><div class="line">        <span class="comment">// 查看 Topic 列表</span></div><div class="line">        ListTopicsResult topicsResult = adminClient.listTopics();</div><div class="line">        Set&lt;String&gt; names = topicsResult.names().get();</div><div class="line">        <span class="keyword">for</span> (String name : names) &#123;</div><div class="line">            System.out.println(name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 查看 Topic 详细信息</span></div><div class="line">        DescribeTopicsResult dtr = adminClient.describeTopics(Arrays.asList(<span class="string">"topic01"</span>));</div><div class="line">        Map&lt;String, TopicDescription&gt; topicDescMap = dtr.all().get();</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, TopicDescription&gt; entry : topicDescMap.entrySet()) &#123;</div><div class="line">            System.out.println(entry.getKey() + <span class="string">"\t"</span> + entry.getValue());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 关闭 AdminClient</span></div><div class="line">        adminClient.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-生产者-消费者代码"><a href="#3-2-生产者-消费者代码" class="headerlink" title="3.2 生产者/消费者代码"></a>3.2 生产者/消费者代码</h3><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerQuickStart</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建 KafkaConsumer</span></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        <span class="comment">// 消费者肯定属于一个组</span></div><div class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"g1"</span>);</div><div class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line"></div><div class="line">        <span class="comment">// 2. 订阅相关的 topics</span></div><div class="line">        consumer.subscribe(Pattern.compile(<span class="string">"^topic.*"</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 遍历消息队列</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</div><div class="line">                Iterator&lt;ConsumerRecord&lt;String, String&gt;&gt; iterator = records.iterator();</div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    ConsumerRecord&lt;String, String&gt; record = iterator.next();</div><div class="line">                    System.out.println(record.topic()+<span class="string">"\t"</span>+record.partition()+<span class="string">","</span></div><div class="line">                            +record.offset()+<span class="string">"\t"</span>+record.key()+<span class="string">" "</span>+record.value()+<span class="string">" "</span>+record.timestamp());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>观察日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 启动第一个消费者（三个组全部分配给消费者1）</span></div><div class="line">Setting newly assigned partitions: topic01-2, topic01-1, topic01-0</div><div class="line"><span class="meta">#</span><span class="bash"> 再启动一个消费者</span></div><div class="line">消费者1：Setting newly assigned partitions: topic01-1, topic01-0</div><div class="line">消费者2：Setting newly assigned partitions: topic01-2</div><div class="line"><span class="meta">#</span><span class="bash"> 再启动一个消费者</span></div><div class="line">消费者1：Setting newly assigned partitions: topic01-0</div><div class="line">消费者2：Setting newly assigned partitions: topic01-1</div><div class="line">消费者3：Setting newly assigned partitions: topic01-2</div><div class="line"><span class="meta">#</span><span class="bash"> 再启动一个消费者，g2 组</span></div><div class="line">消费者4：Setting newly assigned partitions: topic01-2, topic01-1, topic01-0</div></pre></td></tr></table></figure><p>由上可以看出，同一个组内，每次新增消费者都会<strong>重新分配分区</strong>，因为组内消息消费是均分的。组间对 topic 消费是并行的。</p><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerQuickStart</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建 KafkaProducer</span></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"topic01"</span>, <span class="string">"key"</span> + i, <span class="string">"value"</span> + i);</div><div class="line">            <span class="comment">// 发送消息</span></div><div class="line">            producer.send(record);</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>手动指定消费分区和每个分区消费位置</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerQuickStart_2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建 KafkaConsumer</span></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        <span class="comment">// 不再使用 kafka 自己的组协调机制</span></div><div class="line"><span class="comment">//        props.put(ConsumerConfig.GROUP_ID_CONFIG, "g2");</span></div><div class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line"></div><div class="line">         <span class="comment">// 2. 订阅相关的 topics，手动指定消费分区，这样将失去组管理特性</span></div><div class="line"><span class="comment">//        consumer.subscribe(Pattern.compile("^topic.*"));</span></div><div class="line">        List&lt;TopicPartition&gt; partitions = Arrays.asList(<span class="keyword">new</span> TopicPartition(<span class="string">"topic01"</span>, <span class="number">0</span>),<span class="keyword">new</span> TopicPartition(<span class="string">"topic01"</span>, <span class="number">1</span>));</div><div class="line">        consumer.assign(partitions);</div><div class="line">        <span class="comment">// 指定消费分区的位置</span></div><div class="line">        <span class="comment">// consumer.seekToBeginning(partitions); // 从头开始消费</span></div><div class="line">        consumer.seek(<span class="keyword">new</span> TopicPartition(<span class="string">"topic01"</span>, <span class="number">0</span>), <span class="number">1</span>); <span class="comment">// 分区 0 从 1 开始取</span></div><div class="line">        consumer.seek(<span class="keyword">new</span> TopicPartition(<span class="string">"topic01"</span>, <span class="number">1</span>), <span class="number">2</span>); <span class="comment">// 分区 1 从 2 开始取</span></div><div class="line"></div><div class="line">        <span class="comment">// 遍历消息队列</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</div><div class="line">                Iterator&lt;ConsumerRecord&lt;String, String&gt;&gt; iterator = records.iterator();</div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    ConsumerRecord&lt;String, String&gt; record = iterator.next();</div><div class="line">                    System.out.println(record.topic()+<span class="string">"\t"</span>+record.partition()+<span class="string">","</span></div><div class="line">                            +record.offset()+<span class="string">"\t"</span>+record.key()+<span class="string">" "</span>+record.value()+<span class="string">" "</span>+record.timestamp());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这样会失去 kafka 组内消费自动协调的功能，相当于每个消费者都是独立的，不会互相影响。</p><h3 id="3-4-自定义分区策略"><a href="#3-4-自定义分区策略" class="headerlink" title="3.4 自定义分区策略"></a>3.4 自定义分区策略</h3><h4 id="默认分区策略"><a href="#默认分区策略" class="headerlink" title="默认分区策略"></a>默认分区策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DefaultPartitioner</div><div class="line">* The default partitioning strategy:</div><div class="line">* &lt;ul&gt;</div><div class="line">* &lt;li&gt;If a partition is specified in the record, use it</div><div class="line">* &lt;li&gt;If no partition is specified but a key is present choose a partition based on a hash of the key</div><div class="line">* &lt;li&gt;If no partition or key is present choose a partition in a round-robin fashion</div></pre></td></tr></table></figure><h4 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h4><p>自定义类实现 Partitioner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinePartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</div><div class="line"></div><div class="line">    AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回分区号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取所有分区</span></div><div class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</div><div class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</div><div class="line">        <span class="comment">// 没有key，轮询</span></div><div class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> andIncrement = counter.getAndIncrement();</div><div class="line">            <span class="keyword">return</span> (andIncrement &amp; Integer.MAX_VALUE) % numPartitions;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有 key hash 分发</span></div><div class="line">            <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"close..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"configure..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>生产者指定分区策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerPartitioner</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建 KafkaProducer</span></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line">        <span class="comment">// 指定自定义分区类</span></div><div class="line">        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, UserDefinePartitioner.class.getName());</div><div class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</div><div class="line">            <span class="comment">// 没有 key，轮询</span></div><div class="line">            <span class="comment">// ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("topic01", "value" + i);</span></div><div class="line">            <span class="comment">// 有 key，hash 分发</span></div><div class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"topic01"</span>, <span class="string">"key"</span> + i, <span class="string">"value"</span> + i);</div><div class="line">            <span class="comment">// 指定 partition</span></div><div class="line">            <span class="comment">// ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("topic01", 0, "key" + i, "value" + i);</span></div><div class="line"></div><div class="line">            <span class="comment">// 发送消息</span></div><div class="line">            producer.send(record);</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-消息的序列化"><a href="#3-3-消息的序列化" class="headerlink" title="3.3 消息的序列化"></a>3.3 消息的序列化</h3><p>自己定义序列化器例子。</p><p>序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefineSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"configure..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String topic, Object data) &#123;</div><div class="line">        <span class="keyword">return</span> SerializationUtils.serialize((Serializable) data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"close..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefineDeserializer</span> <span class="keyword">implements</span> <span class="title">Deserializer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"configure...."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String topic, <span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SerializationUtils.deserialize(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"close...."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-Kafka-API-高级特性"><a href="#4-Kafka-API-高级特性" class="headerlink" title="4. Kafka API 高级特性"></a>4. Kafka API 高级特性</h2><h3 id="4-1-消息拦截器"><a href="#4-1-消息拦截器" class="headerlink" title="4.1 消息拦截器"></a>4.1 消息拦截器</h3><p><code>interceptor.classes</code> 配置指定拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserdefineIntercepter</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord <span class="title">onSend</span><span class="params">(ProducerRecord record)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord(record.topic(),record.partition(),record.timestamp(),record.key(),record.value()+<span class="string">"--alvin intr"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</div><div class="line">        System.out.println(metadata.toString()+<span class="string">","</span> + exception);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-2-Offset-偏移量控制"><a href="#4-2-Offset-偏移量控制" class="headerlink" title="4.2 Offset 偏移量控制"></a>4.2 Offset 偏移量控制</h3><p>新消费者组，初始读取位置控制：</p><p>auto.offset.reset=latest/earliest/none</p><p>Kafka 消费者在消费数据的时候默认会定期的提交消费的偏移量，告诉 broker 我消费到哪里了，这样就可以保证所有的消息至少可以被消费者消费 1 次，用户可以通过以下两个参数配置：</p><ul><li>enale.atuo.commit=true 默认</li><li>auto.commit.interval.ms=5000 默认</li></ul><p>自动提交间隔问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-05 20:13</span></div><div class="line"><span class="comment"> * 新的消费者 g7，从头开始消费。</span></div><div class="line"><span class="comment"> * 在提交 offset 之前关闭程序。</span></div><div class="line"><span class="comment"> * 再启动程序，发现还是可以消费到之前的记录</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerOffest03</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Properties prop = <span class="keyword">new</span> Properties();</div><div class="line">        prop.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        prop.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        prop.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        prop.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"g7"</span>);</div><div class="line">        <span class="comment">// 默认 latest</span></div><div class="line">        prop.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</div><div class="line">        <span class="comment">// 十秒才提交 offset</span></div><div class="line">        prop.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="number">10000</span>);</div><div class="line">        <span class="comment">// 允许自动提交</span></div><div class="line">        prop.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(prop);</div><div class="line"></div><div class="line">        consumer.subscribe(Arrays.asList(<span class="string">"topic01"</span>));</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (records.isEmpty()) <span class="keyword">continue</span>;</div><div class="line">            Iterator&lt;ConsumerRecord&lt;String, String&gt;&gt; iterator = records.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                ConsumerRecord&lt;String, String&gt; record = iterator.next();</div><div class="line">                System.out.println(record.topic()+<span class="string">"\t"</span>+record.partition()+<span class="string">","</span></div><div class="line">                        +record.offset()+<span class="string">"\t"</span>+record.key()+<span class="string">" "</span>+record.value()+<span class="string">" "</span>+record.timestamp());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>手动提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-05 20:13</span></div><div class="line"><span class="comment"> * 关闭自动提交。</span></div><div class="line"><span class="comment"> * 手动提交 offset 必须加一，即提交的是下一次读取的 offset</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerOffest04</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Properties prop = <span class="keyword">new</span> Properties();</div><div class="line">        prop.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        prop.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        prop.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</div><div class="line">        prop.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"g8"</span>);</div><div class="line">        <span class="comment">// 默认 latest</span></div><div class="line">        prop.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</div><div class="line">        <span class="comment">// 允许自动提交</span></div><div class="line">        prop.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(prop);</div><div class="line"></div><div class="line">        consumer.subscribe(Arrays.asList(<span class="string">"topic01"</span>));</div><div class="line"></div><div class="line">        Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (records.isEmpty()) <span class="keyword">continue</span>;</div><div class="line">            Iterator&lt;ConsumerRecord&lt;String, String&gt;&gt; iterator = records.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                ConsumerRecord&lt;String, String&gt; record = iterator.next();</div><div class="line">                <span class="comment">// 记录消费分区的偏移量元数据，这里一定要加一，不然每个分区的最后一条数据提交不上去</span></div><div class="line">                offsets.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), <span class="keyword">new</span> OffsetAndMetadata(record.offset()+<span class="number">1</span>));</div><div class="line">                <span class="comment">// 提交消费者偏移量</span></div><div class="line">                consumer.commitAsync(offsets, <span class="keyword">new</span> OffsetCommitCallback() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</div><div class="line">                        System.out.println(<span class="string">"offsets:"</span> + offsets + <span class="string">"\texception:"</span> + exception);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">                System.out.println(record.topic()+<span class="string">"\t"</span>+record.partition()+<span class="string">","</span></div><div class="line">                        +record.offset()+<span class="string">"\t"</span>+record.key()+<span class="string">" "</span>+record.value()+<span class="string">" "</span>+record.timestamp());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-3-Acks-amp-Retries"><a href="#4-3-Acks-amp-Retries" class="headerlink" title="4.3 Acks &amp; Retries"></a>4.3 Acks &amp; Retries</h3><ul><li><p>生产者发送消息要求 Broker 在规定时间（<strong>request.timeout.ms</strong>）内应答  Ack</p></li><li><p>什么时候应答可由 Ack 配置</p><ul><li>acks=1，Leader 将 Record 记录到本地日志后，不等待 Follower 的响应，立即返回。如果 Leader 确认记录后，Follower 复制记录之前宕机，则记录将丢失。</li><li>acks=0，生产者不会等待服务器的任何确认，自己把记录添加到套接字缓冲区中就视为已发送。这种情况下不能保证服务器已经收到记录。</li><li>acks=all，Leader 等所有 Follower 确认后再给生产者回复确认。这是最有力的保证。和 acks=-1 相同。</li></ul></li><li>生产者没有收到 Broker Ack 应答或应答超时，生产者可以设置重试次数（<strong>retries</strong>)。</li></ul><p>三个配置的默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 请求超时时间，broker 在该时间内没有应答这重发</div><div class="line">request.timeout.ms=30000</div><div class="line"># 重发次数</div><div class="line">retries=214748647</div><div class="line"># 只需要 leadder 收到消息接口，不需要所有 follower 同步完成</div><div class="line">acks=1</div></pre></td></tr></table></figure><p>注意：<strong>retries 会导致数据重复。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerAcks</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Properties prop = <span class="keyword">new</span> Properties();</div><div class="line">        prop.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        prop.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line">        prop.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line"></div><div class="line">        <span class="comment">// Follower 同步完成后，Leader 应答</span></div><div class="line">        prop.put(ProducerConfig.ACKS_CONFIG, <span class="string">"all"</span>);</div><div class="line">        <span class="comment">// 超时时间设置为 1ms（模拟肯定超时场景）</span></div><div class="line">        prop.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">1</span>);</div><div class="line">        <span class="comment">// 重试 3 次，不包含初始发送那次</span></div><div class="line">        prop.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</div><div class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(prop);</div><div class="line"></div><div class="line">        producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"topic01"</span>,<span class="string">"ackskey"</span>, <span class="string">"acksvalue"</span>));</div><div class="line">        producer.flush();</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>消费后，发现数据重复。</p><h3 id="4-3-幂等性"><a href="#4-3-幂等性" class="headerlink" title="4.3 幂等性"></a>4.3 幂等性</h3><p>HTTP/1.1 中对幂等性的定义：一次和多次请求某一个资源对于资源本身也应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p>Methods can also have the property of “idempotence” in that(aside from error or expiration issues) the side-effects of N-&gt;0 indentical requests is the same as for a single request.</p><p>Kafka 在 0.11.0.0 版本增加幂等性支持。幂等是针对生产者角度的特性。保证生产者发送的消息<strong>不会丢失(retries)也不会重复</strong>。</p><p>实现幂等的关键就是服务端可以区分请求是否重复，过滤掉重复请求：</p><ul><li>请求中增加唯一标识，例如支付请求中，订单号就是唯一标识。</li><li>记录已经处理过的请求，用于和新请求的唯一标识对比，从而判断请求是否为重复请求。如果重复，则拒绝掉。</li></ul><p>幂等又称为 exactly one。在初始化期间，kafka 会给生产者生成一个唯一的 ID 称为 Producer ID 或 PID。</p><p>PID 和序列号与消息捆绑在一起，然后发送给 Broker。</p><p>序列号从零开始并且单调递增，因此，仅仅当消息的序列号比该 PID/TopicPartition 对中最后提交的消息的系列号大 1 时，Broker 才会接收该消息。如果不是这种情况，则 Broker 认定是生产者重发该消息。</p><p>开启幂等：enable.idempotence=true 默认为 false</p><p>注意：在使用幂等的时候，要求必须开启 retries=true 和 acks=all，并且 max.in.flight.requests.per.connection 小于等于 5。</p><p><img src="../../images/kafka/幂等.png" alt=""></p><p>生产者新增配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开启幂等性，默认为 false</span></div><div class="line">prop.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="keyword">true</span>);</div><div class="line"><span class="comment">// 一个连接发送未确认请求阻塞前的最大数量。</span></div><div class="line"><span class="comment">// 幂等性要求：必须小于等于 5，建议为 1。如果大于 1，并且设置了重发，就不能保证写入顺序了。</span></div><div class="line">prop.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, <span class="number">1</span>);</div></pre></td></tr></table></figure><h3 id="4-4-事务控制"><a href="#4-4-事务控制" class="headerlink" title="4.4 事务控制"></a>4.4 事务控制</h3><p>Kafka 的幂等性，只能保证一条记录在<strong>分区发送的原子性</strong>，但是如果要保证多条记录（多个分区）之间的原子性，这个时候就需要开启 Kafka 的事务了。</p><p>Kafka 在 0.11.0.0 版本增加幂等性支持的同时也加入事务的支持。</p><p>Kafka 有两种事务：</p><ol><li>生产者 only 事务</li><li>消费者 &amp; 生产之事务</li></ol><p>消费者消费的消息的级别是 read_uncommited 数据，这有可能读取到事务失败的数据（<strong>脏读</strong>），所以在开启了生产者事务之后，需要用户设置消费者的事务隔离级别(<strong>isolation.level=read_committed</strong>)，该配置默认为 read_uncommited。</p><p>开启生产者事务，只需要指定 <strong>transactional.id</strong> 属性即可，一旦开启事务，默认生产者就已经开启了幂等性。transactional.id 的取值必须是唯一的，同一时刻只能有一个 transactional.id 存在，其他的将会被关闭。</p><h4 id="生产者-only"><a href="#生产者-only" class="headerlink" title="生产者 only"></a>生产者 only</h4><p>生产者：</p><ul><li><p>transactional.id</p></li><li><p>enable.idempotence</p></li><li><p>acks</p></li><li><p>request.timeout.ms</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">producer.initTransactions();</div><div class="line">producer.beginTransaction();</div><div class="line">producer.commitTransaction();</div><div class="line">producer.abortTransaction();</div></pre></td></tr></table></figure></li></ul><p>消费者：</p><ul><li>isolation.level</li></ul><p>生产者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerTransactionProducerOnly</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        KafkaProducer&lt;String, String&gt; producer = buildKafkaProducer();</div><div class="line">        <span class="comment">// 1. 初始化事务</span></div><div class="line">        producer.initTransactions();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 2. 开启事务</span></div><div class="line">            producer.beginTransaction();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line"><span class="comment">//                if (i == 8) &#123;</span></div><div class="line"><span class="comment">//                    int j = 10/0;</span></div><div class="line"><span class="comment">//                &#125;</span></div><div class="line">                ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"topic01"</span>, <span class="string">"transaction"</span> + i, <span class="string">"right data!!!"</span> + i);</div><div class="line">                <span class="comment">// 发送消息</span></div><div class="line">                producer.send(record);</div><div class="line">                producer.flush();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 3. 提交事务</span></div><div class="line">            producer.commitTransaction();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"出现错误了~"</span> + e.getMessage());</div><div class="line">            <span class="comment">// 4. 终止事务</span></div><div class="line">            producer.abortTransaction();</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KafkaProducer&lt;String, String&gt; <span class="title">buildKafkaProducer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建 KafkaProducer</span></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"node01:9092,node02:9092,node03:9092"</span>);</div><div class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</div><div class="line"></div><div class="line">        <span class="comment">// 必须配置事务 ID。必须是唯一的</span></div><div class="line">        props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, <span class="string">"transaction-id"</span>+ UUID.randomUUID().toString());</div><div class="line">        <span class="comment">// 配置 Kafka 批处理大小</span></div><div class="line">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">1024</span>);</div><div class="line">        <span class="comment">// 如果 batch 中数据不足 1024 大小，等待 5ms</span></div><div class="line">        props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">5</span>);</div><div class="line">        <span class="comment">// 配置 Kafka 重试机制和幂等性</span></div><div class="line">        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="keyword">true</span>);</div><div class="line">        props.put(ProducerConfig.ACKS_CONFIG, <span class="string">"all"</span>);</div><div class="line">        props.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">20000</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>消费者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置消费者的消费事务的隔离级别 read_committed</span></div><div class="line">props.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, <span class="string">"read_committed"</span>);</div><div class="line"><span class="comment">// props.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_uncommitted");</span></div></pre></td></tr></table></figure><h4 id="生产者消费者事务"><a href="#生产者消费者事务" class="headerlink" title="生产者消费者事务"></a>生产者消费者事务</h4><p>消费 topic01 数据发送到 topic 02。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">    KafkaProducer&lt;String, String&gt; producer = buildKafkaProducer();</div><div class="line">    KafkaConsumer&lt;String, String&gt; consumer = buildKafkaConsumer();</div><div class="line">    <span class="comment">// 1. 初始化事务</span></div><div class="line">    producer.initTransactions();</div><div class="line"></div><div class="line">    consumer.subscribe(Arrays.asList(<span class="string">"topic01"</span>));</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (!consumerRecords.isEmpty()) &#123;</div><div class="line">            Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            Iterator&lt;ConsumerRecord&lt;String, String&gt;&gt; recordIterator = consumerRecords.iterator();</div><div class="line">            <span class="comment">// 开启事务</span></div><div class="line">            producer.beginTransaction();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 迭代数据，进行业务处理</span></div><div class="line">                <span class="keyword">while</span> (recordIterator.hasNext()) &#123;</div><div class="line">                    ConsumerRecord&lt;String, String&gt; consumerRecord = recordIterator.next();</div><div class="line">                    <span class="comment">// 存储元数据</span></div><div class="line">                    offsets.put(<span class="keyword">new</span> TopicPartition(consumerRecord.topic(),consumerRecord.partition()),</div><div class="line">                            <span class="keyword">new</span> OffsetAndMetadata(consumerRecord.offset() + <span class="number">1</span>));</div><div class="line">                    producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"topic02"</span>, consumerRecord.key(),</div><div class="line">                            consumerRecord.value() + <span class="string">" alvin..."</span>));</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 提交事务</span></div><div class="line">                producer.sendOffsetsToTransaction(offsets, <span class="string">"g1"</span>); <span class="comment">// 提交消费者的偏移量</span></div><div class="line">                producer.commitTransaction();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                System.out.println(<span class="string">"错误了~"</span>  + e.getMessage());</div><div class="line">                <span class="comment">// 终止事务</span></div><div class="line">                producer.abortTransaction();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 必须关闭消费者端的 offset 自动提交</span></div><div class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>); <span class="comment">// 为啥必须关闭?</span></div></pre></td></tr></table></figure><h2 id="5-Kafka-架构进阶"><a href="#5-Kafka-架构进阶" class="headerlink" title="5. Kafka 架构进阶"></a>5. Kafka 架构进阶</h2><h3 id="5-1-Kafka-副本同步机制"><a href="#5-1-Kafka-副本同步机制" class="headerlink" title="5.1 Kafka 副本同步机制"></a>5.1 Kafka 副本同步机制</h3><p>Kafka 的 Topic 被分为多个分区，分区是按照 Segments 存储文件块的。分区日志是存储在磁盘上的日志序列，Kafka 可以保证分区里的事件是有序的。其中 Leader 负责对应分区的读写，Follower 负责同步分区的数据。0.11 版本之前，Kafka 使用 highwatermarker 机制保证数据的同步，但是基于 highwatermarker 的同步数据可能会导致数据的不一致或者是乱序。</p><h4 id="关键概念理解"><a href="#关键概念理解" class="headerlink" title="关键概念理解"></a>关键概念理解</h4><p><strong>LEO</strong>：log end offset，标识<strong>每个分区</strong>中下一个写入位置，分区的每个副本都有自己的 LEO。</p><p><strong>HW</strong>：high watermarker 称为高水位线。所有 HW 之前的数据都可以理解为是<strong>已经备份</strong>的，当所有节点都备份成功，Leader 会更新水位线。所有副本都有自己的 LEO 和 HW。</p><p><strong>ISR</strong>：In-sync-replicas，kafka 的 leader 会维护一份<strong>处于同步的副本集合</strong>，如果在 <code>replica.lag.time.max.ms</code> 时间内，系统没有发送 fetch 请求，或者已经发送请求但是在该期限内没有赶上 leader 的数据就会被剔除 ISR 列表。0.9.0 版本剔除了 <code>replica.lag.max.messages</code> 消息个数限定，因为这个会导致其他的 broker 节点频繁的加入和退出 ISR。</p><p><strong>Leader</strong>：Leader 副本，响应 clients 端的读写请求。</p><p><strong>Follower</strong>：Follower 副本，被动的备份 leader 副本中 数据，不能响应读写。</p><p><strong>所有的副本</strong>（leader、follower）都有 LEO 和 HW 值。</p><h4 id="follower-副本更新-LEO-时机"><a href="#follower-副本更新-LEO-时机" class="headerlink" title="follower 副本更新 LEO 时机"></a>follower 副本更新 LEO 时机</h4><p>Kafka 有两套 follower 副本 LEO：1. 一套 LEO 保存在 follower 副本所在的 broker 的副本管理机中；2. 另一套 LEO 保存在 leader 副本所在的 broker 的副本管理机中。<strong>即 leader 副本机器上保存了所有 follower 副本的 LEO。</strong></p><p>第一套帮助 follower 副本更新其 HW 值；第二套帮助 leader 部分更新其 HW 值。</p><ul><li>follower 端 follower 副本的 LEO 何时更新？</li></ul><p>follower 发送 FETCH 请求后，leader 将数据返回给 follower，此时 follower 开始向底层 log 写数据，从而自动的更新 LEO 值。</p><ul><li>leader 端 follower 副本的 LEO 何时更新？</li></ul><p>leader 端 follower 副本的 LEO 更新发生在 leader 处理 follower FETCH 请求时。一旦 leader 收到 follower 发送的 FETCH 请求，它首先会从自己的 log 中读取相应的数据，但是在给 follower 返回数据之前它先去更新 follower 的 LEO。</p><h4 id="follower-副本更新-HW-时机"><a href="#follower-副本更新-HW-时机" class="headerlink" title="follower 副本更新 HW 时机"></a>follower 副本更新 HW 时机</h4><p>发生在 follower 更新 LEO 之后。HW = min(follower LEO, leader HW)。由此可见 follower 的 HW 始终小于 leader 的 HW。</p><h4 id="leader-副本更新-LEO-时机"><a href="#leader-副本更新-LEO-时机" class="headerlink" title="leader 副本更新 LEO 时机"></a>leader 副本更新 LEO 时机</h4><p>和follower更新LEO道理相同，leader写log时就会自动地更新它自己的LEO值。</p><h4 id="leader-副本更新-HW-时机"><a href="#leader-副本更新-HW-时机" class="headerlink" title="leader 副本更新 HW 时机"></a>leader 副本更新 HW 时机</h4><p>这个值直接影响分区数据对于 consumer 的可见性。</p><ul><li>副本成为 leader 副本时</li><li>broker 出现崩溃导致副本被剔除 ISR时</li><li>producer 向 leader 副本写入消息时：写入消息会更新 leader 的 LEO，所以有必要再查看下 HW 值是否也需要修改</li><li>leader 处理 follower FETCH 请求时：先从底层的 log 读取数据，然后尝试更新分区的 HW 值。选出副本中最小的 LEO 作为 HW 值。候选副本有两个条件：<ul><li>处于 ISR 中</li><li>副本 LEO 落后于 leader LEO 的时长不大于 replica.lag.time.max.ms 参数值（默认 10 s）</li></ul></li></ul><h4 id="例子：一个-topic，单分区，副本因子为-2"><a href="#例子：一个-topic，单分区，副本因子为-2" class="headerlink" title="例子：一个 topic，单分区，副本因子为 2"></a>例子：一个 topic，单分区，副本因子为 2</h4><p><img src="../../images/kafka/hw副本机制.png" alt=""></p><ul><li>producer 发送一条消息 leader 端处理<ul><li>把消息写入底层 log（同时更新了 leader 的 LEO = 1）</li><li>尝试更新 leader HW。leader LEO 和 follower LEO 最小值为 0，不更新分区 HW</li></ul></li><li>follower 发送 fetch 请求，leader 端处理<ul><li>读取底层 log 数据</li><li>更新 follower LEO = 0（思考为什么是 0 ？）</li><li>尝试更新分区的 HW = min(leader LEO, follower LEO) = 0</li><li>把数据和当前分区 HW 值（依然是 0）发送给 follower 副本</li></ul></li><li>follower 收到 fetch response 后处理<ul><li>写入本地 log（同时更新 follower LEO = 1）</li><li>尝试更新 follower HW = min(follower LEO, leader HW) = 0</li></ul></li></ul><p>此时第一轮 fetch RPC 结束，发现 leader 和 follower 都已经在 log 中保存了这条消息，但是分区 HW 值还没更新</p><ul><li>follower 再次发送 fetch 请求，leader 端处理<ul><li>读取底层 log</li><li>更新 follower LEO = 1（思考这次为什么是 1 了？）</li><li>尝试更新分区 HW， HW = min(leader LEO, follower LEO) = 1</li><li>把数据（实际上没数据）和当前分区 HW 值（已更新为 1）发送给 follower 副本</li></ul></li><li>follower 收到 fetch response 后处理<ul><li>写入本地 log（这里每东西可写）</li><li>尝试更新 follower HW = min(follower LEO, leader HW) = 1</li></ul></li></ul><h4 id="高水位截断数据丢失问题"><a href="#高水位截断数据丢失问题" class="headerlink" title="高水位截断数据丢失问题"></a>高水位截断数据丢失问题</h4><p><img src="../../images/kafka/高水位截断_数据丢失问题.png" alt=""></p><p>A 还没来得及同步 B 的水位线，A 宕机；</p><p>A 启动起来，截断 A 水位线之后的数据，尝试同步 leader B 数据</p><p>B 突然宕机，A 成为新的 leader，数据 m2 永久丢失。</p><h4 id="高水位机制数据不一致问题"><a href="#高水位机制数据不一致问题" class="headerlink" title="高水位机制数据不一致问题"></a>高水位机制数据不一致问题</h4><p><img src="../../images/kafka/高水位机制_数据不一致问题.png" alt=""></p><h4 id="解决高水位的问题"><a href="#解决高水位的问题" class="headerlink" title="解决高水位的问题"></a>解决高水位的问题</h4><p>造成上面两个问题的根本原因在于 HW 值被用于衡量副本备份的成功与否以及在出现宕机时作为日志截断的依据，但 HW 值的更新是异步延迟的，特别是需要额外的 FETCH 请求处理流程才能更新，故中间发生的任何崩溃都可能导致 HW 值的过期。</p><p>kafka 0.11 之后版本引入了 leader epoch 来解决这个问题，不再使用 HW 作为数据截断的依据。</p><p>任意一个 leader 都持有一个 leader epoch，该 leader epoch 是一个由 controller 管理的 32 位数字，存储在 zookeeper 的分区状态信息中，并作为 leaderAndIsrRequest 的一部分传递给每个新的 leader。</p><p>所谓 leader epoch 实际上是一对值：（epoch, offset），epoch 表示 leader 的版本号，从 0 开始，每次 leader 变更时 epoch 加一，offset 则对应于该 epoch 版本的 leader 写入第一条消息的 offset。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(0,0)</div><div class="line">(1,120)</div><div class="line"><span class="meta">#</span><span class="bash"> 第一个 leader 从位移 0 开始写入消息，共写了 120 条[0,199]</span></div><div class="line"><span class="meta">#</span><span class="bash"> 第二个 leader 从位移 120 开始写入消息</span></div></pre></td></tr></table></figure><p>leader broker 中会保存这样一份缓存，这份缓存会定期地写入到一个 checkpoint 文件中。</p><p>每当 leader 写底层 log 时，它会尝试更新整个缓存，如果这个 leader 是首次写消息，则会在缓存中增加一个条目；否则不做更新。</p><p>每次副本重新成为 leader 时会查询这个缓存，获取出对应的 leader 版本的位移，这样就不会发生数据不一致和丢失的情况。</p><p>leader 接收 producer 请求数据后使用 leader epoch 标记每个 message，然后该 leader epoch 编号将通过复制协议传播，并用于替换 HW 标记，作为消息截断的参考点。</p><p><img src="../../images/kafka/leader_epoch机制.png" alt=""></p><p>改进消息格式，以便每个消息集都带有一个 4 字节的 leader epoch 号。在每个日志目录中，会创建一个新的 leader epoch sequence 文件，在其中存储 leader epoch 的序列和在该 epoch 中生成的消息的 start offset。它也缓存在每个副本中，也缓存在内存中。</p><ul><li>follower 变成 leader</li></ul><p>先将新的 leader epoch 和副本的 LEO 添加到 leader epoch sequence 序列文件的末尾并刷新数据，给 leader 产生的每个新消息集都带有新的 leader epoch 标记。</p><ul><li>leader 变成 follower</li></ul><p>如果需要从本地的 leader epoch sequence 加载数据，将数据存储在内存中，给相应的分区的 leader 发送 epoch 请求，该请求包含最新的 epochId,startOffset 信息，leader 接收到信息以后返回该 epochId 所对应的 lastOffset 信息。该信息可能是最新 epochId 的 startoffset 或者是当前 epochId 的 LEO 信息。</p><p>说明：</p><p>解决数据丢失问题：</p><p><img src="../../images/kafka//epoch处理数据丢失问题.png" alt=""></p><p>解决数据不一致问题：</p><p><img src="../../images/kafka/epoche解决数据不一致问题.png" alt=""></p><h3 id="5-2-Kafka-eagle-监控"><a href="#5-2-Kafka-eagle-监控" class="headerlink" title="5.2 Kafka eagle 监控"></a>5.2 Kafka eagle 监控</h3><p>kafka eagle 是一个 kafka 监控平台。相比 kafka tools，kafka eagle 多了一个报表统计、聚合已经提醒等功能。</p><p>官网地址：<a href="http://download.kafka-eagle.org/" target="_blank" rel="external">http://download.kafka-eagle.org/</a></p><h4 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 下载软件</span></div><div class="line">http://download.kafka-eagle.org/</div><div class="line"><span class="meta">#</span><span class="bash"> 安装软件</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解压</span></span></div><div class="line">tar -zxvf kafka-eagle-bin-2.0.0.tar.gz</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 移动到安装目录</span></span></div><div class="line">mv kafka-eagle-bin-2.0.0 /opt/kafka-eagle</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解压 web 包</span></span></div><div class="line">tar -zxvf kafka-eagle-web-2.0.0-bin.tar.gz</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 配置环境变量</span></span></div><div class="line">vim /etc/profile</div><div class="line">  export KE_HOME=/opt/kafka-eagle</div><div class="line">  export PATH=$PATH:$KE_HOME/bin</div><div class="line">source /etc/profile</div><div class="line">echo $KE_HOME</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 修改 kafka eagle 配置</span></div><div class="line">vim conf/system-config.properties</div><div class="line">  kafka.eagle.zk.cluster.alias=cluster1</div><div class="line">  cluster1.zk.list=node01:2181,node02:2181,node03:2181</div><div class="line">  cluster1.kafka.eagle.offset.storage=kafka</div><div class="line">  kafka.eagle.driver=org.sqlite.JDBC</div><div class="line"><span class="meta">  #</span><span class="bash"> 这里注意 sqllite db 文件的路径</span></div><div class="line">  kafka.eagle.url=jdbc:sqlite:/opt/kafka-eagle/db/ke.db</div><div class="line">  kafka.eagle.username=root</div><div class="line">  kafka.eagle.password=123456</div><div class="line">  </div><div class="line"><span class="meta">#</span><span class="bash"> 修改 kafka 配置</span></div><div class="line">cd kafka_2.12-2.3.1/</div><div class="line">vim bin/kafka-server-start.sh</div><div class="line">    if [ "x$KAFKA_HEAP_OPTS" = "x" ]; then</div><div class="line">        export KAFKA_HEAP_OPTS="-Xmx1G -Xms1G"</div><div class="line">        export JMX_PORT="7788"</div><div class="line">    fi</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启 kafka 服务</span></span></div><div class="line">jps</div><div class="line">kill -9 11816</div><div class="line">./bin/kafka-server-start.sh -daemon config/server.properties</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 启动 kafka eagle</span></div><div class="line">chmod +x ke.sh</div><div class="line">ke.sh start</div></pre></td></tr></table></figure><p>这是一个 kafka 的监控系统。感觉实现不是很难，就是连接 kafka 做一些聚合和操作，但是别人却做出来了，而自己只会找轮子，获取这就是差别吧。</p><h3 id="5-3-Flume-和-Kafka-Sink-集成"><a href="#5-3-Flume-和-Kafka-Sink-集成" class="headerlink" title="5.3 Flume 和 Kafka Sink 集成"></a>5.3 Flume 和 Kafka Sink 集成</h3><h3 id="5-4-Spring-Boot-集成-Kafka"><a href="#5-4-Spring-Boot-集成-Kafka" class="headerlink" title="5.4 Spring Boot 集成 Kafka"></a>5.4 Spring Boot 集成 Kafka</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kafka 关键概念理解也演示；kafka 安装和部署；kafka 监控。&lt;br&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习(二)</title>
    <link href="http://yoursite.com/2020-07-08-kafka/kafka%E5%AD%A6%E4%B9%A02.html"/>
    <id>http://yoursite.com/2020-07-08-kafka/kafka学习2.html</id>
    <published>2020-07-08T14:13:12.000Z</published>
    <updated>2020-07-08T16:23:56.213Z</updated>
    
    <content type="html"><![CDATA[<p>kafka 集群安全<br><a id="more"></a></p><h2 id="1-安全概览"><a href="#1-安全概览" class="headerlink" title="1. 安全概览"></a>1. 安全概览</h2><p>目前支持的安全方式：</p><ol><li>使用 SSL 或者 SASL 对从客户端（生产者、消费者）、其他 broker 和工具到 broker 的连接进行身份认证。kafka 支持的 SASL 机制：<ol><li>SASL/GSSAPI</li><li>SASL/PLAIN</li><li>SASL/SCRAM-SHA-256/512</li><li>SASL/OAUTHBEARER</li></ol></li><li>broker 到 zookeeper 的连接身份认证</li><li>使用 SSL 对客户端和 broker 之间的数据进行加密（会有性能损耗）</li><li>客户端读写操作身份认证</li><li>身份认证是可插拔的，也可以混合</li></ol><h2 id="2-使用-SSL-进行加密和身份认证"><a href="#2-使用-SSL-进行加密和身份认证" class="headerlink" title="2. 使用 SSL 进行加密和身份认证"></a>2. 使用 SSL 进行加密和身份认证</h2><h2 id="3-使用-SASL-进行身份认证"><a href="#3-使用-SASL-进行身份认证" class="headerlink" title="3. 使用 SASL 进行身份认证"></a>3. 使用 SASL 进行身份认证</h2><h3 id="3-1-JAAS-配置"><a href="#3-1-JAAS-配置" class="headerlink" title="3.1 JAAS 配置"></a>3.1 JAAS 配置</h3><p>kafka 使用 Java 身份认证和<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html" target="_blank" rel="external">身份认证服务</a>来进行 SASL 配置。</p><h4 id="1-broker-的-JAAS-配置"><a href="#1-broker-的-JAAS-配置" class="headerlink" title="1. broker 的 JAAS 配置"></a>1. broker 的 JAAS 配置</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kafka 集群安全&lt;br&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-07-01-web/C1.html"/>
    <id>http://yoursite.com/2020-07-01-web/C1.html</id>
    <published>2020-07-01T12:11:03.399Z</published>
    <updated>2020-07-01T15:16:31.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactive（反应式）"><a href="#Reactive（反应式）" class="headerlink" title="Reactive（反应式）"></a>Reactive（反应式）</h2><p>官方定义：</p><p>Project Reactor + Spring</p><h3 id="什么式响应式处理"><a href="#什么式响应式处理" class="headerlink" title="什么式响应式处理"></a>什么式响应式处理</h3><p>non-blocking, asynchronous applications that can handle back-pressure (flow control).</p><p>背压？</p><h3 id="为什么使用响应式处理？"><a href="#为什么使用响应式处理？" class="headerlink" title="为什么使用响应式处理？"></a>为什么使用响应式处理？</h3><ul><li>better utilize modern processors. </li><li>响应式处理中的背压确保解耦组件之间有更好弹性</li></ul><h2 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a>Project Reactor</h2><p>被阻塞基础，包含背压机制。</p><p>Spring 生态系统中响应式技术栈的基石。体现在：Spring WebFlux，Spring Data，and Spring Cloud Gataway</p><h2 id="Reactive-Microservices"><a href="#Reactive-Microservices" class="headerlink" title="Reactive Microservices"></a>Reactive Microservices</h2><ul><li>效率高 efficiency</li><li>资源消耗少 does more work with fewer resources</li><li>Project Reactor、Spring WebFlux 更好的利用多核、下一代处理器。可以处理大量并发连接</li><li>使用更少的微服务实例，满足更多的并发用户</li></ul><h3 id="Spring-Boot-响应式微服务"><a href="#Spring-Boot-响应式微服务" class="headerlink" title="Spring Boot 响应式微服务"></a>Spring Boot 响应式微服务</h3><p>两套技术栈</p><p>命令式编程</p><p>响应式 web 开发：响应的是谁？客户端。</p><p>回调和异步（事件）的区别。</p><p>观察者模式</p><p>sse</p><p>websocket</p><p>webflux reactive</p><p>gateway</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reactive（反应式）&quot;&gt;&lt;a href=&quot;#Reactive（反应式）&quot; class=&quot;headerlink&quot; title=&quot;Reactive（反应式）&quot;&gt;&lt;/a&gt;Reactive（反应式）&lt;/h2&gt;&lt;p&gt;官方定义：&lt;/p&gt;
&lt;p&gt;Project React
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM 学习（二）</title>
    <link href="http://yoursite.com/2020-06-29-jvm/jvm%E5%AD%A6%E4%B9%A02_class%E5%8A%A0%E8%BD%BD.html"/>
    <id>http://yoursite.com/2020-06-29-jvm/jvm学习2_class加载.html</id>
    <published>2020-06-29T14:13:12.000Z</published>
    <updated>2020-07-26T15:24:39.469Z</updated>
    
    <content type="html"><![CDATA[<p>Class Loading Linking Initializing<br><a id="more"></a></p><h2 id="1-Class-Loading"><a href="#1-Class-Loading" class="headerlink" title="1. Class Loading"></a>1. Class Loading</h2><h3 id="1-1-class-整体加载流程"><a href="#1-1-class-整体加载流程" class="headerlink" title="1.1 class 整体加载流程"></a>1.1 class 整体加载流程</h3><ul><li>loading</li><li>linking<ul><li>verification</li><li>preparation</li><li>resolution</li></ul></li><li>initializing</li></ul><p><img src="../../images/jvm/02/class整体加载流程.png" alt=""></p><h3 id="1-2-理解-Class-对象"><a href="#1-2-理解-Class-对象" class="headerlink" title="1.2 理解 Class 对象"></a>1.2 理解 Class 对象</h3><p>Class 对象指向 class 文件被加载到内存的内存区域。通过该对象我们可以访问 class 文件内容。</p><p><img src="../../images/jvm/02/理解class对象.png" alt=""></p><h3 id="1-3-ClassLoader-级别"><a href="#1-3-ClassLoader-级别" class="headerlink" title="1.3 ClassLoader 级别"></a>1.3 ClassLoader 级别</h3><p>custom -&gt; app -&gt; extension -&gt; bootstrap</p><p><img src="../../images/jvm/02/类加载器2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T002_ClassLoaderLevel</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// bootstrap，c++ 实现，打印 null</span></div><div class="line">        System.out.println(String.class.getClassLoader());</div><div class="line">        <span class="comment">// bootstrap，c++ 实现，打印 null</span></div><div class="line">        System.out.println(sun.awt.HKSCS.class.getClassLoader());</div><div class="line">        <span class="comment">// extension，c++ 实现，打印 sun.misc.Launcher$ExtClassLoader@6d6f6e28</span></div><div class="line">        System.out.println(sun.net.spi.nameservice.dns.DNSNameService.class.getClassLoader());</div><div class="line">        <span class="comment">// classpath 内容，打印 sun.misc.Launcher$AppClassLoader@18b4aac2</span></div><div class="line">        System.out.println(T002_ClassLoaderLevel.class.getClassLoader());</div><div class="line"></div><div class="line">        <span class="comment">// Launcher$ExtClassLoader.class 的 class loader =&gt; bootstrap，打印 null</span></div><div class="line">        System.out.println(sun.net.spi.nameservice.dns.DNSNameService.class.getClassLoader().getClass().getClassLoader());</div><div class="line">        <span class="comment">// Launcher$AppClassLoader.class 的 class loader =&gt; bootstrap，打印 null</span></div><div class="line">        System.out.println(T002_ClassLoaderLevel.class.getClassLoader().getClass().getClassLoader());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-4-ClassLoader-Scope"><a href="#1-4-ClassLoader-Scope" class="headerlink" title="1.4 ClassLoader Scope"></a>1.4 ClassLoader Scope</h3><p>从 Launcher 源码可以找到三那个类加载器加载的 class 范围。</p><p><img src="../../images/jvm/02/各个类加载器加载范围.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T003_ClassLoaderScope</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// bootstrap classloader 加载哪些类?</span></div><div class="line">        String pathBoot = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</div><div class="line">        System.out.println(pathBoot.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</div><div class="line"></div><div class="line">        <span class="comment">// ext classloader 加载哪些类?</span></div><div class="line">        System.out.println(<span class="string">"------------"</span>);</div><div class="line">        String pathExt = System.getProperty(<span class="string">"java.ext.dirs"</span>);</div><div class="line">        System.out.println(pathExt.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</div><div class="line"></div><div class="line">        <span class="comment">// app classloader 加载哪些类?</span></div><div class="line">        System.out.println(<span class="string">"------------"</span>);</div><div class="line">        String pathApp = System.getProperty(<span class="string">"java.class.path"</span>);</div><div class="line">        System.out.println(pathApp.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">D:\jdk\jdk1.8\jre\lib\resources.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\rt.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\sunrsasign.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jsse.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jce.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\charsets.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jfr.jar</div><div class="line">D:\jdk\jdk1.8\jre\classes</div><div class="line">------------</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext</div><div class="line">C:\WINDOWS\Sun\Java\lib\ext</div><div class="line">------------</div><div class="line">D:\jdk\jdk1.8\jre\lib\charsets.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\deploy.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\access-bridge-<span class="number">64</span>.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\cldrdata.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\dnsns.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\jaccess.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\jfxrt.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\localedata.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\nashorn.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\sunec.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\sunjce_provider.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\sunmscapi.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\sunpkcs11.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\ext\zipfs.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\javaws.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jce.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jfr.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jfxswt.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\jsse.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\management-agent.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\plugin.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\resources.jar</div><div class="line">D:\jdk\jdk1.8\jre\lib\rt.jar</div><div class="line">D:\<span class="number">01</span>_code\<span class="number">01</span>_javasebasic\learnJvm\target\classes</div><div class="line">C:\IntelliJ IDEA <span class="number">2019.2</span>.3\lib\idea_rt.jar</div></pre></td></tr></table></figure><h3 id="1-5-ClassLoader-Child-and-Parent"><a href="#1-5-ClassLoader-Child-and-Parent" class="headerlink" title="1.5 ClassLoader Child and Parent"></a>1.5 ClassLoader Child and Parent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T004_ParentAndChild</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// AppClassloader</span></div><div class="line">        System.out.println(T004_ParentAndChild.class.getClassLoader());</div><div class="line">        <span class="comment">// AppClassloader is loaded by bootstrap classloader,print null</span></div><div class="line">        System.out.println(T004_ParentAndChild.class.getClassLoader().getClass().getClassLoader());</div><div class="line">        <span class="comment">// the parent classloader of AppClassloader  =&gt; ExtClassLoader</span></div><div class="line">        System.out.println(T004_ParentAndChild.class.getClassLoader().getParent());</div><div class="line">        <span class="comment">// the parent classloader of ExtClassLoader =&gt; bootstrap classloader,print null</span></div><div class="line">        System.out.println(T004_ParentAndChild.class.getClassLoader().getParent().getParent());</div><div class="line"><span class="comment">//        System.out.println(T004_ParentAndChild.class.getClassLoader().getParent().getParent().getParent());</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-6-Load-class-by-hand"><a href="#1-6-Load-class-by-hand" class="headerlink" title="1.6 Load class by hand"></a>1.6 Load class by hand</h3><p>ClassLoader.loadClass(name) 得到该类的 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T005_LoadClassByHand</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">        <span class="comment">// 拿到 classloader</span></div><div class="line">        ClassLoader appClassLoader = T005_LoadClassByHand.class.getClassLoader();</div><div class="line">        <span class="comment">// 加载</span></div><div class="line">        Class clazz = appClassLoader.loadClass(<span class="string">"com.monkeykong.classloader.T005_LoadClassByHand"</span>);</div><div class="line">        System.out.println(clazz.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-7-自定义-class-loader"><a href="#1-7-自定义-class-loader" class="headerlink" title="1.7 自定义 class loader"></a>1.7 自定义 class loader</h3><h4 id="如何自定义？"><a href="#如何自定义？" class="headerlink" title="如何自定义？"></a>如何自定义？</h4><p>继承 ClassLoader，重写 findClass 方法即可，如果需要返回 Class 对象，调用父类的 defineClass 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T006_AlvinClasssLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\01_code\\01_javasebasic\\learnJvm\\target\\classes\\"</span>,</div><div class="line">                name.replaceAll(<span class="string">"."</span>, <span class="string">"/"</span>).concat(<span class="string">".class"</span>));</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</div><div class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> ((b = fis.read()) != <span class="number">0</span>) &#123;</div><div class="line">                baos.write(b);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</div><div class="line">            baos.close();</div><div class="line">            fis.close();</div><div class="line">            <span class="comment">// 把二进制内容转换为 class 对象返回</span></div><div class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassLoader l = <span class="keyword">new</span> T006_AlvinClasssLoader();</div><div class="line">        Class&lt;?&gt; clazz = l.loadClass(<span class="string">"com.monkeykong.classloader.Hello"</span>);</div><div class="line">        Hello h = (Hello)clazz.newInstance();</div><div class="line">        h.m();</div><div class="line"></div><div class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></div><div class="line">        System.out.println(h.getClass().getClassLoader());</div><div class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></div><div class="line">        System.out.println(l.getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="自定义类加载器的-parent-是哪个？"><a href="#自定义类加载器的-parent-是哪个？" class="headerlink" title="自定义类加载器的 parent 是哪个？"></a>自定义类加载器的 parent 是哪个？</h4><p>这其实是一个继承的基础问题。创建子类对象时，如果没有显示调用父类构造方法，会调用父类默认的构造方法。ClassLoader 默认的构造方法中获取了 parent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 最终调用 Luncher 的构造函数获取 systemClassLoader</span></div><div class="line"><span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</div></pre></td></tr></table></figure><h3 id="1-8-双亲委派机制"><a href="#1-8-双亲委派机制" class="headerlink" title="1.8 双亲委派机制"></a>1.8 双亲委派机制</h3><h4 id="父加载器和委派机制"><a href="#父加载器和委派机制" class="headerlink" title="父加载器和委派机制"></a>父加载器和委派机制</h4><ul><li>父加载器（<strong>不是类加载器的加载器；也不是类加载器的父类的类加载器</strong>），而是加载其中 parent 属性所执行的类加载器。</li><li>双亲委派是一个孩子向父亲方向查找类是否已经加载，然后父亲向孩子方向的委托加载类过程。</li></ul><h4 id="为什么需要双亲委派机制？"><a href="#为什么需要双亲委派机制？" class="headerlink" title="为什么需要双亲委派机制？"></a>为什么需要双亲委派机制？</h4><p>主要原因出于<strong>安全考虑</strong>。如果任何类都可以 load 到内存，如果我们自己定义一个 java.lang.String 并用我们自定义的类加载器载入内存，把 java 原生的 String 覆盖掉，然后把这个类打包成类库发布出去让客户使用。因为这个类是我们自己写的，想做什么操作都行，我们甚至可以把所有密码都读出来发个邮件给自己。</p><p>如果采用双亲委派就不会有这种问题。因为会向上查找该类是否已经加载过，如果加载过直接返回，不会再加载。</p><p>次要原因是使用了缓存，可以节省资源。</p><h4 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制?"></a>如何打破双亲委派机制?</h4><p>重写 loadClass() 方法，不再按照默认的查找和加载逻辑即可打破。</p><p>何时打破过该机制?</p><ul><li>JDK 1.2 之前,自定义 ClassLoader 都必须重写 loadClass()</li><li>ThreadContextClassLoader 可以实现基础类调用实现类代码,通过 thread.setContextClassLoader 指定</li><li><strong>热启动，热部署，热加载</strong>。osgi、tomcat 都有自己的模块指定 classloader（可以加载用一类库的不同版本，即可以加载同名类）</li></ul><h3 id="1-9-ClassLoader-源码解析"><a href="#1-9-ClassLoader-源码解析" class="headerlink" title="1.9 ClassLoader 源码解析"></a>1.9 ClassLoader 源码解析</h3><h4 id="ClassLoader-loadClass"><a href="#ClassLoader-loadClass" class="headerlink" title="ClassLoader#loadClass"></a>ClassLoader#loadClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ClassLoader 的 parent 为 final 类型，没法修改，所以不得不遵守双亲委派规则，我们自己没法修改</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</div><div class="line"></div><div class="line"><span class="comment">// 加载一个类传入类名字就行</span></div><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">        <span class="comment">// First, check if the class has already been loaded</span></div><div class="line">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">        <span class="comment">// 如已经加载直接返回</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 如果没加载，查询 parent 是否已经加载。这里类似递归</span></div><div class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    c = findBootstrapClassOrNull(name);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                <span class="comment">// from the non-null parent class loader</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 找完所有父类都没有加载过该类，开始 findclass 加载</span></div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></div><div class="line">                <span class="comment">// to find the class.</span></div><div class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                c = findClass(name);</div><div class="line"></div><div class="line">                <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (resolve) &#123;</div><div class="line">            resolveClass(c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ClassLoader-findClass"><a href="#ClassLoader-findClass" class="headerlink" title="ClassLoader#findClass"></a>ClassLoader#findClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空实现，类型为 protected，由子类来实现，这就是典型的<strong>模板方法</strong>设计模式的使用。由此我们也可以看出，我们自定义 classloader 时，只需要重写 findClass 方法即可。</p><h4 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h4><p>将字节数组转为 Class 对象。defineClass 是 final 方法，所以自定义类加载器无法重写该方法。defineClass 中还有一些安全校验，比如不允许加载<code>java.</code>开头的类，因为这些类是 java 的核心类，应该由 bootstrap 类加载器来加载。</p><h2 id="2-Class-Linking"><a href="#2-Class-Linking" class="headerlink" title="2. Class Linking"></a>2. Class Linking</h2><ol><li><strong>Verification</strong><ol><li>验证文件是否符合 JVM 规定</li></ol></li><li><strong>Preparation</strong><ol><li>静态成员变量赋默认值</li></ol></li><li><strong>Resolution</strong><ol><li>将类、方法、属性等符号引用解析为直接引用</li><li>常量池中的各种符号引用解析为指针、偏移量等<strong>内存地址</strong>的直接引用</li></ol></li></ol><h2 id="3-Class-Initializing"><a href="#3-Class-Initializing" class="headerlink" title="3. Class Initializing"></a>3. Class Initializing</h2><p>调用类<strong>初始化代码</strong>，给<strong>静态成员变量</strong>赋初始值</p><p>理解类加载过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T001_ClassLoadingProcedure</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 2/3</span></div><div class="line">        System.out.println(T.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T t = <span class="keyword">new</span> T(); <span class="comment">// t：默认值 null</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">// count：默认值 0</span></div><div class="line"></div><div class="line">    <span class="comment">// 普通成员变量也有两个过程，因为创建对象有申请空间和调用构造方法两个步骤。</span></div><div class="line">    <span class="comment">// 1. new T() 时，申请内存，m = 0</span></div><div class="line">    <span class="comment">// 2. 执行构造方法时，m = 8</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">()</span> </span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>问题：懒汉模式，DCL 单例，是否需要加 volatile ?</p><p>答案：需要。新建对象时，可能存在<strong>指令重排序</strong>问题。正常来说，应该是<strong>分配空间-&gt;赋默认值-&gt;赋初始值-&gt;变量指向内存空间</strong>。但是如果出现指令重排序，可能赋默认值后，先给变量指向内存空间了，所以必须要 volatile 来<strong>禁止指令重排序</strong>。</p><p> 如果 invokespecial 和 astore 指令顺序反转，那么就可以对象还没有初始化完成，就被其他线程拿去用了，所以必须要加 volatile </p><p><img src="D:/02_blog/blog/source/images/jvm/03/新建类对象指令重排序问题.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Class Loading Linking Initializing&lt;br&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习（一）</title>
    <link href="http://yoursite.com/2020-06-28-jvm/jvm%E5%AD%A6%E4%B9%A01_jvm%E5%9F%BA%E7%A1%80_jsf.html"/>
    <id>http://yoursite.com/2020-06-28-jvm/jvm学习1_jvm基础_jsf.html</id>
    <published>2020-06-28T14:13:12.000Z</published>
    <updated>2020-07-28T11:50:55.132Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JVM基础</li><li>java class format</li></ul><a id="more"></a><h2 id="1-JVM-基础"><a href="#1-JVM-基础" class="headerlink" title="1. JVM 基础"></a>1. JVM 基础</h2><h3 id="1-1-java-从编码到执行"><a href="#1-1-java-从编码到执行" class="headerlink" title="1.1  java 从编码到执行"></a>1.1  <strong>java 从编码到执行</strong></h3><ul><li>编译器编译源文件为 class 文件</li><li>java 运行时通过 classLoader 加载 class 文件到内存</li><li>JVM 解释执行 class 文件</li></ul><p><img src="../../images/jvm/01/java从编码到执行.png" alt=""></p><h3 id="1-2-JVM，从跨平台的语言到跨语言的平台"><a href="#1-2-JVM，从跨平台的语言到跨语言的平台" class="headerlink" title="1.2  JVM，从跨平台的语言到跨语言的平台"></a>1.2  <strong>JVM，从跨平台的语言到跨语言的平台</strong></h3><p>目前 JVM 支持任何能编译为 class 文件的语言，支持多个操作系统。</p><p><img src="../../images/jvm/01/JVM_跨语言的平台.png" alt=""></p><p>JVM 根 java 没有什么必然关系，任何能编译为字节码文件的语言都可以使用 JVM 解释执行。</p><p><img src="../../images/jvm/01/JVM和java无关.png" alt=""></p><h3 id="1-3-JVM-是一种规范"><a href="#1-3-JVM-是一种规范" class="headerlink" title="1.3 JVM 是一种规范"></a>1.3 JVM 是一种规范</h3><p> java virtual machine specifications 。</p><p>官方规范文档：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/13/" target="_blank" rel="external">https://docs.oracle.com/en/java/javase/13/</a> </li><li><a href="https://docs.oracle.com/javas/specs/index.html" target="_blank" rel="external">https://docs.oracle.com/javas/specs/index.html</a> </li></ul><p>JVM 是虚构出来的一台计算机，它有自己的：</p><ul><li><p>字节码指令集（汇编语言）</p></li><li><p>内存管理：栈、堆、方法区等</p></li></ul><h3 id="1-4-常见-JVM-实现"><a href="#1-4-常见-JVM-实现" class="headerlink" title="1.4 常见 JVM 实现"></a>1.4 常见 JVM 实现</h3><p>Hotspot</p><ul><li><p>oracle 官方，我们做实验用的 JVM </p><ul><li>java -version 可以看到</li></ul></li></ul><p>Jrockit</p><ul><li>BEA，曾经号称世界上最快的 JVM</li></ul><ul><li>被 Orable 收购，合并于 hotspot</li></ul><p>J9 - IBM</p><p>Microsoft VM</p><p>TaobaoVM</p><ul><li>hotspot 深度定制版</li></ul><p>LiquidVM</p><ul><li>直接针对硬件</li></ul><p>azul zing</p><ul><li><p>最新垃圾回收的业界标杆</p></li><li><p>www.azul.com</p></li><li><p>是一个商业产品，收费的</p></li></ul><h3 id="1-5-JDK、JRE-和-JVM-关系"><a href="#1-5-JDK、JRE-和-JVM-关系" class="headerlink" title="1.5 JDK、JRE 和 JVM 关系"></a>1.5 JDK、JRE 和 JVM 关系</h3><p><img src="../../images/jvm/01/JDK_JRE_JVM关系.png" alt=""></p><h2 id="2-java-class-format"><a href="#2-java-class-format" class="headerlink" title="2. java class format"></a>2. java class format</h2><h3 id="2-1-查看字节码"><a href="#2-1-查看字节码" class="headerlink" title="2.1 查看字节码"></a>2.1 查看字节码</h3><p>例子程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T0100_ByteCode01</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查看字节码方式：</p><ul><li>java 自带的 javap 工具</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">lixianfu</span>&gt;<span class="title">javap</span> -<span class="title">v</span> <span class="title">D</span>:\01<span class="title">_code</span>\01<span class="title">_javasebasic</span>\<span class="title">learnJvm</span>\<span class="title">target</span>\<span class="title">classes</span>\<span class="title">com</span>\<span class="title">monkeykong</span>\<span class="title">bytecode</span>\<span class="title">T0100_ByteCode01.class</span></span></div><div class="line"><span class="function"><span class="title">Classfile</span> /<span class="title">D</span>:/01<span class="title">_code</span>/01<span class="title">_javasebasic</span>/<span class="title">learnJvm</span>/<span class="title">target</span>/<span class="title">classes</span>/<span class="title">com</span>/<span class="title">monkeykong</span>/<span class="title">bytecode</span>/<span class="title">T0100_ByteCode01.class</span></span></div><div class="line"><span class="function">  <span class="title">Last</span> <span class="title">modified</span> 2020-6-28; <span class="title">size</span> 321 <span class="title">bytes</span></span></div><div class="line"><span class="function">  <span class="title">MD5</span> <span class="title">checksum</span> 40<span class="title">fb02a37f90d7929a55d69e77ed6190</span></span></div><div class="line"><span class="function">  <span class="title">Compiled</span> <span class="title">from</span> "<span class="title">T0100_ByteCode01.java</span>"</span></div><div class="line"><span class="function"><span class="title">public</span> <span class="title">class</span> <span class="title">com.monkeykong.bytecode.T0100_ByteCode01</span></span></div><div class="line"><span class="function">  <span class="title">minor</span> <span class="title">version</span>: 0</span></div><div class="line"><span class="function">  <span class="title">major</span> <span class="title">version</span>: 52</span></div><div class="line"><span class="function">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></div><div class="line"><span class="function"><span class="title">Constant</span> <span class="title">pool</span>:</span></div><div class="line"><span class="function">   #1 = <span class="title">Methodref</span>          #3.#13         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>."&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></div><div class="line"><span class="function">   #2 = <span class="title">Class</span>              #14            // <span class="title">com</span>/<span class="title">monkeykong</span>/<span class="title">bytecode</span>/<span class="title">T0100_ByteCode01</span></span></div><div class="line"><span class="function">   #3 = <span class="title">Class</span>              #15            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></div><div class="line"><span class="function">   #4 = <span class="title">Utf8</span>               &lt;<span class="title">init</span>&gt;</span></div><div class="line"><span class="function">   #5 = <span class="title">Utf8</span>               ()<span class="title">V</span></span></div><div class="line"><span class="function">   #6 = <span class="title">Utf8</span>               <span class="title">Code</span></span></div><div class="line"><span class="function">   #7 = <span class="title">Utf8</span>               <span class="title">LineNumberTable</span></span></div><div class="line"><span class="function">   #8 = <span class="title">Utf8</span>               <span class="title">LocalVariableTable</span></span></div><div class="line"><span class="function">   #9 = <span class="title">Utf8</span>               <span class="title">this</span></span></div><div class="line"><span class="function">  #10 = <span class="title">Utf8</span>               <span class="title">Lcom</span>/<span class="title">monkeykong</span>/<span class="title">bytecode</span>/<span class="title">T0100_ByteCode01</span>;</span></div><div class="line"><span class="function">  #11 = <span class="title">Utf8</span>               <span class="title">SourceFile</span></span></div><div class="line"><span class="function">  #12 = <span class="title">Utf8</span>               <span class="title">T0100_ByteCode01.java</span></span></div><div class="line"><span class="function">  #13 = <span class="title">NameAndType</span>        #4:#5          // "&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></div><div class="line"><span class="function">  #14 = <span class="title">Utf8</span>               <span class="title">com</span>/<span class="title">monkeykong</span>/<span class="title">bytecode</span>/<span class="title">T0100_ByteCode01</span></span></div><div class="line"><span class="function">  #15 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">  <span class="title">public</span> <span class="title">com.monkeykong.bytecode.T0100_ByteCode01</span>();</span></div><div class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">V</span></span></div><div class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></div><div class="line"><span class="function">    <span class="title">Code</span>:</span></div><div class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></div><div class="line"><span class="function">         0: <span class="title">aload_0</span></span></div><div class="line"><span class="function">         1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>."&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></div><div class="line"><span class="function">         4: <span class="title">return</span></span></div><div class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></div><div class="line"><span class="function">        <span class="title">line</span> 3: 0</span></div><div class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></div><div class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></div><div class="line"><span class="function">            0       5     0  <span class="title">this</span>   <span class="title">Lcom</span>/<span class="title">monkeykong</span>/<span class="title">bytecode</span>/<span class="title">T0100_ByteCode01</span>;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function"><span class="title">SourceFile</span>: "<span class="title">T0100_ByteCode01.java</span>"</span></div></pre></td></tr></table></figure><ul><li>idea 插件：jclasslib</li></ul><p><img src="../../images/jvm/01/jclasslib插件.png" alt=""></p><ul><li>直接编辑器打开查看16进制数据</li></ul><p><img src="../../images/jvm/01/字节码16进制.png" alt=""></p><h3 id="2-2-分析字节码"><a href="#2-2-分析字节码" class="headerlink" title="2.2 分析字节码"></a>2.2 分析字节码</h3><h4 id="2-2-1-class-字节码文件组成"><a href="#2-2-1-class-字节码文件组成" class="headerlink" title="2.2.1 class 字节码文件组成"></a>2.2.1 class 字节码文件组成</h4><h5 id="常量池项目类型表"><a href="#常量池项目类型表" class="headerlink" title="常量池项目类型表"></a>常量池项目类型表</h5><p><img src="../../images/jvm/01/常量池项目类型表.png" alt=""></p><h5 id="常量池-17-种数据类型的结构总表"><a href="#常量池-17-种数据类型的结构总表" class="headerlink" title="常量池 17 种数据类型的结构总表"></a>常量池 17 种数据类型的结构总表</h5><p><img src="../../images/jvm/01/常量池17种数据类型结构总表.png" alt=""></p><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p><img src="../../images/jvm/01/access_flag.png" alt=""></p><h4 id="2-2-2-根据格式分析类文件"><a href="#2-2-2-根据格式分析类文件" class="headerlink" title="2.2.2 根据格式分析类文件"></a>2.2.2 根据格式分析类文件</h4><p><img src="../../images/jvm/01/classfile解析.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JVM基础&lt;/li&gt;
&lt;li&gt;java class format&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之 - 从代理模式到 Spring AOP</title>
    <link href="http://yoursite.com/2020-06-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%B0%20AOP.html"/>
    <id>http://yoursite.com/2020-06-27-设计模式/设计模式-从代理模式到 AOP.html</id>
    <published>2020-06-27T14:13:12.000Z</published>
    <updated>2020-06-27T15:18:48.893Z</updated>
    
    <content type="html"><![CDATA[<p>静态代理到动态代理到 AOP。</p><p>模式定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>模式引入：我们有一辆坦克，坦克有 move 行为，现在接到一个需求，我们需要测试 move 方法的性能，并在 move 执行前后记录日志。</p><a id="more"></a><h2 id="1-直接修改坦克源码"><a href="#1-直接修改坦克源码" class="headerlink" title="1. 直接修改坦克源码"></a>1. 直接修改坦克源码</h2><p>这种方式可能是最容易想到也最容易实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">    System.out.println(<span class="string">"Tank moving claclacla..."</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 模拟坦克 move</span></div><div class="line">        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">    System.out.println(end - start);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，我们面临一个问题，tank 的源码可能是第三方代码不允许修改。</p><h2 id="2-使用继承"><a href="#2-使用继承" class="headerlink" title="2. 使用继承"></a>2. 使用继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeTank</span> <span class="keyword">extends</span> <span class="title">Tank</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">super</span>.move();</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用继承的确可以实现这个功能。但是这样我们代码耦合度和 Tank 太高，因为性能测试、日志记录等功能可能不仅仅坦克的 move 需要，很可能其他 Movable 对象也是需要的，比如卡车的 move，如果都使用继承实现，我们系统肯定会类爆炸。</p><h2 id="3-使用静态代理"><a href="#3-使用静态代理" class="headerlink" title="3. 使用静态代理"></a>3. 使用静态代理</h2><p>我们新建一个代理，这个代理和 Tank 实现相同的 Movable 接口，并且持有一个 Movable 成员变量，表示需要代理的对象。这样所有的 Movable 类型的对象都可以传给这个代理来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 代理 Movable 对象</span></div><div class="line">    Movable movable;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Movable movable)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movable = movable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 代理插入的逻辑</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="comment">// 被代理对象原逻辑</span></div><div class="line">        movable.move();</div><div class="line">        <span class="comment">// 代理插入的逻辑</span></div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们使用时，只需要把需要代理的对象传给代理，就可以像使用原对象一样了。并且由于代理中持有的成员变量是 Movable 类型，所以可以代理所有的 Movable 对象。这就是我们常说的<strong>依赖倒置原则</strong>，即依赖抽象而并不是具体或者说面向接口编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 把 tank 做为代理对象传给 TankTimeProxy 代理</span></div><div class="line">    <span class="comment">// 然后把 TankTimeProxy 作为代理对象传给 TankLogProxy 代理然后执行</span></div><div class="line">    <span class="keyword">new</span> TankLogProxy(<span class="keyword">new</span> TankTimeProxy(<span class="keyword">new</span> Tank())).move();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时程序看上去非常完美了，但是其实我们现在的代理其实只能代理 Movable 类型的对象，而没法代理其他类型对象，如果需要代理其他类型对象就需要使用动态代理了。所谓的动态代理就是我们不再需要手动写代理类了，系统会自动生成代理类，这个代理类我们看不到（可以配置系统参数 <strong>saveGeneratedFiles</strong> 保存文件然后反编译看到）。</p><h2 id="4-使用-JDK-自带的动态代理"><a href="#4-使用-JDK-自带的动态代理" class="headerlink" title="4. 使用 JDK 自带的动态代理"></a>4. 使用 JDK 自带的动态代理</h2><p>jdk  Proxy 类提供了动态代理的功能，但是 jdk 代理是基于接口的，也就是说被代理的对象必须实现某个接口，否则没法代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Tank tank = <span class="keyword">new</span> Tank();</div><div class="line"></div><div class="line">    <span class="comment">// 保存一下动态生成的那个代理类</span></div><div class="line">    <span class="comment">// System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");</span></div><div class="line">    System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 动态生成代理对象</span></div><div class="line">    Movable m = (Movable) Proxy.newProxyInstance(</div><div class="line">        Tank.class.getClassLoader(), <span class="comment">// 代理对象的 classLoader，和被代理对象一致即可</span></div><div class="line">        <span class="keyword">new</span> Class[]&#123;Movable.class&#125;,  <span class="comment">// 代理对象应该实现哪些接口</span></div><div class="line">        <span class="keyword">new</span> LogHandler(tank)); <span class="comment">// 被代理对象那个方法被调用时，我们怎么做处理</span></div><div class="line">    m.move();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    Tank tank;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Tank tank)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.tank = tank;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 生成的代理对象（m）</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理的方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method "</span>  + method.getName() + <span class="string">" start..."</span>);</div><div class="line">        <span class="comment">// 调用被代理对象的方法（tank.move()）</span></div><div class="line">        Object o = method.invoke(tank, args);</div><div class="line">        System.out.println(<span class="string">"method "</span> + method.getName() + <span class="string">" end"</span>);</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-JDK-动态代理实现原理"><a href="#5-JDK-动态代理实现原理" class="headerlink" title="5. JDK 动态代理实现原理"></a>5. JDK 动态代理实现原理</h2><h3 id="5-1-JDK-代理类"><a href="#5-1-JDK-代理类" class="headerlink" title="5.1 JDK 代理类"></a>5.1 JDK 代理类</h3><p>其实用上面代码就大致可以看出，它的实现原理应该静态代理类似，只是这个代理类是运行时动态生成的。我设置了 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code> 属性，保存了这个代理类（<strong>$Proxy0.class</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line"></div><div class="line">    <span class="comment">// 构造函数，就是我们外边传入的 LogHandler 对象</span></div><div class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</div><div class="line">        <span class="comment">// Proxy：this.h = h; </span></div><div class="line">        <span class="keyword">super</span>(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 代理类的 move 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 调用 LogHandler 的 move 方法</span></div><div class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</div><div class="line">            m4 = Class.forName(<span class="string">"com.monkeykong.proxy.v05.Movable"</span>).getMethod(<span class="string">"move"</span>);</div><div class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</div><div class="line">            m3 = Class.forName(<span class="string">"com.monkeykong.proxy.v05.Movable"</span>).getMethod(<span class="string">"go"</span>);</div><div class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-2-ASM"><a href="#5-2-ASM" class="headerlink" title="5.2 ASM"></a>5.2 ASM</h3><p>还有一个问题，我们发现 <code>$Proxy0</code> 这个类没有源文件就直接生成了对象给我们使用，这是怎么实现的呢？这是通过 ASM 实现的，一个字节码操作和分析框架。 <strong>ASM</strong> is an all purpose Java bytecode manipulation and analysis framework.  ASM 官网： <a href="https://asm.ow2.io/" target="_blank" rel="external">https://asm.ow2.io/</a> </p><p>比如我们使用 ASM api 直接生成一个 Comparable 类例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriteTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</div><div class="line">        cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,</div><div class="line">                <span class="string">"pkg/Comparable"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>,</div><div class="line">                <span class="keyword">null</span>);</div><div class="line">        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">"LESS"</span>, <span class="string">"I"</span>,</div><div class="line">                <span class="keyword">null</span>, -<span class="number">1</span>).visitEnd();</div><div class="line">        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">"EQUAL"</span>, <span class="string">"I"</span>,</div><div class="line">                <span class="keyword">null</span>, <span class="number">0</span>).visitEnd();</div><div class="line">        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">"GREATER"</span>, <span class="string">"I"</span>,</div><div class="line">                <span class="keyword">null</span>, <span class="number">1</span>).visitEnd();</div><div class="line">        cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class="string">"compareTo"</span>,</div><div class="line">                <span class="string">"(Ljava/lang/Object;)I"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>).visitEnd();</div><div class="line">        cw.visitEnd();</div><div class="line">        <span class="keyword">byte</span>[] b = cw.toByteArray();</div><div class="line"></div><div class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</div><div class="line">        Class c = myClassLoader.defineClass(<span class="string">"pkg.Comparable"</span>, b);</div><div class="line">        <span class="comment">// 输出 compareTo，可以看出 pkg.Comparable 这个类已经存在于 JVM 中。</span></div><div class="line">        System.out.println(c.getMethods()[<span class="number">0</span>].getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-3-整体时序图"><a href="#5-3-整体时序图" class="headerlink" title="5.3 整体时序图"></a>5.3 整体时序图</h3><p><img src="../../images/dp/jdk动态代理原理.png" alt=""></p><h2 id="6-使用-cglib-的动态代理"><a href="#6-使用-cglib-的动态代理" class="headerlink" title="6. 使用 cglib 的动态代理"></a>6. 使用 cglib 的动态代理</h2><p>除了使用 JDK 自带的动态代理功能，cglib 也提供了动态代理的功能，不同的是 cglib 不需要被代理的对象实现什么接口，普通的类也可以被代理。cglib 的底层实现也是 <strong>ASM</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        <span class="comment">// 这里就可以看出，cglib 的代理类会继承被代理类</span></div><div class="line">        enhancer.setSuperclass(Tank.class);</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> TimeMethodInterceptor());</div><div class="line">        Tank tank = (Tank)enhancer.create();</div><div class="line">        tank.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// 所以生成的代理类是 Tank 类的一个子类。所以 final 类不能使用 cglib 实现动态代理</span></div><div class="line">        <span class="comment">// System.out.println(o.getClass().getSuperclass().getName());</span></div><div class="line">        System.out.println(<span class="string">"before"</span>);</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        result = methodProxy.invokeSuper(o, objects);</div><div class="line">        System.out.println(<span class="string">"after"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-Spring-AOP"><a href="#7-Spring-AOP" class="headerlink" title="7. Spring AOP"></a>7. Spring AOP</h2><p>我们都知道 Spring 的核心之一就是 AOP，AOP 就是动态代理的典型应用。下面就写一下基本的例子。</p><h3 id="7-1-schema-based-approach"><a href="#7-1-schema-based-approach" class="headerlink" title="7.1 schema-based approach"></a>7.1 schema-based approach</h3><p>业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Tank moving claclacla..."</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method start..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method end..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 加载 Spring 容器</span></div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"app.xml"</span>);</div><div class="line">        <span class="comment">// 从容器中取出一个 bean</span></div><div class="line">        Tank tank = (Tank) context.getBean(<span class="string">"tank"</span>);</div><div class="line">        tank.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>额，发现什么都没写啊，怎么就动态代理了？别急，Spring 的理念就是让你发现用了就跟没用一样，主要在 Spring 的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tank"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v1.Tank"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeProxy"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v1.TimeProxy"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 切面：插什么。需要插入的内容 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">ref</span>=<span class="string">"timeProxy"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 切点：插到哪里。需要被代理的方法 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"tankPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.monkeykong.proxy.springaop.v1.Tank.move())"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 通知：什么时候插 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"tankPointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"tankPointcut"</span> <span class="attr">method</span>=<span class="string">"after"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="7-2-AspectJ-annotation-style"><a href="#7-2-AspectJ-annotation-style" class="headerlink" title="7.2 @AspectJ annotation style"></a>7.2 @AspectJ annotation style</h3><p>使用注解配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span> <span class="comment">// 插入什么</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个方法什么时候插入（before），插入到哪里（move）</span></div><div class="line">    <span class="meta">@Before</span>(<span class="string">"execution(void com.monkeykong.proxy.springaop.v2.Tank.move())"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method start..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@After</span>(<span class="string">"execution(void com.monkeykong.proxy.springaop.v2.Tank.move())"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method end..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 xml 中启用 aop：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tank"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v2.Tank"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeProxy"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v2.TimeProxy"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 启用 aop --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></div></pre></td></tr></table></figure><h2 id="1-8-代理模式类图"><a href="#1-8-代理模式类图" class="headerlink" title="1.8 代理模式类图"></a>1.8 代理模式类图</h2><p><img src="../../images/dp/代理模式类图.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态代理到动态代理到 AOP。&lt;/p&gt;
&lt;p&gt;模式定义：为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;p&gt;模式引入：我们有一辆坦克，坦克有 move 行为，现在接到一个需求，我们需要测试 move 方法的性能，并在 move 执行前后记录日志。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Proxy" scheme="http://yoursite.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-06-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-factory.html"/>
    <id>http://yoursite.com/2020-06-22-设计模式/设计模式-factory.html</id>
    <published>2020-06-22T14:36:55.850Z</published>
    <updated>2020-06-22T15:49:20.018Z</updated>
    
    <content type="html"><![CDATA[<p>简单工厂</p><p>静态工厂</p><p>工厂方法：方便单一产品的扩展</p><p>抽象工厂：方便产品族的扩展，但是单一产品扩展不方便。</p><p>任何可以产生对象的方法或类，都可以称之为工厂。单例也是一种工厂。</p><p>为什么有了 new 之后，还要工厂？</p><ul><li>灵活控制生产过程</li><li>权限、修饰、日志…</li></ul><p>更好的解决方案？</p><ul><li>Spring ioc</li><li>bean 工厂</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单工厂&lt;/p&gt;
&lt;p&gt;静态工厂&lt;/p&gt;
&lt;p&gt;工厂方法：方便单一产品的扩展&lt;/p&gt;
&lt;p&gt;抽象工厂：方便产品族的扩展，但是单一产品扩展不方便。&lt;/p&gt;
&lt;p&gt;任何可以产生对象的方法或类，都可以称之为工厂。单例也是一种工厂。&lt;/p&gt;
&lt;p&gt;为什么有了 new 之后，还要工厂
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IO学习（七）</title>
    <link href="http://yoursite.com/2020-06-21-IO/IO%E5%AD%A6%E4%B9%A07.html"/>
    <id>http://yoursite.com/2020-06-21-IO/IO学习7.html</id>
    <published>2020-06-21T14:13:12.000Z</published>
    <updated>2020-06-21T15:37:27.779Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。<br><a id="more"></a></p><h2 id="1-混杂模式服务"><a href="#1-混杂模式服务" class="headerlink" title="1. 混杂模式服务"></a>1. 混杂模式服务</h2><p>一个服务监听只有一个线程负责 accept，每个都会被分配 client，进行 R/W。</p><h3 id="1-1-MainThread"><a href="#1-1-MainThread" class="headerlink" title="1.1 MainThread"></a>1.1 MainThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 入口，这里不做关于 IO 和业务的事情</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1. 创建 IO Thread（一个或者多个）</span></div><div class="line">    SelectorThreadGroup stg = <span class="keyword">new</span> SelectorThreadGroup(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 2. 应该把监听的 server 注册到某一个 selector 上</span></div><div class="line">    stg.bind(<span class="number">9999</span>);</div><div class="line">    <span class="comment">// stg.bind(8888);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-SelectorThreadGroup"><a href="#1-2-SelectorThreadGroup" class="headerlink" title="1.2 SelectorThreadGroup"></a>1.2 SelectorThreadGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorThreadGroup</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 线程集合</span></div><div class="line">    SelectorThread[] sts;</div><div class="line">    <span class="comment">// 服务端</span></div><div class="line">    ServerSocketChannel server = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 轮询器</span></div><div class="line">    AtomicInteger xid = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">    <span class="comment">// 线程组构造器</span></div><div class="line">    SelectorThreadGroup (<span class="keyword">int</span> num) &#123;</div><div class="line">        <span class="comment">// num 线程数</span></div><div class="line">        sts = <span class="keyword">new</span> SelectorThread[num];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</div><div class="line">            sts[i] = <span class="keyword">new</span> SelectorThread(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">new</span> Thread(sts[i]).start(); <span class="comment">// 启动线程</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = ServerSocketChannel.open();</div><div class="line">            server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">            <span class="comment">// server 注册到哪个 selector 呢？</span></div><div class="line">            nextSelector(server);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 无论 ServerSocketChannel 还是 SocketChannel 都复用这个方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSelector</span><span class="params">(Channel c)</span> </span>&#123;</div><div class="line">        <span class="comment">// 在 main 线程中，取到堆里的 selectorThread 对象</span></div><div class="line">        SelectorThread st = next();</div><div class="line"></div><div class="line">        <span class="comment">// 1. 通过队列传递数据，消息。让 SelectorThread 自己去注册</span></div><div class="line">        st.lbq.add(c);</div><div class="line">        <span class="comment">// 2. 通过打断阻塞，让对应的线程去自己在打断后完成注册 selector</span></div><div class="line">        st.selector.wakeup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> SelectorThread <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 轮询，可能会倾斜</span></div><div class="line">        <span class="keyword">int</span> index = xid.incrementAndGet() % sts.length;</div><div class="line">        <span class="keyword">return</span> sts[index];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-SelectorThread"><a href="#1-3-SelectorThread" class="headerlink" title="1.3 SelectorThread"></a>1.3 SelectorThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="comment">// 每个线程对应一个 selector，</span></div><div class="line">    <span class="comment">// 多线程情况下，该主机/该程序的并发客户端被分配到多个 selector 上</span></div><div class="line">    <span class="comment">// 注意，每个客户端只绑定到其中一个 selector</span></div><div class="line">    <span class="comment">// 其实不会有交互问题</span></div><div class="line"></div><div class="line">    Selector selector = <span class="keyword">null</span>;</div><div class="line">    LinkedBlockingQueue&lt;Channel&gt; lbq = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">    <span class="comment">// 线程所属组</span></div><div class="line">    SelectorThreadGroup stg;</div><div class="line"></div><div class="line">    <span class="comment">// 构造器</span></div><div class="line">    SelectorThread(SelectorThreadGroup stg) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.stg = stg;</div><div class="line">            selector = Selector.open();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// loop</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 1. 阻塞的 select</span></div><div class="line">                <span class="comment">// System.out.println(Thread.currentThread().getName() + " ==&gt;before select......" + selector.keys().size());</span></div><div class="line">                <span class="keyword">int</span> nums = selector.select();</div><div class="line">                <span class="comment">// System.out.println(Thread.currentThread().getName() + " ==&gt;after select......" + selector.keys().size());</span></div><div class="line"></div><div class="line">                <span class="comment">// 2. 处理 selectkeys</span></div><div class="line">                <span class="keyword">if</span> (nums &gt; <span class="number">0</span>) &#123;</div><div class="line">                    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</div><div class="line">                    <span class="comment">// 线性处理 keys</span></div><div class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                        SelectionKey key = iter.next();</div><div class="line">                        iter.remove();</div><div class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                            <span class="comment">// 复杂，接收客户端的过程（接收之后要注册，多线程情况下，注册到哪里？）</span></div><div class="line">                            <span class="comment">// 轮询注册</span></div><div class="line">                            acceptHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                            readHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">                            <span class="comment">// <span class="doctag">TODO:</span></span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 3. 处理一些 task</span></div><div class="line">                <span class="keyword">if</span> (!lbq.isEmpty()) &#123;</div><div class="line">                    Channel c = lbq.take();</div><div class="line">                    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</div><div class="line">                        ServerSocketChannel server = (ServerSocketChannel) c;</div><div class="line">                        server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" register accept......"</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SocketChannel) &#123;</div><div class="line">                        SocketChannel client = (SocketChannel) c;</div><div class="line">                        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);</div><div class="line">                        client.register(selector, SelectionKey.OP_READ, buffer);</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" register read......"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" ==&gt;readHandler.... "</span>);</div><div class="line">        ByteBuffer buffer = (ByteBuffer)key.attachment();</div><div class="line">        SocketChannel client = (SocketChannel)key.channel();</div><div class="line">        buffer.clear();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> num = client.read(buffer);</div><div class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</div><div class="line">                    buffer.flip(); <span class="comment">// 将读到的内容翻转，然后直接写出</span></div><div class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                        client.write(buffer);</div><div class="line">                    &#125;</div><div class="line">                    buffer.clear();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 客户端断开了(异常情况)</span></div><div class="line">                    System.out.println(<span class="string">"client: "</span> + client.getRemoteAddress() + <span class="string">" closed......"</span>);</div><div class="line">                    key.cancel();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" ==&gt;acceptHandler.... "</span>);</div><div class="line">        ServerSocketChannel server = (ServerSocketChannel)key.channel();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// accept client</span></div><div class="line">            SocketChannel client = server.accept();</div><div class="line">            client.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            <span class="comment">// choose a selector and register</span></div><div class="line">            stg.nextSelector(client);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="../../images/io/7/混杂模型.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。&lt;br&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
</feed>
