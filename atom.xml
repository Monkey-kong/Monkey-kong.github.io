<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-17T14:31:31.416Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>悟空</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2021-03-17-README.html"/>
    <id>http://yoursite.com/2021-03-17-README.html</id>
    <published>2021-03-17T14:31:31.416Z</published>
    <updated>2021-03-17T14:31:31.416Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>高并发架构(六)</title>
    <link href="http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(6)-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB.html"/>
    <id>http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(6)-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB.html</id>
    <published>2021-01-18T12:43:12.000Z</published>
    <updated>2021-02-01T14:35:23.589Z</updated>
    
    <content type="html"><![CDATA[<ul><li>资源隔离</li></ul><a id="more"></a><h2 id="1、什么叫资源隔离？"><a href="#1、什么叫资源隔离？" class="headerlink" title="1、什么叫资源隔离？"></a>1、什么叫资源隔离？</h2><p>服务隔离是指在一个大型系统中，可以把原来连接在一起的组件，模块，服务，资源拆分开。</p><p>那么在系统出现故障的时候，可以<strong>隔离故障，阻止传播，不会出现滚雪球和雪崩的效应</strong>。就是出现问题的时候，尽量不要互相影响。</p><p>隔离的方式主要有</p><ul><li>线程隔离</li><li>进程隔离</li><li>集群隔离</li><li>机房隔离</li><li>读写隔离</li><li>动静隔离</li><li>爬虫隔离</li><li>等….</li></ul><h2 id="2、线程隔离"><a href="#2、线程隔离" class="headerlink" title="2、线程隔离"></a>2、线程隔离</h2><p>主要是在多线程环境下，对线程池进行治理，<strong>把核心业务和非核心业务分割开</strong>。</p><h3 id="2-1-线程隔离是否能起到资源隔离的作用？"><a href="#2-1-线程隔离是否能起到资源隔离的作用？" class="headerlink" title="2.1 线程隔离是否能起到资源隔离的作用？"></a>2.1 线程隔离是否能起到资源隔离的作用？</h3><h4 id="可以"><a href="#可以" class="headerlink" title="可以"></a>可以</h4><p>假设一个系统中，用户、商品、订单模块分别占用 30%、60%、10% 比重，我们想让他们分别占用比重的服务器资源。那么假设系统线程阈值是 100 个，我们可以分别为三个模块创建三个不同的线程池，线程池的最大线程数分别是 30、60 和 10 个。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB.png"></p><h4 id="不可以"><a href="#不可以" class="headerlink" title="不可以"></a>不可以</h4><p>我们只能通过不同的线程池，粗粒度的通过线程个数来进行资源隔离，但是线程内部的资源消耗我们没有办法控制，如果有线程 CPU 消耗特别大或者出现内存泄漏等问题，我们是无法控制的。</p><h3 id="2-2-Netty-中的线程隔离"><a href="#2-2-Netty-中的线程隔离" class="headerlink" title="2.2 Netty 中的线程隔离"></a>2.2 Netty 中的线程隔离</h3><p>netty 本身是负载网络 io 的框架，为了做到网络服务和业务隔离，网络服务线程池和线程池分别是不同的线程池。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/Netty%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB.png"></p><h3 id="2-3-Tomcat-Servlet2-0-资源隔离"><a href="#2-3-Tomcat-Servlet2-0-资源隔离" class="headerlink" title="2.3 Tomcat Servlet2.0 资源隔离"></a>2.3 Tomcat Servlet2.0 资源隔离</h3><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/tomcat-servlet2%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB.png"></p><p>每个连接都创建线程，那么一些状态信息怎么存储的？答案：<strong>ThreadLocal</strong>。</p><h3 id="2-4-Tomcat-Servlet3-0-资源隔离"><a href="#2-4-Tomcat-Servlet3-0-资源隔离" class="headerlink" title="2.4 Tomcat Servlet3.0 资源隔离"></a>2.4 Tomcat Servlet3.0 资源隔离</h3><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/tomcat-servlet3%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB.png"></p><p>Servlet3.0 这种处理方式，可以增加服务器处理连接的数量，连接的接入不受到服务器线程阈值的影响，也就是说可以<strong>提升系统的 QPS，但是提升不了 TPS</strong>，因为服务器的处理能力没有变化。</p><p><strong>Connector</strong>  接入连接，可以配置 socket 处理方式：</p><ul><li>Http11Protocol    </li><li>Http11NioProtocol    </li><li>Http11Nio2Protocol    </li><li>Http11AprProtocol</li></ul><p>所以 servlet 2.0 和 servlet 3.0 的区别并不是 BIO、NIO，是 BIO 还是 NIO 在 Connector 处可以配置。</p><p><strong>Executor Servlet</strong> 可以使用独立的线程池来维护 servlet 的创建。connector 能接入的请求肯定比业务复杂的 servlet 处理的个数要多，在中间，Tomcat 还加入了队列，来等待 servlet 线程池空闲。这两步是 Tomcat 内核完成的，在一阶段无法区分具体业务或资源，所以只能在连接接入，servlet 初始化完成后我们根据自己的业务线去划分独立的连接池。那么在独立的业务或资源中如果出现崩溃，不会影响其他的业务线程，从而达到<strong>资源隔离和服务降级</strong>的效果。</p><p>在使用了servlet3 之后，系统线程隔离变得更灵活了。可以<strong>划分核心业务队列和非核心业务队列</strong>。但是：</p><ol><li>资源一旦出现问题，虽然是隔离状态，想要让资源重新可用，很难做到不重启 jvm。</li><li>线程池内部线程如果出现 OOM、FullGC、cpu 耗尽等问题也是无法控制的</li></ol><p><strong>结论</strong>：</p><p><strong>线程隔离，只能保证在分配线程这个资源上进行隔离，并不能保证整体稳定性。</strong></p><h2 id="3、进程隔离"><a href="#3、进程隔离" class="headerlink" title="3、进程隔离"></a>3、进程隔离</h2><p>在项目最初期，一般都是 all in one 的技术架构，然后做负载均衡，session 共享。</p><p>java 应用程序 cpu、内存这些资源可以通过不同的虚拟机进程来做隔离。</p><h3 id="3-1-集群式"><a href="#3-1-集群式" class="headerlink" title="3.1 集群式"></a>3.1 集群式</h3><p>所谓集群就是全量复制。虽然每个节点包含全量功能，但是还是可以通过负载均衡器实现<strong>定向流量分发</strong>。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/%E8%BF%9B%E7%A8%8B%E9%9A%94%E7%A6%BB-%E9%9B%86%E7%BE%A4%E5%BC%8F.png"></p><h3 id="3-2-分布式"><a href="#3-2-分布式" class="headerlink" title="3.2 分布式"></a>3.2 分布式</h3><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/%E8%BF%9B%E7%A8%8B%E9%9A%94%E7%A6%BB-%E5%88%86%E5%B8%83%E5%BC%8F.png"></p><h2 id="4、集群隔离"><a href="#4、集群隔离" class="headerlink" title="4、集群隔离"></a>4、集群隔离</h2><p>如果系统中某个业务模块包含像</p><ul><li>抢购、秒杀</li><li>存储 I/O 密集度高</li><li>网络 I/O 高</li><li>计算 I/O 高</li></ul><p>这类需求的时候，很容易在并发量高的时候因为这种功能把整个模块占有的资源全部耗尽，导致响应编码甚至节点不可用。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li>独立拆分模块</li><li>微服务化</li></ul><p>可以使用 hystrix 在微服务中隔离分布式服务故障。他可以通过线程和信号量进行隔离。</p><p>如何划分微服务和成本相关，预算、时间。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/%E9%9B%86%E7%BE%A4%E9%9A%94%E7%A6%BB.png"></p><h2 id="5、机房隔离异地多活"><a href="#5、机房隔离异地多活" class="headerlink" title="5、机房隔离异地多活"></a>5、机房隔离异地多活</h2><p>解决数据容量大，计算，I/O（网络）密集度高的问题</p><p>把服务建立整体副本（计算服务、数据存储），在多机房内做异地多活或冷备份、是微服务数据异构的放大版</p><p>当在机房层面出现问题的时候，可以通过智能 dns、httpdns（只使用 cs）、负载均衡等技术快速切换</p><p>机房备份。怎么备份。</p><p>闭环数据</p><p>分布式数据中心。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/6/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB.png"></p><h2 id="6、数据（读写）分离"><a href="#6、数据（读写）分离" class="headerlink" title="6、数据（读写）分离"></a>6、数据（读写）分离</h2><p>通过主从模式，将 mysql、redis 等数据存储服务集群化，读写分离，那么在写入数据不可用的时候，也可以通过<strong>重试机制</strong>临时通过其他节点读取到数据。</p><p>多节点在做子网划分的时候，除了异地多活，还可以做数据中心，所有数据在本地机房crud 异步同步到数据中心，数据中心再去分发数据给其他机房</p><p>那么数据临时在本地机房不可用的时候，就可以尝试连接异地机房或数据中心。</p><h2 id="7、动静隔离"><a href="#7、动静隔离" class="headerlink" title="7、动静隔离"></a>7、动静隔离</h2><p>把静态资源从原有服务中隔离出来，参考 cdn 技术</p><h2 id="8、爬虫隔离"><a href="#8、爬虫隔离" class="headerlink" title="8、爬虫隔离"></a>8、爬虫隔离</h2><p>目前我们开发的都是 API 接口，并且多数都是开放的 API 接口。也就是说，只要有人拿到这个接口，任何人都可以通过这个 API 接口获取数据，那么像网络爬虫的，请求速度又快，获取的数据又多，不用多久，爬虫方完全可以用我们 API 的接口来开发一个同样的网站，这样的话，后果就有点严重了，所以我们需要限流，限制访问的频率</p><p>开放平台的 API 接口调用需要限制其频率，以节约服务器资源和避免恶意的频繁调用</p><p>在大型互联网项目中，对于 web 服务和网络爬虫的访问流量能达到 5:1，甚至更高，有的系统有时候就会因为爬虫流量过高而导致资源耗尽，服务不可用。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;资源隔离&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(七)</title>
    <link href="http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(7)-%E9%99%90%E6%B5%81.html"/>
    <id>http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(7)-%E9%99%90%E6%B5%81.html</id>
    <published>2021-01-18T12:43:12.000Z</published>
    <updated>2021-02-01T14:20:41.624Z</updated>
    
    <content type="html"><![CDATA[<ul><li>服务限流</li></ul><a id="more"></a><p>nginx 限流</p><h2 id="1、什么是限流？"><a href="#1、什么是限流？" class="headerlink" title="1、什么是限流？"></a>1、什么是限流？</h2><p>限流即限制流量进入。</p><p><strong>缓存</strong>，是用来增加系统吞吐量，提升访问速度提供高并发。</p><p><strong>降级</strong>，是在系统某些服务组件不可用的时候、流量暴增、资源耗尽等情况下，暂时屏蔽掉出问题的服务，继续提供降级服务，给用户尽可能的友好提示，返回兜底数据，不会影响整体业务流程，待问题解决再重新上线服务 </p><p><strong>限流</strong>，是指在使用缓存和降级无效的场景。比如当达到阈值后限制接口调用频率，访问次数，库存个数等，在出现服务不可用之前，提前把服务降级。只服务好一部分用户。</p><p>在我们使用微信、支付宝、短信等等这些 api 的时候，每个接口都会有调用上的限流。</p><p>限流是对某一时间窗口内的请求数进行限制，保持系统的可用性、稳定性和安全性，防止因流量暴增而导致的系统运行缓慢或宕机。</p><p><strong>限制流量涌入不等于拒绝连接。</strong></p><h2 id="2、限流算法"><a href="#2、限流算法" class="headerlink" title="2、限流算法"></a>2、限流算法</h2><h3 id="2-1-计数器算法"><a href="#2-1-计数器算法" class="headerlink" title="2.1 计数器算法"></a>2.1 计数器算法</h3><p>简单粗暴，比如线程池大小，数据库连接池大小、nginx 连接数等都属于计数器算法。</p><p>全局或某段时间范围达到阈值则限流。</p><h4 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h4><pre><code class="nginx">worker_processes  1;events &#123;    worker_connections  1024;&#125;</code></pre><p>默认最大连接 1024。但是后边服务不可能同时处理 1024 和请求，比如 nginx 中业务 lua 脚本，可能只能处理 200 并发，所以建立连接后到执行业务逻辑前需要一个东西在中间<strong>限流</strong>。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/nginx%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%99%90%E6%B5%81.png"></p><p>这时我们可能想到，直接把最大连接数配置成 200 就行了。但是通常我们肯定不止一个业务，比如还有另外一个图片静态资源服务，可以处理 5000 个请求，这样把连接配置为 200 就不合适了。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E8%AE%A1%E6%95%B0%E5%99%A8%E9%99%90%E6%B5%81%E7%93%B6%E9%A2%88.png"></p><h4 id="Tomcat-配置"><a href="#Tomcat-配置" class="headerlink" title="Tomcat 配置"></a>Tomcat 配置</h4><p>访问限流就是计数器，比如 tomcat</p><ul><li>acceptCount 响应连接数</li><li>maxConnections 瞬时最大连接数</li><li>maxThreads 最大线程数</li></ul><p>设置系统阈值总的 qps 个数</p><h4 id="ngx-http-limit-conn-module"><a href="#ngx-http-limit-conn-module" class="headerlink" title="ngx_http_limit_conn_module"></a>ngx_http_limit_conn_module</h4><p>针对指定路径进行<strong>连接数限流</strong>。</p><p>官网说明：<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html">http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html</a></p><p><strong>注意点</strong>：</p><ul><li>lvs 做负载均衡，nginx 做后端 server 的时候，需要加白名单</li><li>只建立连接不会进入计数，只有被 nginx 读取了请求头的才进入计数</li></ul><p><strong>http 块配置</strong></p><pre><code class="nginx"># 共享mit_conn内存区域的配置，内存大小，key# $binary_remote_addr -&gt; ip 地址# $server_name -&gt; 主机名limit_conn_zone $binary_remote_addr zone=perid:10m;limit_conn_zone $server_name zone=perserver:10m;# 被限流后的状态码limit_conn_status 503;limit_conn_log_level error;</code></pre><p><strong>location 块配置</strong></p><pre><code class="nginx"># 测试 nginx 限流location = /limit &#123;    default_type text/html;    # 存放 key 的共享区域 zone，和指定 key 的最大连接数    limit_conn perid 1;    limit_conn perserver 1;    set $value &#39;first&#39;;    redis2_query set one $value;    redis2_pass 127.0.0.1:6379;    # content_by_lua_file conf/lua/hello.lua;&#125;</code></pre><p><strong>使用 ab 测试</strong></p><pre><code class="shell"># 安装测试工具yum install httpd-tools# 监控 nginx 日志tail -f ../logs/access.log# 测试 -n 总请求数 -c 并发数ab -n 50 -c 50 http://192.168.47.11/limit</code></pre><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/nginx%E6%97%A5%E5%BF%97.png"></p><p><strong>使用 jmeter 测试</strong></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/jmeter%E6%B5%8B%E8%AF%95.png"></p><h4 id="app-统计"><a href="#app-统计" class="headerlink" title="app 统计"></a>app 统计</h4><p><a href="https://www.umeng.com/"><strong>友盟</strong></a>、CNZZ</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E5%8F%8B%E7%9B%9F%E7%BB%9F%E8%AE%A1.png"></p><h3 id="2-2-漏桶算法"><a href="#2-2-漏桶算法" class="headerlink" title="2.2 漏桶算法"></a>2.2 漏桶算法</h3><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p><ul><li>缓存请求：桶中放的是请求</li><li>多余请求直接丢弃：桶满了，多余请求溢出（丢弃）</li><li>均匀处理：比如设置 2r/s，表示每 500ms 处理一个请求</li></ul><p>漏桶可以起到<strong>削峰</strong>、<strong>缓冲</strong>的作用。峰值流量突然涌入，请求的处理也是匀速的。</p><h4 id="ngx-limit-req-module"><a href="#ngx-limit-req-module" class="headerlink" title="ngx_limit_req_module"></a>ngx_limit_req_module</h4><p><strong>漏桶算法</strong>的实现。</p><p>官网说明：<a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">http://nginx.org/en/docs/http/ngx_http_limit_req_module.html</a></p><p><strong>http 块配置</strong></p><pre><code class="nginx"># 漏桶算法限流 rate=2r/s =&gt; 每秒 2 个。每 500ms 处理一个请求limit_req_zone $binary_remote_addr zone=limit1:10m rate=2r/s;# 被限流后的状态码limit_conn_status 503;limit_conn_log_level error;</code></pre><p><strong>location 块配置</strong></p><pre><code class="nginx">location = /limit1 &#123;    default_type text/html;    limit_req zone=limit1;    content_by_lua_file conf/lua/hello.lua;&#125;</code></pre><h4 id="理解-burst-匀速处理请求"><a href="#理解-burst-匀速处理请求" class="headerlink" title="理解 burst 匀速处理请求"></a>理解 burst 匀速处理请求</h4><p><strong>测试：一秒内打入10个请求</strong></p><p>注意这里是一秒内 10 个请求，不是 10 个并发，10 个并发是 0 秒内打入 10 个请求。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E4%B8%80%E7%A7%9210%E8%AF%B7%E6%B1%82.png"></p><p>由于没有设置桶大小，不能缓存请求。所以<strong>两个被处理。</strong>0s 处理一个，501ms 处理第二个。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E4%B8%80%E7%A7%9210%E8%AF%B7%E6%B1%82%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p><p><strong>测试：400ms 内打入 10 个请求</strong></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/400ms%E5%8D%81%E4%B8%AA%E8%AF%B7%E6%B1%82.png"></p><p><strong>只有一个请求被处理</strong>。因为第二请求要 501ms 时才处理，结果就不截图了。</p><p><strong>测试：设置桶大小</strong></p><p>设置 burst=4</p><pre><code class="nginx">location = /limit1 &#123;    default_type text/html;    limit_req zone=limit1 burst=4;    content_by_lua_file conf/lua/hello.lua;&#125;</code></pre><p>再次看测试结果：</p><ul><li>一秒内10请求：2个请求立即被处理（0s和501ms时），4个请求被放进桶中，4个请求被丢弃。桶中4个请求以500ms的速率被处理。<strong>最终6个请求被处理。</strong></li></ul><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E4%B8%80%E7%A7%9210%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png"></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E4%B8%80%E7%A7%9210%E8%AF%B7%E6%B1%82%E5%A2%9E%E5%8A%A0burst.png"></p><ul><li>400ms内10请求：1个请求立即被处理，4个请求被放进桶中，5个请求被丢弃。桶中4个请求以500ms的速率被处理。<strong>最终5个请求被处理。</strong>。</li></ul><h4 id="理解-nodelay-降低排队时间"><a href="#理解-nodelay-降低排队时间" class="headerlink" title="理解 nodelay 降低排队时间"></a>理解 nodelay 降低排队时间</h4><p>如果不加 nodelay 参数，队列里的请求不会立即处理，而是按照 rate 设置的速度，以毫秒级精确的速度慢慢处理。</p><p>如果队列设置的比较大（即桶大小），请求排队的时间就会比较长，从用户角度看就是 RT 变长了，对用户不友好。所以可以增加 nodelay 参数，使得桶内缓存的请求可以立即被执行，这样系统的 QPS 是有可能超过设置的速率的。</p><pre><code class="nginx">location = /limit1 &#123;    default_type text/html;    limit_req zone=req burst=4 nodelay;    content_by_lua_file conf/lua/hello.lua;&#125;</code></pre><blockquote><p>虽然设置 burs t和 nodelay 能够降低突发请求的处理时间，但是长期来看并不会提高吞吐量的上限，长期吞吐量的上限是由 rate 决定的，因为 nodelay 只能保证 burst 的请求被立即处理，但 Nginx 会<strong>限制队列元素释放的速度</strong>，就像是限制了令牌桶中令牌产生的速度。</p></blockquote><p>从结果看，请求的成功率并没有变化，但是<strong>总体耗时变短了</strong>。</p><blockquote><p>问： 加了 nodelay 参数的限流是漏桶还是令牌桶？</p><p>答：漏桶。nodelay 只是让桶内的请求立即执行。这看上去和令牌桶对请求的处理一致，但是对请求的接入是完全不同的。令牌桶还有一个队列，当桶满了时，请求会缓存进队列。但是漏桶是如果桶满了，直接拒绝请求。所以如果令牌桶当队列设置为0那么就变成漏桶算法了。</p></blockquote><h3 id="2-3-令牌桶算法"><a href="#2-3-令牌桶算法" class="headerlink" title="2.3 令牌桶算法"></a>2.3 令牌桶算法</h3><p><img src="../../images/%E6%9E%B6%E6%9E%84/7/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p><ul><li>缓存令牌：桶中放的时令牌</li><li>多余令牌被丢弃：桶满了，多余令牌丢弃</li><li>令牌以固定速率产生</li><li>请求要消耗等比例的令牌才能被处理</li><li>令牌不够时，请求被缓存到队列</li></ul><p>和漏桶不同，令牌桶除了桶以外，还有一个队列。桶是用来存放令牌的，队列才是用来存放请求的。</p><p>漏桶和令牌桶最大的区别是对突发流量处理方式不同。漏桶不管请求怎么打入，处理速率始终一样；令牌桶如果桶中令牌足够，请求同时被处理。即漏桶不允许突发流量处理，而令牌桶能够在限制数据的平均传输速率的情况下，允许某种程度的突发传输。</p><h2 id="3、并发限流"><a href="#3、并发限流" class="headerlink" title="3、并发限流"></a>3、并发限流</h2><p>配置 Nginx（worker_connections、ngx_http_limit_conn_module）、Tomcat。</p><h2 id="4、接口限流"><a href="#4、接口限流" class="headerlink" title="4、接口限流"></a>4、接口限流</h2><h3 id="4-1-限制接口并发总数"><a href="#4-1-限制接口并发总数" class="headerlink" title="4.1 限制接口并发总数"></a>4.1 限制接口并发总数</h3><p>可以使用 atomic 或者 semaphore 进行限流。</p><p>这种方式简单粗暴，没有平滑处理，用来限制某个接口的总并发数。比如限制某个接口最大十个并发。</p><pre><code class="java">// 限制并发最大 100private static final Integer totalCountLimit = 10;private final AtomicInteger totalCountLimitCounter = new AtomicInteger(0);/*** atomic类或者semaphore进行限流*/@RequestMapping(&quot;/test01&quot;)@ResponseBodypublic String totalCountLimit() &#123;    try &#123;        if (totalCountLimitCounter.incrementAndGet() &gt; totalCountLimit) &#123;            return &quot;系统繁忙，请稍后再试&quot;;        &#125;        System.out.println(&quot;test01......&quot;);        Thread.sleep(1000);        System.out.println(&quot;test01 finish......&quot;);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125; finally &#123;        totalCountLimitCounter.decrementAndGet();    &#125;    return String.valueOf(totalCountLimitCounter.get());&#125;</code></pre><h3 id="4-2-限制接口-qps-Guava-Cache"><a href="#4-2-限制接口-qps-Guava-Cache" class="headerlink" title="4.2 限制接口 qps - Guava Cache"></a>4.2 限制接口 qps - Guava Cache</h3><p>可以使用 Guava Cache，类似于 ConcurrentMap，但是可以配置自动过期时间。例如限制某个接口 2qps，即最多每秒处理两次访问。</p><pre><code class="java">LoadingCache&lt;Long, AtomicLong&gt; timeWinCounter = CacheBuilder.newBuilder()    // 一秒过期    .expireAfterWrite(1, TimeUnit.SECONDS)    .build(new CacheLoader&lt;Long, AtomicLong&gt;() &#123;        @Override        public AtomicLong load(Long key) throws Exception &#123;            System.out.println(&quot;key====&gt;&quot;+key);            // 处理缓存键不存在时的处理逻辑            return new AtomicLong(0);        &#125;    &#125;);/**     * 一秒最多 2 个请求     * @return     * @throws ExecutionException     */@RequestMapping(&quot;test02&quot;)@ResponseBodypublic String timeWinLimit() throws ExecutionException &#123;    Long current = System.currentTimeMillis() / 1000;    long count = timeWinCounter.get(current).incrementAndGet();    if (count &gt; 2) &#123;        System.out.println(&quot;系统繁忙，请稍后再试&quot;);        return &quot;系统繁忙，请稍后再试&quot; + count;    &#125;    timeWinCounter.asMap().forEach((key, value) -&gt; &#123;        System.out.println(key +&quot;====&quot;+ value.get());    &#125;);    System.out.println(&quot;请求成功&quot;);    return &quot;请求成功：&quot; + current + &quot;====&quot; + count;&#125;</code></pre><h3 id="4-3-限制接口-qps-Guava-RateLimiter"><a href="#4-3-限制接口-qps-Guava-RateLimiter" class="headerlink" title="4.3 限制接口 qps - Guava RateLimiter"></a>4.3 限制接口 qps - Guava RateLimiter</h3><pre><code class="java">// 每秒产生 2 个令牌RateLimiter limiter = RateLimiter.create(2);@RequestMapping(&quot;test03&quot;)@ResponseBodypublic String tateLimiter() throws ExecutionException &#123;    boolean pass = limiter.tryAcquire(1, 1, TimeUnit.SECONDS);    if (pass) &#123;        System.out.println(&quot;请求成功&quot;);        return &quot;请求成功&quot;;    &#125; else &#123;        System.out.println(&quot;系统繁忙，请稍后再试&quot;);        return &quot;系统繁忙，请稍后再试&quot;;    &#125;&#125;</code></pre><h2 id="5、分布式系统限流"><a href="#5、分布式系统限流" class="headerlink" title="5、分布式系统限流"></a>5、分布式系统限流</h2><h3 id="5-1-Nginx-Lua"><a href="#5-1-Nginx-Lua" class="headerlink" title="5.1 Nginx + Lua"></a>5.1 Nginx + Lua</h3><p>可以使用resty.lock保持原子特性，请求之间不会产生锁的重入</p><p><a href="https://github.com/openresty/lua-resty-lock">https://github.com/openresty/lua-resty-lock</a></p><p>使用lua_shared_dict存储数据</p><pre><code class="lua">local locks = require &quot;resty.lock&quot;local function acquire()    local lock =locks:new(&quot;locks&quot;)    local elapsed, err =lock:lock(&quot;limit_key&quot;) --互斥锁 保证原子特性    local limit_counter =ngx.shared.limit_counter --计数器    local key = &quot;ip:&quot; ..os.time()    local limit = 5 --限流大小    local current =limit_counter:get(key)    if current ~= nil and current + 1&gt; limit then --如果超出限流大小       lock:unlock()       return 0    end    if current == nil then       limit_counter:set(key, 1, 1) --第一次需要设置过期时间，设置key的值为1，过期时间为1秒    else        limit_counter:incr(key, 1) --第二次开始加1即可    end    lock:unlock()    return 1endngx.print(acquire())</code></pre><h3 id="5-2-lua-resty-limit-traffic"><a href="#5-2-lua-resty-limit-traffic" class="headerlink" title="5.2 lua-resty-limit-traffic"></a>5.2 lua-resty-limit-traffic</h3><p>可以更灵活的配置 key、速率、桶大小这些属性。</p><p><a href="https://github.com/openresty/lua-resty-limit-traffic">https://github.com/openresty/lua-resty-limit-traffic</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/c830726edbdb">https://www.jianshu.com/p/c830726edbdb</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;服务限流&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(8) 扩容</title>
    <link href="http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(8)-%E6%89%A9%E5%AE%B9.html"/>
    <id>http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(8)-%E6%89%A9%E5%AE%B9.html</id>
    <published>2021-01-18T12:43:12.000Z</published>
    <updated>2021-02-06T08:14:22.214Z</updated>
    
    <content type="html"><![CDATA[<ul><li>扩容</li></ul><a id="more"></a><h2 id="1、硬件与云服务扩容"><a href="#1、硬件与云服务扩容" class="headerlink" title="1、硬件与云服务扩容"></a>1、硬件与云服务扩容</h2><h3 id="1-1-整机硬件"><a href="#1-1-整机硬件" class="headerlink" title="1.1 整机硬件"></a>1.1 整机硬件</h3><p>整机：IBM、浪潮、DELL、HP 等。</p><p><strong>CPU</strong></p><p>Intel、Amd 单路，双路，四路</p><p><strong>网卡</strong></p><p>千兆、万兆。服务器吞吐量大时，比如处理日志，MySQL binlog，Redis rdf等。</p><p><strong>内存</strong></p><p>ECC 校验</p><p><strong>磁盘</strong></p><p>SCSI HDD（机械）、HHD（混合）、SATA SSD、PCI-e SSD、MVMe SSD</p><h2 id="2、水平扩容"><a href="#2、水平扩容" class="headerlink" title="2、水平扩容"></a>2、水平扩容</h2><h3 id="2-1-系统复制-集群"><a href="#2-1-系统复制-集群" class="headerlink" title="2.1 系统复制-集群"></a>2.1 系统复制-集群</h3><p>服务做集群（复制），统一入口，负载均衡。</p><h3 id="2-2-系统拆分-分布式"><a href="#2-2-系统拆分-分布式" class="headerlink" title="2.2 系统拆分-分布式"></a>2.2 系统拆分-分布式</h3><p>拆分完成会发生以下问题</p><ul><li><p>系统间共享数据</p><ul><li>中央数据中心，数据库集群</li><li>独立资源，消息中间件异步消费数据</li></ul></li><li><p>接口调用</p><ul><li>rpc rmi dubbo</li><li>http restful</li></ul></li><li><p>持久化数据雪崩</p><ul><li>数据库分库分表</li><li>资源隔离</li><li>对访问量大的</li></ul></li><li><p>静态资源分布在各个系统中</p><ul><li>防刷</li><li>cdn技术统一分发管理</li></ul></li><li><p>高并发问题</p><ul><li>缓存</li><li>数据闭环</li></ul></li><li><p>数据一致性问题</p><ul><li>分布式锁</li></ul></li></ul><h3 id="2-3-如何处理多库-join"><a href="#2-3-如何处理多库-join" class="headerlink" title="2.3 如何处理多库 join"></a>2.3 如何处理多库 join</h3><h4 id="多次查询"><a href="#多次查询" class="headerlink" title="多次查询"></a>多次查询</h4><p>向多库分别发送查询</p><h4 id="冗余字段"><a href="#冗余字段" class="headerlink" title="冗余字段"></a>冗余字段</h4><p>对常用字段进行冗余。空间换时间的思想。</p><p>问题：需要结合实际业务来看一致性的要求。比如订单表除了有 userId，还冗余了 userName，当用户修改名称时，是否需要同步更新呢？如果需要可以借助数据库中的触发器或者在业务代码层面去保证。</p><h4 id="全局表-冗余表"><a href="#全局表-冗余表" class="headerlink" title="全局表/冗余表"></a>全局表/冗余表</h4><p>复制表到本地数据库。</p><p>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</p><h4 id="使用搜索引擎"><a href="#使用搜索引擎" class="headerlink" title="使用搜索引擎"></a>使用搜索引擎</h4><p>ES、Solar</p><h4 id="连接表"><a href="#连接表" class="headerlink" title="连接表"></a>连接表</h4><p>以 MySQL 为例，链接表与常见的 MyISAM, InnoDB 等等，都是一种表的结构类型（称之为 存储引擎）。使用 show engines; 命令即可看到数据库所支持的存储引擎，默认 FEDERATED 引擎 是关闭的，我们需要去 mysql 配置文件开启它。</p><ul><li>本地的表结构必须与远程的完全一样</li><li>远程数据库目前仅限 MySQL</li><li>不支持事务</li><li>不支持表结构修改</li></ul><pre><code class="sql">        CREATE TABLE TABLE2 (            id     INT(20) NOT NULL AUTO_INCREMENT,            name   VARCHAR(32) NOT NULL DEFAULT &#39;&#39;,            other  INT(20) NOT NULL DEFAULT &#39;0&#39;,            PRIMARY KEY  (id),            INDEX name (name),            INDEX other_key (other)        )        ENGINE=FEDERATED        DEFAULT CHARSET=latin1        CONNECTION=&#39;mysql://192.168.1.2:3307/DB2/TABLE2&#39;;</code></pre><h2 id="3、分布式-ID"><a href="#3、分布式-ID" class="headerlink" title="3、分布式 ID"></a>3、分布式 ID</h2><ul><li><p>全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</p></li><li><p>递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</p></li><li><p>信息安全：如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p></li><li><p>极高的可用性</p></li><li><p>高并发</p></li></ul><h3 id="3-1-全局唯一数据库"><a href="#3-1-全局唯一数据库" class="headerlink" title="3.1 全局唯一数据库"></a>3.1 全局唯一数据库</h3><p>集群中独立一台数据库服务器，专门用于生成 ID。</p><p>特点：</p><ul><li>实现简单</li><li>性能一般，难扩展</li><li>需要维护一台服务器</li><li>服务器存在单点故障问题</li><li>整型 ID 自增，分页、排序等需求实现很方便</li><li>由于每个数据库产品对 ID 生产策略实现不同，数据库中的数据迁移跨数据库平台需要处理</li></ul><h3 id="3-2-数据库集群"><a href="#3-2-数据库集群" class="headerlink" title="3.2 数据库集群"></a>3.2 数据库集群</h3><p>为了避免重复，设置成起始数字不一样，步长一样即可。</p><ul><li>扩展性差。如果需要扩展数据库实例将比较麻烦。</li></ul><h3 id="3-3-UUID"><a href="#3-3-UUID" class="headerlink" title="3.3 UUID"></a>3.3 UUID</h3><p>可以用数据库生产，也可以用代码生成。</p><ul><li>简单</li><li>不可读。<ul><li>变种，替换或增加字段用来存储生成时间</li></ul></li><li>生成性能好，没有网络开销</li><li>全球唯一，数据合并一般没有问题<ul><li>mac 地址，原子钟</li><li>保证服务时间不回退</li></ul></li><li>无法排序，没有递增关系</li><li>字符串存储空间大，查询效率低</li><li>数据传输量大</li></ul><h3 id="3-4-zookeeper"><a href="#3-4-zookeeper" class="headerlink" title="3.4 zookeeper"></a>3.4 zookeeper</h3><p>自身高可用，原子性。</p><ul><li>有序，使用临时序号节点</li><li>使用节点的数据版本号</li><li>高并发下性能不好</li></ul><h3 id="3-5-MongoDB"><a href="#3-5-MongoDB" class="headerlink" title="3.5 MongoDB"></a>3.5 MongoDB</h3><p>使用 ObjectId，原生分布式数据库。</p><h3 id="3-6-Redis"><a href="#3-6-Redis" class="headerlink" title="3.6 Redis"></a>3.6 Redis</h3><p>单线程的 redis 可以提供原子特性及高性能</p><p>实现分布式 id 可以用 Redis 的原子操作 INCR 和 INCRBY 来实现<code>起始数字不一样，步长一样</code></p><ul><li>高性能</li><li>数字 id，排序，分页方便</li><li>局部有序，全局无法保证有序</li></ul><h3 id="3-7-SnowFlake"><a href="#3-7-SnowFlake" class="headerlink" title="3. 7 SnowFlake"></a>3. 7 SnowFlake</h3><p>snowflake 是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID</p><p>这种方案大致来说是一种以划分命名空间（UUID 也算，由于比较常见，所以单独分析）来生成 ID 的一种算法，这种方案把 64-bit 分别划分成多段，分开来标示机器、时间等，比如在 snowflake 中的64-bit分别表示如下图</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/8/slowflake.png"></p><ul><li>性能好</li><li>单机上是递增的，强依赖机器时钟，分布式系统中无法保证每台机器时钟都一样，所以不是全局递增</li><li>禁止机器上时钟回拨</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;扩容&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(9) 降级</title>
    <link href="http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(9)-%E9%99%8D%E7%BA%A7.html"/>
    <id>http://yoursite.com/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(9)-%E9%99%8D%E7%BA%A7.html</id>
    <published>2021-01-18T12:43:12.000Z</published>
    <updated>2021-02-06T05:24:53.193Z</updated>
    
    <content type="html"><![CDATA[<p>在高并发场景下，当系统中的一些功能组件出现异常，无法继续提供服务的时候，为了保证整体系统可用性，可以牺牲一部分功能依旧提供<strong>有损服务</strong>。</p><a id="more"></a><h2 id="1、SLA-Service-Level-Agreement"><a href="#1、SLA-Service-Level-Agreement" class="headerlink" title="1、SLA(Service Level Agreement)"></a>1、SLA(Service Level Agreement)</h2><p>SLA 是判定压测是否异常的重要依据。压测过程中，通过监控核心服务状态的 SLA 指标数据，可以更直观的了解压测业务状态。</p><p>SLA 是服务商与购买方达成的正常运行时间保证。SLA 分为网络服务、云服务提供商的在线保证率和项目自身故障率。</p><p><a href="https://help.aliyun.com/document_detail/111729.html?spm=a2c4g.11186623.3.3.19693e74AnPY9O">https://help.aliyun.com/document_detail/111729.html?spm=a2c4g.11186623.3.3.19693e74AnPY9O</a></p><h2 id="2、6-个-9"><a href="#2、6-个-9" class="headerlink" title="2、6 个 9"></a>2、6 个 9</h2><p>2个9 = （1-99%）X24 X 365 = 87.6 小时 = 3.65天</p><p>3个9 = （1-99.9%）X24 X 365 = 8.76 小时</p><p>4个9 = （1-99.99%）X24 X 365 = 0.876 小时 = 52.56分钟</p><p>5个9 = （1-99.999%）X24 X 365 = 0.0876 小时 = 5.256分钟</p><p>6个9 = （1-99.9999%）X24 X 365 = 0.00876 小时 = 0.5256分钟 = 31秒</p><p>如果服务器只保证 99% 的可用性，那么一年中有 3.65 天服务是不可用的，这对于大型公司来说是致命的，损失是极大的。例如 2015 年携程服务瘫痪从中午 11 时到晚上 23:29 才恢复，携程股价暴跌 11.67%。</p><h2 id="3、降级处理"><a href="#3、降级处理" class="headerlink" title="3、降级处理"></a>3、降级处理</h2><p>降级的规则是距离用户越近，造成的损失越小，避免滚雪球效应。</p><h3 id="3-1-兜底数据"><a href="#3-1-兜底数据" class="headerlink" title="3.1 兜底数据"></a>3.1 兜底数据</h3><ul><li>默认值：设置安全的默认值，不会引起数据问题，比如库存设置为 0 </li><li>静态值：请求的页面或 api 无法返回数据，提供一套静态数据据展示，比如加载失败提示重试，或默认菜单</li><li>缓存：缓存无法<strong>回源</strong>更新则使用旧的缓存</li></ul><h3 id="3-2-限流降级"><a href="#3-2-限流降级" class="headerlink" title="3.2 限流降级"></a>3.2 限流降级</h3><p>当流量洪峰到达的时候，对于丢弃的用户可以提供友好的提示。比如提示用户当前系统繁忙，请稍后重试等等，而不是直接返回 503 错误，应该返回更加友好的错误页面。</p><h3 id="3-3-超时降级"><a href="#3-3-超时降级" class="headerlink" title="3.3 超时降级"></a>3.3 超时降级</h3><p>对调用的数据设置超时时间，当调用失败，对服务降级。</p><h3 id="3-4-重试-自动处理"><a href="#3-4-重试-自动处理" class="headerlink" title="3.4 重试/自动处理"></a>3.4 重试/自动处理</h3><ul><li>客户端做高可用：提供多个可调用的服务地址</li><li>微服务重试：dobbo 重试机制、robbin 重试机制</li><li>API 调用重试：当达到重试次数后，增加访问标记即降级开关，异步探测服务是否已经恢复</li><li>WEB 端：在服务不可用时，web 端增加重试按钮或自动重试可以提供更加友好的体验</li></ul><p>自动重试需要设置重试次数和数据<strong>幂等</strong>处理。</p><h3 id="3-5-降级开关"><a href="#3-5-降级开关" class="headerlink" title="3.5 降级开关"></a>3.5 降级开关</h3><p>对于一些较为不稳定的服务，可以在服务调用方设置一个 flag，标记服务是否可用。这个标记需要存储在第三方：配置文件、数据库、Redis、zookeeper 中。</p><p>配置文件和数据库在高并发系统中不适用，频繁调用数据库是非常致命的。至于放在 redis 中还是 zookeeper 中，这里我们没必要要求这个 flag 强一致性，而是更注重服务的可用性，所以选择 AP 架构的 redis。</p><h3 id="3-6-数据组装降级"><a href="#3-6-数据组装降级" class="headerlink" title="3.6 数据组装降级"></a>3.6 数据组装降级</h3><p>多库、多维度组装 JSON 或 XML 时，如果有一些不重要的数据无法获取或数据出错，可以忽略错误，返回可以返回的数据，而不是直接将服务降级。</p><h3 id="3-7-爬虫和机器人"><a href="#3-7-爬虫和机器人" class="headerlink" title="3.7 爬虫和机器人"></a>3.7 爬虫和机器人</h3><p>网络爬虫占用的流量非常大，一个正常的网站，网站越好，爬虫占用的比值就越高，可能 30%-50% 的流量都来自爬虫。爬虫的目的是搜索引擎为了提高数据质量，所以不停爬虫获取实时数据。搜索引擎厂商也比较多，所以网站可能被频繁爬取数据。</p><ul><li>分析机器人行为：短时间连续操作、agent（正规的爬虫会带有 agent，表明自己是爬虫请求）、行为轨迹分析（js 录屏，发送到服务器，服务器分析是否是人的行为）、拖拽（模拟登录/秒杀/灌水）</li><li>爬虫：引导爬虫请求到静态页或者缓存页。</li></ul><h3 id="3-8-读降级"><a href="#3-8-读降级" class="headerlink" title="3.8 读降级"></a>3.8 读降级</h3><p>在一个请求内，多级缓存架构下，后端缓存或 DB 不可用，可以使用前端缓存或兜底数据。</p><h3 id="3-9-写降级"><a href="#3-9-写降级" class="headerlink" title="3.9 写降级"></a>3.9 写降级</h3><p>在 CAP 原理和 BASE 理论中，写操作存在于<strong>数据一致性</strong>这个环节。降级的目的是为了提供高可用性，在多数的互联网架构中，可用性是大于数据一致性的。所以丧失写入数据同步，通过上面的理论，我们也可以勉强接受数据最终一致性。所以在高并发场景下，写入操作无法及时同步或者抗压，可以降级为异步消费数据/cache更新/log等方式。</p><p><img src="../../images/%E6%9E%B6%E6%9E%84/9/%E9%99%8D%E7%BA%A7%E5%BA%94%E7%94%A8.png"></p><h3 id="3-10-前端降级"><a href="#3-10-前端降级" class="headerlink" title="3.10 前端降级"></a>3.10 前端降级</h3><p>当系统出现问题的时候，尽量让请求隔离在离用户最近的位置，避免无效链路访问，防止雪崩。</p><p>在后端服务部分或完全不可用的时候，可以使用本地缓存或兜底数据。在一些特殊场景下，对数据一致性要求不高的时候，比如秒杀、抽奖等可以做假数据。</p><h4 id="js-降级"><a href="#js-降级" class="headerlink" title="js 降级"></a>js 降级</h4><p>在 js 中埋降级开关，在访问不到或者系统阈值的时候可以避免发送请求。</p><h4 id="接入层降级"><a href="#接入层降级" class="headerlink" title="接入层降级"></a>接入层降级</h4><p>可以在接入层，在用户请求还没有到达服务的时候，通过 nginx + lua 或者 Haproxy + lua 过滤无效请求和服务降级。</p><h4 id="应用层降级"><a href="#应用层降级" class="headerlink" title="应用层降级"></a>应用层降级</h4><p>hystrix。</p><h4 id="片段降级"><a href="#片段降级" class="headerlink" title="片段降级"></a>片段降级</h4><p>在页面中异步加载数据，可能有一部分无法得到。比如 js、css 无法加载，可以使用兜底 css。</p><h4 id="静态化处理"><a href="#静态化处理" class="headerlink" title="静态化处理"></a>静态化处理</h4><p>在活动前可以通过静态化技术，把原来需要调用多个动态接口的页面整体缓存下来保存成一个静态文件。当动态服务无法支撑的时候，可以降级为静态化服务。</p><p>静态文件中尽量不要去异步加载数据。静态文件中包含的动态内容，可以使用模板技术定时生成更新。</p><h4 id="提前预埋"><a href="#提前预埋" class="headerlink" title="提前预埋"></a>提前预埋</h4><p>大促前，在 APP、浏览器缓存一些数据比如 js/css 等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在高并发场景下，当系统中的一些功能组件出现异常，无法继续提供服务的时候，为了保证整体系统可用性，可以牺牲一部分功能依旧提供&lt;strong&gt;有损服务&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(四)</title>
    <link href="http://yoursite.com/2021-01-17-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(4)-%E7%BC%93%E5%AD%98.html"/>
    <id>http://yoursite.com/2021-01-17-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(4)-%E7%BC%93%E5%AD%98.html</id>
    <published>2021-01-17T12:43:12.000Z</published>
    <updated>2021-01-17T15:15:49.321Z</updated>
    
    <content type="html"><![CDATA[<ul><li>CAP 理论、BASE 理论</li><li>Redis、Zookeeper、Eureka 对比</li></ul><a id="more"></a><h2 id="1、服务并发化"><a href="#1、服务并发化" class="headerlink" title="1、服务并发化"></a>1、服务并发化</h2><p>一个网页，不可能一次把所有数据都请求加载出来。应该优先加载骨架和重要信息，然后异步并发加载其他信息。</p><h2 id="2、客户端缓存"><a href="#2、客户端缓存" class="headerlink" title="2、客户端缓存"></a>2、客户端缓存</h2><h3 id="2-1-浏览器缓存"><a href="#2-1-浏览器缓存" class="headerlink" title="2.1 浏览器缓存"></a>2.1 浏览器缓存</h3><p>首先，限定在 get 请求，其他请求不会缓存。由于浏览器缓存涉及到的应用比较多，所以针对不同的应用和版本效果也会有差异</p><p>浏览器：chrome</p><p>服务器：nginx</p><p>在系统中不常改变的资源上可以使用浏览器缓存，其中在 frame 下</p><pre><code>Cache-Control: max-age=2592000ETag: &quot;5d8c4a06-a0fc&quot;  Expires: Sat, 26 Oct 2019 15:16:24 GMT</code></pre><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>http1.1支持</p><p>在 HTTP 协议中 <strong>If-Modified-Since</strong> 和 <strong>If-None-Match</strong> 分别对应 <strong>Last-Modified</strong> 和 <strong>ETag</strong>，ETag 就是 Entity Tag 的缩写，中文译过来就是实体标签的意思。HTTP 中并没有指定如何生成 ETag，哈希是比较理想的选择。</p><p>在计算 Etag 的时候，会产生 CPU 的耗费，所以也可以用时间戳，但这样直接使用 Last-Modified 即可。</p><p>ETag 用来校验用户请求的资源是否有变化，作用和 Last-Modified 很像，区别是 Last-Modified 只能精确到秒，ETag 可以用 hash 算法来生成更精确的比对内容。</p><p>当用户首次请求资源的时候返回给用户数据和 200 状态码并生成 ETag，再次请求的时候服务器比对 ETag，没有发生变化的话返回 304。</p><h4 id="Cache-Control-、Expires"><a href="#Cache-Control-、Expires" class="headerlink" title="Cache-Control 、Expires"></a>Cache-Control 、Expires</h4><p>Last-Modified : 表示文档最后修改时间，浏览器在访问重复资源的时候会发送<code>IF-Modified-Since</code> 携带此时间去服务器验证，如果时间匹配则返回 304，浏览器加载本地资源</p><p>Expires： 文档过期时间，在浏览器内可以通过这个时间来判断是否发送请求。如果没有过期，请求都不用发，直接使用缓存。</p><p>Cache-Control ：http1.1 的规范，使用 max-age 表示文件可以在浏览器中缓存的时间以秒为单位</p><p><strong>Cache-Control</strong> 缓存头,分为响应头和请求头</p><table><thead><tr><th>标记</th><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>public</td><td>响应头</td><td>响应的数据可以被缓存，客户端和代理层都可以缓存</td></tr><tr><td>private</td><td>响应头</td><td>可私有缓存，客户端可以缓存，代理层不能缓存（CDN，proxy_pass）</td></tr><tr><td>no-cache</td><td>请求头</td><td>可以使用本地缓存，但是必须发送请求到服务器回源验证</td></tr><tr><td>no-store</td><td>请求和响应</td><td>应禁用缓存</td></tr><tr><td>max-age</td><td>请求和响应</td><td>文件可以在浏览器中缓存的时间以秒为单位</td></tr><tr><td>s-maxage</td><td>请求和响应</td><td>用户代理层缓存，CDN 下发，当客户端数据过期时会重新校验</td></tr><tr><td>max-stale</td><td>请求和响应</td><td>缓存最大使用时间，如果缓存过期，但还在这个时间范围内则可以使用缓存数据</td></tr><tr><td>min-fresh</td><td>请求和响应</td><td>缓存最小使用时间，</td></tr><tr><td>must-revalidate</td><td>请求和响应</td><td>当缓存过期后，必须回源重新请求资源。比no-cache更严格。因为HTTP 规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候。那么带有must-revalidate的缓存必须校验，其他条件全部失效。</td></tr><tr><td>proxy-revalidate</td><td>请求和响应</td><td>和must-revalidate类似，只对CDN这种代理服务器有效，客户端遇到此头，需要回源验证</td></tr><tr><td>stale-while-revalidate</td><td>响应</td><td>表示在指定时间内可以先使用本地缓存，后台进行异步校验</td></tr><tr><td>stale-if-error</td><td>响应</td><td>在指定时间内，重新验证时返回状态码为5XX的时候，可以用本地缓存</td></tr><tr><td>only-if-cached</td><td>响应</td><td>那么只使用缓存内容，如果没有缓存 则504 getway timeout</td></tr></tbody></table><p>在浏览器和服务器端验证文件是否过期的时候，浏览器在二次请求的时候会携带 IF-Modified-Since 属性。</p><h4 id="Cache-Control-和-ETag-区别"><a href="#Cache-Control-和-ETag-区别" class="headerlink" title="Cache-Control 和 ETag 区别"></a>Cache-Control 和 ETag 区别</h4><p>Cache-Control 直接是通过不请求来实现，而 ETag 是会发请求的，只不过服务器根据请求的东西的内容有无变化来判断是否返回请求的资源。</p><h4 id="强制刷新"><a href="#强制刷新" class="headerlink" title="强制刷新"></a>强制刷新</h4><p>在强制刷新的时候浏览器就不再发送 <code>IF-Modified-Since</code> 了，而会带上<code>from disk cache &amp; from memory cache</code> 可以验证请求是否使用了浏览器缓存和是否发送请求给服务器端。</p><p>当点击链接、引入外部资源和浏览器的前进后退的时候，会强制刷新？</p><h4 id="from-memory-cache"><a href="#from-memory-cache" class="headerlink" title="from memory cache"></a>from memory cache</h4><p>字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，<strong>不会请求服务器</strong>，一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache 的情况。</p><h4 id="from-disk-cache"><a href="#from-disk-cache" class="headerlink" title="from disk cache"></a>from disk cache</h4><p>是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，<strong>不会请求服务器</strong>但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会 from disk cache</p><p>不做深入研究。js 脚本，css，图片，音视频，字体</p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>是 CDN 添加的属性表示在 CDN 中缓存了多少秒。</p><h4 id="via"><a href="#via" class="headerlink" title="via"></a>via</h4><p>用来标识 CDN 缓存经历了哪些服务器，缓存是否命中，使用的协议</p><h3 id="2-2-浏览器缓存原则"><a href="#2-2-浏览器缓存原则" class="headerlink" title="2.2 浏览器缓存原则"></a>2.2 浏览器缓存原则</h3><ul><li><p><strong>首页</strong>可以看做是框架，应该禁用缓存，以保证加载的资源都是最新的</p></li><li><p>还有一些场景下我们希望禁用浏览器缓存。比如轮训 api 上报数据</p></li><li><p>浏览器缓存很难彻底禁用，大家的做法是加版本号，随机数等方法。</p></li><li><p>只缓存 200 响应头的数据，像 3XX 这类跳转的页面不需要缓存。</p></li><li><p>对于 js，css 这类可以缓存很久的数据，可以通过加版本号的方式更新内容</p></li><li><p>不需要强一致性的数据，可以缓存几秒</p></li><li><p>异步加载的接口数据，可以使用 ETag 来校验。</p></li><li><p>在服务器添加 Server 头，有利于排查错误</p></li></ul><h2 id="3、应用缓存"><a href="#3、应用缓存" class="headerlink" title="3、应用缓存"></a>3、应用缓存</h2><p>分为手机 APP 和 Client 以及是否遵循 http 协议来讨论。</p><p>在没有联网的状态下可以展示数据</p><p>流量消耗过多</p><ul><li>漂亮的加载过程</li><li>提前下发  避免秒杀时同时下发数据造成流量短时间暴增</li><li>兜底数据 在服务器崩溃和网络不可用的时候展示</li><li>临时缓存  退出即清理</li><li>固定缓存  展示框架这种，可能很长时间不会更新，可以随客户端下发</li><li>父子连接 页面跳转时有一部分内容不需要重新加载，可以从父菜单带过来</li><li>预加载     某些逻辑可以判定用户接下来的操作，那么可以异步加载那些资源</li><li>异步加载 先展示框架，然后异步加载内容，避免主线程阻塞</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;CAP 理论、BASE 理论&lt;/li&gt;
&lt;li&gt;Redis、Zookeeper、Eureka 对比&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(五)</title>
    <link href="http://yoursite.com/2021-01-17-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(5)-CAP%E7%90%86%E8%AE%BA.html"/>
    <id>http://yoursite.com/2021-01-17-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(5)-CAP%E7%90%86%E8%AE%BA.html</id>
    <published>2021-01-17T12:43:12.000Z</published>
    <updated>2021-01-17T14:56:22.347Z</updated>
    
    <content type="html"><![CDATA[<ul><li>CAP 理论、BASE 理论</li><li>Redis、Zookeeper、Eureka 对比</li></ul><a id="more"></a><h2 id="1、日志"><a href="#1、日志" class="headerlink" title="1、日志"></a>1、日志</h2><h3 id="1-1-异常控制-错误编码"><a href="#1-1-异常控制-错误编码" class="headerlink" title="1.1 异常控制/错误编码"></a>1.1 异常控制/错误编码</h3><p>细分异常，多下功夫，功夫不是白费的，有可能一天、一个月、一年一个错误编码也没抛出来，但是<strong>一旦出了问题能够急速定位，根本不用看代码</strong>。</p><p>我们永远不能保证系统没有 bug，bug 可以藏的很深埋的很久，但我们不怕，因为我们的伏兵也一 直在，你一跳我们立马抓，毫不犹豫。</p><h2 id="2、异步"><a href="#2、异步" class="headerlink" title="2、异步"></a>2、异步</h2><p>异步本身不是什么高深的技术，关键是哪些 业务可以走异步，这更体现架构师的业务理解能力和综合能力。</p><h2 id="3、6-个-9"><a href="#3、6-个-9" class="headerlink" title="3、6 个 9"></a>3、6 个 9</h2><p>99.9999%。可用性、数据一致性。</p><h2 id="4、ACID-特性"><a href="#4、ACID-特性" class="headerlink" title="4、ACID 特性"></a>4、ACID 特性</h2><p>以传统数据库为代表，依然坚守：原子性、一致性、隔离性、持久性</p><h2 id="5、CAP-原则"><a href="#5、CAP-原则" class="headerlink" title="5、CAP 原则"></a>5、CAP 原则</h2><p>CAP 定理又被成为布鲁尔定理，是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。</p><p>CAP 定义，在高并发的场景下要做取舍，在<strong>大型集群中分区容错很难保证</strong>，一旦要确保容错性，那么就会损失数据一致性和高可用特性。</p><h3 id="5-1-Consistency-数据一致性"><a href="#5-1-Consistency-数据一致性" class="headerlink" title="5.1 Consistency-数据一致性"></a>5.1 Consistency-数据一致性</h3><p>G1，G2 为数据节点，同时存储了键值对 key=v、value=0</p><p>如果当前节点写完即返回完成：</p><ul><li>数据写入完成，G1-&gt;v:1，写入完成后，在向G1读取数据的时候就会得到v:1，此时是一致性</li><li>那么此时如果向G2发起读请求的话，因为数据没有同步，就会得到v:0,此时<strong>数据不一致</strong></li></ul><p>如果集群所有节点同步完成才返回完成：</p><ul><li>写入G1</li><li>G1 向 G2 同步数据</li><li><strong>等待</strong>同步完成</li><li>通知写完成</li><li>读取数据</li></ul><p>这样似乎得到了一致性，一致性是指分布式系统中，数据在多节点存在副本，那么数据如果<strong>一直不修改</strong>，在读的时候是不存在问题的，你访问哪个节点的数据都一样。可一旦要是发生了<strong>修改</strong>，那么数据同步无法在修改的<strong>瞬间</strong>广播到所有副本节点，那么在读的时候就可能发生<strong>数据脏读</strong>。</p><p><strong>同步存在的问题</strong>：</p><ol><li>集群非常大同步时间太长</li><li>集群节点挂了怎么办？</li><li>怎么同步？</li><li>同步过程中，可不可以读取？</li></ol><h4 id="如何解决数据一致性问题？"><a href="#如何解决数据一致性问题？" class="headerlink" title="如何解决数据一致性问题？"></a>如何解决数据一致性问题？</h4><p><strong>数据库</strong></p><p>单点/AP</p><p><strong>redis 高性能</strong></p><p>AP</p><p>分布式锁：AOF RDB？</p><p><strong>redis 不能做分布式锁？不能，因为分布式锁要求强一致性，redis 做不到</strong></p><p>redis：注重可用性 A</p><p>zk：注重数据一致性 C</p><p>脏写=&gt;脑裂</p><p><strong>zookeeper-饥渴式</strong></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/5/zk%E9%A5%A5%E6%B8%B4%E5%BC%8F.png"></p><p><strong>zookeeper-懒汉式</strong></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/5/zk%E6%87%92%E6%B1%89%E5%BC%8F.png"></p><p><strong>数据篡改</strong></p><p>拜占庭将军问题</p><h3 id="5-2-Availability-可用性"><a href="#5-2-Availability-可用性" class="headerlink" title="5.2 Availability-可用性"></a>5.2 Availability-可用性</h3><p>指的是服务是否可用，范围涵盖终端客户访问我们的系统或者是集群内部相互通讯交换数据，也就是说在 Client 向 Server 发起请求时，服务器返回了正确的响应，称之为可用，反之为不可用。</p><p><strong>这里有一个问题，如果发送请求在300年后给我返回数据了，那么算不算可用？</strong></p><p>所以要提出访问延迟的概念，在某个时间范围内响应才算可用。</p><p><strong>1s法则</strong></p><p>1S 法则”是面向 Web 侧，H5 链路上加载性能 和体验方向上的一个指标，具体指：</p><ul><li>“强网” (4G/WIFI)下，1秒完全完成页面加载，包括首屏 资源，可看亦可用;</li><li>3G下1秒完成首包的返回 ;</li><li>2G下1秒完成建连。</li></ul><p><strong>高可用架构在实施的时候可以分两个方向</strong></p><h4 id="客户端容错"><a href="#客户端容错" class="headerlink" title="客户端容错"></a>客户端容错</h4><p>例如：游戏服务器。某一个区挂了，可以换一个区继续玩。</p><h4 id="服务器端容错"><a href="#服务器端容错" class="headerlink" title="服务器端容错"></a>服务器端容错</h4><p>例如：Nginx负载均衡。</p><p><strong>Redis 和 Zookeeper 如何选择</strong></p><p>需要存数据、高可用用 Redis；需要协调、数据一致性用 zk。</p><h3 id="5-3-Partition-Tolerance-分区容忍性"><a href="#5-3-Partition-Tolerance-分区容忍性" class="headerlink" title="5.3 Partition Tolerance-分区容忍性"></a>5.3 Partition Tolerance-分区容忍性</h3><p>发生在分布式系统<strong>内部</strong>互访通信，是指分布式网络中部分<strong>网络</strong>不可用，但系统依然正常对外提供<strong>服务</strong>。</p><p>分区容错性是指分区具有容错性，我们可以尽可能的提高容错性，但是<strong>无法避免</strong>，如果发生分区问题，就要在 A 和 C 之间做出选择。<strong>要么停止系统进行错误恢复，要么继续服务但是降低一致性，所以我们说只能保证 AP 或 CP。</strong></p><p>单节点，没有分区问题。</p><p>集群，节点间存在网络，有分区问题，并且导致分区不仅仅是网络问题，可能其他各种故障导致两个节点间无法访问。分区不仅仅是指两个节点间网络。有可能 a 可以访问，但是 b 不能访问。</p><p>CP：一致性+分区容错性。允许网络异常的情况下，提高数据一致性。</p><p>AP：可用性+分区容错性。</p><p>CA：实现不了。因为没有网络的容忍，要实现 CA，要保证网络永远是好的。</p><p>我的理解就是当网络出现问题，你是想保证可用性还是数据一致性。</p><p>高可用带来的是高性能，强一致性带来的是低性能。</p><p><strong>要强一致性的地方</strong>: </p><ul><li>唯一ID生成, 这种性能很差. 并发不高.</li><li>对一致性要求比较高的系统，例如银行转账</li></ul><p>要高可用: 最终一致， 即有可能读到脏数据，但是一段时间之后总是能够读到新数据。</p><h3 id="5-4-Zookeeper和Eureka"><a href="#5-4-Zookeeper和Eureka" class="headerlink" title="5.4 Zookeeper和Eureka"></a>5.4 Zookeeper和Eureka</h3><h4 id="zookeepr"><a href="#zookeepr" class="headerlink" title="zookeepr"></a><strong>zookeepr</strong></h4><p>保证 <strong>CP</strong>，即任何时刻对 zookeeper 的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性。从实际情况来分析，在使用 zookeeper 获取服务列表时，如果 zk 正在选举或者 zk 集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk 不能保证服务可用性。</p><h4 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h4><p>保证 <strong>AP</strong>，eureka 在设计时优先保证可用性，每一个节点都是平等的，一部分节点挂掉不会影响到正常节点的工作，不会出现类似 zk 的选举 leader 的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点，只要有一台 eureka 存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信息。</p><h3 id="5-5-BASE-理论"><a href="#5-5-BASE-理论" class="headerlink" title="5.5 BASE 理论"></a>5.5 BASE 理论</h3><p>eBay 的架构师 Dan Pritchet t<strong>源于对大规模分布式系统的实践总结</strong>，在 ACM 上发表文章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（StrongConsistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p><h4 id="Basically-Available"><a href="#Basically-Available" class="headerlink" title="Basically Available"></a>Basically Available</h4><p><strong>基本可用</strong></p><p>在分布式系统出现故障的时候，允许损失部分可用性,支持分区失败，即保证核心可用。</p><h4 id="Soft-State"><a href="#Soft-State" class="headerlink" title="Soft State"></a>Soft State</h4><p><strong>软状态</strong></p><p>接受一段时间的状态不同步，及中间状态，而改中间状态不影响系统整体可用性。这里的中间状态就是CAP理论中的数据不一致性。</p><h4 id="Eventually-Consistent"><a href="#Eventually-Consistent" class="headerlink" title="Eventually Consistent"></a>Eventually Consistent</h4><p><strong>最终一致性</strong></p><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;CAP 理论、BASE 理论&lt;/li&gt;
&lt;li&gt;Redis、Zookeeper、Eureka 对比&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(三)</title>
    <link href="http://yoursite.com/2021-01-16-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(3)-dns%E5%92%8Cnginx%E9%80%9A%E8%BF%87lua%E8%AE%BF%E9%97%AEredis.html"/>
    <id>http://yoursite.com/2021-01-16-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(3)-dns%E5%92%8Cnginx%E9%80%9A%E8%BF%87lua%E8%AE%BF%E9%97%AEredis.html</id>
    <published>2021-01-16T12:43:12.000Z</published>
    <updated>2021-01-17T15:20:21.563Z</updated>
    
    <content type="html"><![CDATA[<ul><li>如何搭建一个高并发系统架构</li><li>Lua 语言学习</li></ul><a id="more"></a><h2 id="1、域名、DNS"><a href="#1、域名、DNS" class="headerlink" title="1、域名、DNS"></a>1、域名、DNS</h2><p>当流量极大，不能用某一台单独的机器来接入流量。nginx 之能 5 万。即使是物理的 F4 负载均衡，只要在一台服务器上，肯定是有上限的。所以需要通过域名来配置多个服务器。</p><h3 id="1-1-浏览器如何通过域名得到-ip"><a href="#1-1-浏览器如何通过域名得到-ip" class="headerlink" title="1.1 浏览器如何通过域名得到 ip"></a>1.1 浏览器如何通过域名得到 ip</h3><ol><li>查询本地 hosts 文件</li><li>查询本机 dns 缓存</li><li>查询远程 dns 服务器</li><li>把 ip 缓存到本机</li></ol><h3 id="1-2-dns-服务器上为啥有你的域名和-ip-映射？"><a href="#1-2-dns-服务器上为啥有你的域名和-ip-映射？" class="headerlink" title="1.2 dns 服务器上为啥有你的域名和 ip 映射？"></a>1.2 dns 服务器上为啥有你的域名和 ip 映射？</h3><p>你购买域名时，需要配置解析，即域名对应的服务器，并且需要配置 dns 服务器。dns 服务器会互相<strong>数据广播</strong>，把你配置的解析同步到网上的 dns 服务器。</p><h3 id="1-3-dns-服务器支持域名、ip一对多"><a href="#1-3-dns-服务器支持域名、ip一对多" class="headerlink" title="1.3 dns 服务器支持域名、ip一对多"></a>1.3 dns 服务器支持域名、ip一对多</h3><p>配置多个 ip 目的是为了达到基于域名的负载均衡。</p><p>但是需要一定的业务逻辑，让 dns 服务器知道，到底该给你哪个 ip。这个业务逻辑的实现需要在配置域名解析时的 dns 服务器是智能 dns，智能 dns 可以获取客户端请求的 ip 地址，根据 ip 地址分析地区或者 ISP 供应商，然后返回对应地区的 ip 地址，即返回离客户端最近的 ip 地址。</p><h3 id="1-4-CDN-节点组成"><a href="#1-4-CDN-节点组成" class="headerlink" title="1.4 CDN 节点组成"></a>1.4 CDN 节点组成</h3><ul><li>负载均衡设备</li><li>高速缓存服务器</li></ul><p>其实就是一个负载均衡器 lvs 或 nginx，配合 keepalived 做到入口高可用，代理或转发请求到内网节点做负载均衡。</p><h3 id="1-5-CDN-应用场景"><a href="#1-5-CDN-应用场景" class="headerlink" title="1.5 CDN 应用场景"></a>1.5 CDN 应用场景</h3><p><strong>适用</strong></p><ol><li>css、js、img 等 html 骨架中包含的静态资源</li><li>app 内需要的 img、html 等资源</li><li>音视频点播资源</li><li>大文件下载</li></ol><p><strong>不适用</strong></p><ol><li>私密的商业数据</li><li>包含有逻辑的请求</li><li>需要鉴权 </li><li>长连接</li><li>reactor 模型</li><li>即时通讯</li></ol><h2 id="2、Nginx-访问-redis"><a href="#2、Nginx-访问-redis" class="headerlink" title="2、Nginx 访问 redis"></a>2、Nginx 访问 redis</h2><h3 id="2-1-redis2-nginx-module"><a href="#2-1-redis2-nginx-module" class="headerlink" title="2.1 redis2-nginx-module"></a>2.1 redis2-nginx-module</h3><p>redis2-nginx-module 是一个支持 Redis 2.0 协议的 Nginx upstream 模块，它可以让 Nginx 以非阻塞方式直接防问远方的 Redis 服务，同时支持 TCP 协议和 Unix Domain Socket 模式，并且可以启用强大的 Redis 连接池功能。</p><p><a href="https://github.com/openresty/redis2-nginx-module">https://github.com/openresty/redis2-nginx-module</a></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="nginx"># redis2-nginx-module 访问 redis，测试location /redis2_test &#123;    default_type text/html;    redis2_pass 127.0.0.1:6379;    #redis2_query auth pass9876;    set $value &#39;first&#39;;    redis2_query set one $value;&#125;</code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="nginx"># redis2-nginx-module 访问 redis, setlocation /redis2_set &#123;    default_type text/html;    redis2_pass 127.0.0.1:6379;    #redis2_query auth pass9876;    set_unescape_uri $key $arg_key;    set_unescape_uri $val $arg_val;    redis2_query set $key $val;&#125;</code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre><code class="nginx"># redis2-nginx-module 访问 redis, getlocation /redis2_get &#123;    default_type text/html;    redis2_pass 127.0.0.1:6379;    #redis2_query auth pass9876;    set_unescape_uri $key $arg_key;    redis2_query get $key;&#125;</code></pre><h4 id="pipelined"><a href="#pipelined" class="headerlink" title="pipelined"></a>pipelined</h4><pre><code class="nginx"># redis2-nginx-module 访问 redis, pipelinedlocation /redis2_pipeline &#123;    default_type text/html;    redis2_pass 127.0.0.1:6379;    #redis2_query auth pass9876;    set $value &#39;fitst&#39;;    redis2_query set one $value;    redis2_query get one;    redis2_query set one two;    redis2_query get one;&#125;</code></pre><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><pre><code class="nginx"># redis2-nginx-module 访问 redis, listlocation /redis2_list &#123;    default_type text/html;    redis2_pass 127.0.0.1:6379;    #redis2_query auth pass9876;    redis2_query lpush key1 C;    redis2_query lpush key1 B;    redis2_query lpush key1 A;    redis2_query lrange key1 0 -1;&#125;</code></pre><h4 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h4><pre><code class="nginx"># upstream 和 server 同一个层级upstream redis_cluster &#123;    server 127.0.0.1:6379;    server 127.0.0.1:6379;&#125;# redis2-nginx-module 访问 redis, clusterlocation /redis2_cluster &#123;    default_type text/html;    redis2_pass redis_cluster;    redis2_next_upstream error timeout invalid_response;    redis2_query get one;&#125;</code></pre><h3 id="2-2-lua-resty-redis-访问-redis"><a href="#2-2-lua-resty-redis-访问-redis" class="headerlink" title="2.2 lua-resty-redis 访问 redis"></a>2.2 lua-resty-redis 访问 redis</h3><p>2.1 方式访问 redis，不好写业务逻辑，可以用 lua-resty-reids，通过 lua 来直接访问 redis。</p><p><a href="https://github.com/openresty/lua-resty-redis">https://github.com/openresty/lua-resty-redis</a></p><p><strong>nginx.conf</strong></p><pre><code class="nginx"># lua-resty-redislocation /lua_resty_redis &#123;    default_type text/html;    content_by_lua_file conf/lua/lua_resty_redis.lua;&#125;</code></pre><p><strong>lua_resty_redis.lua</strong></p><pre><code class="lua">-- 引入 resty.redislocal redis = require &quot;resty.redis&quot;-- 初始化实力local red = redis:new()red:set_timeouts(1000, 1000, 1000)local ok, err = red:connect(&quot;127.0.0.1&quot;, 6379)if not ok then    ngx.say(&quot;failed to connect:&quot;, err)    returnend--local res, err = red:auth(&quot;pass9876&quot;)--if not res then--    ngx.say(&quot;failed to authenticate:&quot;, err)--    return--endok, err = red:set(&quot;dog&quot;, &quot;an animal&quot;)if not ok then    ngx.say(&quot;failed to set dog:&quot;, err)    returnendngx.say(&quot;set result:&quot;, ok)local res, err = red:get(&quot;dog&quot;)if not res then    ngx.say(&quot;failed to get dog: &quot;, err)    returnendif res == ngx.null then    ngx.say(&quot;dog not found.&quot;)    returnendngx.say(&quot;dog: &quot;, res)red:init_pipeline()red:set(&quot;cat&quot;, &quot;Marry&quot;)red:set(&quot;horse&quot;, &quot;Bob&quot;)red:get(&quot;cat&quot;)red:get(&quot;horse&quot;)local results, err = red:commit_pipeline()if not results then    ngx.say(&quot;failed to commit the pipelined requests: &quot;, err)    returnendfor i, res in ipairs(results) do   if type(res) == &quot;table&quot; then        if res[1] == false then            ngx.say(&quot;failed to run command &quot;, i, &quot;: &quot;, res[2])        else            -- process the table value        end    else        -- process the scalar value    endend-- put it into the connection pool of size 100,-- with 10 seconds max idle timelocal ok, err = red:set_keepalive(10000, 100)if not ok then    ngx.say(&quot;failed to set keepalive: &quot;, err)    returnend-- or just close the connection right away:-- local ok, err = red:close()-- if not ok then--     ngx.say(&quot;failed to close: &quot;, err)--     return-- end</code></pre><p><strong>redis-cluster 支持</strong></p><p><a href="https://github.com/steve0511/resty-redis-cluster">https://github.com/steve0511/resty-redis-cluster</a></p><h2 id="3、URL-一致性哈希负载均衡-lua-resty-http"><a href="#3、URL-一致性哈希负载均衡-lua-resty-http" class="headerlink" title="3、URL 一致性哈希负载均衡 lua-resty-http"></a>3、URL 一致性哈希负载均衡 lua-resty-http</h2><p>有针对性的对 url 进行一致性 hash 定向负载到后端 Nginx ，提高 Nginx 缓存系统命中率。</p><h3 id="3-1-nginx-url-hash"><a href="#3-1-nginx-url-hash" class="headerlink" title="3.1 nginx url_hash"></a>3.1 nginx url_hash</h3><p>Nginx第三方模块，在转发请求时如果后端服务器宕机，会导致503错误</p><h3 id="3-2-lua-resty-http"><a href="#3-2-lua-resty-http" class="headerlink" title="3.2 lua-resty-http"></a>3.2 lua-resty-http</h3><p><a href="https://github.com/ledgetech/lua-resty-http">https://github.com/ledgetech/lua-resty-http</a></p><h4 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h4><p>wget <a href="https://github.com/ledgetech/lua-resty-http/archive/v0.15.tar.gz">https://github.com/ledgetech/lua-resty-http/archive/v0.15.tar.gz</a></p><p>把 http_headers.lua、http.lua 移动到 <code>/usr/local/openresty/lualib/resty</code> 即可。</p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p><strong>nginx.conf</strong></p><pre><code class="nginx"># lua-resty-httplocation /lua_resty_http &#123;    resolver 8.8.8.8;    default_type text/html;    content_by_lua_file conf/lua/lua_resty_http_test.lua;&#125;</code></pre><p><strong>lua_resty_http_test.lua</strong></p><pre><code class="lua">local http = require(&quot;resty.http&quot;)local httpc = http.new()local resp, err = httpc:request_uri(&quot;http://www.sogou.com&quot;, &#123;    method = &quot;GET&quot;,    path= &quot;/sogou?query=resty.http&quot;,    headers = &#123;        [&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36&quot;    &#125;,    keepalive_timeout = 60000,    keepalive_pool = 10&#125;)if not resp then    ngx.say(&quot;request error:&quot;, err)    returnendngx.status = resp.statusfor k,v in pairs(resp.headers) do    if k ~= &quot;Transfer-Encoding&quot; and k ~= &quot;Connection&quot; then        ngx.header[k] = v    endendngx.say(resp.body)httpc:close()</code></pre><h4 id="实现一致性哈希负载均衡"><a href="#实现一致性哈希负载均衡" class="headerlink" title="实现一致性哈希负载均衡"></a>实现一致性哈希负载均衡</h4><p><strong>nginx.conf</strong></p><pre><code class="nginx"># lua-resty-http 一致性哈希负载均衡location /lua_resty_http_lb &#123;    resolver 8.8.8.8;    default_type text/html;    content_by_lua_file conf/lua/lua_resty_http_lb.lua;&#125;</code></pre><p><strong>lua_resty_http_lb.lua</strong></p><pre><code class="lua">local http = require(&quot;resty.http&quot;)local httpc = http.new()local hosts = &#123;&quot;192.168.47.12&quot;, &quot;192.168.47.13&quot;&#125;-- 取请求参数 id，做哈希local item_id = ngx.var.arg_idlocal id_hash = ngx.crc32_long(item_id)local index = (id_hash % 2) + 1local resp, err = httpc:request_uri(&quot;http://&quot;..hosts[index], &#123;    method = &quot;GET&quot;,    path = &quot;/?query=resty.http&quot;,    headers = &#123;        [&quot;User-Agent&quot;] = &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36&quot;    &#125;&#125;)if not resp then    ngx.say(&quot;request error:&quot;, err)    returnendngx.say(resp.body)httpc:close()</code></pre><p>192.168.47.12、192.168.47.13 机器启动两个服务。</p><pre><code class="shell">yum install httpdservice httpd startvim /var/www/html/index.html&lt;h1&gt;hi, this is node02&lt;/h1&gt;&lt;h1&gt;hi, this is node03&lt;/h1&gt;</code></pre><h2 id="4、模板实时渲染-lua-resty-template"><a href="#4、模板实时渲染-lua-resty-template" class="headerlink" title="4、模板实时渲染 lua-resty-template"></a>4、模板实时渲染 lua-resty-template</h2><p><a href="https://github.com/bungle/lua-resty-template">https://github.com/bungle/lua-resty-template</a></p><p>如果学习过 JavaEE 中的 servlet 和 JSP 的话，应该知道 JSP 模板最终会被翻译成 Servlet 来执行；</p><p>而 lua-resty-template 模板引擎可以认为是 JSP，其最终会被翻译成 Lua 代码，然后通过 ngx.print 输出。   </p><p><strong>lua-resty-template 大体内容</strong>有： </p><p>l   模板位置：从哪里查找模板； </p><p>l   变量输出/转义：变量值输出； </p><p>l   代码片段：执行代码片段，完成如 if/else、for 等复杂逻辑，调用对象函数/方法； </p><p>l   注释：解释代码片段含义； </p><p>l   include：包含另一个模板片段； </p><p>l   其他：lua-resty-template还提供了不需要解析片段、简单布局、可复用的代码块、宏指令等支持。</p><p><strong>基础语法</strong></p><pre><code>&#123;(include_file)&#125;：包含另一个模板文件；&#123;* var *&#125;：变量输出；&#123;&#123; var &#125;&#125;：变量转义输出；&#123;% code %&#125;：代码片段；&#123;# comment #&#125;：注释；&#123;-raw-&#125;：中间的内容不会解析，作为纯文本输出；</code></pre><h3 id="4-1-lua-代码热加载"><a href="#4-1-lua-代码热加载" class="headerlink" title="4.1 lua 代码热加载"></a>4.1 lua 代码热加载</h3><p>在 http 模块中加入</p><pre><code class="nginx">lua_code_cache off;</code></pre><p>reload 后 Nginx 会提示影响性能，记得在生产环境中关掉。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;如何搭建一个高并发系统架构&lt;/li&gt;
&lt;li&gt;Lua 语言学习&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(二)</title>
    <link href="http://yoursite.com/2021-01-08-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(2)-redis%E6%89%A7%E8%A1%8Clua%E5%92%8Cnginx%E6%89%A7%E8%A1%8Clua.html"/>
    <id>http://yoursite.com/2021-01-08-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(2)-redis%E6%89%A7%E8%A1%8Clua%E5%92%8Cnginx%E6%89%A7%E8%A1%8Clua.html</id>
    <published>2021-01-08T12:43:12.000Z</published>
    <updated>2021-01-16T06:23:17.534Z</updated>
    
    <content type="html"><![CDATA[<ul><li>如何搭建一个高并发系统架构</li><li>Lua 语言学习</li></ul><a id="more"></a><ul><li>网关 API 路由转发</li><li>waf 软防火墙</li><li>单点登录</li><li>整合缓存系统</li><li>输出动态页面</li><li>直接输出 JSON</li></ul><h2 id="1、Redis-与-Lua-整合"><a href="#1、Redis-与-Lua-整合" class="headerlink" title="1、Redis 与 Lua 整合"></a>1、Redis 与 Lua 整合</h2><h3 id="1-1-Redis-执行-Lua-脚本"><a href="#1-1-Redis-执行-Lua-脚本" class="headerlink" title="1.1 Redis 执行 Lua 脚本"></a>1.1 Redis 执行 Lua 脚本</h3><p>通过 Lua 脚本的<strong>全局变量 KEYS 和 ARGV</strong>，能够访问 EVAL 和 EVALSHA 命令的 key [key …] 参数和 arg [arg …] 参数。作为 Lua Table，能够将 KEYS 和 ARGV 作为一维数组使用，其下标从 1 开始。</p><pre><code class="shell"># 命令 脚本 参数个数# 进入 redis 客户端执行eval &quot;return 1+1&quot; 0eval &quot;local msg=&#39;hello world&#39; return msg..KEYS[1]&quot; 1 AAA BBB# 直接在外部执行redis-cli -p 6380 eval &quot;return 1+1&quot; 0# 一个参数，取出参数的 key 和 valueredis-cli -p 6380 eval &quot;local msg=&#39;hello:&#39; return msg..KEYS[1]..&#39;-&#39;..ARGV[1]&quot; 1 name alvin</code></pre><h3 id="1-2-Redis-执行-Lua-脚本文件"><a href="#1-2-Redis-执行-Lua-脚本文件" class="headerlink" title="1.2 Redis 执行 Lua 脚本文件"></a>1.2 Redis 执行 Lua 脚本文件</h3><p>Lua 脚本内部允许通过内置函数<code>redis.call()、redis.pcall()</code>执行 Redis 命令</p><ul><li><code>redis.call()</code>：若 Redis 命令执行错误，将错误抛出</li><li><code>redis.pcall()</code>：若 Redis 命令执行错误，将错误返回</li></ul><p><strong>获取指定 key 的 value</strong></p><p>脚本文件内容：</p><pre><code class="lua">local key = KEYS[1]local list = redis.call(&quot;get&quot;, key)return list</code></pre><p>执行脚本：</p><pre><code class="shell"># 获取 count 这个 key 的 valueredis-cli -p 6380 --eval Test03.lua count</code></pre><p><strong>获取集合</strong></p><p>脚本文件内容：</p><pre><code class="lua">local key=KEYS[1]local list=redis.call(&quot;lrange&quot;,key,0,-1)return list</code></pre><p>执行脚本：</p><pre><code class="shell">redis-cli -p 6380 --eval Test03.lua listkey</code></pre><p><strong>网站计数</strong></p><p>脚本文件内容：</p><pre><code class="lua">local count = redis.call(&quot;get&quot;, &quot;count&quot;)redis.call(&quot;incr&quot;, &quot;count&quot;)return count</code></pre><p>执行脚本：</p><pre><code class="shell">redis-cli -p 6380 --eval Test03.lua</code></pre><p><strong>远程执行</strong></p><pre><code class="shell">redis-cli -h 192.168.2.161 -a 密码 --eval /usr/local/luascript/test.lua name age , xiao6</code></pre><h3 id="1-3-Redis-WATCH-MULTI-EXEC-与-Lua"><a href="#1-3-Redis-WATCH-MULTI-EXEC-与-Lua" class="headerlink" title="1.3 Redis WATCH/MULTI/EXEC 与 Lua"></a>1.3 Redis WATCH/MULTI/EXEC 与 Lua</h3><p>Redis 原生支持监听、事务、批处理，那么还需要 Lua 吗？</p><p>两者不存在竞争关系，而是增强关系，lua 可以完成 redis 自身没有的功能。</p><ul><li>lua 中可以使用上一步的结果，也就是可以<strong>后面的操作依赖前面操作的执行结果</strong>，MULTI 中的命令都是独立操作。</li><li>redis 本身也可以编写模块增强功能，但是 c 语言写模块，难度太大了，lua 简单的多</li><li>计算向数据移动，类似 sql 语句或者存储过程</li><li>原子操作</li></ul><p>lua 脚本要尽量短小且尽量保证同一事务写在一段脚本中，因为 redis 是单线程的，过长的执行会造成阻塞，影响服务器的性能。</p><h3 id="1-4-Redis-lua-脚本管理"><a href="#1-4-Redis-lua-脚本管理" class="headerlink" title="1.4 Redis lua 脚本管理"></a>1.4 Redis lua 脚本管理</h3><ol><li>script load：将 lua 脚本加载到 redis 内存中</li><li>script exists sha1：判断 sha1 是否已经加载到 redis 内存中</li><li>script flush：清除 redis 内存已经加载的所有 lua 脚本</li><li>script kill：杀掉正在执行的 lua 脚本</li></ol><h3 id="1-5-死锁"><a href="#1-5-死锁" class="headerlink" title="1.5 死锁"></a>1.5 死锁</h3><p>下面代码会进入死循环，导致 redis 无法接受其他命令</p><pre><code class="lua">eval &quot;while true do end&quot; 0</code></pre><p>无法接受其他命令：</p><pre><code class="shell">E:\01_code\08_jg\lua&gt;redis-cli -p 6380 eval &quot;return 1+1&quot; 0(error) BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.</code></pre><p>但是可以接受 script kill 或者 shutdown nosave 两个命令。</p><ul><li>shutdown nosave：不会进行持久化操作</li><li>script kill：杀死正在执行的进程</li></ul><pre><code class="shell">E:\01_code\08_jg\lua&gt;redis-cli -p 6380 script killE:\01_code\08_jg\lua&gt;redis-cli -p 6380 eval &quot;while true do end&quot; 0(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): @user_script:1: Script killed by user with SCRIPT KILL...</code></pre><h3 id="1-6-生产环境下部署-lua-脚本"><a href="#1-6-生产环境下部署-lua-脚本" class="headerlink" title="1.6 生产环境下部署 lua 脚本"></a>1.6 生产环境下部署 lua 脚本</h3><p><strong>加载到 redis</strong></p><pre><code class="shell">redis-cli script load &quot;$(cat test.lua)&quot;</code></pre><p>得到 sha1 值。</p><p><strong>执行</strong></p><pre><code class="shell">redis-cli evalsha &quot;7a2054836e94e19da22c13f160bd987fbc9ef146&quot; 0</code></pre><h2 id="2、Openresty-Nginx-Lua"><a href="#2、Openresty-Nginx-Lua" class="headerlink" title="2、Openresty Nginx + Lua"></a>2、Openresty Nginx + Lua</h2><p>Nginx 是一个主进程配合多个工作进程的工作模式，每个进程由单个线程来处理多个连接。在生产环境中，我们往往会把 cpu 内核直接绑定到工作进程上，从而提升性能。</p><h3 id="2-1-安装-Openresty"><a href="#2-1-安装-Openresty" class="headerlink" title="2.1 安装 Openresty"></a>2.1 安装 Openresty</h3><p>官网安装说明：<a href="http://openresty.org/cn/installation.html">http://openresty.org/cn/installation.html</a></p><p>centos 安装方式：</p><p><strong>预编译安装</strong></p><pre><code class="shell">yum install yum-utilsyum-config-manager --add-repo https://openresty.org/package/centos/openresty.repoyum install openrestysudo yum install openresty-resty</code></pre><p><strong>源码编译安装</strong></p><pre><code class="shell"># 安装依赖yum install gcc openssl-devel pcre-devel zlib-devel postgresql-devel# 编译./configure --prefix=/opt/openresty \            --with-luajit \            --without-http_redis2_module \            --with-http_iconv_module \            --with-http_postgres_module# 查看更多编译选项./configure --help# 安装make &amp;&amp; make install</code></pre><p><strong>服务命令</strong></p><pre><code class="shell">service openresty startservice openresty stopservice openresty reloadservice openresty status# 检查配置文件是否正确nginx -t# 查看已安装模块和版本号nginx -v</code></pre><h3 id="2-2-Openresty-测试-lua-脚本"><a href="#2-2-Openresty-测试-lua-脚本" class="headerlink" title="2.2 Openresty 测试 lua 脚本"></a>2.2 Openresty 测试 lua 脚本</h3><pre><code class="shell"># nginx.conf 中配置location /lua &#123;    default_type text/html;    content_by_lua &#39;        ngx.say(&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;)    &#39;;&#125;</code></pre><p>访问：<a href="http://192.168.47.11/lua">http://192.168.47.11/lua</a></p><p>中文乱码解决：在 server 对象下配置 <code>charset utf-8;</code></p><h3 id="2-3-Openresty-测试-lua-脚本文件"><a href="#2-3-Openresty-测试-lua-脚本文件" class="headerlink" title="2.3 Openresty 测试 lua 脚本文件"></a>2.3 Openresty 测试 lua 脚本文件</h3><pre><code class="shell"># nginx.conf 中配置location /lua &#123;    default_type text/html;    content_by_lua_file conf/lua/hello.lua;&#125;# 新建文件：/usr/local/openresty/nginx/conf/lua/hello.luangx.say(&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;);</code></pre><h3 id="2-4-获取-uri-中的单一变量"><a href="#2-4-获取-uri-中的单一变量" class="headerlink" title="2.4 获取 uri 中的单一变量"></a>2.4 获取 uri 中的单一变量</h3><pre><code class="shell">ngx.say(&quot;获取 nginx uri 中的单一变量，变量 a 的值为：&quot;..ngx.var.arg_a);</code></pre><h3 id="2-5-获取-uri-中的所有变量"><a href="#2-5-获取-uri-中的所有变量" class="headerlink" title="2.5 获取 uri 中的所有变量"></a>2.5 获取 uri 中的所有变量</h3><pre><code class="lua">ngx.say(&quot;获取 nginx uri 中的所有变量：&quot;, &quot;&lt;br/&gt;&quot;);local uri_args = ngx.req.get_uri_args();for k,v in pairs(uri_args) do    if type(v) == &quot;table&quot; then        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;,&quot;), &quot;&lt;br/&gt;&quot;);    else        ngx.say(k, &quot; : &quot;, v, &quot;&lt;br/&gt;&quot;);    end;end;</code></pre><h3 id="2-6-获取nginx请求头信息"><a href="#2-6-获取nginx请求头信息" class="headerlink" title="2.6 获取nginx请求头信息"></a>2.6 获取nginx请求头信息</h3><pre><code class="lua">ngx.say(&quot;获取 nginx 请求头信息：&quot;, &quot;&lt;br/&gt;&quot;);local headers = ngx.req.get_headers();ngx.say(&quot;Host:&quot;, headers[&quot;Host&quot;], &quot;&lt;br/&gt;&quot;);ngx.say(&quot;user-agent:&quot;, headers[&quot;user-agent&quot;], &quot;&lt;br/&gt;&quot;);ngx.say(&quot;user-agent:&quot;, headers.user_agent, &quot;&lt;br/&gt;&quot;);for k,v in pairs(headers) do    if type(v) == &quot;table&quot; then        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;,&quot;), &quot;&lt;br/&gt;&quot;);    else        ngx.say(k, &quot; : &quot;, v, &quot;&lt;br/&gt;&quot;);    end;end;</code></pre><h3 id="2-7-获取-post-请求参数"><a href="#2-7-获取-post-请求参数" class="headerlink" title="2.7 获取 post 请求参数"></a>2.7 获取 post 请求参数</h3><pre><code class="lua">ngx.say(&quot;获取 post 请求参数：&quot;, &quot;&lt;br/&gt;&quot;);ngx.req.read_body();local post_args = ngx.req.get_post_args();for k,v in pairs(post_args) do    if type(v) == &quot;table&quot; then        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;,&quot;), &quot;&lt;br/&gt;&quot;);    else        ngx.say(k, &quot;:&quot;, v, &quot;&lt;br/&gt;&quot;);    end;end;</code></pre><h3 id="2-8-获取-http-协议版本"><a href="#2-8-获取-http-协议版本" class="headerlink" title="2.8 获取 http 协议版本"></a>2.8 获取 http 协议版本</h3><pre><code class="lua">ngx.say(&quot;获取 http 协议版本：&quot;, &quot;&lt;br/&gt;&quot;);ngx.say(&quot;ngx.req.http_version:&quot;, ngx.req.http_version(), &quot;&lt;br/&gt;&quot;);</code></pre><h3 id="2-9-获取请求方法"><a href="#2-9-获取请求方法" class="headerlink" title="2.9 获取请求方法"></a>2.9 获取请求方法</h3><pre><code class="lua">ngx.say(&quot;获取请求方式：&quot;, &quot;&lt;br/&gt;&quot;);ngx.say(&quot;ngx.req.get_method:&quot;, ngx.req.get_method(), &quot;&lt;br/&gt;&quot;);</code></pre><h3 id="2-10-获取-body-内容体"><a href="#2-10-获取-body-内容体" class="headerlink" title="2.10 获取 body 内容体"></a>2.10 获取 body 内容体</h3><pre><code class="lua">ngx.say(&quot;获取body内容体：&quot;, &quot;&lt;br/&gt;&quot;);ngx.say(&quot;ngx.req.get_body_data():&quot;, ngx.req.get_body_data(), &quot;&lt;br/&gt;&quot;);</code></pre><h3 id="2-11-获取原始请求头"><a href="#2-11-获取原始请求头" class="headerlink" title="2.11 获取原始请求头"></a>2.11 获取原始请求头</h3><pre><code class="lua">ngx.say(&quot;获取原始请求头内容：&quot;, &quot;&lt;br/&gt;&quot;);ngx.say(&quot;ngx.req.raw_header:&quot;, ngx.req.raw_header(), &quot;&lt;br/&gt;&quot;);</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;如何搭建一个高并发系统架构&lt;/li&gt;
&lt;li&gt;Lua 语言学习&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发架构(一)</title>
    <link href="http://yoursite.com/2021-01-07-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(1)-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E5%92%8Clua%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html"/>
    <id>http://yoursite.com/2021-01-07-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(1)-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E5%92%8Clua%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-01-07T12:43:12.000Z</published>
    <updated>2021-01-07T15:32:50.398Z</updated>
    
    <content type="html"><![CDATA[<ul><li>如何搭建一个高并发系统架构</li><li>Lua 语言学习</li></ul><a id="more"></a><h2 id="1、高并发系统架构"><a href="#1、高并发系统架构" class="headerlink" title="1、高并发系统架构"></a>1、高并发系统架构</h2><h3 id="1-1-高并发多高才算高？"><a href="#1-1-高并发多高才算高？" class="headerlink" title="1.1 高并发多高才算高？"></a>1.1 高并发多高才算高？</h3><p>用 qps、pv、uv 来衡量</p><ul><li>第一阶梯：JD、阿里、腾讯。qps 没有上限<ul><li>电商详情页</li></ul></li><li>第二阶梯：国美、美团、58。单个模块，单个业务线，5k 以下</li><li>第三阶梯：瓜子、携程 等三线电商。单个模块，单个业务线，2k 以下</li></ul><h3 id="1-2-聊高并发前需要问清楚的问题"><a href="#1-2-聊高并发前需要问清楚的问题" class="headerlink" title="1.2 聊高并发前需要问清楚的问题"></a>1.2 聊高并发前需要问清楚的问题</h3><ol><li><p>流量究竟有多大？</p></li><li><p>接入的数据是否有数据一致性的要求？这是解决高并发的一个核心问题。如果有，在做网站的架构或者系统架构的时候要考虑到数据的分布、数据的同步以及要考虑数据接入时用户的响应时间。如果不要求数据的高一致性，保证数据的最终一致性即可。高一致性带来的是高的性能消耗。</p></li></ol><p>所有流量接进来的时候，第一要考虑的就是<strong>数据一致性</strong>，第二就是适当的<strong>削峰</strong>，就是把峰值的流量一点点的消耗掉，不要让大量的流量在同一时间点打到某一个单一的节点上，容易造成节点的宕机。削峰最常见的一个手段就是做集群。</p><p>但是在集群削峰之前需要有一个角色来做削峰这件事情，所以这个角色一定要<strong>能抗住峰值的流量</strong>。否则这个角色自己挂了，后面的集群机器再多也是没有用的。Nginx 在机器配置都还行的情况下官方压测声明单机可以抗住 5w 并发。但实际中不可能让某一台机器去抗 5w 并发。所以当并发量上万后，Nginx 来充当这个角色就不行了。</p><p>一般做系统用量估算的时候，单节点 tomcat 不会超过 200 qps。</p><p>一般大型系统会线通过业务线划分模块，然后配置不同域名，比如 down.qq.com、games.qq.com。我们要处理就是单个业务线，单一模块上的高并发请求。</p><h3 id="1-3-第一级别削峰：CDN-动静态缓存"><a href="#1-3-第一级别削峰：CDN-动静态缓存" class="headerlink" title="1.3 第一级别削峰：CDN 动静态缓存"></a>1.3 第一级别削峰：CDN 动静态缓存</h3><p>如果单一业务线扛不住了，比如 games.qq.com 并发超过 5w 了，Nginx 已经扛不住了，可以使用 CDN 来做第一级削峰，用 CDN 来缓存静态资源以及少量<strong>一致性要求低</strong>（比如电商系统列表页面、搜索结果页面）的动态缓存。静态缓存指的是 html、css、图片等静态资源，可以分发到全网的各个节点里；动态缓存是指请求到我们业务服务器的某个接口，缓存这些接口的返回值，后端服务器定时提交一些 url 的返回数据，从而更新 cdn 的动态缓存，另外 CDN 也可以定时去抓取服务器的数据来更新动态缓存。这样能极大的降低请求打入到业务系统。CDN 是全网的，全球各地的机器，你在上海访问，缓存在上海，你在深圳访问，缓存在深圳。</p><h3 id="1-4-第二级别削峰：LVS-对接入层-Nginx-负载均衡"><a href="#1-4-第二级别削峰：LVS-对接入层-Nginx-负载均衡" class="headerlink" title="1.4 第二级别削峰：LVS 对接入层 Nginx 负载均衡"></a>1.4 第二级别削峰：LVS 对接入层 Nginx 负载均衡</h3><p>每个 Nginx 只做反向代理。每个接入层 Nginx 分发给一组应用层 Nginx。这一层的 Nginx 也可以做适当的开发，比如将 URL 取摘要算法然后模上应用层 Nginx 组数，让相同的请求打在同一组 Nginx 上。</p><h3 id="1-5-第三级别削峰：应用层-Nginx-缓存"><a href="#1-5-第三级别削峰：应用层-Nginx-缓存" class="headerlink" title="1.5 第三级别削峰：应用层 Nginx 缓存"></a>1.5 第三级别削峰：应用层 Nginx 缓存</h3><p>根据用户数量不同考虑是否需要应用层 Nginx。</p><p>Nginx 是可以做开发的，可以写业务逻辑，比如连接 Redis、Kafka，让请求缓存更加前置或者把请求放入消息队列，达到削峰的目的。</p><ul><li>C 语言开发 Nginx 模块</li><li>Lua 语言内嵌</li></ul><p>应用层 Nginx 主要有：</p><ul><li>Nginx + Lua + Redis：请求访问到应用层 Nginx 直接返回</li><li>Nginx + Lua + Kafka：把请求丢进消息队列，让 Tomcat 慢慢消费</li></ul><p>访问 Redis 的之前，还可以在应用层 Nginx 再做一个本地缓存（Lua Cache、Nginx 内置缓存等）。</p><p><strong>架构难点：</strong></p><ol><li>微服务集群怎么更新 Redis 缓存？</li><li>当 Redis 缓存更新了，怎么同步到应用层 Nginx 本地缓存？</li></ol><h3 id="1-6-架构完整图"><a href="#1-6-架构完整图" class="headerlink" title="1.6 架构完整图"></a>1.6 架构完整图</h3><p><strong>读请求高并发系统架构</strong></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/1/%E8%AF%BB%E8%AF%B7%E6%B1%82%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><p><strong>百万秒杀解决方案</strong></p><p><img src="../../images/%E6%9E%B6%E6%9E%84/1/%E7%99%BE%E4%B8%87%E7%A7%92%E6%9D%80%E6%96%B9%E6%A1%88.png"></p><h2 id="2、Lua-语言"><a href="#2、Lua-语言" class="headerlink" title="2、Lua 语言"></a>2、Lua 语言</h2><h3 id="2-1-Lua-简介"><a href="#2-1-Lua-简介" class="headerlink" title="2.1 Lua 简介"></a>2.1 Lua 简介</h3><p>Lua 是一种轻量、小巧的脚本语言，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a href="http://www.lua.org/">http://www.lua.org/</a></p><p>Redis 在 2.6 版本中推出了脚本功能，允许开发者将 Lua 语言编写的脚本传到 Redis 中执行，类似于数据库的存储过程。使用 Lua 脚本的优点有如下几点:</p><ul><li><p>减少网络开销：本来需要多次请求的操作，可以一次请求完成，从而节约网络开销；</p></li><li><p>原子操作：Redis 会将整个脚本作为一个整体执行，中间不会执行其它命令；</p></li><li><p>复用：客户端发送的脚本会存储在 Redis 中，从而实现脚本的复用。</p></li></ul><h3 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h3><p>lua解释器：</p><ul><li><a href="https://github.com/rjpcomputing/luaforwindows/releases">https://github.com/rjpcomputing/luaforwindows/releases</a></li><li><a href="http://luadist.org/">http://luadist.org/</a></li></ul><p>idea 插件：</p><ul><li>lua</li><li>EmmyLua</li></ul><h3 id="2-3-基础语法"><a href="#2-3-基础语法" class="headerlink" title="2.3 基础语法"></a>2.3 基础语法</h3><h4 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h4><p><code>and</code>       <code>break</code>     <code>do   </code> <code>else</code>      <code>elseif</code>      <code>end</code>       <code>false</code>    <code> for</code>       <code>function  if</code>      <code>in</code>        <code>local</code>     <code>nil</code>      <code>not</code>      <code>or</code>      <code>repeat</code>    <code>return</code>    <code>then</code>     <code> true</code>      <code>until</code>    <code> while</code></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><pre><code class="lua">-- 两个减号是行注释--[[ 这是块注释 这是块注释. --]]</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>Lua的数字只有double型，64bits</p><p>你可以以如下的方式表示数字</p><pre><code class="lua">num = 1024num = 3.0num = 3.1416num = 314.16e-2num = 0.31416E1num = 0xffnum = 0x56</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>可以用单引号，也可以用双引号，也可以使用转义字符‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\’ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\” （单引号)等等。</p><p>下面的四种方式定义了完全相同的字符串（其中的两个中括号可以用于定义有换行的字符串</p><pre><code class="lua">a = &#39;alo\n123&quot;&#39;a = &quot;alo\n123\&quot;&quot;a = &#39;\97lo\10\04923&quot;&#39;a = [[alo123&quot;]]</code></pre><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>C 语言中的 NULL 在Lua中是 nil，比如你访问一个没有声明过的变量，就是 nil</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>只有 nil 和 false 是 false</p><p>数字 0，‘’空字符串（’\0’）都是 true</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>lua 中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。变量前加 <strong>local</strong> 关键字的是局部变量。</p><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><pre><code class="lua">local i = 0local max = 10while i &lt;= max doprint(i)i = i +1end</code></pre><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><pre><code class="lua">sum = 0for i = 100, 1, -2 do    sum = sum + iendprint(sum)</code></pre><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><pre><code class="lua">local function main()    local age = 18    local sex = &#39;Male&#39;    if age == 40 and sex ==&quot;Male&quot; then        print(&quot; 男人四十一枝花 &quot;)    elseif age &gt; 60 and sex ~=&quot;Female&quot; then        print(&quot;old man without country!&quot;)    elseif age &lt; 20 then        io.write(&quot;too young, too naive!\n&quot;)    else        print(&quot;Your age is &quot;..age)    endend-- 调用main()</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code class="lua">function myPower(x,y)    return y+xendpower2 = myPower(2,3)print(power2)function newCounter()    local i = 0    return function()     -- 匿名函数        i = i + 1        return i    endendc1 = newCounter()print(c1())  --&gt; 1print(c1())  --&gt; 2print(c1())  --&gt; 3</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><pre><code class="lua">name,age,bGay = &quot;yiming&quot;, 37, false, &quot;yimingl@hotmail.com&quot;print(name,age,bGay)function isMyGirl(name)    return name == &#39;xiao6&#39;, nameendlocal bol,name = isMyGirl(&#39;xiao6&#39;)print(name,bol)</code></pre><h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><p>key，value的键值对 类似 map</p><pre><code class="lua">xiao6 = &#123;name=&#39;xiao6&#39;,age=18,height=165.5&#125;xiao6.age=35print(xiao6.name,xiao6.age,xiao6.height)print(xiao6)</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>下标从 1 开始</p><pre><code class="lua">arr = &#123;&quot;string&quot;, 100, &quot;xiao6&quot;,function() print(&quot;memeda&quot;) return 1 end&#125;print(arr[4](), arr[1])</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><pre><code class="lua">for k, v in pairs(arr) do    print(k, v)endfor k, v in pairs(xiao6) do    print(k, v)end</code></pre><h4 id="面向对象-成员函数"><a href="#面向对象-成员函数" class="headerlink" title="面向对象-成员函数"></a>面向对象-成员函数</h4><pre><code class="lua">person = &#123;name=&#39;xiao6&#39;,age = 18&#125;function  person.eat(food)    print(person.name ..&quot; eating &quot;..food)endperson.eat(&quot;xxoo&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;如何搭建一个高并发系统架构&lt;/li&gt;
&lt;li&gt;Lua 语言学习&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第 5-9 章 Web 中的 Spring</title>
    <link href="http://yoursite.com/2020-12-25-13Spring%E5%9F%BA%E7%A1%80/springmvc.html"/>
    <id>http://yoursite.com/2020-12-25-13Spring%E5%9F%BA%E7%A1%80/springmvc.html</id>
    <published>2020-12-25T14:13:12.000Z</published>
    <updated>2021-01-02T04:52:51.292Z</updated>
    
    <content type="html"><![CDATA[<p>书中的代码是用 Grandle 构建，怎么跑起来是个问题。记录一下采坑过程。</p><a id="more"></a><h2 id="1、构建-Spring-Web-应用程序"><a href="#1、构建-Spring-Web-应用程序" class="headerlink" title="1、构建 Spring Web 应用程序"></a>1、构建 Spring Web 应用程序</h2><h3 id="1-1-构建-Spring-MVC-项目"><a href="#1-1-构建-Spring-MVC-项目" class="headerlink" title="1.1 构建 Spring MVC 项目"></a>1.1 构建 Spring MVC 项目</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p><img src="../../images/sia/c5/%E6%96%B0%E5%BB%BAgradle%E9%A1%B9%E7%9B%AE.png"></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p><strong>build.gradle</strong></p><pre><code class="json">apply plugin: &#39;eclipse&#39;apply plugin: &#39;war&#39;apply plugin: &#39;eclipse-wtp&#39;// 依赖dependencies &#123;    compile &quot;org.springframework:spring-webmvc:$springVersion&quot;    compile &quot;org.springframework:spring-jdbc:$springVersion&quot;    compile &quot;com.h2database:h2:$h2Version&quot;    compile &quot;org.hibernate:hibernate-validator:$hibernateValidatorVersion&quot;    compile &quot;org.apache.commons:commons-lang3:$commonsLangVersion&quot;    compile &quot;javax.servlet:jstl:$jstlVersion&quot;// jdk 版本高于8时可能需要//    compile &quot;javax.xml.bind:jaxb-api:2.3.0&quot;//    compile &quot;com.sun.xml.bind:jaxb-impl:2.3.0&quot;//    compile &quot;com.sun.xml.bind:jaxb-core:2.3.0&quot;//    compile &quot;javax.activation:activation:1.1.1&quot;    providedCompile &quot;javax.servlet:javax.servlet-api:$servletApiVersion&quot;    providedCompile &quot;javax.servlet.jsp:jsp-api:$jspApiVersion&quot;    providedCompile &quot;javax.el:javax.el-api:$jspElVersion&quot;    testCompile &quot;junit:junit-dep:$junitVersion&quot;    testCompile &quot;org.springframework:spring-test:$springVersion&quot;    testCompile &quot;org.mockito:mockito-core:$mockitoVersion&quot;    testCompile &quot;org.hamcrest:hamcrest-library:$hamcrestVersion&quot;&#125;// 仓库地址repositories &#123;    maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; &#125;&#125;war &#123;    baseName = &#39;spittr&#39;&#125;</code></pre><p><strong>gradle.properties</strong></p><pre><code class="properties">activeMQVersion=5.7.0aspectJVersion=1.7.2commonsLangVersion = 3.1ehcacheVersion=2.7.4ehcacheJCacheVersion=1.4.0-beta1h2Version=1.4.182hamcrestVersion = 1.3hibernateVersion=4.1.6.FinalhibernateEntityManagerVersion=4.0.1.FinalhibernateValidatorVersion = 5.0.1.FinaljspApiVersion = 2.1jspElVersion = 2.2.4jstlVersion = 1.2junitVersion=4.11log4jVersion=1.2.14mockitoVersion=1.9.5servletApiVersion = 3.1.0slf4jVersion = 1.7.5springAMQPVersion=1.0.0.RELEASEspringDataJpaVersion=1.3.2.RELEASEspringSecurityVersion = 3.2.0.RELEASEspringVersion=4.0.7.RELEASEspringWebflowVersion=2.4.1.RELEASEsystemRulesVersion=1.5.0thymeleafVersion = 2.1.3.RELEASEtilesVersion = 3.0.1</code></pre><h4 id="mvc-demo-配置和编写"><a href="#mvc-demo-配置和编写" class="headerlink" title="mvc demo 配置和编写"></a>mvc demo 配置和编写</h4><pre><code class="java">/** * 配置 mvc 的 DispatcherServlet */public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    /**     * 指定配置类     * @return     */    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[]&#123; RootConfig.class &#125;;    &#125;    /**     * 指定配置类     * @return     */    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123; WebConfig.class &#125;;    &#125;    /**     * 指定 DispatcherServlet 处理哪些请求     * @return     */    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123; &quot;/&quot; &#125;;    &#125;&#125;</code></pre><pre><code class="java">/** * 配置包扫描。springboot 一般配置在启动类上 */@Configuration@ComponentScan(basePackages=&#123;&quot;spittr&quot;&#125;,        excludeFilters=&#123;                @ComponentScan.Filter(type= FilterType.ANNOTATION, value= EnableWebMvc.class)        &#125;)public class RootConfig &#123;&#125;</code></pre><pre><code class="java">/** * 定义 DispatcherServlet 应用上下文中的 bean * 包含控制器、视图解析器以及处理器映射等 */@Configuration// 启动 mvc@EnableWebMvc// RootConfig 不是已经配置了吗？这里不需要了吧@ComponentScan(&quot;spittr.web&quot;)public class WebConfig extends WebMvcConfigurerAdapter &#123;    /**     * 配置 JSP 视图解析器     * Spring默认会使用BeanNameViewResolver，这个视图解析器会查找ID与视图名称匹配的bean，     * 并且查找的bean要实现View接口，它以这样的方式来解析视图。     */    @Bean    public ViewResolver viewResolver() &#123;        InternalResourceViewResolver resolver = new InternalResourceViewResolver();        resolver.setPrefix(&quot;/WEB-INF/templates/&quot;);        resolver.setSuffix(&quot;.jsp&quot;);        resolver.setExposeContextBeansAsAttributes(true);        return resolver;    &#125;    /**     * 配置静态资源的处理     * 要求DispatcherServlet将对静态资源的请求转发到Servlet容器中默认的Servlet上，     * 而不是使用DispatcherServlet本身来处理此类请求。     * @param configurer     */    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;        super.configureDefaultServletHandling(configurer);    &#125;&#125;</code></pre><pre><code class="java">@Controllerpublic class HomeController &#123;    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)    public String hone() &#123;        return &quot;home&quot;;    &#125;&#125;</code></pre><pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;&lt;%@ page session=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Spittr&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot;          href=&quot;&lt;c:url value=&quot;/resources/css/style.css&quot;/&gt;&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to Spittr&lt;/h1&gt;&lt;a href=&quot;&lt;c:url value=&quot;/spittles&quot; /&gt;&quot;&gt;Spittles&lt;/a&gt;&lt;a href=&quot;&lt;c:url value=&quot;/spitter/register&quot; /&gt;&quot;&gt;Register&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-2-启动项目"><a href="#1-2-启动项目" class="headerlink" title="1.2 启动项目"></a>1.2 启动项目</h3><h4 id="配置-tomcat"><a href="#配置-tomcat" class="headerlink" title="配置 tomcat"></a>配置 tomcat</h4><p><img src="../../images/sia/c5/tomcat%E9%85%8D%E7%BD%AE1.png"></p><p><img src="../../images/sia/c5/tomcat%E9%85%8D%E7%BD%AE2.png"></p><p>这里有个根路径配置，选完之后自动变了，记得手动修改下</p><p><img src="../../images/sia/c5/tomcat%E9%85%8D%E7%BD%AE3.png"></p><h4 id="启动-tomcat"><a href="#启动-tomcat" class="headerlink" title="启动 tomcat"></a>启动 tomcat</h4><p>如果使用的是高版本 jdk（大于8），可能 404 都看不到，直接报错</p><p><img src="../../images/sia/c5/%E9%AB%98%E7%89%88%E6%9C%ACjdk%E9%97%AE%E9%A2%98.png"></p><p>这个报错的解决方法：</p><ul><li><p>降低 jdk 版本到8</p></li><li><p>增加几个依赖</p><pre><code class="json">// jdk 版本高于8时可能需要compile &quot;javax.xml.bind:jaxb-api:2.3.0&quot;compile &quot;com.sun.xml.bind:jaxb-impl:2.3.0&quot;compile &quot;com.sun.xml.bind:jaxb-core:2.3.0&quot;compile &quot;javax.activation:activation:1.1.1&quot;</code></pre></li></ul><p>再启动，可能会 404，只在 jdk8 上出现这情况。</p><p><img src="../../images/sia/c5/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%BB%93%E6%9E%9C.png"></p><p>如出现上面 404 问题，修改如下配置，全部改为 <strong>IntelliJ IDEA</strong>，注意 jdk 大于 8 时无需修改，我用 jdk12，修改了反而报错：</p><p><img src="../../images/sia/c5/404%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D.png"></p><h3 id="1-3-乱码问题解决"><a href="#1-3-乱码问题解决" class="headerlink" title="1.3 乱码问题解决"></a>1.3 乱码问题解决</h3><p>tomcat 控制台可能乱码、idea 控制台也可能乱码</p><p>idea 相关 vmoptions 全局加 <code>-Dfile.encoding=UTF-8</code>。</p><p>tomcat 启动 vmoptions 也加 <code>-Dfile-encoding=UTF-8</code>。</p><p>tomcat 日志配置文件<code>D:\16_tomcat\apache-tomcat-9.0.41\conf\logging.properties</code> 所有 GBK 替换为 UTF-8。</p><h2 id="2、Spring-MVC-学习"><a href="#2、Spring-MVC-学习" class="headerlink" title="2、Spring MVC 学习"></a>2、Spring MVC 学习</h2><h3 id="2-1-Spring-MVC-基本组成"><a href="#2-1-Spring-MVC-基本组成" class="headerlink" title="2.1 Spring MVC 基本组成"></a>2.1 Spring MVC 基本组成</h3><p><img src="../../images/sia/c5/mvc%E7%BB%84%E6%88%90.png"></p><h3 id="2-2-测试-Controller-的方法"><a href="#2-2-测试-Controller-的方法" class="headerlink" title="2.2 测试 Controller 的方法"></a>2.2 测试 Controller 的方法</h3><h4 id="测试视图是否正确"><a href="#测试视图是否正确" class="headerlink" title="测试视图是否正确"></a>测试视图是否正确</h4><pre><code class="java">package spittr.web;import org.junit.Test;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup;public class HomeControllerTest &#123;    /**     * 测试控制器的方法     * @throws Exception     */    @Test    public void testHomePage() throws Exception &#123;        HomeController controller = new HomeController();        // 搭建 MockMvc        MockMvc mockMvc = standaloneSetup(controller).build();        // 对“/”执行 GET 请求，预期得到 home 视图        mockMvc.perform(get(&quot;/&quot;)).andExpect(view().name(&quot;home&quot;));    &#125;&#125;</code></pre><h4 id="测试-model"><a href="#测试-model" class="headerlink" title="测试 model"></a>测试 model</h4><pre><code class="java">@Testpublic void testSpitte() throws Exception &#123;    Spittle exceptedSpittle = new Spittle(&quot;Hello&quot;, new Date());    SpittleRepository mockRepository = mock(SpittleRepository.class);    when(mockRepository.findOne(1))        .thenReturn(exceptedSpittle);    SpittleController controller = new SpittleController(mockRepository);    MockMvc mockMvc = standaloneSetup(controller)        .setSingleView(new InternalResourceView(&quot;/WEB-INF/views/spittle.jsp&quot;))        .build();    mockMvc.perform(get(&quot;/spittles/1&quot;))        .andExpect(view().name(&quot;spittle&quot;))        .andExpect(model().attributeExists(&quot;spittle&quot;))        .andExpect(model().attribute(&quot;spittle&quot;, exceptedSpittle));&#125;</code></pre><h3 id="2-3-传递模型数据到视图"><a href="#2-3-传递模型数据到视图" class="headerlink" title="2.3 传递模型数据到视图"></a>2.3 传递模型数据到视图</h3><p>把数据塞进 Model 就行，Model 就是一个 map。</p><pre><code class="java">@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) &#123;    // 将 spittle 添加到模型中    model.addAttribute(&quot;spittleList&quot;,                       spittleRepository.findSpittles(Long.MAX_VALUE, 20));    // 返回视图    return &quot;spittles&quot;;&#125;</code></pre><h3 id="2-4-接受请求的输入"><a href="#2-4-接受请求的输入" class="headerlink" title="2.4 接受请求的输入"></a>2.4 接受请求的输入</h3><p><strong>直接从请求参数中拿</strong></p><pre><code class="java">@RequestMapping(value = &quot;/pageList&quot;, method = RequestMethod.GET)public String spittles(@RequestParam(value = &quot;max&quot;, defaultValue = MAX_LONG_AS_STRING) long max,                       @RequestParam(value = &quot;count&quot;, defaultValue = &quot;20&quot;) int count, Model model) &#123;    model.addAttribute(spittleRepository.findSpittles(max, count));    return &quot;spittles&quot;;&#125;</code></pre><p><strong>直接从请求路径中拿</strong></p><pre><code class="java">@RequestMapping(value = &quot;/&#123;spittleId&#125;&quot;, method = RequestMethod.GET)public String spittle(@PathVariable(&quot;spittleId&quot;) long spittleId, Model model) &#123;    model.addAttribute(spittleRepository.findOne(spittleId));    return &quot;spittle&quot;;&#125;</code></pre><h3 id="2-5-处理表单"><a href="#2-5-处理表单" class="headerlink" title="2.5 处理表单"></a>2.5 处理表单</h3><h4 id="注册功能实现"><a href="#注册功能实现" class="headerlink" title="注册功能实现"></a>注册功能实现</h4><p>获取表单参数，校验表单参数，校验通过后重定向到个人主页。</p><p><strong>控制器</strong></p><pre><code class="java">/*** 执行注册* @param spitter* @return*/@RequestMapping(value = &quot;/register&quot;, method = RequestMethod.POST)public String processRegister(@Valid Spitter spitter, Errors errors) &#123;    if (errors.hasErrors()) &#123;        return &quot;registerForm&quot;;    &#125;    // 保存 spitter    spitterRepository.save(spitter);    // 重定向到基本信息页，防止用户重复提交    return &quot;redirect:/spitter/&quot; + spitter.getUsername();&#125;/*** 个人主页* @param username* @param model* @return*/@RequestMapping(value = &quot;/&#123;username&#125;&quot;, method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123;    Spitter spitter = spitterRepository.findByUsername(username);    model.addAttribute(spitter);    return &quot;profile&quot;;&#125;</code></pre><p><strong>页面</strong></p><pre><code class="jsp">&lt;body&gt;    &lt;h1&gt;Register&lt;/h1&gt;    &lt;form method=&quot;POST&quot;&gt;        First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot;/&gt;&lt;br/&gt;        Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot;/&gt;&lt;br/&gt;        Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;        Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><pre><code class="jsp">&lt;body&gt;    &lt;h1&gt;Your Profile&lt;/h1&gt;    &lt;c:out value=&quot;$&#123;spitter.username&#125;&quot;/&gt;&lt;br/&gt;    &lt;c:out value=&quot;$&#123;spitter.firstName&#125;&quot;/&gt;,    &lt;c:out value=&quot;$&#123;spitter.lastName&#125;&quot;/&gt;&lt;/body&gt;</code></pre><p><strong>pojo</strong></p><pre><code class="java">public class Spitter &#123;    private Long id;    @NotNull    @Size(min=2, max = 30)    private String firstName;    @NotNull    @Size(min=2, max = 30)    private String lastName;    @NotNull    @Size(min=5, max = 16)    private String username;    @NotNull    @Size(min=5, max = 25)    private String password;&#125;</code></pre><h2 id="3、渲染-Web-视图"><a href="#3、渲染-Web-视图" class="headerlink" title="3、渲染 Web 视图"></a>3、渲染 Web 视图</h2><ul><li>将模型数据渲染为 HTML</li><li>使用 JSP 视图</li><li>通过 tiles 定义视图布局</li><li>使用 Thymeleaf 视图</li></ul><h3 id="3-1-理解视图解析器"><a href="#3-1-理解视图解析器" class="headerlink" title="3.1 理解视图解析器"></a>3.1 理解视图解析器</h3><p>根据 Controller 返回的逻辑视图名，找到真正的物理视图。</p><pre><code class="java">public interface ViewResolver &#123;    View resolveViewName(String viewName, Locale locale) throws Exception;&#125;</code></pre><pre><code class="java">public interface View &#123;    /**     * Render the view given the specified model.     * &lt;p&gt;The first step will be preparing the request: In the JSP case,     * this would mean setting model objects as request attributes.     * The second step will be the actual rendering of the view,     * for example including the JSP via a RequestDispatcher.     * @param model Map with name Strings as keys and corresponding model     * objects as values (Map can also be &#123;@code null&#125; in case of empty model)     * @param request current HTTP request     * @param response HTTP response we are building     * @throws Exception if rendering failed     */    void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;&#125;</code></pre><p>View 的 render 方法把处理结果写入 response，返回浏览器。</p><p>一般来说，我们无需自己实现 ViewResolver，Spring 内置了 13 个视图解析器。常用的有<strong>InternalResourceViewResolver</strong> 用于解析 JSP；</p><p><img src="../../images/sia/c5/spring%E5%86%85%E7%BD%AE%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8.png"></p><h3 id="3-2-创建-JSP-视图"><a href="#3-2-创建-JSP-视图" class="headerlink" title="3.2 创建 JSP 视图"></a>3.2 创建 JSP 视图</h3><h4 id="配置适用于-JSP-的视图解析器"><a href="#配置适用于-JSP-的视图解析器" class="headerlink" title="配置适用于 JSP 的视图解析器"></a>配置适用于 JSP 的视图解析器</h4><p><strong>InternalResourceViewResolver</strong></p><h4 id="使用-Spring-的-JSP-库-表单库"><a href="#使用-Spring-的-JSP-库-表单库" class="headerlink" title="使用 Spring 的 JSP 库-表单库"></a>使用 Spring 的 JSP 库-表单库</h4><p>标签库能够避免在脚本块中直接编写 Java 代码。Spring 提供了两个 JSP 标签库，用来帮助定义 Spring MVC Web 的视图。其中一个标签库会用来<strong>渲染HTML表单</strong>标签，这些标签可以绑定 model 中的某个属性。另外一个标签库包含了一些工具类标签，我们随时都可以非常便利地使用它们。</p><p><strong>引入标签库</strong></p><pre><code class="jsp">&lt;%-- 引入Spring表单标签库 --%&gt;&lt;%@ taglib prefix=&quot;sf&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;</code></pre><p><strong>标签一览表</strong></p><p>一个有意思的标签是<code>&lt;sf:errors&gt;</code>，可以渲染表单表校验的错误信息。</p><p><img src="../../images/sia/c5/spring%E6%A0%87%E7%AD%BE%E5%BA%93.png"></p><p><strong>使用标签</strong></p><p>修改注册页面，进行友好提示。</p><p>直接在表单后面提示。</p><pre><code class="jsp">    &lt;%--  使用spring标签库进行校验提示。每个元素后边提示  --%&gt;    &lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot;&gt;        First Name: &lt;sf:input path=&quot;firstName&quot;/&gt;            &lt;%--展现表单校验错误--%&gt;            &lt;sf:errors path=&quot;firstName&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Last Name: &lt;sf:input path=&quot;lastName&quot;/&gt;            &lt;sf:errors path=&quot;lastName&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Email: &lt;sf:input path=&quot;email&quot; type=&quot;email&quot;/&gt;            &lt;sf:errors path=&quot;email&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Username: &lt;sf:input path=&quot;username&quot;/&gt;            &lt;sf:errors path=&quot;username&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        Password: &lt;sf:password path=&quot;password&quot;/&gt;            &lt;sf:errors path=&quot;password&quot; cssClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;    &lt;/sf:form&gt;</code></pre><p><img src="../../images/sia/c5/%E4%BD%BF%E7%94%A8spring%E6%A0%87%E7%AD%BE%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E6%8F%90%E7%A4%BA.png"></p><p>统一提示，方便排版。</p><pre><code class="jsp">    &lt;sf:form method=&quot;POST&quot; commandName=&quot;spitter&quot;&gt;        &lt;sf:errors path=&quot;*&quot; element=&quot;div&quot; cssClass=&quot;error&quot;/&gt;        &lt;sf:label path=&quot;firstName&quot; cssErrorClass=&quot;error&quot;&gt;First Name&lt;/sf:label&gt; :        &lt;sf:input path=&quot;firstName&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;lastName&quot; cssErrorClass=&quot;error&quot;&gt;Last Name&lt;/sf:label&gt; :        &lt;sf:input path=&quot;lastName&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;email&quot; cssErrorClass=&quot;error&quot;&gt;Email&lt;/sf:label&gt; :        &lt;sf:input path=&quot;email&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;username&quot; cssErrorClass=&quot;error&quot;&gt;Username&lt;/sf:label&gt; :        &lt;sf:input path=&quot;username&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;sf:label path=&quot;password&quot; cssErrorClass=&quot;error&quot;&gt;Password&lt;/sf:label&gt; :        &lt;sf:input path=&quot;password&quot; cssErrorClass=&quot;error&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;    &lt;/sf:form&gt;</code></pre><p><img src="../../images/sia/c5/%E6%A0%A1%E9%AA%8C%E9%94%99%E8%AF%AF%E7%BB%9F%E4%B8%80%E6%8F%90%E7%A4%BA.png"></p><h4 id="使用-Spring-的-JSP-库-工具库"><a href="#使用-Spring-的-JSP-库-工具库" class="headerlink" title="使用 Spring 的 JSP 库-工具库"></a>使用 Spring 的 JSP 库-工具库</h4><p><strong>引入标签库</strong></p><pre><code class="jsp">&lt;%--引入Spring工具标签库--%&gt;&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</code></pre><p><strong>标签一览表</strong></p><p><img src="../../images/sia/c5/spring%E5%B7%A5%E5%85%B7%E6%A0%87%E7%AD%BE%E4%B8%80%E8%A7%88%E8%A1%A8.png"></p><p><strong>使用标签</strong></p><p>使用<code>&lt;s:message&gt;</code>实现国际化</p><p>配置资源加载器</p><pre><code class="java">@Beanpublic MessageSource messageSource() &#123;    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    messageSource.setBasename(&quot;messages&quot;);    return messageSource;&#125;</code></pre><p>创建资源文件<code>messages.properties</code></p><pre><code class="properties">spittr.welcome=Welcome to Spittr!</code></pre><p>页面使用</p><pre><code class="jsp">&lt;h1&gt;&lt;s:message code=&quot;spittr.welcome&quot;/&gt;&lt;/h1&gt;</code></pre><h3 id="3-3-创建-Apache-Tiles-视图"><a href="#3-3-创建-Apache-Tiles-视图" class="headerlink" title="3.3 创建 Apache Tiles 视图"></a>3.3 创建 Apache Tiles 视图</h3><p>Apache Tiles 布局引擎。</p><p>配置 视图解析器</p><pre><code class="java">    /**     * 配置 TilesConfigurer     * @return     */    @Bean    public TilesConfigurer tilesConfigurer() &#123;        TilesConfigurer tiles = new TilesConfigurer();        // 指定 tile 定义的位置        tiles.setDefinitions(new String[] &#123;                &quot;/WEB-INF/**/tiles.xml&quot;        &#125;);        // 启用刷新功能        tiles.setCheckRefresh(true);        return tiles;    &#125;    /**     * 配置 tile 的视图解析器     * 查找与逻辑视图名称相匹配的 Tile 定义     * @return     */    @Bean    public ViewResolver viewResolver() &#123;        return new TilesViewResolver();    &#125;</code></pre><p>然后配置 tails.xml，然后定义模板在页面中使用即可。这里不再演示了。</p><h3 id="3-4-使用-Thymeleaf"><a href="#3-4-使用-Thymeleaf" class="headerlink" title="3.4 使用 Thymeleaf"></a>3.4 使用 Thymeleaf</h3><p>JSP 模板的问题</p><ol><li>JSP 模板采用 HTML 形式，但是参杂了各种 JSP 标签库的标签，很混乱</li><li>看起来像是 html，但是并不是，未经渲染直接打开是一场视觉灾难</li><li>JSP 规范与 Servlet 规范紧密耦合，只能用在基于 Servlet 的 Web 应用之中，不能作为通用模板，比如格式化 Email</li></ol><h4 id="配置-Thymeleaf-视图解析器"><a href="#配置-Thymeleaf-视图解析器" class="headerlink" title="配置 Thymeleaf 视图解析器"></a>配置 Thymeleaf 视图解析器</h4><ul><li>ThymeleafViewResolver：将逻辑视图名称解析为 Thymeleaf 模板视图</li><li>SpringTemplateEngine：处理模板并渲染结果</li><li>TemplateResolver：加载 Thymeleaf 模板</li></ul><pre><code class="java">    @Bean    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123;        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();        viewResolver.setTemplateEngine(templateEngine);        return viewResolver;    &#125;    @Bean    public SpringTemplateEngine templateEngine(TemplateResolver templateResolver) &#123;        SpringTemplateEngine templateEngine = new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver);        return templateEngine;    &#125;    @Bean    public TemplateResolver templateResolver() &#123;        TemplateResolver templateResolver = new ServletContextTemplateResolver();        templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);        templateResolver.setSuffix(&quot;.html&quot;);        templateResolver.setTemplateMode(&quot;HTML5&quot;);        return templateResolver;    &#125;</code></pre><h4 id="编写模板"><a href="#编写模板" class="headerlink" title="编写模板"></a>编写模板</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;title&gt;Spittr&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;          th:href=&quot;@&#123;/resources/style.css&#125;&quot;/&gt;&lt;/head&gt;&lt;body&gt;    &lt;form method=&quot;post&quot; th:object=&quot;$&#123;spitter&#125;&quot;&gt;        &lt;!--展示错误--&gt;        &lt;div class=&quot;errors&quot; th:if=&quot;$&#123;#fields.hasErrors('*')&#125;">            <ul>                <li th:each="err : $&#123;#fields.errors('*')&#125;" th:text="$&#123;err&#125;">Input is incorrect</li>            </ul>        </div>        <!--FirstName-->        <label th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'">First Name</label>        <input type="text" th:field="*&#123;firstName&#125;" th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'" /><br/>        <!--LastName-->        <label th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'">Last Name</label>        <input type="text" th:field="*&#123;lastName&#125;" th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'" /><br/>        <!--Email-->        <label th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'">Email</label>        <input type="text" th:field="*&#123;email&#125;" th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'" /><br/>        <!--Username-->        <label th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'">Username</label>        <input type="text" th:field="*&#123;username&#125;" th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'" /><br/>        <!--Password-->        <label th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'">Password</label>        <input type="text" th:field="*&#123;password&#125;" th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'" /><br/>        <input type="submit" value="Register" />    </form></body><style>    span.error &#123;        color: red;    &#125;    label.error &#123;        color: red;    &#125;    input.error &#123;        background-color: #ffcccc;    &#125;    div.error &#123;        background-color: #ffcccc;        border: 2px solid red;    &#125;</style></html>```## 4、Spring MVC 配置的替代方案### 4.1 自定义 DispatcherServlet 配置AbstractAnnotationConfigDispatcherServletInitializer 将 DispatcherServlet 注册到 Servlet 容器后，就会调用 customizeRegistration，并将注册后得到的 ServletRegistration.Dynamic 传递进来，所以我们可以通过重载这个方法来对 DispatcherServlet 进行额外配置。```java/** * 配置 mvc 的 DispatcherServlet */public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    @Override    protected Class<?>[] getRootConfigClasses() &#123;        return new Class[]&#123; RootConfig.class &#125;;    &#125;    @Override    protected Class<?>[] getServletConfigClasses() &#123;        return new Class[]&#123; WebConfig.class &#125;;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123; "/" &#125;;    &#125;    /**     * 配置 multipart 支持     * @param registration     */    @Override    protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;        // 设置优先级        // registration.setLoadOnStartup();        // 设置 DispatcherServlet 初始化参数        // registration.setInitParameter();        registration.setMultipartConfig(                new MultipartConfigElement("/tmp/spittr/uploads"));    &#125;&#125;```### 4.2 添加 Servlet 和 Filter继承 WebApplicationInitializer，在 onStartup 中增加相应的内容即可。**Servlet 注册之后，怎么验证？**```javapublic class MyServletInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        // 注册一个自定义的 servlet        ServletRegistration.Dynamic myServlet = servletContext.addServlet("myServlet", MyServlet.class);        // 映射到指定路径        myServlet.addMapping("/custom/**");    &#125;&#125;``````javapublic class MyFilterInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        FilterRegistration.Dynamic myFilter = servletContext.addFilter("myFilter", MyFilter.class);        myFilter.addMappingForUrlPatterns(null, false, "/custom/*");    &#125;&#125;``````java    /**     * 如果自定义 Filter 只映射到 DispatcherServlet 上的话，在这里返回即可。     * @return     */    @Override    protected Filter[] getServletFilters() &#123;        return new Filter[]&#123;new MyFilter()&#125;;    &#125;```## 5、处理文件上传### 5.1 配置 multipart 解析器```java    /**     * 配置 multipart 解析器     * @return     * @throws IOException     */    @Bean    public MultipartResolver multipartResolver() throws IOException &#123;        return new StandardServletMultipartResolver();    &#125;```**配置上传细节参数**```java    @Override    protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;        registration.setMultipartConfig(                /**                 * 文件路径                 * 文件最大容量                 * 文件请求最大容量                 * 不缓存，直接落盘                 */                new MultipartConfigElement("D:/00_tmpdownload/tmp/", 2097152, 4194304, 0));    &#125;```### 5.2 处理 multipart 请求**修改 from 表单**- enctype="multipart/form-data"- type="file" accept="image/jpeg,image/png,image/gif"```html    <!--enctype="multipart/form-data" 告诉浏览器以 multipart 数据形式提交表单-->    <form method="post" th:object="$&#123;spitter&#125;" enctype="multipart/form-data">        <!--展示错误-->        <div class="errors" th:if="$&#123;#fields.hasErrors('*')&#125;">            <ul>                <li th:each="err : $&#123;#fields.errors('*')&#125;" th:text="$&#123;err&#125;">Input is incorrect</li>            </ul>        </div>        <!--FirstName-->        <label th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'">First Name</label>        <input type="text" th:field="*&#123;firstName&#125;" th:class="$&#123;#fields.hasErrors('firstName')&#125; ? 'error'" /><br/>        <!--LastName-->        <label th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'">Last Name</label>        <input type="text" th:field="*&#123;lastName&#125;" th:class="$&#123;#fields.hasErrors('lastName')&#125; ? 'error'" /><br/>        <!--Email-->        <label th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'">Email</label>        <input type="text" th:field="*&#123;email&#125;" th:class="$&#123;#fields.hasErrors('email')&#125; ? 'error'" /><br/>        <!--Username-->        <label th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'">Username</label>        <input type="text" th:field="*&#123;username&#125;" th:class="$&#123;#fields.hasErrors('username')&#125; ? 'error'" /><br/>        <!--Password-->        <label th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'">Password</label>        <input type="text" th:field="*&#123;password&#125;" th:class="$&#123;#fields.hasErrors('password')&#125; ? 'error'" /><br/>        <!--ProfilePicture-->        <label>Profile Picture</label>        <input type="file" name="profilePicture" accept="image/jpeg,image/png,image/gif"/><br/>        <input type="submit" value="Register" />    </form>```**使用 MutipartFile 接口接收图片数据**```java    /**     * 执行注册     * @RequestPart 接收图片     * @param spitter     * @return     */    @RequestMapping(value = "/register", method = RequestMethod.POST)    public String processRegister(@RequestPart("profilePicture") MultipartFile profilePicture,                                  @Valid Spitter spitter, Errors errors) throws IOException &#123;        if (errors.hasErrors()) &#123;            return "registerForm";        &#125;        // 把图片保存到指定位置        profilePicture.transferTo(new File("D:/00_tmpdownload/spittr/" + profilePicture.getOriginalFilename()));        // 保存 spitter        spitterRepository.save(spitter);        // 重定向到基本信息页，防止用户重复提交        return "redirect:/spitter/" + spitter.getUsername();    &#125;```**MultipartFile 接口详情**```javapublic interface MultipartFile &#123;String getName();String getOriginalFilename();String getContentType();boolean isEmpty();long getSize();byte[] getBytes() throws IOException;InputStream getInputStream() throws IOException;void transferTo(File dest) throws IOException, IllegalStateException;&#125;```**也可使用 javax.servlet.http.Part 接口接收**该接口和 MultipartFile 接口类似。但是使用这个接口就不用配置 MultipartResolver 了。你丫不早说。。。**图片上传云端**## 6、在控制器中处理异常Spring 提供了多种方式将异常转换为响应：- 特定的 Spring 异常将会自动映射为指定的 HTTP 状态码- 异常上可以添加 @ResponseStatus 注解，从而将其映射为某一个 HTTP 状态码- 在方法上可以添加 @ExceptionHandler 注解，使其用来处理异常### 6.1 将异常映射为 HTTP 状态码**Spring 自动映射**![](../../images/sia/c5/Spring默认异常映射.png)**使用 @ResponseStatus 手动映射**```java/** * 使用 @ResponseStatus 将异常映射为指定 http 响应码 */@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Spitter Not Found")public class SpitterNotFoundException extends RuntimeException&#123;&#125;```### 6.2 编写异常处理的方法**错误的处理方式**```java    @RequestMapping(value = "/register", method = RequestMethod.POST)    public String processRegister(@RequestPart("profilePicture") MultipartFile profilePicture,                                  @Valid Spitter spitter, Errors errors) throws IOException &#123;        if (errors.hasErrors()) &#123;            return "registerForm";        &#125;        // 把图片保存到指定位置        profilePicture.transferTo(new File("D:/00_tmpdownload/spittr/" + profilePicture.getOriginalFilename()));        try &#123;            // 保存 spitter            spitterRepository.save(spitter);            // 重定向到基本信息页，防止用户重复提交            return "redirect:/spitter/" + spitter.getUsername();        &#125; catch (DuplicateSpitterException e) &#123;            return "error/duplicate";        &#125;    &#125;```这么处理异常导致**同一个方法有两条路线，不易测试**。异常代码也业务代码混杂。**正确的处理方式**所以我们可以用**ExceptionHandler**注解抽取统一的处理方法```java    /**     * 这个 Controller 中所有的 DuplicateSpitterException 异常都会来这里     * @return     */    @ExceptionHandler(DuplicateSpitterException.class)    public String handleDuplicateSpitter() &#123;        return "error/duplicate";    &#125;```这样子写在某个 Controller 中好像也不太好，这样只能处理这一个 Controller 中的这个异常，但是系统中其他地方也很可能出现这种异常，有没有办法统一处理呢？答案是 **@ControllerAdvice**### 6.3 为控制器添加通知任意带有 **@ControllerAdvice** 注解的类，这个类会包含一个或多个如下类型的方法：- @ExceptionHandler 注解标注的方法；- @InitBinder 注解标注的方法；- @ModelAttribute 注解标注的方法。这些方法作用于整个应用程序所有控制器中带有**@RequestMapping注解**的方法上。例子：定义统一异常处理类```java@ControllerAdvicepublic class AppWideExceptionHandler &#123;    @ExceptionHandler(DuplicateSpitterException.class)    public String handleDuplicateSpitter() &#123;        return "error/duplicate";    &#125;&#125;```## 7、跨重定向请求传递数据### 7.1 通过 URL 模板进行重定向```java// 重定向到基本信息页，防止用户重复提交。而不是返回某个视图// 直接拼接字符串没有转义不安全，// return "redirect:/spitter/" + spitter.getUsername();// 向模型中塞数据，然后在请求中用占位符匹配。没有匹配到的模型数据自动添加查询参数// 结果：spitter/alvin?spitterId=42model.addAttribute("username", spitter.getUsername());model.addAttribute("spitterId", spitter.getId());return "redirect:/spitter/&#123;username&#125;";```通过 URL 只能传递简单数值，如 String 和数字。如果要传递对象类型，需要使用 **flash 属性 RedirectAttributes**### 7.2 使用 flash 属性flash 属性会一直携带这些数据直到下一次请求，然后才会消失。原理就是重定向前把 Flash 属性复制到会话中，重定向后把 Flash 属性从会话中取出放到新请求的 model 中。![](../../images/sia/c5/flash属性原理.png)```java// 向模型中塞数据，然后在请求中用占位符匹配。没有匹配到的模型数据自动添加查询参数// 结果：spitter/alvin?spitterId=42model.addAttribute("username", spitter.getUsername());model.addAttribute("spitterId", spitter.getId());// 非基础类型，使用 flash 属性。注意此时 model 类型为 RedirectAttributes model.addFlashAttribute("spitter", spitter);return "redirect:/spitter/&#123;username&#125;";``````java@RequestMapping(value = "/&#123;username&#125;", method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123;    // 上游已经传了 spitter 就不用查询了    if (!model.containsAttribute("spitter")) &#123;        Spitter spitter = spitterRepository.findByUsername(username);        model.addAttribute(spitter);        if (spitter == null) &#123;            throw new SpitterNotFoundException();        &#125;    &#125;    return "profile";&#125;```## 8、使用 Spring Web Flow- 创建回话式的 Web 应用程序- 定义流程状态和行为- 保护 Web 流程Spring Web Flow 是一个 Web 框架，它适用于元素按规定流程运行的程序。**流程与实现分开**。Spring Web Flow 是 Spring MVC 的扩展，它支持开发基于流程的应用程序。它将**流程的定义与****实现流程行为的类和视图分离开来**。### 8.1 在 Spring 中配置 Web Flow#### 装配流程执行器#### 配置流程注册表定义哪些文件定义的是流程，已经流程的 ID 是多少。#### 处理流程请求将普通请求映射到对应的流程上。需要注入流程注册表。#### 响应流程请求真正的处理（响应）流程。需要注入流程执行器。一切尽在这个 flow.xml 文件中配置：```xml<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:flow="http://www.springframework.org/schema/webflow-config" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/webflow-config    http://www.springframework.org/schema/webflow-config/spring-webflow-config-2.3.xsd   http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.0.xsd">  <context:component-scan base-package="com.sia.pizza.flow" />  <!-- 配置流程执行器 -->  <flow:flow-executor id="flowExecutor" />  <!-- 配置流程注册表。-->  <!-- 从/WEB-INF/flows目录找流程定义；        任何以 -flow.xml 结尾的都认为是流程定义；        所有流程通过ID引用。**所代表的路径就是流程ID-->  <flow:flow-registry id="flowRegistry" base-path="/WEB-INF/flows">     <flow:flow-location-pattern value="/**/*-flow.xml" />     <!--显示声明流程定义文件的位置。此时流程ID从文件名获取，就是springpizza；         或者也可以显示定义ID，如 id="pizza"-->      <!--<flow:flow-location path="/WEB-INF/flows/springpizza.xml" />-->  </flow:flow-registry>  <!--FlowHandlerMapping 处理流程请求。将流程请求发送给Spring Web Flow-->  <bean class="org.springframework.webflow.mvc.servlet.FlowHandlerMapping">    <!-- 装配了注册表，所以知道如何将请求的 URL 匹配到流程上 -->    <property name="flowRegistry" ref="flowRegistry" />  </bean>  <!--   FlowHandlerAdapter 响应流程请求。   是 DispatcherServlet 和 Spring Web Flow 之间的桥梁。  -->  <bean class="org.springframework.webflow.mvc.servlet.FlowHandlerAdapter">    <property name="flowExecutor" ref="flowExecutor" />  </bean></beans>```### 8.2 流程组件- 状态：业务执行逻辑- 转移：通过转移从一个状态到另外一个- 流程数据：流程的当前状况#### 状态Spring Web Flow 定义了五种不同类型的状态。![](../../images/sia/c5/流程的5种状态.png)**视图状态**`<view-state id="welcome" />` 定义了一个 id 和逻辑视图名都为 weblcome 的视图状态。`<view-state id="welcome" view="greeting" />`另外指定视图名。`<view-state id="takePayment" model="flowScope.paymentDetails" />` 当然也可绑定模型数据。**行为状态**视图状态会涉及到流程应用程序的用户，而行为状态则是应用程序自身在执行任务。行为状态一般会触发 Spring 所管理 bean 的一些方法并根据方法调用的执行结果转移到另一个状态。定义行为状态：```xml<action-state id="saveOrder"><evaluate expression="pizzaFlowActions.saveOrder(order)" />    <transition to="thankYou" /></action-state>```**决策状态**用来处理流程的分支情况。决策状态能够在流程执行时产生两个分支。定义决策状态：```xml<decision-state id="checkDeliveryArea"><if test="pizzaFlowActions.checkDeliveryArea(customer.zipCode)"        then="addCustomer"        else="deliveryWarning" /></decision-state>```**子流程状态**一个流程中调用另外一个流程。定义子流程状态：```xml<subflow-state id="order" subflow="pizza/order">    <!--传递订单对象作为子流程的输入--><input name="order" value="order" />    <!--如果子流程的结束状态ID为 orderCreated，那么流程将会转移到名为 payment 的状态-->    <transition on="orderCreated" to="payment" /></subflow-state>```**结束状态**定义流程结束状态：`<end-state id="customerReady" />`- 如果是子流程，执行父流程- 如果设置了 view，渲染视图- 如果都不是，仅仅结束#### 转移处理结束状态之外，其他每个状态至少都需要有一个转移。一个状态可能有多个转移，表示不同路径。- on：触发点- to：转移到- on-exception：异常时**全局转移**```xml<global-transitions><transition on="cancel" to="endState" /></global-transitions>```#### 流程数据**声明变量**流程数据保存在变量中，而变量可以在流程的各个地方进行引用。它能够以多种方式创建。在流程中创建变量的最简单形式是使用`<var>`元素。`<var name="customer" class="com.sia.pizza.domain.Customer"/>`这里，创建了一个新的Customer实例并将其放在名为customer的变量中。这个变量可以在流程的任意状态进行访问。- var：流程作用域- evaluate：作用域通过 name 或 result 属性的前缀指定- set：同上**变量的流程作用域、视图作用域**流程中携带的数据会拥有不同的生命作用域和可见性，这取决于保存数据的变量本身的作用域。Spring Web Flow定义了五种不同作用域。![](../../images/sia/c5/流程数据作用域.png)### 8.3 组合起来：披萨流程#### 定义基本流程![](../../images/sia/c5/披萨订单流程.png)```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <!-- order 变量声明，每次流程开始就新建一个 Order 实例 -->    <var name="order" class="com.sia.pizza.domain.Order"/>        <!-- 顾客子流程状态 -->    <subflow-state id="customer" subflow="pizza/customer">      <!-- 订单作为子流程的输入 -->      <input name="order" value="order"/>      <transition on="customerReady" to="order" />    </subflow-state>        <!-- 订单子流程状态 -->    <subflow-state id="order" subflow="pizza/order">      <input name="order" value="order"/>      <transition on="orderCreated" to="payment" />    </subflow-state>            <!-- 支付子流程状态 -->    <subflow-state id="payment" subflow="pizza/payment">      <input name="order" value="order"/>      <transition on="paymentTaken" to="saveOrder"/>          </subflow-state>    <!-- 保存订单行为状态 -->    <action-state id="saveOrder">        <!-- 执行保存订单行为 -->        <evaluate expression="pizzaFlowActions.saveOrder(order)" />        <transition to="thankYou" />    </action-state>    <!-- 视图状态 -->    <view-state id="thankYou">      <transition to="endState" />    </view-state>                    <!-- 结束状态 -->    <end-state id="endState" />    <!-- 全局转移 -->    <global-transitions>      <transition on="cancel" to="endState" />    </global-transitions></flow>```#### 收集顾客信息![](../../images/sia/c5/识别顾客子流程.png)```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <input name="order" required="true"/>        <!-- 视图状态-欢迎顾客 -->    <view-state id="welcome">        <transition on="phoneEntered" to="lookupCustomer"/>        <transition on="cancel" to="cancel"/>    </view-state>    <!-- 行为状态-查找顾客 -->    <action-state id="lookupCustomer">        <!-- 查找顾客，查询结果设置到订单的顾客属性上 -->        <evaluate result="order.customer" expression=            "pizzaFlowActions.lookupCustomer(requestParameters.phoneNumber)" />        <!-- 未找到顾客，跳转到注册页面 -->        <transition to="registrationForm" on-exception=            "com.sia.pizza.service.CustomerNotFoundException" />        <!-- 找到顾客，直接进入结束流程 -->        <transition to="customerReady" />    </action-state>    <!-- 视图状态-注册新顾客 -->    <view-state id="registrationForm" model="customer" popup="true" >        <on-entry>          <evaluate expression="order.customer.phoneNumber = requestParameters.phoneNumber" />        </on-entry>        <!-- 提交注册 -->        <transition on="submit" to="checkDeliveryArea" />        <transition on="cancel" to="cancel" />    </view-state>    <!-- 决策状态-检查配送区域 -->    <decision-state id="checkDeliveryArea">      <if test="pizzaFlowActions.checkDeliveryArea(order.customer.zipCode)"           then="addCustomer"           else="deliveryWarning"/>    </decision-state>    <!-- 视图状态-配送范围超出警告 -->    <view-state id="deliveryWarning">        <transition on="accept" to="addCustomer" />        <transition on="cancel" to="cancel" />    </view-state>    <!-- 行为状态-新增顾客 -->    <action-state id="addCustomer">        <evaluate expression="pizzaFlowActions.addCustomer(order.customer)" />        <transition to="customerReady" />    </action-state>                <!-- 结束状态-取消 -->    <end-state id="cancel" />    <!-- 结束状态-顾客就绪 -->    <end-state id="customerReady" /></flow>```#### 构建订单```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <input name="order" required="true" />        <!-- 视图状态-订单视图 -->    <view-state id="showOrder">        <!-- 添加披萨 -->        <transition on="createPizza" to="createPizza" />        <!-- 提交订单 -->        <transition on="checkout" to="orderCreated" />        <!-- 取消 -->        <transition on="cancel" to="cancel" />    </view-state>    <!-- 视图状态-添加披萨 -->    <view-state id="createPizza" model="flowScope.pizza">        <on-entry>          <!-- 创建披萨实例，当前流程可见 -->            <set name="flowScope.pizza"               value="new com.sia.pizza.domain.Pizza()" />          <!-- 获取配料列表，当前视图状态可见 -->          <evaluate result="viewScope.toppingsList"               expression="T(com.sia.pizza.domain.Topping).asList()" />        </on-entry>        <transition on="addPizza" to="showOrder">          <evaluate expression="order.addPizza(flowScope.pizza)" />        </transition>        <transition on="cancel" to="showOrder" />    </view-state>    <!-- 结束状态 -->    <end-state id="cancel" />    <end-state id="orderCreated" /></flow>```#### 支付```xml<?xml version="1.0" encoding="UTF-8"?><flow xmlns="http://www.springframework.org/schema/webflow"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://www.springframework.org/schema/webflow   http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">    <input name="order" required="true"/>    <!-- 视图状态-输入支付信息 -->    <view-state id="takePayment" model="flowScope.paymentDetails">        <on-entry>          <set name="flowScope.paymentDetails"              value="new com.sia.pizza.domain.PaymentDetails()" />          <evaluate result="viewScope.paymentTypeList"              expression="T(com.sia.pizza.domain.PaymentType).asList()" />        </on-entry>        <transition on="paymentSubmitted" to="verifyPayment" />        <transition on="cancel" to="cancel" />    </view-state>    <!-- 行为状态-验证支付信息 -->    <action-state id="verifyPayment">        <evaluate result="order.payment" expression=            "pizzaFlowActions.verifyPayment(flowScope.paymentDetails)" />        <transition to="paymentTaken" />    </action-state>                <!-- End state -->    <end-state id="cancel" />    <end-state id="paymentTaken" /></flow>```### 8.4 保护 Web 流程结合 Spring Security 保护 Spring Web Flow 中的状态、转移甚至整个流程。```xml<view-state id="restricted"><secured attributes="ROLE_ADMIN" match="all"/></view-state>```match:- all：必须全部满足- any：满足一个即可## 9、保护 Web 应用- Spring Security 介绍- 使用 Servlet 规范中的 Filter 保护 Web 应用- 基于数据库和 LDAP 进行认证### 9.1 Spring Security 简介Spring Security 是为基于 Spring 的应用程序提供声明式安全保护的安全性框架。Spring Security 提供了完整的安全性解决方案，它能够在 **Web 请求级别和方法调用级别**处理身份认证和授权。因为基于 Spring 框架，所以 Spring Security 充分利用了依赖注入（dependency injection，DI）和面向切面的技术。最新版本为 3.2，Spring Security 从两个角度来解决安全性问题。它使用 **Servlet 规范中的 Filter 保护 Web 请求并限制URL级别的访问**。Spring Security 还能够**使用 Spring AOP 保护方法调用**——借助于**对象代理和使用通知**，能够确保只有具备适当权限的用户才能访问安全保护的方法。> **可以实现 Web 请求级别和方法级别的身份认证和授权**>> **请求级别基于 Filter 实现；方法级别使用 AOP 实现**#### Spring Security 的 11 个模块![](../../images/sia/c5/springsecurity模块.png)至少需要 Core 和 Configuration 两个模块。#### 过滤 Web 请求**在 xml 中配置**Spring Security 借助一系列 Servlet Filter 来提供各种安全性功能。但是我们不用在 web.xml 中配置多个 Filter，只需要配置 **DelegatingFilterProxy** 就行，他会把工作委托给各个自定义 Filter。**DelegatingFilterProxy**  的 filter-name 配置为 springSecurityFilterChain，所以 **DelegatingFilterProxy** 会将过滤逻辑委托给 springSecurityFilterChain。```xml<filter><filter-name>springSecurityFilterChain</filter-name>    <filter-class>    org.springframework.web.filter.DelegatingFilterProxy    </filter-class></filter>```**在 Java 中配置**只需创建一个新类，继承`AbstractSecurityWebApplicationInitializer`即可，他会自动注册`DelegatingFilterProxy`。```javapublic class SecurityWebInitializer        extends AbstractSecurityWebApplicationInitializer &#123;&#125;```#### 编写简单的安全配置Spring Security 必须配置在一个实现了 WebSecurityConfigurer 的 bean 中，或者扩展 WebSecurityConfigurerAdapter。**@EnableWebSecurity** 可以启用任意 Web 应用的安全性功能。如果碰巧使用 Spring MVC 开发，应该使用 **@EnableWebMvcSecurity** 代替。@EnableWebMvcS ecurity 额外配置了一个 Spring MVC 参数解析器，这样处理器方法就能够通过带有 **@AuthenticationPrincipal** 注解的参数获得认证用户的 principal（或 username）。另外还配置了一个 bean，在使用 Spring 表单绑定标签库来定义表单时，这个 bean 会自动添加一个隐藏的跨站请求伪造（cross-site request forgery，CSRF）token 输入域。```java@Configuration// 启用 Web 安全性// @EnableWebSecurity// 启用 Spring MVC 安全性@EnableWebMvcSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125;```可以通过重载 WebSecurityConfigurerAdapter 中的三个 **configure()** 方法来配置 Web 安全性。| 方法                                    | 描述                                        || --------------------------------------- | ------------------------------------------- || configure(WebSecurity)                  | 通过重载，配置 Spring Security 的 Filter 链 || configure(HttpSecurity)                 | 通过重载，配置如何通过拦截器保护请求        || configure(AuthenticationManagerBuilder) | 通过重载，配置 user-detail 服务             |**默认配置**```javahttp    .authorizeRequests()    // 所有请求需要认证    .anyRequest().authenticated()    .and()    // 配置支持基于表单的登录    .formLogin()    .and()    // 配置支持基于 HTTP Basic 方式的认证    .httpBasic();```由于我们没有重载 configure(AuthenticationManagerBuilder) 方法，所以没有用户存储支撑认证过程，所以没用用户，但是默认所有请求都需要认证，所以没有人能够登录成功。所以我们还需要如下配置：- 配置用户存储- 指定哪些请求需要认证，哪些不需要，以及所需要的的权限- 提供一个自定义的登录页面，替代原来简单的默认登录页### 9.2 选择查询用户详细信息的服务#### 基于内存的用户存储```java    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth                // 启用内存用户存储                .inMemoryAuthentication()                .withUser("user").password("pass9876").roles("USER").and()                .withUser("admin").password("pass9876").roles("USER","ADMIN");    &#125;```**用户详细信息配置一览表**![](../../images/sia/c5/用户配置.png)#### 基于数据库表进行认证```java        auth                // 启用数据库用户存储                .jdbcAuthentication()                .dataSource(dataSource)                // 自定义用户查询，因为实际中数据表很可能和默认的不一样                .usersByUsernameQuery("select username, password, true from Spitter where username = ?")                .authoritiesByUsernameQuery("select username, 'ROLE_USER', from Spitter where username = ?")                // 密码转码                .passwordEncoder(new StandardPasswordEncoder("123456"));```#### 基于 LDAP 进行认证```java        auth                .ldapAuthentication()                .userSearchBase("ou=people")                .userSearchFilter("&#123;uid=&#123;0&#125;&#125;&quot;)                .groupSearchBase(&quot;ou=groups&quot;)                .groupSearchFilter(&quot;member=&#123;0&#125;&quot;)                .passwordCompare()                .passwordEncoder(new Md5PasswordEncoder())                .passwordAttribute(&quot;passcode&quot;)                .and()                .contextSource()                // 配置 LDAP 服务器                // .url(&quot;ldap://monkey-kong.com:389/db=alvin,dc=com&quot;)                // 使用嵌入式服务器                .root(&quot;dc=alvin,dc=com&quot;)                // 指定LDAP服务器从类路径根目录下的users.ldif文件中加载内容                .ldif(&quot;classpath:users.ldif&quot;)        ;</code></pre><h4 id="配置自定的用户服务"><a href="#配置自定的用户服务" class="headerlink" title="配置自定的用户服务"></a>配置自定的用户服务</h4><p>提供一个自定义的 <strong>UserDetailsService</strong> 接口实现</p><pre><code class="java">/** * 自定义 spring security 用户服务 */public class SpitterUserService implements UserDetailsService &#123;    private final SpitterRepository spitterRepository;    public SpitterUserService(SpitterRepository spitterRepository) &#123;        this.spitterRepository = spitterRepository;    &#125;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        Spitter spitter = spitterRepository.findByUsername(username);        if (spitter != null) &#123;            List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();            authorities.add(new SimpleGrantedAuthority(&quot;ROLE_SPITTER&quot;));            return new User(spitter.getUsername(), spitter.getPassword(), authorities);        &#125;        throw  new UsernameNotFoundException(&quot;User &#39;&quot; + username + &quot;&#39; not found.&quot; );    &#125;&#125;</code></pre><p>配置</p><pre><code class="java">// 使用自定义用户服务auth.userDetailsService(new SpitterUserService(spitterRepository));</code></pre><h3 id="9-3-拦截请求"><a href="#9-3-拦截请求" class="headerlink" title="9.3 拦截请求"></a>9.3 拦截请求</h3><pre><code class="java">    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()                .antMatchers(&quot;/spitters/me&quot;).authenticated()                .antMatchers(HttpMethod.POST, &quot;/spittles&quot;).authenticated()                // 其他所有请求不需要认证和权限                .anyRequest().permitAll()                ;    &#125;</code></pre><p><strong>配置一览表</strong></p><p><img src="../../images/sia/c5/%E8%B7%AF%E5%BE%84%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.png"></p><p>增加角色配置</p><pre><code class="java">        http.authorizeRequests()                .antMatchers(&quot;/spitters/me&quot;)                .hasRole(&quot;SPITTER&quot;)                .antMatchers(HttpMethod.POST, &quot;/spittles&quot;)                .hasAnyAuthority(&quot;ROLE_SPITTER&quot;)                // 其他所有请求不需要认证和权限                .anyRequest().permitAll()                ;</code></pre><h4 id="使用-SPEL-进行安全保护"><a href="#使用-SPEL-进行安全保护" class="headerlink" title="使用 SPEL 进行安全保护"></a>使用 SPEL 进行安全保护</h4><p>用于定制更加特殊的请求限制。比如通过 IP 地址限制，比如限制某个角色只能在星期二进行访问。</p><p><img src="../../images/sia/c5/spel%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84%E6%A0%A1%E9%AA%8C.png"></p><pre><code class="java">.antMatchers(&quot;/spitters/me&quot;).access(&quot;hasRole(&#39;ROLE_SPITTER&#39;) and hasIpAddress(&#39;192.168.1.2&#39;)&quot;)</code></pre><h4 id="强制通道的安全性"><a href="#强制通道的安全性" class="headerlink" title="强制通道的安全性"></a>强制通道的安全性</h4><pre><code class="java">.and()    // 指定哪些请求需要走安全通道（https），哪些不需要    .requiresChannel()    .antMatchers(&quot;/spitter/form&quot;).requiresSecure()    .antMatchers(&quot;/&quot;).requiresInsecure()</code></pre><h4 id="防止跨站请求伪造"><a href="#防止跨站请求伪造" class="headerlink" title="防止跨站请求伪造"></a>防止跨站请求伪造</h4><p>如果一个站点欺骗用户提交请求到其他服务器的话，就会发生 CSRF 攻击，这可能会带来消极的后果。尽管提交“I’m stupid!”这样的信息到微博站点算不上什么 CSRF 攻击的最糟糕场景，但是你可以很容易想到更为严重的攻击情景，它可能会对你的银行账号执行难以预期的操作。</p><p>Spring Security通过一个同步 token 的方式来实现 CSRF 防护的功能。它将会拦截状态变化的请求（例如，非GET、HEAD、OPTIONS 和 TRACE 的请求）并检查 CSRF token。如果请求中不包含 CSRF token 的话，或者token 不能与服务器端的 token 相匹配，请求将会失败，并抛出 CsrfException 异常。</p><p><strong>Thymeleaf</strong></p><p>如果使用 Thymeleaf 作为页面模板，只要 form 标签的 action 添加 Thymeleaf 命名空间前缀，那么就会自动生成一个 “_csrf” 隐藏域。</p><pre><code class="html">&lt;form method=&quot;POST&quot; th:action=&quot;@&#123;/spittles&#125;&quot;&gt;    ...&lt;/form&gt;</code></pre><p><strong>JSP</strong></p><p>手动增加一个隐藏域。</p><pre><code class="html">&lt;input type=&quot;hidden&quot; name=&quot;$&#123;_csrf.parameterName&#125;&quot; value=&quot;$&#123;_csrf.token&#125;&quot; /&gt;</code></pre><p>如果使用了 Spring 的表单绑定标签， <code>&lt;sf:form&gt;</code>标签也会自动帮我们添加隐藏的 CSRF token 标签。</p><p>处理 CSRF 的另一种方式就是根本不去处理它，直接禁用掉，但是会有 CSRF 攻击的风险。</p><pre><code class="java">// 禁用 CSRF 防护功能http.csrf.disabled;</code></pre><h3 id="9-4-认证用户"><a href="#9-4-认证用户" class="headerlink" title="9.4 认证用户"></a>9.4 认证用户</h3><h4 id="添加自定义的登录页"><a href="#添加自定义的登录页" class="headerlink" title="添加自定义的登录页"></a>添加自定义的登录页</h4><pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;  &lt;head&gt;    &lt;title&gt;Spitter&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot;           type=&quot;text/css&quot;           th:href=&quot;@&#123;/resources/style.css&#125;&quot;&gt;&lt;/link&gt;  &lt;/head&gt;  &lt;body onload=&#39;document.f.username.focus();&#39;&gt;      &lt;div id=&quot;header&quot; th:include=&quot;page :: header&quot;&gt;&lt;/div&gt;      &lt;div id=&quot;content&quot;&gt;          &lt;a th:href=&quot;@&#123;/spitter/register&#125;&quot;&gt;注册&lt;/a&gt;          &lt;form name=&#39;f&#39; th:action=&#39;@&#123;/login&#125;&#39; method=&#39;POST&#39;&gt;               &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;用户名:&lt;/td&gt;                    &lt;td&gt;&lt;input type=&#39;text&#39; name=&#39;username&#39; value=&#39;&#39; /&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;密码:&lt;/td&gt;                    &lt;td&gt;&lt;input type=&#39;password&#39; name=&#39;password&#39;/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=&#39;2&#39;&gt;                        &lt;input id=&quot;remember_me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt;                        &lt;label for=&quot;remember_me&quot; class=&quot;inline&quot;&gt;记住我&lt;/label&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=&#39;2&#39;&gt;                        &lt;input name=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Login&quot;/&gt;                    &lt;/td&gt;                &lt;/tr&gt;               &lt;/table&gt;          &lt;/form&gt;      &lt;/div&gt;      &lt;div id=&quot;footer&quot; th:include=&quot;page :: copy&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="启用-HTTP-Basic-认证"><a href="#启用-HTTP-Basic-认证" class="headerlink" title="启用 HTTP Basic 认证"></a>启用 HTTP Basic 认证</h4><p>对于应用程序的人类用户来说，基于表单的认证是比较理想的。但是当应用程序的使用者是另外一个应用程序的<br>话，使用表单来提示登录的方式就不太适合了。</p><pre><code class="java">// 启用 httpBasic.httpBasic()    // 指定域    .realmName(&quot;Spittr&quot;)</code></pre><p>如何测试？</p><h4 id="启用-Remember-me-功能"><a href="#启用-Remember-me-功能" class="headerlink" title="启用 Remember-me 功能"></a>启用 Remember-me 功能</h4><pre><code class="java">.rememberMe()    .tokenValiditySeconds(2419200)    .key(&quot;spittrKey&quot;)</code></pre><p>存储在 cookie 中的 token 包含用户名、密码、过期时间和一个私钥——在写入 cookie 前都进行了 MD5 哈希。默认情况下，私钥的名为 SpringSecured，但在这里我们将其设置为 spitterKey，使它专门用于 Spittr 应用。</p><p>登录请求必须包含一个名为<strong>remember-me</strong>的参数。</p><pre><code class="html">&lt;input id=&quot;remember_me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt;&lt;label for=&quot;remember_me&quot; class=&quot;inline&quot;&gt;记住我&lt;/label&gt;</code></pre><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>退出功能是通过 Servlet 容器中的 Filter 实现的（默认情况下），这个 Filter 会拦截针<br>对“/logout”的请求。退出后，所有的 remember-me token 都会被清除掉。</p><pre><code class="html">&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;登出&lt;/a&gt;</code></pre><pre><code class="java">// 设置登出相关操作.logout()    .logoutSuccessUrl(&quot;/&quot;)</code></pre><h3 id="9-5-保护视图"><a href="#9-5-保护视图" class="headerlink" title="9.5 保护视图"></a>9.5 保护视图</h3><p>上面是发起请求时，校验是否登录以及登录人是否有操作权限。换个角度，我们可以不给用户显示其无权访问的连接。</p><h4 id="使用-Spring-Security-的-JSP-标签库"><a href="#使用-Spring-Security-的-JSP-标签库" class="headerlink" title="使用 Spring Security 的 JSP 标签库"></a>使用 Spring Security 的 JSP 标签库</h4><p><img src="../../images/sia/c5/SpringSecurityJSP%E6%A0%87%E7%AD%BE%E5%BA%93.png"></p><h4 id="使用-Thymeleaf-的-Spring-Security-方言"><a href="#使用-Thymeleaf-的-Spring-Security-方言" class="headerlink" title="使用 Thymeleaf 的 Spring Security 方言"></a>使用 Thymeleaf 的 Spring Security 方言</h4><p><img src="../../images/sia/c5/thymeleafsecurity%E6%96%B9%E8%A8%80.png"></p><p><strong>模板引擎中注册安全方言</strong></p><pre><code class="java">@Beanpublic SpringTemplateEngine templateEngine(TemplateResolver templateResolver) &#123;    SpringTemplateEngine templateEngine = new SpringTemplateEngine();    templateEngine.setTemplateResolver(templateResolver);    // 注册安全方言    templateEngine.addDialect(new SpringSecurityDialect());    return templateEngine;&#125;</code></pre><p><strong>在模板中生命安全方言命名空间</strong></p><pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;      xmlns:th=&quot;http://www.thymeleaf.org&quot;      xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3&quot;&gt;</code></pre><p><strong>在模板中使用</strong></p><pre><code class="html">&lt;!-- 条件渲染 --&gt;&lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;    &lt;!-- 渲染认证对象的属性 --&gt;    Hello there...&lt;span sec:authentication=&quot;name&quot;&gt;user-name&lt;/span&gt;&lt;/div&gt;&lt;!-- 基于URL权限来渲染，这样就不用页面和url拦截写两份相同的控制了 --&gt;&lt;span sec:authorize-url=&quot;/admin&quot;&gt;    &lt;br/&gt; &lt;a th:href=&quot;@&#123;/admin&#125;&quot;&gt;Admin&lt;/a&gt;&lt;/span&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;书中的代码是用 Grandle 构建，怎么跑起来是个问题。记录一下采坑过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>第 4 章 面向切面的 Spring</title>
    <link href="http://yoursite.com/2020-12-24-13Spring%E5%9F%BA%E7%A1%80/20191026sia4.html"/>
    <id>http://yoursite.com/2020-12-24-13Spring%E5%9F%BA%E7%A1%80/20191026sia4.html</id>
    <published>2020-12-24T14:13:12.000Z</published>
    <updated>2020-12-27T15:18:50.488Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面向切面编程的基本原理</li><li>通过 POJO 创建切面</li><li>使用 @AspectJ 注解</li><li>为 AspectJ 切面注入依赖</li></ul><p>在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把<strong>这些横切关注点与业务逻辑相分离</strong>正是面向切面编程（AOP）所要解决的问题。</p><p>在第2章，我们介绍了如何使用依赖注入（DI）管理和配置我们的应用对象。DI有助于应用<br>对象之间的解耦，而 AOP 可以<strong>实现横切关注点与它们所影响的对象之间的解耦</strong>。  </p><p>切面适用场景：日志、声明式事务、安全和缓存 </p><a id="more"></a><h2 id="4-1-什么是面向切面编程"><a href="#4-1-什么是面向切面编程" class="headerlink" title="4.1 什么是面向切面编程"></a>4.1 什么是面向切面编程</h2><p>在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要<br>以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</p><h3 id="定义-AOP-术语"><a href="#定义-AOP-术语" class="headerlink" title="定义 AOP 术语"></a>定义 AOP 术语</h3><ol><li>通知（advice）</li></ol><p>切面要完成的工作就是通知。通知定义了切面要做什么以及什么时候做。Spring 切面有 5 个类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul><ol start="2"><li>切点（pointcut）</li></ol><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些 AOP 框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p><ol start="3"><li>连接点（join point）</li></ol><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><ol start="4"><li>切面（Aspect）</li></ol><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</p><ol start="5"><li>引入（Introduction）</li></ol><p>引入允许我们向现有的类添加新方法或属性。</p><ol start="6"><li>织入（Weaving）</li></ol><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving,LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的。</li></ul><h3 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h3><p>Spring 提供了 4 种类型的 AOP 支持：</p><ul><li>基于代理的经典Spring AOP；</li><li>纯POJO切面；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）</li></ul><p>Spring 通知是 Java 编写的。</p><p>Spring 在运行时通知对象。</p><p>Spring 只支持方法级别的连接点。</p><h2 id="4-2-通过切点来选择连接点"><a href="#4-2-通过切点来选择连接点" class="headerlink" title="4.2 通过切点来选择连接点"></a>4.2 通过切点来选择连接点</h2><p>关于 Spring AOP 的 AspectJ 切点，最重要的一点就是 Spring 仅支持 AspectJ 切点指示器（pointcut<br>designator）的一个子集。</p><p>Spring借助AspectJ的切点表达式语言来定义Spring切面。</p><table><thead><tr><th>AspectJ 指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><p>在Spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgument-Exception异常。</p><p>只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们使用其他指示器来限制所匹配的切点。</p><h3 id="编写切点"><a href="#编写切点" class="headerlink" title="编写切点"></a>编写切点</h3><pre><code class="java">// 设置 perform() 方法执行时触发通知@Pointcut(&quot;execution(* concert.Performance.perform(..))&quot;)// 配置的切点仅匹配concert包@Pointcut(&quot;execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*)&quot;)</code></pre><h3 id="在切点中选择-bean"><a href="#在切点中选择-bean" class="headerlink" title="在切点中选择 bean"></a>在切点中选择 bean</h3><p>Spring 还引入了一个新的 bean() 指示器，它允许我们在切点表达式中使用 bean 的 ID 来标识 bean。</p><h2 id="4-3-使用注解创建切面"><a href="#4-3-使用注解创建切面" class="headerlink" title="4.3 使用注解创建切面"></a>4.3 使用注解创建切面</h2><h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><p>从演出的角度来看，观众是非常重要的，但是对演出本身的功能来讲，它并不是核心，这是一个单独的关注点。因此，将观众定义为一个切面，并将其应用到演出上就是较为明智的做法。</p><p>AspectJ提供了五个注解来定义通知</p><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr></tbody></table><p>如果你使用JavaConfig的话，可以在配置类的类级别上通过使用 EnableAspectJAutoProxy 注解启用自动代理功能。</p><pre><code class="java">@Aspectpublic class Audience &#123;    // 定义命名的切点    @Pointcut(&quot;execution(* concert.Performance.perform(..))&quot;)    public void performance() &#123;&#125;    // 前置通知    @Before(&quot;performance()&quot;)    // @Before(&quot;execution(* concert.Performance.perform(..))&quot;)    public void silenceCellPhone() &#123;        System.out.println(&quot;Silencing cell phones&quot;);    &#125;    @Before(&quot;performance()&quot;)    public void takeSeats() &#123;        System.out.println(&quot;Taking seats&quot;);    &#125;    // 后置通知    @AfterReturning(&quot;performance()&quot;)    public void applause() &#123;        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    &#125;    // 异常通知    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund() &#123;        System.out.println(&quot;Demanding a refund&quot;);    &#125;&#125;</code></pre><p>Java 配置：</p><pre><code class="java">@Configuration// 启用 AspectJ 自动代理@EnableAspectJAutoProxy@ComponentScanpublic class ConcertConfig &#123;    @Bean    public Audience audience() &#123;        return new Audience();    &#125;&#125;</code></pre><p>XML 配置：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.0.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;  &lt;context:component-scan base-package=&quot;concert&quot;/&gt;  &lt;!-- 启用 AspectJ 自动代理 --&gt;  &lt;aop:aspectj-autoproxy /&gt;  &lt;bean class=&quot;concert.Audience&quot; /&gt;&lt;/beans&gt;</code></pre><p>不管你是使用JavaConfig还是XML，AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理，这个代理会围绕着所有该切面的切点所匹配的bean。在这种情况下，将会为Concertbean创建一个代理，Audience类中的通知方法将会在perform()调用前后执行。</p><h3 id="创建环绕通知"><a href="#创建环绕通知" class="headerlink" title="创建环绕通知"></a>创建环绕通知</h3><p>环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。</p><pre><code class="java">@Around(&quot;performance()&quot;)public void watchPerformance(ProceedingJoinPoint jp) &#123;    try &#123;        System.out.println(&quot;Silencing cell phones&quot;);        System.out.println(&quot;Taking seats&quot;);        jp.proceed();        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    &#125; catch (Throwable e) &#123;        System.out.println(&quot;Demanding a refund&quot;);    &#125;&#125;</code></pre><p>需要注意的是，别忘记调用proceed()方法。如果不调这个方法的话，那么你的通知实际上会阻塞对被通知方法的调用。</p><h3 id="处理通知中的参数"><a href="#处理通知中的参数" class="headerlink" title="处理通知中的参数"></a>处理通知中的参数</h3><p>需求：记录每个磁道被播放的次数。<br>方法1：直接修改<code>playTrack()</code>方法，直接在每次调用的时候记录这个数量。但是，记录磁道的播放次数与播放本身是不同的关注点，因此不应该属于<code>playTrack()</code>方法。<br>方法2：创建 <code>TrackCounter</code>类，他是通知<code>playTrack()</code>方法的一个切面。</p><ol><li><p>创建切面</p><pre><code class="java">@Aspectpublic class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;&gt;(); // 切点。通知playTrack()方法，并且声明了要提供给通知方法的参数 @Pointcut(&quot;execution(* params.CompactDisc.playTrack(int)) &quot; +         &quot;&amp;&amp; args(trackNumber)&quot;) public void trackPlayed(int trackNumber) &#123; &#125; // 前置通知。参数由切点传递过来 @Before(&quot;trackPlayed(trackNumber)&quot;) public void countTrack(int trackNumber) &#123;     int currentCount = getPlayCount(trackNumber);     trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber) &#123;     return trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : 0; &#125;&#125;</code></pre><p><img src="./sia4images/%E5%A4%84%E7%90%86%E9%80%9A%E7%9F%A5%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0.png" alt="处理通知中的参数"></p></li><li><p>理解通知中参数传递<br>定义切点时，使用<code>args(trackNumber)</code>指定参数，然后该切点的通知<code>@Before(&quot;trackPlayed(trackNumber)&quot;)</code>就可以接收到指定参数了。</p></li><li><p>测试切面是否生效</p><pre><code class="java">@Autowiredprivate TrackCounter counter;</code></pre></li></ol><p>@Test<br>public void testTrackCounter() {<br>    cd.playTrack(1);<br>    cd.playTrack(2);<br>    cd.playTrack(3);<br>    cd.playTrack(3);<br>    cd.playTrack(3);<br>    cd.playTrack(3);<br>    cd.playTrack(6);<br>    cd.playTrack(7);<br>    cd.playTrack(7);</p><pre><code>assertEquals(1, counter.getPlayCount(1));assertEquals(1, counter.getPlayCount(2));assertEquals(4, counter.getPlayCount(3));assertEquals(0, counter.getPlayCount(4));assertEquals(0, counter.getPlayCount(5));assertEquals(1, counter.getPlayCount(6));assertEquals(2, counter.getPlayCount(7));</code></pre><p>}</p><pre><code>### 通过注解引入新功能目前我们还没有为对象增加任何新的方法，但是已经为对象拥有的方法添加了新功能。如果切面能够为现有的方法增加额外的功能，为什么不能为一个对象增加新的方法呢？实际上，利用被称为引入的 AOP 概念，切面可以为 Spring bean 添加新方法。通过切面为 Spring bean 添加新方法步骤。1. 定义需要额外实现的接口2. 声明切面，使用 @DeclareParents 注解将该接口应用到需要扩展的 Spring bean3. 将切面注入到 Spring 容器具体实现：1. 定义 Encoreable 接口    ```java    public interface Encoreable &#123;        void performEncore();    &#125;    ```2. 将这个接口应用到Performance实现中假设你能够访问Performance的所有实现，并对其进行修改，让它们都实现Encoreable接口。但是，从设计的角度来看，这并不是最好的做法，并不是所有的Performance都是具有Encoreable特性的。另外一方面，有可能无法修改所有的Performance实现，当使用第三方实现并且没有源码的时候更是如此。借助于 AOP 的引入功能，我们可以不必在设计上妥协或者侵入性地改变现有的实现就可以实现该功能。定义 EncoreableIntroducer 切面。该切面并没有像之前那样提供前置、后置或环绕通知，而是通过 @DeclareParents 注解，将 Encoreable 接口引入到 Performance benan 中。```java@Aspectpublic class EncoreableIntroducer &#123;    @DeclareParents(value = &quot;concert.Performance+&quot;, defaultImpl = DefaultEncoreable.class)    public static Encoreable encoreable;&#125;</code></pre><p>@DeclareParents 注解由三部分组成：</p><p>​    value：指定那种类型的 bean 要引入该接口。在本例中，就是所有实现 Performance 的类型。（标记符后面的加号表示是Performance的所有子类型，而不是Performance本身。）</p><p>​    defaultImpl：指定了为引入功能提供的实现类。在这里我们指定 DefaultEncoreable 提供实现。</p><p>​    @DeclareParents 注解所标注的静态属性指明了要引入的接口。贼这里我们所引入的是 Encoreable 接口。</p><ol start="3"><li>将 EncoreableIntroducer 切面声明为一个 bean</li></ol><pre><code class="java">@Beanpublic EncoreableIntroducer encoreableIntroducer() &#123;    return new EncoreableIntroducer();&#125;</code></pre><p>Spring 的自动代理机制将会获取到它的声明，当 Spring 发现一个 bean 使用了@Aspect 注解时，Spring 就会创建一个代理，然后将调用委托给被代理的 bean 或被引入的实现，这取决于调用的方法属于被代理的 bean 还是属于被引入的接口。</p><ol start="4"><li>测试</li></ol><pre><code class="java">@Autowiredprivate Performance performance;@Testpublic void testPerformance() &#123;    // performance.perform();    Encoreable encoreable = (Encoreable)performance;    encoreable.performEncore();    assertEquals(&quot;Default encoreable\r\n&quot;, log.getLog());&#125;</code></pre><p>其实有点没明白。这和我自定定义接口实现然后调用有啥区别？</p><h3 id="通过注解声明切面劣势"><a href="#通过注解声明切面劣势" class="headerlink" title="通过注解声明切面劣势"></a>通过注解声明切面劣势</h3><p>面向注解的切面声明有一个明显的劣势：你必须能够为通知类添加注解。为了做到这一点，必须要有源码。如果没有源码，或者不想将AspectJ注解放到你的代码之中，Spring为切面提供了另外一种可选方案，那就是在 xml 配置文件中声明切面。</p><h2 id="4-4-在-XML-中声明切面"><a href="#4-4-在-XML-中声明切面" class="headerlink" title="4.4 在 XML 中声明切面"></a>4.4 在 XML 中声明切面</h2><p>在 Spring 的 aop 命名空间中，提供了多个元素用来在 XML 中声明切面。</p><table><thead><tr><th>AOP 配置元素</th><th>用途</th></tr></thead><tbody><tr><td>&lt;aop:advisor&gt;</td><td>定义AOP通知器</td></tr><tr><td>&lt;aop:after&gt;</td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>&lt;aop:after-returning&gt;</td><td>定义返回通知</td></tr><tr><td>&lt;aop:after-throwing&gt;</td><td>定义异常通知</td></tr><tr><td>&lt;aop:around&gt;</td><td>定义环绕通知</td></tr><tr><td>&lt;aop:aspect&gt;</td><td>定义一个切面</td></tr><tr><td>&lt;aop:aspect-autoproxy&gt;</td><td>启用@Aspect注解驱动切面</td></tr><tr><td>&lt;aop:before&gt;</td><td>定义前置通知</td></tr><tr><td>&lt;aop:config&gt;</td><td>顶层AOP配置元素</td></tr><tr><td>&lt;aop:declare-parents&gt;</td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>&lt;aop:pointcut&gt;</td><td>定义一个切点</td></tr></tbody></table><p>我们重新看一下 Audience 类，这一次我们将它所有的AspectJ注解全部移除掉：</p><pre><code class="java">public class Audience &#123;    public void silenceCellPhone() &#123;        System.out.println(&quot;Silencing cell phones&quot;);    &#125;    public void takeSeats() &#123;        System.out.println(&quot;Taking seats&quot;);    &#125;    public void applause() &#123;        System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);    &#125;    public void demandRefund() &#123;        System.out.println(&quot;Demanding a refund&quot;);    &#125;    public void watchPerformance(ProceedingJoinPoint jp) &#123;        try &#123;            System.out.println(&quot;Silencing cell phones&quot;);            System.out.println(&quot;Taking seats&quot;);            jp.proceed();            System.out.println(&quot;CLAP CLAP CLAP!!!&quot;);        &#125; catch (Throwable e) &#123;            System.out.println(&quot;Demanding a refund&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="声明前置和后置通知"><a href="#声明前置和后置通知" class="headerlink" title="声明前置和后置通知"></a>声明前置和后置通知</h3><p>在&lt;aop:config&gt;元素内，我们可以声明一个或多个通知器、切面或者切点。</p><pre><code class="xml">&lt;!-- 顶层元素 --&gt;&lt;aop:config&gt;    &lt;!-- 定义切面 audience --&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!-- 定义切点 performance --&gt;        &lt;aop:pointcut id=&quot;performance&quot; expression=&quot;execution(* concert.Performance.perform(..))&quot; /&gt;        &lt;!-- 配置通知 --&gt;        &lt;aop:before method=&quot;silenceCellPhone&quot; pointcut-ref=&quot;performance&quot; /&gt;        &lt;aop:before method=&quot;takeSeats&quot; pointcut-ref=&quot;performance&quot; /&gt;        &lt;aop:after-returning method=&quot;applause&quot; pointcut-ref=&quot;performance&quot; /&gt;        &lt;aop:after-throwing method=&quot;demandRefund&quot; pointcut-ref=&quot;performance&quot; /&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h3 id="声明环绕通知"><a href="#声明环绕通知" class="headerlink" title="声明环绕通知"></a>声明环绕通知</h3><p>如果不使用成员变量存储信息的话，在前置通知和后置通知之间共享信息非常麻烦。例如，假设除了进场关闭手机和表演结束后鼓掌，我们还希望观众确保一直关注演出，并报告每个参赛者表演了多长时间。使用前置通知和后置通知实现该功能的唯一方式是在前置通知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话我们必须在一个成员变量中保存开始时间。因为Audience是单例的，如果像这样保存状态的话，将会存在<strong>线程安全</strong>问题。</p><p>使用环绕通知，可以完美的解决此问题。</p><pre><code class="xml">&lt;aop:around method=&quot;watchPerformance&quot; pointcut-ref=&quot;performance&quot; /&gt;</code></pre><h3 id="为通知传递参数"><a href="#为通知传递参数" class="headerlink" title="为通知传递参数"></a>为通知传递参数</h3><pre><code class="xml">&lt;bean id=&quot;trackCounter&quot; class=&quot;params.TrackCounter&quot; /&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot;            expression=&quot;execution(* params.CompactDisc.playTrack(int)) and args(trackNumber)*&quot; /&gt;        &lt;aop:before method=&quot;countTrack&quot; pointcut-ref=&quot;trackPlayed&quot; /&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h3 id="通过切面引入新的功能"><a href="#通过切面引入新的功能" class="headerlink" title="通过切面引入新的功能"></a>通过切面引入新的功能</h3><pre><code class="xml">&lt;aop:aspect&gt;    &lt;aop:declare-parents        types-matching=&quot;concert.Performance+&quot;        implement-interface=&quot;concert.Encoreable&quot;        default-impl=&quot;concert.DefaultEncoreable&quot;    /&gt;&lt;/aop:aspect&gt;</code></pre><h2 id="4-5-注入-AspectJ-切面"><a href="#4-5-注入-AspectJ-切面" class="headerlink" title="4.5 注入 AspectJ 切面"></a>4.5 注入 AspectJ 切面</h2><p>虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP 是一个功能比较弱的AOP解决方案。AspectJ提供了Spring AOP所不能支持的许多类型的切点。</p><p>例如，当我们需要在创建对象时应用通知，构造器切点就非常方便。不像某些其他面向对象语言中的构造器，Java构造器不同于其他的正常方法。这使得Spring基于代理的AOP无法把通知应用于对象的创建过程。</p><p>为了演示，我们为上面的演出创建一个新切面。具体来讲，我们以切面的方式创建一个评论员的角色，他会观看演出并且会在演出之后提供一些批评意见。下面的CriticAspect 就是一个这样的切面。</p><ol><li>定义切面 CriticAspect</li></ol><pre><code class="java">public aspect CriticAspect &#123;    private CriticismEngine criticismEngine;    pointcut performance():execution(* concert.Performance.perform(..));    pointcut construct():execution(concert.CriticismEngineImpl.new());    after():performance()&#123;        System.out.println(criticismEngine.getCriticism());    &#125;    after():construct()&#123;        System.out.println(&quot;After Performance constructor&quot;);    &#125;    before():construct()&#123;        System.out.println(&quot;Before Performance constructor&quot;);    &#125;    public CriticismEngine getCriticismEngine() &#123;        return this.criticismEngine;    &#125;    public void setCriticismEngine(CriticismEngine criticismEngine) &#123;        this.criticismEngine = criticismEngine;    &#125;&#125;</code></pre><p>aspect 是啥？pointcut performance() 又是啥？这看着不行 java 语法啊！</p><ol start="2"><li>定义评论引擎 CriticismEngine</li></ol><pre><code class="java">public interface CriticismEngine &#123;    String getCriticism();&#125;</code></pre><ol start="3"><li>定义并注入引擎实现</li></ol><pre><code class="java">public class CriticismEngineImpl implements CriticismEngine &#123;    private String[] criticismPool;    public CriticismEngineImpl() &#123;    &#125;    @Override    public String getCriticism() &#123;        int i = (int) (Math.random() * criticismPool.length);        return criticismPool[i];    &#125;    public void setCriticismPool(String[] criticismPool) &#123;        this.criticismPool = criticismPool;    &#125;&#125;</code></pre><pre><code class="xml">&lt;bean id=&quot;criticismEngine&quot; class=&quot;concert.CriticismEngineImpl&quot;&gt;    &lt;property name=&quot;criticismPool&quot;&gt;        &lt;list&gt;            &lt;value&gt;Worst performance ever!&lt;/value&gt;            &lt;value&gt;I laughed, I cried, then I realized I was at the wrong show.&lt;/value&gt;            &lt;value&gt;A must see show!&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ol start="4"><li>为 CriticAspect 装配 CriticismEngineImple</li></ol><p>在展示如何实现注入之前，我们必须清楚 AspectJ 切面根本不需要 Spring 就可以织入到我们的应用中。如果想使用 Spring 的依赖注入为 AspectJ 切面注入协作者，那我们就需要在 Spring 配置中把切面声明为一个 Spring 配置中的 <bean>。如下的 <bean> 声明会把 criticismEnginebean 注入到 CriticAspect 中：</p><pre><code class="xml">&lt;bean class=&quot;concert.CriticAspect&quot; factory-method=&quot;aspectOf&quot;&gt;    &lt;property name=&quot;criticismEngine&quot; ref=&quot;criticismEngine&quot; /&gt;&lt;/bean&gt;</code></pre><p>很大程度上，<bean> 的声明与我们在 Spring 中所看到的其他 <bean> 配置并没有太多的区别，但是最大的不同在于使用了factory-method属性。通常情况下，Spring bean 由 Spring 容器初始化，但是 AspectJ 切面是由 AspectJ 在运行期创建的。等到 Spring 有机会为 CriticAspect 注入 CriticismEngine 时，CriticAspect 已经被实例化了。</p><p>没懂啥意思！！！</p><p>因为 Spring 不能负责创建 CriticAspect，那就不能在 Spring 中简单地把CriticAspect 声明为一个 bean。相反，我们需要一种方式为 Spring 获得已经由AspectJ 创建的 CriticAspect 实例的句柄，从而可以注入 CriticismEngine。幸好，所有的AspectJ切面都提供了一个静态的 aspectOf() 方法，该方法返回切面的一个单例。所以为了获得切面的实例，我们必须使用 factory-method 来调用asepctOf() 方法而不是调用 CriticAspect 的构造器方法。</p><p>简而言之，Spring 不能像之前那样使用 <bean> 声明来创建一个 CriticAspect实例——它已经在运行时由 AspectJ 创建完成了。Spring 需要通过 aspectOf() 工厂方法获得切面的引用，然后像 <bean> 元素规定的那样在该对象上执行依赖注入。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面向切面编程的基本原理&lt;/li&gt;
&lt;li&gt;通过 POJO 创建切面&lt;/li&gt;
&lt;li&gt;使用 @AspectJ 注解&lt;/li&gt;
&lt;li&gt;为 AspectJ 切面注入依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把&lt;strong&gt;这些横切关注点与业务逻辑相分离&lt;/strong&gt;正是面向切面编程（AOP）所要解决的问题。&lt;/p&gt;
&lt;p&gt;在第2章，我们介绍了如何使用依赖注入（DI）管理和配置我们的应用对象。DI有助于应用&lt;br&gt;对象之间的解耦，而 AOP 可以&lt;strong&gt;实现横切关注点与它们所影响的对象之间的解耦&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;切面适用场景：日志、声明式事务、安全和缓存 &lt;/p&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>第 3 章 高级装配</title>
    <link href="http://yoursite.com/2020-12-23-13Spring%E5%9F%BA%E7%A1%80/20191025sia3.html"/>
    <id>http://yoursite.com/2020-12-23-13Spring%E5%9F%BA%E7%A1%80/20191025sia3.html</id>
    <published>2020-12-23T14:13:12.000Z</published>
    <updated>2021-01-02T12:44:05.694Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="3-1-环境与-profile"><a href="#3-1-环境与-profile" class="headerlink" title="3.1 环境与 profile"></a>3.1 环境与 profile</h2><h3 id="Java-配置-profile-bean"><a href="#Java-配置-profile-bean" class="headerlink" title="Java 配置 profile bean"></a>Java 配置 profile bean</h3><pre><code class="java">@Configurationpublic class DataSourceConfig&#123;  @Bean(destroyMethod = &quot;shutdown&quot;)  @Profile(&quot;dev&quot;)  public DataSource embeddedDataSource()  &#123;    return new EmbeddedDatabaseBuilder()        .setType(EmbeddedDatabaseType.H2)        .addScript(&quot;classpath:schema.sql&quot;)        .addScript(&quot;classpath:test-data.sql&quot;)        .build();  &#125;  @Bean  @Profile(&quot;prod&quot;)  public DataSource jndiDataSource()  &#123;    JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();    jndiObjectFactoryBean.setJndiName(&quot;jdbc/myDS&quot;);    jndiObjectFactoryBean.setResourceRef(true);    jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);    return (DataSource) jndiObjectFactoryBean.getObject();  &#125;&#125;</code></pre><h3 id="XML-配置-profile-bean"><a href="#XML-配置-profile-bean" class="headerlink" title="XML 配置 profile bean"></a>XML 配置 profile bean</h3><pre><code class="xml">&lt;beans profile=&quot;dev&quot;&gt;    &lt;jdbc:embedded-database id=&quot;dataSource&quot; type=&quot;H2&quot;&gt;        &lt;jdbc:script location=&quot;classpath:schema.sql&quot; /&gt;        &lt;jdbc:script location=&quot;classpath:test-data.sql&quot; /&gt;    &lt;/jdbc:embedded-database&gt;&lt;/beans&gt;&lt;beans profile=&quot;prod&quot;&gt;    &lt;jee:jndi-lookup id=&quot;dataSource&quot;                     lazy-init=&quot;true&quot;                     jndi-name=&quot;jdbc/myDatabase&quot;                     resource-ref=&quot;true&quot;                     proxy-interface=&quot;javax.sql.DataSource&quot; /&gt;&lt;/beans&gt;</code></pre><p>带有 @Profile(“dev”) 注解的 bean，只有对应的 profile 被激活时，才会创建，否则会被忽略。</p><p>没有指定 profile 的 bean 始终都会被创建，与激活哪个 profile 没有关系。</p><h3 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h3><p>Spring 在确定哪个 profile 处于激活状态时，需要依赖两个独立的属性:</p><ul><li>spring.profiles.active</li><li>spring.profiles.default</li></ul><p>如果设置了 active，则激活的 profile 就是 active 指定的 profile。</p><p>如果没有设置 active，则激活的 profile 就是 default 指定的 profile。</p><p>如果 active、default 都没有设置，那么所有的 profile bean 都会被忽略。</p><p>设置这两个属性的方式：</p><ul><li>作为 DispatcherServlet 的初始化参数；</li><li>作为 Web 应用的上下文参数；</li><li>作为 JNDI 条目；</li><li>作为环境变量；</li><li>作为 JVM 的系统属性；</li><li>在集成测试类上，使用 @ActiveProfiles 注解设置。</li></ul><p>DispatcherServlet 的初始化参数</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;        &lt;param-value&gt;dev&lt;/param-value&gt;        &lt;/init-param&gt;&lt;/servlet&gt;</code></pre><p>Web 应用的上下文参数</p><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;    &lt;param-value&gt;dev&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><p>@ActiveProfiles 注解</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=DataSourceConfig.class)// xml 形式// @ContextConfiguration(&quot;classpath:datasource-config.xml&quot;)@ActiveProfiles(&quot;prod&quot;)public static class ProductionDataSourceTest&#123;    @Autowired    private DataSource dataSource;    @Test    public void shouldBeEmbeddedDatasource()    &#123;        // should be null, because there isn&#39;t a datasource configured in JNDI        assertNull(dataSource);    &#125;&#125;</code></pre><h2 id="3-2-条件化的-bean"><a href="#3-2-条件化的-bean" class="headerlink" title="3.2 条件化的 bean"></a>3.2 条件化的 bean</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>配置类 bean 方法增加 conditional 注解</li></ol><pre><code class="java">@Configurationpublic class MagicConfig&#123;  @Bean  @Conditional(MagicExistsCondition.class)  public MagicBean magicBean()  &#123;    return new MagicBean();  &#125;&#125;</code></pre><ol start="2"><li>编写 conditional 类</li></ol><pre><code class="java">public class MagicExistsCondition implements Condition&#123;  @Override  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)  &#123;    Environment env = context.getEnvironment();    return env.containsProperty(&quot;magic&quot;);  &#125;&#125;</code></pre><ol start="3"><li>测试</li></ol><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=MagicConfig.class)public class MagicExistsTest&#123;  @Autowired  private ApplicationContext context;  @BeforeClass  public static void settingProperty()  &#123;    // 设置环境变量    System.setProperty(&quot;magic&quot;,&quot;magic property&quot;);  &#125;  @Test  public void shouldNotBeNull()   &#123;    assertTrue(context.containsBean(&quot;magicBean&quot;));  &#125;&#125;</code></pre><h3 id="理解原理"><a href="#理解原理" class="headerlink" title="理解原理"></a>理解原理</h3><p>MagicExistsCondition 中只是使用了 ConditionContext 得到的 Environment，但 Condition 实现的考量因素可能会比这更多。matches() 方法会得到 ConditionContext 和 AnnotatedTypeMetadata 对象用来做出决策。</p><pre><code class="java">public interface ConditionContext &#123;    // 返回 BeanDefinitionRegistry 检查 bean 定义；    BeanDefinitionRegistry getRegistry();    // 返回 ConfigurableListableBeanFactory 检查 bean 是否存在，甚至探查 bean 的属性；    ConfigurableListableBeanFactory getBeanFactory();    // 返回 Environment 检查环境变量是否存在以及它的值是什么；    Environment getEnvironment();    // 返回 ResourceLoader 所加载的资源；    ResourceLoader getResourceLoader();    // 返回 ClassLoader 加载并检查类是否存在。    ClassLoader getClassLoader();&#125;</code></pre><pre><code class="java">public interface AnnotatedTypeMetadata&#123;    // 够判断带有 @Bean 注解的方法是不是还有其他特定的注解    boolean isAnnotated(String annotationType);    // 检查 @Bean 注解的方法上其他注解的属性    Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType);    Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType, boolean classValuesAsString);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType, boolean classValuesAsString);&#125;</code></pre><h3 id="Spring-自身项目中的实际应用"><a href="#Spring-自身项目中的实际应用" class="headerlink" title="Spring 自身项目中的实际应用"></a>Spring 自身项目中的实际应用</h3><p>从 Spring 4 开始，@Profile 注解进行了重构，使其基于 @Conditional 和 Condition 实现。作为如何使用 @Conditional 和 Condition 的例子，我们来看一下在 Spring 4 中，@Profile 是如何实现的。</p><ol><li>profile 注解的定义</li></ol><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123;    String[] value();&#125;</code></pre><ol start="2"><li>ProfileCondition 定义</li></ol><pre><code class="java">class ProfileCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)    &#123;        if (context.getEnvironment() != null)         &#123;            MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());            if (attrs != null)             &#123;                for (Object value : attrs.get(&quot;value&quot;))                 &#123;                    if (context.getEnvironment().acceptsProfiles(((String[]) value)))                     &#123;                        return true;                    &#125;                &#125;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><p>可以看到，ProfileCondition 通过 AnnotatedTypeMetadata 得到了用于 @Profile 注解的所有属性。借助该信息，它会明确地检查 value 属性，该属性包含了 bean 的 profile 名称。然后，它根据通 ConditionContext 得到的 Environment 来检查［借助 acceptsProfiles() 方法］该 profile 是否处于激活状态。</p><h2 id="3-3-处理自动装配的歧义性"><a href="#3-3-处理自动装配的歧义性" class="headerlink" title="3.3 处理自动装配的歧义性"></a>3.3 处理自动装配的歧义性</h2><p>在自动装配中，仅有一个 bean 匹配所需的结果时，自动装配才是有效的。如果有多个匹配的 bean，则会报错：NoUniqueBeanDefinitionException。Spring 提供了两种方案来解决此问题：</p><ul><li>将可选 bean 中的某一个设为首选（primary）的 bean</li><li>使用限定符（qualifier）来帮助 Spring 将可选的 bean 的范围缩小到只有一个 bean</li></ul><pre><code class="java">public interface Dessert&#123;    void eat();&#125;@Componentpublic class Cake implements Dessert&#123;    public void eat()    &#123;        System.out.println(&quot;I am eating cakes.&quot;);    &#125;&#125;@Componentpublic class Cookies implements Dessert&#123;    public void eat()    &#123;        System.out.println(&quot;I am eating Cookies.&quot;);    &#125;&#125;@Componentpublic class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;// 配置组件扫描注入@Configuration@ComponentScanpublic class MonkeyKongConfig&#123;&#125;@Componentpublic class MonkeyKong&#123;    private Dessert dessert;    // 如果不采取措施，此处 Spring 无法确认具体注入哪个甜点    @Autowired    public void setDessert(Dessert dessert)    &#123;        this.dessert = dessert;    &#125;    public void eat()    &#123;        dessert.eat();    &#125;&#125;</code></pre><h3 id="标示首选的-bean"><a href="#标示首选的-bean" class="headerlink" title="标示首选的 bean"></a>标示首选的 bean</h3><pre><code class="java">@Component@Primarypublic class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;</code></pre><p>使用 @Primary 标示首选的 bean 后，下面测试就可以通过了</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=MonkeyKongConfig.class)public class MonkeyKongTest&#123;    @Rule    public final StandardOutputStreamLog log = new StandardOutputStreamLog();    @Autowired    MonkeyKong monkeyKong;    @Test    public void play()    &#123;        monkeyKong.eat();        assertEquals(&quot;I am eating IceCream.&quot;, log.getLog());    &#125;&#125;</code></pre><p>另外两种注入方式配置首选 bean</p><pre><code class="java">@Bean@Primarypublic Dessert iceCream()&#123;    return new IceCream();&#125;</code></pre><pre><code class="xml">&lt;bean id=&quot;iceCream&quot; class=&quot;Icecream&quot; primary=&quot;true&quot;/&gt;</code></pre><h3 id="限定自动装配的-bean"><a href="#限定自动装配的-bean" class="headerlink" title="限定自动装配的 bean"></a>限定自动装配的 bean</h3><ol><li>限定符的基本使用</li></ol><p>当首选 bean 标示超过一个时，Spring 还是无法确认到底该自动装配哪个 bean。所以需要限定。</p><pre><code class="java">@Component@Primary@Qualifier(&quot;cold&quot;) // 定义 bean 时指定限定名称public class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;@Autowired@Qualifier(&quot;cold&quot;) // 根据限定符cold自动注入，所以即使有多个 primary bean 也没有影响public void setDessert(Dessert dessert)&#123;    this.dessert = dessert;&#125;</code></pre><p>自定义的限定符（cold）一般为 bean 的类型，此处可以理解为凉的甜点。但是，如果多个 bean 都具备相同特性的话，这种做法也会出现问题，比如，现在又来了一个【冰棍】甜点。</p><pre><code class="java">@Component@Primary@Qualifier(&quot;cold&quot;)public class Popsicle implements Dessert&#123;    @Override    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;</code></pre><p>如此一来，Spring 再次遇到了歧义性的问题。需要使用更多的限定符来将可选范围限定到只有一个 bean。</p><ol start="2"><li>创建自定义限定符注解</li></ol><pre><code class="java">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,        ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Cold &#123;&#125;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,        ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Creamy &#123;&#125;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,        ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Fruity &#123;&#125;</code></pre><p>自己定义了三个限定符注解，这样就可以将 IceCream 和 Popsicle 区分开来了。</p><pre><code class="java">@Component@Primary@Qualifier(&quot;cold&quot;)@Cold@Creamypublic class IceCream implements Dessert&#123;    public void eat()    &#123;        System.out.print(&quot;I am eating IceCream.&quot;);    &#125;&#125;@Autowired@Qualifier(&quot;cold&quot;)@Cold@Creamypublic void setDessert(Dessert dessert)&#123;    this.dessert = dessert;&#125;</code></pre><p>通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有 Java 编译器的限制或错误。与此同时，相对于使用原始的 @Qualifier 并借助 String 类型来指定限定符，自定义的注解也更为类型安全。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>为了创建自定义的条件化注解，我们创建一个新的注解并在这个注解上添加了@Conditional。</p><p>为了创建自定义的限定符注解，我们创建一个新的注解并在这个注解上添加了@Qualifier。</p><p>这种技术可以用到很多的 Spring 注解中，从而能够将它们组合在一起形成特定目标的自定义注解。</p><h2 id="3-4-bean-的作用域"><a href="#3-4-bean-的作用域" class="headerlink" title="3.4 bean 的作用域"></a>3.4 bean 的作用域</h2><p>在<strong>默认</strong>情况下，Spring 应用上下文中所有 bean 都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个 bean 被注入到其他 bean 多少次，每次所注入的都是同一个实例。</p><p>有时候，可能会发现，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将 class 声明为单例的 bean 就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。</p><p>Spring 的作用域：</p><ul><li>单例（Singleton）：在整个应用中，只创建 bean 的一个实例。</li><li>原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（Session）：在 Web 应用中，为每个会话创建一个 bean 实例。</li><li>请求（Rquest）：在 Web 应用中，为每个请求创建一个 bean 实例。</li></ul><h3 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h3><ol><li>设置作用域的方式</li></ol><pre><code class="java">// 组件自动注入@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad &#123;&#125;// bean 注解显示注入@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad()&#123;    return new Notepad();&#125;// xml 显示注入&lt;bean class=&quot;com.myapp.Notepad&quot; scope=&quot;prototype&quot; /&gt;</code></pre><ol start="2"><li>使用会话和请求作用域</li></ol><pre><code class="java">@Component// Session 级别，每个会话创建一个ShoppingCart@Scope(value = WebApplicationContext.SCOPE_SESSION,    proxyMode = ScopedProxyMode.TARGET_CLASS)public class ShoppingCart &#123;&#125;// StoreService@Autowiredpublic void setShoppingCart(ShoppingCart shoppingCart)&#123;    this.shoppingCart = shoppingCart;&#125;</code></pre><p>proxyMode 的理解：</p><p>StoreService 是单例的，会在 Spring 应用上下文加载的时候创建，当它创建的时候，Spring 会试图将 ShoppingCart bean 注入到 setShoppingCart() 方法中。但是 ShoppingCart bean 是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现 ShoppingCart 实例。</p><p>所以，Spring 并不会将实际的 ShoppingCart bean 注入到 StoreService 中，Spring 会注入一个到 ShoppingCart bean 的代理。这个代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。但是，当 StoreService 调用 ShoppingCart 的方法时，代理会对其进行<strong>懒解析并将调用委托给会话作用域内</strong>真正的 ShoppingCart bean。</p><p>proxyMode 属性被设置成了 ScopedProxyMode.INTERFACES，这表明这个代理要实现 ShoppingCart 接口，并将调用委托给实现 bean。</p><h3 id="在-XML-中声明作用域代理"><a href="#在-XML-中声明作用域代理" class="headerlink" title="在 XML 中声明作用域代理"></a>在 XML 中声明作用域代理</h3><pre><code class="xml">&lt;bean id=&quot;cart&quot; class=&quot;com.myapp.ShoppingCart&quot; scope=&quot;session&quot; &gt;    &lt;aop:scoped-proxy proxy-target-class=&quot;true&quot;/&gt;&lt;/bean&gt;</code></pre><h2 id="3-5-运行时注入"><a href="#3-5-运行时注入" class="headerlink" title="3.5 运行时注入"></a>3.5 运行时注入</h2><p>还记得第二章我们注入 CD 的 title 和 artist 时，我们都是在 java 或者 xml 中硬编码实现。</p><pre><code class="xml">&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;&lt;/bean&gt;</code></pre><p>但有的时候，我们可能会希望避免硬编码值，而是想让这些值在运行时再确定。为了实现这些功能，Spring 提供了两种在运行时求值的方式：</p><h3 id="使用属性占位符实现"><a href="#使用属性占位符实现" class="headerlink" title="使用属性占位符实现"></a>使用属性占位符实现</h3><p>属性源：</p><pre><code class="properties">disc.title=Sgt. Peppers Lonely Hearts Club Banddisc.artist=The Beatles</code></pre><p>注入属性：</p><pre><code class="java">@Configuration// 声明属性源@PropertySource(&quot;classpath:/com/soundsystem/app.properties&quot;)public class EnvironmentConfig&#123;  @Autowired  Environment env;  @Bean  public BlankDisc blankDisc()  &#123;    // 检索属性值进行注入    return new BlankDisc(        env.getProperty(&quot;disc.title&quot;),        env.getProperty(&quot;disc.artist&quot;));  &#125;&#125;</code></pre><p>验证：</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=EnvironmentConfig.class)public static class InjectFromProperties &#123;    @Autowired    private BlankDisc blankDisc;    @Test    public void assertBlankDiscProperties()     &#123;        assertEquals(&quot;The Beatles&quot;, blankDisc.getArtist());        assertEquals(&quot;Sgt. Peppers Lonely Hearts Club Band&quot;, blankDisc.getTitle());    &#125;&#125;</code></pre><p>深入学习 Spring 的 Environment:</p><pre><code class="java">public interface Environment extends PropertyResolver &#123;    String[] getActiveProfiles();    String[] getDefaultProfiles();    // 如果 environment 支持给定 profile 的话，就返回 true。    boolean acceptsProfiles(String... profiles);&#125;</code></pre><pre><code class="java">public interface PropertyResolver &#123;    boolean containsProperty(String key);    String getProperty(String key);    // 给默认值    String getProperty(String key, String defaultValue);    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);    &lt;T&gt; Class&lt;T&gt; getPropertyAsClass(String key, Class&lt;T&gt; targetType);    // 属性必须定义    String getRequiredProperty(String key) throws IllegalStateException;    &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;    String resolvePlaceholders(String text);    String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;&#125;</code></pre><ol><li>XML 属性占位符实现</li></ol><pre><code class="xml">&lt;!-- 引入属性源 --&gt;&lt;context:property-placeholder location=&quot;com/soundsystem/app.properties&quot; /&gt;&lt;!-- 使用占位符注入属性 --&gt;&lt;bean class=&quot;com.soundsystem.BlankDisc&quot;      c:_0 = &quot;$&#123;disc.title&#125;&quot;      c:_1 = &quot;$&#123;disc.artist&#125;&quot;/&gt;</code></pre><ol start="2"><li>Java 属性占位符实现</li></ol><pre><code class="java">// 修改构造器public BlankDisc(@Value(&quot;$&#123;disc.title&#125;&quot;) String title,                 @Value(&quot;$&#123;disc.artist&#125;&quot;) String artist) &#123;    this.title = title;    this.artist = artist;&#125;// 为了在 java 中使用占位符，需要配置 PropertySourcesPlaceholderConfigurer@Beanpublic static PropertySourcesPlaceholderConfigurer placeholderConfigurer()&#123;    return new PropertySourcesPlaceholderConfigurer();&#125;</code></pre><p>怎么调用？</p><h3 id="使用-SPEL-实现"><a href="#使用-SPEL-实现" class="headerlink" title="使用 SPEL 实现"></a>使用 SPEL 实现</h3><p>SpEL拥有很多特性：</p><ul><li>使用bean的ID来引用bean；</li><li>调用方法和访问对象的属性；</li><li>对值进行算术、关系和逻辑运算；</li><li>正则表达式匹配；</li><li>集合操作。</li></ul><p>SpEL 样例：</p><pre><code class="java">#&#123;1&#125;#&#123;T&#123;System&#125;.currentTimeMillis()&#125;// 计算得到ID 为sgtPeppers的bean的artist属性#&#123;sgtPeppers.artist&#125;#&#123;systemProperties[&#39;disc.title&#39;]&#125;</code></pre><p>SpEL所支持的基础表达式:</p><ol><li>字面量</li></ol><p><code>#&#123;1&#125;、#&#123;&#39;hello&#39;&#125;、#&#123;false&#125;</code></p><ol start="2"><li>引用 bean、属性和方法</li></ol><p><code>#&#123;sgtPeppers&#125;、#&#123;sgtPeppers.artist&#125;、#&#123;sgtPeppers.getArtist()?.toUpperCase()&#125;</code></p><ol start="3"><li>访问类</li></ol><pre><code>#&#123;T&#123;System&#125;.currentTimeMillis()&#125;#&#123;T&#123;java.lang.Math&#125;.PI&#125;</code></pre><p>SpEL 运算符：</p><table><thead><tr><th>运算符类型</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+、-、 * 、/、%、^</td></tr><tr><td>比较运算符</td><td>&lt; 、 &gt; 、 == 、 &lt;= 、 &gt;= 、 lt 、 gt 、 eq 、 le 、 ge</td></tr><tr><td>逻辑运算符</td><td>and 、 or 、 not 、│</td></tr><tr><td>条件运算符</td><td>?: (ternary) 、 ?: (Elvis)</td></tr><tr><td>正则表达式</td><td>matches</td></tr></tbody></table><pre><code class="java">// 类型和算术运算#&#123;2 * T&#123;java.lang.Math&#125;.PI * circle.radius&#125;#&#123;T&#123;java.lang.Math&#125;.PI * circle.radius^2&#125;#&#123;disc.title + &#39; by &#39; + disc.artist&#125;// 比较运算#&#123;counter.total == 100&#125;// 条件运算#&#123;scoreboard.score &gt; 1000 ? &quot;Winner&quot; : &quot;Loser&quot;&#125;#&#123;disc.tatle ?: &#39;Default title&#39;&#125;// 正则运算#&#123;admin.email matches &#39;[a-zA-Z0-9._%...]+\\.com&#39;&#125;  // 集合运算#&#123;jukebox.songs[4].title&#125;#&#123;jukebox.songs.?[artist eq &#39;Aerosmith&#39;]&#125;#&#123;jukebox.songs.^[artist eq &#39;Aerosmith&#39;]&#125;#&#123;jukebox.songs.$[artist eq &#39;Aerosmith&#39;]&#125;#&#123;jukebox.songs.?[artist eq &#39;Aerosmith&#39;].![title]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;3-1-环境与-profile&quot;&gt;&lt;a href=&quot;#3-1-环境与-profile&quot; class=&quot;headerlink&quot; title=&quot;3.1 环境与 profile&quot;&gt;&lt;/a&gt;3.1 环境与 profile&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令备忘</title>
    <link href="http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/Linux%E5%A4%87%E5%BF%98.html"/>
    <id>http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/Linux%E5%A4%87%E5%BF%98.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2021-02-09T12:53:38.329Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h3><pre><code class="shell"># 查看 Linux 系统内核cat /proc/versionuname -a# 查看 Linux 系统版本# 适用于所有的Linux发行版，包括Redhat、SuSE、Debian…等发行版lsb_release -a# 只适合Redhat系的Linuxcat /etc/redhat-release# 适用于所有的Linux发行版cat /etc/issue</code></pre><h3 id="切换-yum-源为阿里云-yum-镜像"><a href="#切换-yum-源为阿里云-yum-镜像" class="headerlink" title="切换 yum 源为阿里云 yum 镜像"></a>切换 yum 源为阿里云 yum 镜像</h3><p>解决“Error: Cannot find a valid baseurl for repo: base”的办法，<strong>切换 yum 源为阿里云 yum 镜像</strong></p><pre><code class="shell">sed -i &quot;s|enabled=1|enabled=0|g&quot; /etc/yum/pluginconf.d/fastestmirror.confmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupcurl -o /etc/yum.repos.d/CentOS-Base.repo https://www.xmpan.com/Centos-6-Vault-Aliyun.repoyum clean allyum makecache</code></pre><h3 id="切换系统语言"><a href="#切换系统语言" class="headerlink" title="切换系统语言"></a>切换系统语言</h3><pre><code class="shell"># 查看系统当前的语言localeecho $LANG# 切换语言为英文vim /etc/sysconfig/i18nLANG=&quot;en_US.UTF-8&quot;</code></pre><h3 id="修改主机名称"><a href="#修改主机名称" class="headerlink" title="修改主机名称"></a>修改主机名称</h3><pre><code class="shell"># 查看主机名hostname# 临时修改主机名hostname node01# 命令形式修改hostnamectl set-hostname node01# 添加主机名 node01vi /etc/hostname# 添加 ip 和 hostname 对应关系192.168.47.11 node01</code></pre><h3 id="升级-gcc-版本"><a href="#升级-gcc-版本" class="headerlink" title="升级 gcc 版本"></a>升级 gcc 版本</h3><p>安装 redis6 时需要升级 gcc，否则报错：<code>server.c:5166:39: error: ‘struct redisServer’ has no member named ‘maxmemory’</code></p><pre><code class="shell">yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilsscl enable devtoolset-9 bash#注意：scl命令启用只是临时的，推出xshell或者重启就会恢复到原来的gcc版本。#如果要长期生效的话，执行如下：echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile</code></pre><h3 id="防火墙相关"><a href="#防火墙相关" class="headerlink" title="防火墙相关"></a>防火墙相关</h3><h4 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h4><pre><code class="shell"># 开启、重启、关闭 firewalld.service 服务service firewalld startservice firewalld restartservice firewalld stop# 查看防火墙规则firewall-cmd --list-all# 查询、开放、关闭端口firewall-cmd --query-port=80/tcpfirewall-cmd --permanent --add-port=80/tcpfirewall-cmd --permanent --remove-port=80/tcp# 重启防火墙（修改配置后需要重启）firewall-cmd --reload# firewall-cmd 是 Linux 提供的操作 firewall 的一个工具</code></pre><h3 id="vim-相关"><a href="#vim-相关" class="headerlink" title="vim 相关"></a>vim 相关</h3><h4 id="复制粘贴剪切"><a href="#复制粘贴剪切" class="headerlink" title="复制粘贴剪切"></a>复制粘贴剪切</h4><ul><li>yy：复制光标所在行</li><li>p：粘贴</li><li>3yy：复制光标所在行和后边的两行</li><li>yw：复制一个单词</li><li>v：选择文本进行复制</li><li>V：按照行为单位进行选择</li><li>d：删除、剪切</li></ul><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul><li>u：撤销</li><li>Ctrl + r：回复撤销</li></ul><h4 id="块编辑复制粘贴"><a href="#块编辑复制粘贴" class="headerlink" title="块编辑复制粘贴"></a>块编辑复制粘贴</h4><ul><li>v：进入块编辑模式，选择指定内容，y 复制、p 粘贴</li><li>V：按行进行选择</li></ul><h4 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h4><ul><li>删除：ctrl + v 进入块编辑模式，选中要删除的后， d 删除</li><li>插入：ctrl + v，按住 shift + i 输入插入的内容，esc 后，选中的列就都增加了</li></ul><h2 id="网卡相关"><a href="#网卡相关" class="headerlink" title="网卡相关"></a>网卡相关</h2><h2 id="service-network-restart-失败"><a href="#service-network-restart-失败" class="headerlink" title="service network restart 失败"></a>service network restart 失败</h2><p>failed because the control process exited with error code 错误</p><pre><code class="shell">systemctl stop NetworkManagersystemctl disable NetworkManager</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;查看系统版本&quot;&gt;&lt;a href=&quot;#查看系统版本&quot; class=&quot;headerlink&quot; title=&quot;查看系统版本&quot;&gt;&lt;/a&gt;查看系统版本&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 查看 Linux 系统</summary>
      
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 frp 实现远程连接和内网穿透</title>
    <link href="http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html"/>
    <id>http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2020-12-27T15:04:15.586Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何使用 <a href="https://github.com/fatedier/frp">frp</a> 内网穿透来实现访问内网服务和远程连接内网机器。首先 frp <strong>需要一台公网机器</strong>，没有的话就散了吧，乖乖的用向日葵等工具吧。</p><a id="more"></a><h2 id="1、访问内网服务"><a href="#1、访问内网服务" class="headerlink" title="1、访问内网服务"></a>1、访问内网服务</h2><p>场景说明：我本地启动了一个服务，但是我本机是没有外网地址的，这样我只能自己本地访问自己的服务，比如<code>http://127.0.0.1:8080</code>，别人是无法访问到的。</p><h3 id="1-1-启动服务端（公网机器）"><a href="#1-1-启动服务端（公网机器）" class="headerlink" title="1.1 启动服务端（公网机器）"></a>1.1 启动服务端（公网机器）</h3><ol><li><p>修改 frps.ini，设置 http 访问端口为 8080</p><pre><code class="json"># frps.ini[common]# frp 应用程序端口bind_port = 7000# 公网 http 监听端口。这里注意理解是公网的端口在监听vhost_http_port = 8088</code></pre></li><li><p>启动 frps</p><p><code>./frps -c ./frps.ini</code></p><p>后台运行：<code>nohup ./frps -c ./frps.ini &amp;</code></p><p><img src="../../images/%E5%85%B6%E4%BB%96/frp/frp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png"></p></li></ol><h3 id="1-2-启动客户端（本地服务所在机器）"><a href="#1-2-启动客户端（本地服务所在机器）" class="headerlink" title="1.2 启动客户端（本地服务所在机器）"></a>1.2 启动客户端（本地服务所在机器）</h3><ol><li><p>修改 frpc.ini</p><pre><code class="json"># frpc.ini[common]# 配置服务端对外的ip地址，就是公网机器IPserver_addr = **.**.**.**# 配置服务端监听的端口server_port = 7000[web]type = http# 本地服务端口local_port = 8080# 公网服务器的IP或者已解析的域名custom_domains = **.**.**.**</code></pre></li><li><p>启动 frpc</p><p><code>frpc.exe -c frpc.ini</code></p><p><img src="../../images/%E5%85%B6%E4%BB%96/frp/frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png"></p></li><li><p>访问测试 <code>http://**.**.**.**:8088</code></p></li></ol><h2 id="2、远程连接内网机器"><a href="#2、远程连接内网机器" class="headerlink" title="2、远程连接内网机器"></a>2、远程连接内网机器</h2><p>比如我在家想远程连接公司的电脑。</p><h3 id="2-1-启动服务端（公网机器）"><a href="#2-1-启动服务端（公网机器）" class="headerlink" title="2.1 启动服务端（公网机器）"></a>2.1 启动服务端（公网机器）</h3><p>和 1.1 一样，无需其他配置。</p><h3 id="2-2-启动客户端（公司电脑）"><a href="#2-2-启动客户端（公司电脑）" class="headerlink" title="2.2 启动客户端（公司电脑）"></a>2.2 启动客户端（公司电脑）</h3><ol><li><p>修改 frpc.ini</p><pre><code class="json"># frpc.ini[common]# 配置服务端对外的ip地址，就是公网机器IPserver_addr = **.**.**.**# 配置服务端监听的端口server_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 3389# 公网机器开一个 6000 端口的服务，代理到本地的 3389remote_port = 6000</code></pre></li><li><p>启动 frpc</p><p><code>frpc.exe -c frpc.ini</code></p></li><li><p>远程连接测试</p><p>在里电脑直接远程连接公司电脑</p><p><img src="../../images/%E5%85%B6%E4%BB%96/frp/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8.png"></p><p>这里要注意远程连接的用户名是<strong>域\用户名</strong>，比如公司的域是 skywares.com，我公司电脑的用户名是 alvin.li，那么远程连接的用户名是<code>skywares.com\alvin.li</code>。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍如何使用 &lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;frp&lt;/a&gt; 内网穿透来实现访问内网服务和远程连接内网机器。首先 frp &lt;strong&gt;需要一台公网机器&lt;/strong&gt;，没有的话就散了吧，乖乖的用向日葵等工具吧。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="frp" scheme="http://yoursite.com/tags/frp/"/>
    
    <category term="内网穿透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="远程连接" scheme="http://yoursite.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>第 2 章 装配 Bean</title>
    <link href="http://yoursite.com/2020-12-22-13Spring%E5%9F%BA%E7%A1%80/20191022sia2.html"/>
    <id>http://yoursite.com/2020-12-22-13Spring%E5%9F%BA%E7%A1%80/20191022sia2.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2021-01-02T08:01:36.425Z</updated>
    
    <content type="html"><![CDATA[<ul><li>自动装配：<ul><li>@Component、@Autowired：定义组件和自动装配</li><li>@Configuration、@ComponentScan：启用组件扫描</li></ul></li><li>Java 方式显示装配：<ul><li>@Configuration、@Bean</li></ul></li><li>Xml 方式显示装配：    <ul><li>构造器注入：&lt;bean、&lt;constructor-arg</li><li>C命名空间注入：c:_0=、c:_0-ref</li><li>属性注入：&lt;property</li><li>P命名空间注入：p:title、p:compactDisc-ref</li><li>Util命名空间工具：&lt;util:list</li></ul></li><li>组合显示装配：<ul><li>Java 配置为主：@Import(、@ImportResource(</li><li>Xml 配置为主：<code>&lt;import resource=&quot;cd-config.xml&quot;/&gt;</code>、<code>&lt;bean class=&quot;soundsystem.CDPlayerConfig&quot; /&gt;</code></li></ul></li></ul><a id="more"></a><h2 id="1、自动化装配-bean"><a href="#1、自动化装配-bean" class="headerlink" title="1、自动化装配 bean"></a>1、自动化装配 bean</h2><ul><li>组件扫描（component scanning）：Spring 自动发现应用上下文中创建的 bean</li><li>自动装配（autowiring）：Spring 自动满足 bean 之间的依赖</li></ul><p>如果你不将 CD 插入（注入）到 CD 播放器中，那么 CD 播放器其实是没有太大用处的。所以，可以这样说，CD 播放器依赖于 CD 才能完成它的使命。</p><h3 id="1-1-组件扫描"><a href="#1-1-组件扫描" class="headerlink" title="1.1 组件扫描"></a>1.1 组件扫描</h3><p><code>@Component</code>：表明该类会作为组件类，并告知 Spring 要为这个类创建 bean。</p><pre><code class="java">@Componentpublic class SgtPeppers implements CompactDisc&#123;  private String title = &quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;;  private String artist = &quot;The Beatles&quot;;  public void play()  &#123;    System.out.print(&quot;Playing &quot; + title + &quot; by &quot; + artist);  &#125;&#125;</code></pre><p><code>@ComponentScan</code>：组件扫描<strong>默认是不启用</strong>，使用注解启用组件扫描，<strong>默认扫描该配置类所在的包。</strong></p><pre><code class="java">@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125;</code></pre><p>在 XML 中启用组件扫描：<code>&lt;context:component-scan base-package=&quot;soundsystem&quot; /&gt;</code></p><pre><code class="xml">&lt;context:component-scan base-package=&quot;soundsystem&quot; /&gt;</code></pre><p>测试：</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest&#123;  @Autowired  private CompactDisc cd;  @Test  public void cdShouldNotBeNull()  &#123;    assertNotNull(cd);  &#125;&#125;</code></pre><p>测试通过，cd 不为 null，所以 cd 已经被注入到 spring 容器。</p><p>为组件扫描的 bean 命名：<code>@Component(&quot;lonelyHeartsClub&quot;)</code></p><p>设置组件扫描的包：</p><ul><li><code>@ComponentScan(basePackages = &#123;&quot;soundsystem&quot;,&quot;aaa&quot;&#125;)</code></li><li><code>@ComponentScan(basePackageClasses = &#123;SgtPeppers.class, CDPlayer.class&#125;)</code>：扫描设置的类所在的包</li></ul><h3 id="1-2-通过为-bean-添加注解实现自动装配"><a href="#1-2-通过为-bean-添加注解实现自动装配" class="headerlink" title="1.2 通过为 bean 添加注解实现自动装配"></a>1.2 通过为 bean 添加注解实现自动装配</h3><p><strong>自动装配</strong>就是让 Spring 自动满足 bean 依赖的一种方法，在满足依赖的过程中，会在 Spring 应用上下文中寻找匹配某个 bean 需求的其他 bean。为了声明要进行自动装配，我们可以借助 Spring 的 <strong>@Autowired</strong> 注解。</p><pre><code class="java">@Componentpublic class CDPlayer implements MediaPlayer&#123;  private CompactDisc cd;  @Autowired  public CDPlayer(CompactDisc cd)  &#123;    this.cd = cd;  &#125;  public void play()  &#123;    cd.play();  &#125;&#125;</code></pre><p>Spring 创建 CDPlayer bean 的时候，会通过这个构造器来进行实例化并且会传入一个可设置给 CompactDisc 类型的 bean。</p><p>@Autowired 注解可以用在类的任何方法上。</p><p>不管是构造器、Setter方法还是其他的方法，Spring 都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean 匹配依赖需求的话，那么这个 bean 将会被装配进来。</p><p>如果没有匹配的 bean，那么在应用上下文创建的时候，Spring 会抛出一个异常。<code>@Autowired(required = false)</code>可以避免该异常。</p><p>如果有多个 bean 都能满足依赖关系的话，Spring 将会抛出一个异常，表明没有明确指定要选择哪个 bean 进行自动装配。</p><h3 id="1-3-验证自动装配"><a href="#1-3-验证自动装配" class="headerlink" title="1.3 验证自动装配"></a>1.3 验证自动装配</h3><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=CDPlayerConfig.class)public class CDPlayerTest&#123;  @Rule  public final StandardOutputStreamLog log = new StandardOutputStreamLog();  @Autowired  private MediaPlayer player;  @Autowired  private CompactDisc cd;  @Test  public void cdShouldNotBeNull()  &#123;    assertNotNull(cd);  &#125;  @Test  public void play()  &#123;    player.play();    assertEquals(&quot;Playing Sgt. Pepper&#39;s Lonely Hearts Club Band by The Beatles&quot;, log.getLog());  &#125;&#125;</code></pre><p>player.play() 方法最终实际调用的的式 cd 的 play() 方法，说明 cd 成功的自动装配到了 cdplay 中。</p><h2 id="2、通过-Java-代码显示装配"><a href="#2、通过-Java-代码显示装配" class="headerlink" title="2、通过 Java 代码显示装配"></a>2、通过 Java 代码显示装配</h2><p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置 Spring。比如说，你想要<strong>将第三方库中的组件</strong>装配到你的应用中，在这种情况下，是没有办法在它的类上添加 @Component 和 @Autowired 注解的，因此就不能使用自动化装配的方案了。</p><h3 id="2-1-创建配置类"><a href="#2-1-创建配置类" class="headerlink" title="2.1 创建配置类"></a>2.1 创建配置类</h3><p>@Configuration：表明这个类是一个配置类，该类应该包含在 Spring 应用上下文中如何创建bean的细节。</p><pre><code class="java">@Configurationpublic class CDPlayerConfig&#123;  @Bean  public CompactDisc compactDisc()  &#123;    return new SgtPeppers();  &#125;  @Bean  public CDPlayer cdPlayer(CompactDisc compactDisc)  &#123;    return new CDPlayer(compactDisc);  &#125;&#125;</code></pre><p>带有 @Bean 注解的方法可以采用任何必要的 Java 功能来产生 bean 实例。</p><h2 id="3、通过-XML-显示装配"><a href="#3、通过-XML-显示装配" class="headerlink" title="3、通过 XML 显示装配"></a>3、通过 XML 显示装配</h2><h3 id="3-1-创建-XML-规范"><a href="#3-1-创建-XML-规范" class="headerlink" title="3.1 创建 XML 规范"></a>3.1 创建 XML 规范</h3><p>快速生成 XML 配置文件：<strong>idea-&gt;new-&gt;file-&gt;config xml file-&gt;spring config file</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h3 id="3-2-声明一个简单的-lt-bean-gt"><a href="#3-2-声明一个简单的-lt-bean-gt" class="headerlink" title="3.2 声明一个简单的&lt;bean&gt;"></a>3.2 声明一个简单的<code>&lt;bean&gt;</code></h3><pre><code class="xml">&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;/&gt;</code></pre><p>XML 配置的缺点：</p><ul><li>bean的类型以字符串的形式设置在了 class 属性中，不能保证设置给 class 属性的值是真正的类</li><li>重命名了类后，xml 也需要修改</li></ul><h3 id="3-3-借助构造器注入初始化-bean"><a href="#3-3-借助构造器注入初始化-bean" class="headerlink" title="3.3 借助构造器注入初始化 bean"></a>3.3 借助构造器注入初始化 bean</h3><ol><li>使用 constructor-arg 注入</li></ol><pre><code class="xml">&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt;    &lt;constructor-arg ref=&quot;compactDisc&quot; /&gt;&lt;/bean&gt;&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;&lt;/bean&gt;&lt;!-- 注入集合 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.collections.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;        &lt;/list&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><ol start="2"><li>使用 c 命名空间注入</li></ol><pre><code class="xml">&lt;!-- 需要引入：xmlns:c=&quot;http://www.springframework.org/schema/c&quot; --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot; /&gt;&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_0=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;       c:_1=&quot;The Beatles&quot; /&gt;&lt;!-- 注入集合,c 命名空间不支持集合的注入 --&gt;</code></pre><p>上面 c:cd-ref 中的 cd 是构造器的名称，这样写有些不友好。可以使用参数索引来替代：</p><pre><code class="xml">&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_0-ref=&quot;compactDisc&quot; /&gt;&lt;!-- 只有一个参数时，索引也可以省略 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_-ref=&quot;compactDisc&quot; /&gt;</code></pre><h3 id="3-4-设置属性"><a href="#3-4-设置属性" class="headerlink" title="3.4 设置属性"></a>3.4 设置属性</h3><p><code>&lt;property&gt;</code>元素为属性的 Setter 方法所提供的功能与 <code>&lt;constructor-arg&gt;</code> 元素为构造器<br>所提供的功能是一样的。</p><ol><li>使用 property 注入</li></ol><pre><code class="xml">&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.properties.CDPlayer&quot;&gt;    &lt;property name=&quot;compactDisc&quot; ref=&quot;compactDisc&quot; /&gt;&lt;/bean&gt;&lt;!-- 注入字面量和集合 --&gt;&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.properties.BlankDisc&quot;&gt;    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ol start="2"><li>使用 p 命名空间注入</li></ol><pre><code class="xml">&lt;!-- 需要引入：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; --&gt;&lt;!-- 注入引用类型 --&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.properties.CDPlayer&quot; p:compactDisc-ref=&quot;compactDisc&quot; /&gt;&lt;!-- 注入字面量 --&gt;&lt;bean id=&quot;compactDisc&quot;      class=&quot;soundsystem.properties.BlankDisc&quot;      p:title=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;      p:artist=&quot;The Beatles&quot;&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;            &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;            &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!-- 注入集合,p 命名空间不支持集合的注入 --&gt;&lt;!-- 但是，我们可以使用 Spring util-命名空间中的一些功能来简化 BlankDiscbean。 --&gt;&lt;bean id=&quot;compactDisc&quot;      class=&quot;soundsystem.properties.BlankDisc&quot;      p:title=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;      p:artist=&quot;The Beatles&quot;      p:tracks-ref=&quot;trackList&quot; /&gt;&lt;util:list id=&quot;trackList&quot;&gt;      &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;    &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;    &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;&lt;/util:list&gt;</code></pre><p><a href="util:list">util:list</a>只是util-命名空间中的多个元素之一。</p><table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody><tr><td>util:constant</td><td>引用某个类型的 public static 域，并将其暴露为bean</td></tr><tr><td>util:list</td><td>创建一个java.util.List类型的bean，其中包含值或引用</td></tr><tr><td>util:map</td><td>创建一个java.util.Map类型的bean，其中包含值或引用</td></tr><tr><td>util:properties</td><td>创建一个java.util.Properties类型的bean</td></tr><tr><td>util:property-path</td><td>引用一个bean的属性（或内嵌属性），并将其暴露为bean</td></tr><tr><td>util:set</td><td>创建一个java.util.Set类型的bean，其中包含值或引用</td></tr></tbody></table><h2 id="4、导入和混合配置"><a href="#4、导入和混合配置" class="headerlink" title="4、导入和混合配置"></a>4、导入和混合配置</h2><p>在典型的 Spring 应用中，我们可能会同时使用自动化和显式配置。这些配置方案都不是互斥的。</p><h3 id="4-1-在-JavaConfig-中引用-XML-配置"><a href="#4-1-在-JavaConfig-中引用-XML-配置" class="headerlink" title="4.1 在 JavaConfig 中引用 XML 配置"></a>4.1 在 JavaConfig 中引用 XML 配置</h3><pre><code class="java">@Configuration@Import(CDPlayerConfig.class) // 引入配置类@ImportResource(&quot;classpath:cd-config.xml&quot;) // 引入配置文件public class SoundSystemConfig&#123;&#125;</code></pre><h3 id="4-2-在-XML-配置中引用-JavaConfig"><a href="#4-2-在-XML-配置中引用-JavaConfig" class="headerlink" title="4.2 在 XML 配置中引用 JavaConfig"></a>4.2 在 XML 配置中引用 JavaConfig</h3><pre><code class="xml">&lt;!-- 引入配置类,注入CDPlayer --&gt;&lt;bean class=&quot;soundsystem.CDPlayerConfig&quot; /&gt;&lt;!-- 引入xml,注入CD --&gt;&lt;import resource=&quot;cd-config.xml&quot;/&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;自动装配：&lt;ul&gt;
&lt;li&gt;@Component、@Autowired：定义组件和自动装配&lt;/li&gt;
&lt;li&gt;@Configuration、@ComponentScan：启用组件扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 方式显示装配：&lt;ul&gt;
&lt;li&gt;@Configuration、@Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Xml 方式显示装配：    &lt;ul&gt;
&lt;li&gt;构造器注入：&amp;lt;bean、&amp;lt;constructor-arg&lt;/li&gt;
&lt;li&gt;C命名空间注入：c:_0=、c:_0-ref&lt;/li&gt;
&lt;li&gt;属性注入：&amp;lt;property&lt;/li&gt;
&lt;li&gt;P命名空间注入：p:title、p:compactDisc-ref&lt;/li&gt;
&lt;li&gt;Util命名空间工具：&amp;lt;util:list&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组合显示装配：&lt;ul&gt;
&lt;li&gt;Java 配置为主：@Import(、@ImportResource(&lt;/li&gt;
&lt;li&gt;Xml 配置为主：&lt;code&gt;&amp;lt;import resource=&amp;quot;cd-config.xml&amp;quot;/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;bean class=&amp;quot;soundsystem.CDPlayerConfig&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客集成 hexo-tag-aplayer</title>
    <link href="http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E5%8D%9A%E5%AE%A2-%E9%9F%B3%E4%B9%90%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90.html"/>
    <id>http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E5%8D%9A%E5%AE%A2-%E9%9F%B3%E4%B9%90%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2021-01-26T15:52:49.798Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 博客通过 <a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a> 插件集成 APlayer 音乐播放器。</p><a id="more"></a><h2 id="1、安装与使用"><a href="#1、安装与使用" class="headerlink" title="1、安装与使用"></a>1、安装与使用</h2><h3 id="1-1-安装-hexo-tag-aplayer"><a href="#1-1-安装-hexo-tag-aplayer" class="headerlink" title="1.1 安装 hexo-tag-aplayer"></a>1.1 安装 hexo-tag-aplayer</h3><p>在博客根目录（<code>package.json</code>文件所在目录）下安装 hexo-tag-aplayer 插件。</p><pre><code class="shell">npm install --save hexo-tag-aplayer</code></pre><h3 id="1-2-使用-hexo-tag-aplayer"><a href="#1-2-使用-hexo-tag-aplayer" class="headerlink" title="1.2 使用 hexo-tag-aplayer"></a>1.2 使用 hexo-tag-aplayer</h3><p><strong>a) 开启 MetingJS</strong><br>在博客根目录（注意是博客的配置文件，不是主题的配置文件）增加如下配置。</p><pre><code class="yml">aplayer:  meting: true</code></pre><p><strong>b) 在博客用插入音乐</strong><br>插入歌单，例如想插入 <a href="https://music.163.com/#/playlist?id=2008272804">https://music.163.com/#/playlist?id=2008272804</a> 这个歌单。在 markdown 文件需要插入的位置加入如下内容即可：</p><pre><code>&#123;% meting "2008272804" "netease" "playlist" "theme:#FF4081" "mode:circulation" "mutex:true" "listmaxheight:340px" "preload:auto" %&#125;</code></pre>    <div id="aplayer-IycSbyzb" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2008272804" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><p>插入单曲，例如想插入 <a href="https://y.qq.com/n/yqq/song/002AFMXr2h7cVY.html">https://y.qq.com/n/yqq/song/002AFMXr2h7cVY.html</a> 这首单曲。在 markdown 文件需要插入的位置加入如下内容即可：</p><pre><code>&#123;% meting "002AFMXr2h7cVY" "tencent" "song" "theme:#555" "mutex:true" "listmaxheight:340px" "preload:auto" %&#125;</code></pre>    <div id="aplayer-WBKtSNZa" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="002AFMXr2h7cVY" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><p>更多详细参数及说明请查阅 <a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer 中文文档</a></p><h2 id="2、踩坑"><a href="#2、踩坑" class="headerlink" title="2、踩坑"></a>2、踩坑</h2><p>以上配置完成，正常来说，博客部署后，进入对应页面，应该是可以加载出音乐插件的。当然也有不正常的情况，比如我弄完后就加载不出来，必须要刷新一下才能加载出来。找了下原因，可能是由于 pjax 导致的。参照 <a href="https://yxyvpn.com/2020/04/15/pjax%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96aplayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/">pjax导致无法初始化aplayer音乐播放器</a> 这篇博客，解决了问题。</p><h3 id="2-1-解决方法"><a href="#2-1-解决方法" class="headerlink" title="2.1 解决方法"></a>2.1 解决方法</h3><p><strong>1、手动引入 <a href="https://aplayer.js.org/#/zh-Hans/?id=%E5%85%A5%E9%97%A8">APlayer</a>、<a href="https://github.com/metowolf/MetingJS">MetingJS</a></strong><br>我使用的主题是 <a href="https://github.com/yelog/hexo-theme-3-hexo">3-hexo</a>，3-hexo 主题中 <code>meta.ejs</code> 是公共 header 引入位置，所以在这里引入相关文件即可。</p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css&quot;/&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/meting@1.2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;</code></pre><p><strong>2、加载 MetingJS</strong><br>在主题中找到 pjax 生命周期相关函数，在<code>paja:success</code>函数中加载 Meting。3-hexo 主题是在 <code>script.js</code> 文件，其他主题需要大致看下源码找到相应位置。</p><pre><code class="js">&#39;pjax:success&#39;: function () &#123;    loadMeting();&#125;</code></pre><p><strong>3、关闭自定加载 MetingJS</strong><br>在博客配置文件中加上如下配置关闭。不过我本地不加也没什么异常。</p><pre><code class="yml">aplayer:  meting: true  asset_inject: false</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo 博客通过 &lt;a href=&quot;https://github.com/MoePlayer/hexo-tag-aplayer&quot;&gt;hexo-tag-aplayer&lt;/a&gt; 插件集成 APlayer 音乐播放器。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>第 1 章 构建 Spring 之旅</title>
    <link href="http://yoursite.com/2020-12-21-13Spring%E5%9F%BA%E7%A1%80/20191019sia1.html"/>
    <id>http://yoursite.com/2020-12-21-13Spring%E5%9F%BA%E7%A1%80/20191019sia1.html</id>
    <published>2020-12-21T14:13:12.000Z</published>
    <updated>2021-01-02T05:39:23.217Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 最根本的使命：简化 Java 开发</p><p>为了降低 Java 开发的复杂性，Spring 采取以下4种策略：</p><ul><li>基于 POJO 的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯例进行声明式编程</li><li>通过切面和模板减少样板式代码</li></ul><a id="more"></a><h2 id="1、简化-Spring-开发"><a href="#1、简化-Spring-开发" class="headerlink" title="1、简化 Spring 开发"></a>1、简化 Spring 开发</h2><h3 id="1-1-基于-POJO-的最小侵入性编程"><a href="#1-1-基于-POJO-的最小侵入性编程" class="headerlink" title="1.1 基于 POJO 的最小侵入性编程"></a>1.1 基于 POJO 的最小侵入性编程</h3><p>很多框架通过强迫应用继承他们的类或者实现他们的接口从而导致应用和框架绑死。</p><p>Spring 竭力避免因自身的 API 而弄乱你的应用代码。Spring 不会强迫你实现 Spring 框架的接口或者继承他的类，相反，在基于 Spring 构建的应用中，他的类通常没有任何痕迹表面你使用了 Spring。</p><h3 id="1-2-依赖注入"><a href="#1-2-依赖注入" class="headerlink" title="1. 2 依赖注入"></a>1. 2 依赖注入</h3><p>DI 功能是如何实现的？</p><p>任何一个有实际意义的项目，都会由两个或者更多的类组成，这些类互相之间进行协作来完成特定的业务逻辑。按照传统的做法，每个对象负责管理与自己项目协作的对象(即它所依赖的对象)的引用，这将会导致高度耦合和难以测试的代码。</p><p>例如：</p><pre><code class="java">/** * 拯救少女的骑士 * DamselRescuingKnight 与 RescueDamselQuest 紧耦合，导致 DamselRescuingKnight 骑士只能执行拯救少女的任务。 */public class DamselRescuingKnight implements Knight&#123;  // 拯救少女任务  private RescueDamselQuest quest;  public DamselRescuingKnight()  &#123;    // 在构造函数自行创建了探险任务，因此极大的限制了骑士的能力。如果一个少女需要救援，这个骑士能    // 够召之即来。但是如果一条恶龙需要杀掉，或者一个圆桌需要滚起来，那么这个    // 骑士就爱莫能助了。    this.quest = new RescueDamselQuest();  &#125;  public void embarkOnQuest()  &#123;    quest.embark();  &#125;&#125;</code></pre><p>上边定义的这个骑士，因为和特定的任务紧耦合了，所以该骑士只能执行一种类型的探险任务。</p><pre><code class="java">/** * 勇敢的骑士 * 这个骑士可以接受任务赋予他的探险任务 */public class BraveKnight implements Knight &#123;  // 骑士的探索任务  private Quest quest;  public BraveKnight(Quest quest) &#123;    this.quest = quest;  &#125;  public void embarkOnQuest() &#123;    quest.embark();  &#125;&#125;</code></pre><p>BraveKnight 可以执行任何探险任务。关键点在于 BraveKnight 没有自行创建探险任务，而是在构造的时候把探险任务作为构造器参数传入。这是<strong>依赖注入</strong>的方式之一，即<strong>构造器注入</strong>（constructor injection）。</p><p>BraveKnight 没有与任何特定的 Quest 实现发生耦合。这就是 DI 所带来的最大收益(<strong>松耦合</strong>)。如果一个对象只通过接口（而不是具体实现或初始化过程）来表明依赖关系，那么这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现进行替换。</p><h4 id="1-2-1-通过-xml-注入-bean"><a href="#1-2-1-通过-xml-注入-bean" class="headerlink" title="1.2.1 通过 xml 注入 bean"></a>1.2.1 通过 xml 注入 bean</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;  &lt;!-- 勇敢的骑士注入 spring 容器，并将杀龙探险任务交给这个骑士 --&gt;  &lt;bean id=&quot;knight&quot; class=&quot;sia.knights.BraveKnight&quot;&gt;    &lt;constructor-arg ref=&quot;quest&quot; /&gt;  &lt;/bean&gt;  &lt;!-- 杀龙探险任务注入 Spring 容器，并将 System.out 交给该任务 --&gt;  &lt;bean id=&quot;quest&quot; class=&quot;sia.knights.SlayDragonQuest&quot;&gt;    &lt;constructor-arg value=&quot;#&#123;T(System).out&#125;&quot; /&gt;  &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="1-2-2-通过配置类注入-bean"><a href="#1-2-2-通过配置类注入-bean" class="headerlink" title="1.2.2 通过配置类注入 bean"></a>1.2.2 通过配置类注入 bean</h4><pre><code class="java">/** * 该功能和 knight.xml 功能相同 */@Configurationpublic class KnightConfig&#123;  @Bean  public Knight knight()  &#123;    return new BraveKnight(quest());  &#125;  @Bean  public Quest quest()  &#123;    return new SlayDragonQuest(System.out);  &#125;&#125;</code></pre><p>Spring通过应用上下文（Application Context）装载 bean 的定义并把它们组装起来。Spring 应用上下文全权负责对象的创建和组装。Spring 自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p><p>从应用上下文获取 bean</p><pre><code class="java">public class KnightMain&#123;  public static void main(String[] args) throws Exception  &#123;    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(            &quot;META-INF/spring/knight.xml&quot;);    Knight knight = context.getBean(Knight.class);    knight.embarkOnQuest();    context.close();  &#125;&#125;</code></pre><p>注意这个类完全不知道我们的英雄骑士接受哪种探险任务，而且完全没有意识到这是由BraveKnight来执行的。只有knights.xml文件知道哪个骑士执行哪种探险任务。</p><h3 id="1-3-应用切面"><a href="#1-3-应用切面" class="headerlink" title="1.3 应用切面"></a>1.3 应用切面</h3><h4 id="1-3-1-应用切面的好处"><a href="#1-3-1-应用切面的好处" class="headerlink" title="1.3.1 应用切面的好处"></a>1.3.1 应用切面的好处</h4><p>DI 能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-oriented-programming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</p><p>诸如<strong>日志、事务管理和安全</strong>这样的系统服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。</p><p>如果将这些关注点分散到多个组件，代码将会有两个问题</p><ol><li>实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。<strong>即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中</strong>。</li><li>组件会因为那些与自身核心业务无关的代码而变得混乱。<strong>一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。</strong></li></ol><p>AOP 能够使这些关注点模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所以业务组件会具有更高的内聚性，只需要关注自身业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。</p><h4 id="1-3-2-应用切面的简单例子"><a href="#1-3-2-应用切面的简单例子" class="headerlink" title="1.3.2 应用切面的简单例子"></a>1.3.2 应用切面的简单例子</h4><p>还是上面骑士的例子，假设我们需要使用吟游诗人这个服务类来记载骑士的所有事迹。</p><p>诗人类：</p><pre><code class="java">/** * 吟游诗人 */public class Minstrel&#123;  private PrintStream stream;  public Minstrel(PrintStream stream)  &#123;    this.stream = stream;  &#125;  public void singBeforeQuest()  &#123;    stream.println(&quot;Fa la la, the knight is so brave!&quot;);  &#125;  public void singAfterQuest()  &#123;    stream.println(&quot;Tee hee hee, the brave knight did embark on a quest!&quot;);  &#125;&#125;</code></pre><p>配置切面：</p><pre><code class="xml">&lt;!-- 配置切面 --&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;minstrel&quot;&gt;        &lt;aop:pointcut id=&quot;embark&quot;                      expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;embark&quot;                     method=&quot;singBeforeQuest&quot;/&gt;        &lt;aop:after pointcut-ref=&quot;embark&quot;                    method=&quot;singAfterQuest&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>当然，我们可以把诗人注入到骑士中，骑士执行完任务后，掉用骑士的方法。但是，管理他的吟游诗人并不是骑士职责范围。在我看来，吟游诗人应该做他份内的事，根本不需要骑士命令他这么做。</p><p>所以，利用 AOP，你可以声明吟游诗人必须歌颂骑士的探险事迹，而骑士本身并不用直接访问 Minstrel 的方法。</p><h3 id="1-4-使用模板消除样板式代码"><a href="#1-4-使用模板消除样板式代码" class="headerlink" title="1.4 使用模板消除样板式代码"></a>1.4 使用模板消除样板式代码</h3><p>在使用 Spring 之前，有时总会写一些版式代码。例如 JDBC，首先你需要创建一个数据库连接，然后再创建一个语句对象，最后你才能进行查询。为了平息 JDBC 可能会出现的怒火，你必须捕捉 SQLException，这是一个检查型异常，即使它抛出后你也做不了太多事情。</p><h2 id="2、Spring-容器"><a href="#2、Spring-容器" class="headerlink" title="2、Spring 容器"></a>2、Spring 容器</h2><ul><li>bean 工厂：由 org.springframework. beans. factory.beanFactory 接口定义</li><li>应用上下文：由 org.springframework.context.ApplicationContext 接口定义</li></ul><h3 id="2-1-应用上下文"><a href="#2-1-应用上下文" class="headerlink" title="2.1 应用上下文"></a>2.1 应用上下文</h3><ul><li>AnnotationConfigApplicationContext</li></ul><pre><code class="java">ApplicationContext ac = new AnnotationConfigApplicationContext(sia.knights.config.KnightConfig.class);</code></pre><ul><li>AnnotationConfigWebApplicationContext</li><li>ClassPathXmlApplicationContext</li></ul><pre><code class="java">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;kinght.xml&quot;);</code></pre><ul><li>FileSystemXmlapplicationcontext</li></ul><pre><code class="java">ApplicationContext ac = new FileSystemXmlapplicationcontext(&quot;c:/knight.xml&quot;);</code></pre><ul><li>XmlWebApplicationContext</li></ul><h3 id="2-2-bean-的生命周期"><a href="#2-2-bean-的生命周期" class="headerlink" title="2.2 bean 的生命周期"></a>2.2 bean 的生命周期</h3><ol><li>Spring 对 bean 进行实例化</li><li>Spring 将值和 bean 的引用注入到 bean 对应的属性中</li><li>如果bean实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给 setBeanName()方法；</li><li>如果bean实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入；</li><li>如果 bean 实现了 ApplicationContextAware 接口，Spring 将调用setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization() 方法；</li><li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 afterPropertiesSet() 方法。类似地，如果 bean 使用 init-method 声明了初始化方法，该方法也会被调用；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessAfterInitialization() 方法；</li><li>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，<br>直到该应用上下文被销毁；</li><li>如果 bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy() 接口方法。同<br>样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用。</li></ol><h2 id="3、Spring-模块"><a href="#3、Spring-模块" class="headerlink" title="3、Spring 模块"></a>3、Spring 模块</h2><ol><li><p>Spring 核心容器</p><p>Beans、Core、Context、Expression、Contextsupport</p></li><li><p>Spring AOP</p><p>AOP、Aspects</p></li><li><p>数据访问与集成</p><p>JDBC、Transaction、ORM、OXM、Messaging、JMS</p></li><li><p>Web 与远程调用</p><p>web、Web servlet、Web portlet、WebSocket</p></li><li><p>Instrumentation</p><p>Instrument、Instrument Tomcat</p></li><li><p>test</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring 最根本的使命：简化 Java 开发&lt;/p&gt;
&lt;p&gt;为了降低 Java 开发的复杂性，Spring 采取以下4种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 POJO 的轻量级和最小侵入性编程&lt;/li&gt;
&lt;li&gt;通过依赖注入和面向接口实现松耦合&lt;/li&gt;
&lt;li&gt;基于切面和惯例进行声明式编程&lt;/li&gt;
&lt;li&gt;通过切面和模板减少样板式代码&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Spring基础" scheme="http://yoursite.com/categories/Spring%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sia" scheme="http://yoursite.com/tags/sia/"/>
    
  </entry>
  
  <entry>
    <title>第 21 章 函数式编程</title>
    <link href="http://yoursite.com/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"/>
    <id>http://yoursite.com/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</id>
    <published>2020-12-21T14:13:12.000Z</published>
    <updated>2020-12-21T16:01:19.293Z</updated>
    
    <content type="html"><![CDATA[<p>Java 讲义进阶之函数式编程。</p><a id="more"></a><h2 id="第一章-函数式编程和-lambda-表达式"><a href="#第一章-函数式编程和-lambda-表达式" class="headerlink" title="第一章 函数式编程和 lambda 表达式"></a>第一章 函数式编程和 lambda 表达式</h2><h3 id="lambda表达式初识"><a href="#lambda表达式初识" class="headerlink" title="lambda表达式初识"></a>lambda表达式初识</h3><pre><code class="java">public class ThreadDemo &#123;    public static void main(String[] args) &#123;        Runnable target = new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;OK&quot;);            &#125;        &#125;;        new Thread(target).start();        // jdk8 lambda        Runnable target1 = () -&gt; System.out.println(&quot;OK&quot;);        // lambda必须返回指定接口实例；并且接口中只有一个需要实现的方法        // Object target2 = () -&gt; System.out.println(&quot;OK&quot;);        new Thread(target1).start();    &#125;&#125;</code></pre><h3 id="lambda表达式常用写法"><a href="#lambda表达式常用写法" class="headerlink" title="lambda表达式常用写法"></a>lambda表达式常用写法</h3><pre><code class="java">public class LambdaDemo2 &#123;    public static void main(String[] args) &#123;        // 其实就是 doubleNum 方法的实现        Interface1 i1 = (i) -&gt; i*2;        System.out.println(i1.add(3,7));        System.out.println(i1.doubleNum(20));        // 这种是最常见写法        Interface1 i2 = i -&gt; i*2;        Interface1 i3 = (int i) -&gt; i*2;        Interface1 i4 = (int i) -&gt; &#123;            System.out.println(&quot;-------&quot;);            return i*2;        &#125;;    &#125;&#125;</code></pre><h3 id="函数接口默认方法"><a href="#函数接口默认方法" class="headerlink" title="函数接口默认方法"></a>函数接口默认方法</h3><pre><code class="java">// 函数接口，只有一个方法，就是一个接口只做一件事情的意思。告诉用户不要再加其他接口方法了@FunctionalInterfaceinterface Interface1&#123;    int doubleNum(int i);    // 默认方法。函数接口是指只有一个需要实现的方法，而不是接口中只有一个方法。    // 很重要的特性。1.8以前，接口中不敢随意增加方法，因为加了方法后，对该接口的所有实现都有影响。    default int add(int x, int y)&#123;        // x = this.doubleNum(x);        return x + y;    &#125;&#125;@FunctionalInterfaceinterface Interface2&#123;    int doubleNum(int i);    default int add(int x, int y)&#123;        return x + y;    &#125;&#125;@FunctionalInterfaceinterface Interface3 extends Interface2, Interface1&#123;    // 函数接口使用默认方法需要注意的地方，当多个接口有相同的默认方法时，需要指定使用哪个    @Override    default int add(int x, int y) &#123;        return Interface1.super.add(x,y);    &#125;&#125;</code></pre><h3 id="函数接口好处"><a href="#函数接口好处" class="headerlink" title="函数接口好处"></a>函数接口好处</h3><ul><li>可以省略接口</li><li>可以进行链式操作</li></ul><pre><code class="java">import java.text.DecimalFormat;import java.util.function.Function;interface IMoneyFormat&#123;    String format(int i);&#125;class MyMoney&#123;    private final int money;    public MyMoney(int money)&#123;        this.money = money;    &#125;    public void printMoney(IMoneyFormat moneyFormat)&#123;        System.out.println(&quot;我的存款：&quot;+moneyFormat.format(this.money));    &#125;    public void printMoney1(Function&lt;Integer, String&gt; moneyFormat)&#123;        System.out.println(&quot;我的存款：&quot;+moneyFormat.apply(this.money));    &#125;&#125;public class MoneyDemo &#123;    public static void main(String[] args) &#123;        MyMoney me = new MyMoney(999999999);        // 接口函数只有一个参数，括号可以省略        me.printMoney(i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i));        // 可以看出，lambda只需要知道接口函数的输入是什么，输出是什么即可。        // 函数接口好处1：所以可以不需要接口，使用jdk自带的function即可，Function 本身就是一个函数式接口        me.printMoney1(i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i));        // 函数接口好处2：链式操作        Function&lt;Integer, String&gt; moneyFormat = i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i);        me.printMoney1(moneyFormat.andThen(s -&gt; &quot;人民币&quot; + s));    &#125;&#125;</code></pre><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><table><thead><tr><th>接口</th><th>输入参数</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td>Predicate<T></td><td>T</td><td>boolean</td><td>断言</td></tr><tr><td>Consumer<T></td><td>T</td><td>/</td><td>消费一个数据</td></tr><tr><td>Function&lt;T,R&gt;</td><td>T</td><td>R</td><td>输入T输出R的函数</td></tr><tr><td>Supplier<T></td><td>/</td><td>T</td><td>提供一个数据</td></tr><tr><td>UnaryOperator<T></td><td>T</td><td>T</td><td>一元函数（输入输出类型相同）</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>(T,U)</td><td>R</td><td>2个输入的函数</td></tr><tr><td>BinaryOperator<T></td><td>(T,T)</td><td>T</td><td>二元函数（输入输出类型相同）</td></tr></tbody></table><pre><code class="java">public class FunctionDemo &#123;    public static void main(String[] args) &#123;        // 断言函数接口        Predicate&lt;Integer&gt; predicate = i -&gt; i&gt;0;        System.out.println(predicate.test(-9));        // 消费函数接口        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);        consumer.accept(&quot;输入的数据&quot;);        // 对于参数是基本类型的，java自带了一些带类型的函数，优先使用        IntPredicate predicate1 = i -&gt; i&gt;0;        // DoubleConsumer    &#125;&#125;</code></pre><h3 id="lambda表达式方法引用"><a href="#lambda表达式方法引用" class="headerlink" title="lambda表达式方法引用"></a>lambda表达式方法引用</h3><pre><code class="java">import java.util.ArrayList;import java.util.List;import java.util.function.*;class Dog&#123;    private String name = &quot;哮天犬&quot;;    private int food = 10;    public Dog()&#123;&#125;    public Dog(String name)&#123;        this.name = name;    &#125;    public static void bark(Dog dog)&#123;        System.out.println(dog.name + &quot;叫了&quot;);    &#125;    /**     * 吃狗粮     * JDK默认会把当前实例传入到非静态方法，参数名称为this，位置是第一个     */    public int eat(Dog this, int num)&#123;        System.out.println(&quot;吃了&quot; + num + &quot;斤狗粮&quot;);        this.food -= num;        return this.food;    &#125;    public String getName()    &#123;        return this.name;    &#125;&#125;public class MethodReferenceDemo &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.eat(3);        Consumer&lt;String&gt; consumerOrg1 = i -&gt; System.out.println(i);        // 方法引用（当输入输出参数相同，可以改写为方法引用）        Consumer&lt;String&gt; consumer1 = System.out::println;        consumer1.accept(&quot;接收的数据&quot;);        // 静态方法的方法引用        Consumer&lt;Dog&gt; consumerOrg2 = i -&gt; Dog.bark(i);        Consumer&lt;Dog&gt; consumer2 = Dog::bark;        consumer2.accept(dog);        // 非静态方法，使用对象实例的方法引用        // Function&lt;Integer, Integer&gt; function = dog::eat;        // 输入输出一样，可以变为一元函数形式        // UnaryOperator&lt;Integer&gt; function = dog::eat;        IntUnaryOperator unaryOrg = i -&gt; dog.eat(i);        IntUnaryOperator unary = dog::eat;        System.out.println(&quot;还剩下：&quot; + unary.applyAsInt(2) + &quot;斤&quot;);        // 使用类名来引用非静态方法        BiFunction&lt;Dog, Integer, Integer&gt; eatFunctionOrg = (T,U) -&gt; T.eat(U);        BiFunction&lt;Dog, Integer, Integer&gt; eatFunction = Dog::eat;        System.out.println(&quot;还剩下&quot; + eatFunction.apply(dog,2)+&quot;斤&quot;);        // 无参构造函数的方法引用        Supplier&lt;Dog&gt; supplierOrg = () -&gt; new Dog();        Supplier&lt;Dog&gt; supplier = Dog::new;        System.out.println(&quot;创建了新对象：&quot; + supplier.get().getName());        // 有参构造函数的方法引用        Function&lt;String, Dog&gt; function2Org = T -&gt; new Dog(T);        Function&lt;String, Dog&gt; function2 = Dog::new;        System.out.println(&quot;创建了新对象：&quot; + function2.apply(&quot;旺财&quot;).getName());        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 传值引用，lambda也是一样的原理。        // 存疑。        MethodReferenceDemo demo = new MethodReferenceDemo();        demo.test(list);        System.out.println(list.size());    &#125;    private void test(List&lt;String&gt; list)&#123;        list = null;    &#125;&#125;</code></pre><h3 id="lambda表达式类型推断"><a href="#lambda表达式类型推断" class="headerlink" title="lambda表达式类型推断"></a>lambda表达式类型推断</h3><pre><code class="java">interface IMath&#123;    int add(int x, int y);&#125;public class TypeDemo &#123;    public static void main(String[] args) &#123;        // 变量类型定义        IMath lambda = (x,y) -&gt; x + y;        // 数组里        IMath[] lambdas = &#123;(x,y) -&gt; x + y&#125;;        // 强转        Object lambda2 = (IMath)(x,y) -&gt; x + y;        // 通过返回类型        IMath createLambda = createLambda();        TypeDemo demo = new TypeDemo();        // 当有二义性时，使用强转对应的接口解决        demo.test((x,y) -&gt; x + y);    &#125;    public void test(IMath math)&#123;    &#125;    public static IMath createLambda()&#123;        return (x,y) -&gt; x+y;    &#125;&#125;</code></pre><h3 id="lambda表达式变量引用"><a href="#lambda表达式变量引用" class="headerlink" title="lambda表达式变量引用"></a>lambda表达式变量引用</h3><pre><code class="java">public class VarDemo &#123;    public static void main(String[] args) &#123;        final String str = &quot;我们的时间&quot;;        // lambda表达式实际上相当于匿名内部类，匿名内部类引用变量时必须是final的。（java参数是传值）        Consumer&lt;String&gt; consumer = s-&gt; System.out.println(s + str);        consumer.accept(&quot;1211&quot;);    &#125;&#125;</code></pre><h3 id="级联表达式和柯里化"><a href="#级联表达式和柯里化" class="headerlink" title="级联表达式和柯里化"></a>级联表达式和柯里化</h3><pre><code class="java">/** * 级联表达式和柯里化 * 柯里化的目的：函数标准化 * 高阶函数：返回函数的函数 */public class CurryDemo &#123;    public static void main(String[] args) &#123;        // 实现了x+y的级联表达式        Function&lt;Integer, Function&lt;Integer,Integer&gt;&gt; fun = x-&gt;y-&gt;x+y;        System.out.println(fun.apply(2).apply(3));        Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; fun2 = x-&gt;y-&gt;z-&gt;x+y+z;        System.out.println(fun2.apply(2).apply(3).apply(4));        // int[] nums = &#123;2,3,4,5,6,7&#125;;        int[] nums = &#123;2,3,4&#125;;        Function f = fun2;        for (int i=0; i&lt;nums.length; i++)&#123;            if(f instanceof Function)&#123;                Object obj = f.apply(nums[i]);                if(obj instanceof Function)&#123;                    f = (Function)obj;                &#125;else&#123;                    System.out.println(&quot;调用结束：结果为&quot; + obj);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="第三章-Stream流编程"><a href="#第三章-Stream流编程" class="headerlink" title="第三章 Stream流编程"></a>第三章 Stream流编程</h2><h3 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a>外部迭代和内部迭代</h3><ul><li>外部迭代：自己编写迭代细节</li><li>内部迭代：告诉需求</li></ul><h3 id="中间操作和终止操作"><a href="#中间操作和终止操作" class="headerlink" title="中间操作和终止操作"></a>中间操作和终止操作</h3><ul><li>中间操作：返回结果还是流</li><li>终止操作：返回的是一个结果</li></ul><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>在终止操作没有调用的情况下，中间操作不会执行</p><pre><code class="java">public class StreamDemo1 &#123;    public static void main(String[] args) &#123;        int[] nums = &#123;1,2,3&#125;;        // 外部迭代        int sum = 0;        for (int i:nums)&#123;            sum += i;        &#125;        System.out.println(&quot;结果为：&quot; + sum);        // 使用stream的内部迭代        // map就是中间操作（返回流的操作）        // sum就是终止操作        int sum2 = IntStream.of(nums).map(StreamDemo1::doubleNum).sum();        System.out.println(&quot;结果为：&quot; + sum2);        System.out.println(&quot;惰性求值就是在终止操作没有调用的情况下，中间操作不会执行&quot;);        IntStream.of(nums).map(StreamDemo1::doubleNum);    &#125;    public static int doubleNum(int i)&#123;        System.out.println(&quot;执行了乘以2&quot;);        return i*2;    &#125;&#125;</code></pre><h3 id="Stream流编程-创建"><a href="#Stream流编程-创建" class="headerlink" title="Stream流编程 - 创建"></a>Stream流编程 - 创建</h3><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>集合</td><td>Collection.stream/parallelStream</td></tr><tr><td>数组</td><td>Arrays.stream</td></tr><tr><td>数字Stream</td><td>IntStream/LongStream.range/rangeClosed String.chars()  Random.ints/longs/doubles</td></tr><tr><td>自己创建</td><td>Stream.generate/iterate</td></tr></tbody></table><pre><code class="java">public class StreamDemo2 &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 从集合创建        list.stream();        list.parallelStream();        // 从数组创建        Arrays.stream(new int[]&#123;2,3,4&#125;);        // 创建数字流        IntStream.of(1,2,3);        IntStream.rangeClosed(1,10);        // 使用random创建一个无限流        new Random().ints().limit(10);        // 自己产生流        Stream.generate(()-&gt; new Random().nextInt()).limit(20);    &#125;&#125;</code></pre><h3 id="Stream流编程-中间操作"><a href="#Stream流编程-中间操作" class="headerlink" title="Stream流编程 - 中间操作"></a>Stream流编程 - 中间操作</h3><p>无状态：当前操作和其他元素没有关系</p><p>有状态：当前操作和其他元素有依赖关系</p><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>无状态操作</td><td>map/mapToXxx （A对象转为B对象）</td></tr><tr><td></td><td>flatMap/flatMapToXxx （A对象下面有B属性，B是集合；得到所有A属下B属性的集合）</td></tr><tr><td></td><td>filter</td></tr><tr><td></td><td>peek （类似each，但是是中间操作）</td></tr><tr><td></td><td>unordered</td></tr><tr><td>有状态操作</td><td>distinct</td></tr><tr><td></td><td>sorted</td></tr><tr><td></td><td>limit/skip</td></tr></tbody></table><pre><code class="java">public class StreamDemo3 &#123;    public static void main(String[] args) &#123;        String str = &quot;my name is 007&quot;;        // 把每个单词的长度打印出来        Stream.of(str.split(&quot; &quot;)).filter(s -&gt; s.length()&gt;2).map(s -&gt; s.length())                // 调用终止操作，否则代码不会执行                .forEach(System.out::println);        // flatMap A-&gt;B属性（是个集合），最终得到所有的A元素里面的所有B属性集合        // intStream/longStream并不是Stream的子类，所以要装箱 boxed        Stream.of(str.split(&quot; &quot;)).flatMap(s-&gt; s.chars().boxed())                .forEach(i -&gt; System.out.println((char)i.intValue()));        // peek是个中间操作，和forEach类似，forEach是终止操作        System.out.println(&quot;------peek----------&quot;);        Stream.of(str.split(&quot; &quot;)).peek(System.out::println).forEach(System.out::println);        // limit,主要终于无限流        new Random().ints().filter(i-&gt; i&gt;100&amp;&amp;i&lt;1000).limit(10)                .forEach(System.out::println);    &#125;&#125;</code></pre><h3 id="Stream流编程-终止操作"><a href="#Stream流编程-终止操作" class="headerlink" title="Stream流编程 - 终止操作"></a>Stream流编程 - 终止操作</h3><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>非短路操作</td><td>forEach/forEachOrdered</td></tr><tr><td></td><td>collect/toArray</td></tr><tr><td></td><td>reduce</td></tr><tr><td></td><td>min/max/count</td></tr><tr><td>短路操作</td><td>findFirst/findAny</td></tr><tr><td></td><td>allMatch/anyMatch/noneMatch</td></tr></tbody></table><pre><code class="java">public class StreamDemo4 &#123;    public static void main(String[] args) &#123;        String str = &quot;my name is 007&quot;;        // 使用并行流        str.chars().parallel().forEach(i -&gt; System.out.println((char)i));        // 使用forEachOrdered包装顺序        str.chars().parallel().forEachOrdered(i -&gt; System.out.println((char)i));        // 收集到list        List&lt;String&gt; list = Stream.of(str.split(&quot; &quot;)).collect(Collectors.toList());        System.out.println(list);        // 使用reduce拼接字符串        Optional&lt;String&gt; letters = Stream.of(str.split(&quot; &quot;)).reduce((s1, s2)-&gt;s1+&quot;|&quot;+s2);        System.out.println(letters.orElse(&quot;&quot;));        // 带初始值的reduce        String reduce = Stream.of(str.split(&quot; &quot;)).reduce(&quot;&quot;, (s1,s2)-&gt;s1+&quot;|&quot;+s2);        System.out.println(reduce);        // 计算所有单词总长度        Integer length = Stream.of(str.split(&quot; &quot;)).map(s -&gt; s.length())                .reduce(0, (s1,s2)-&gt;s1 + s2);        System.out.println(length);        // max        Optional&lt;String&gt; max = Stream.of(str.split(&quot; &quot;))                .max((s1,s2)-&gt; s1.length() - s2.length());        System.out.println(max.get());        // 使用 findFirst 短路操作        OptionalInt i = new Random().ints().findFirst();        System.out.println(i.getAsInt());    &#125;&#125;</code></pre><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><pre><code class="java">public class StreamDemo5 &#123;    public static void main(String[] args) &#123;        // IntStream.range(1,100).parallel().peek(StreamDemo5::debug).count();        // 现在要实现先并行再串行        // 结论：多次调用parallel/sequential，以最后一次调用为准//        IntStream.range(1,100)//                .parallel().peek(StreamDemo5::debug)//                .sequential().peek(StreamDemo5::debug2)//                .count();        // 并行流使用的线程池：ForkJoinPool.commonPool        // 默认的线程数是当前机器cpu个数        // 使用这个属性修改默认线程数//        System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;5&quot;);//        IntStream.range(1,100).parallel().peek(StreamDemo5::debug).limit(6).count();        // 使用自己的线程池，不使用默认的线程池，防止被其他任务阻塞        ForkJoinPool pool = new ForkJoinPool(20);        pool.submit(()-&gt; IntStream.range(1,100).parallel()            .peek(StreamDemo5::debug).count());        pool.shutdown();        // 让主线程不退出        synchronized (pool)&#123;            try &#123;                pool.wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void debug(int i)&#123;        System.out.println(Thread.currentThread().getName() + &quot;debug &quot; + i);        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void debug2(int i)&#123;        System.err.println(&quot;debug2 &quot; + i);        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><pre><code class="java">        // 得到所有学生的年龄列表        // 尽量使用方法引用（不会多生成一个lambda$0函数），不要使用 s -&gt; s.getAge()。        List&lt;Integer&gt; ages = students.stream().map(Student::getAge)                .collect(Collectors.toList());        Set&lt;Integer&gt; ages1 = students.stream().map(Student::getAge)                .collect(Collectors.toCollection(TreeSet::new));        System.out.println(&quot;所有学生的年龄：&quot; + ages);        System.out.println(&quot;所有学生的年龄：&quot; + ages1);        // 统计汇总信息        IntSummaryStatistics agesSum = students.stream()                .collect(Collectors.summarizingInt(Student::getAge));        System.out.println(&quot;年龄汇总信息：&quot; + agesSum);        // 分块        Map&lt;Boolean, List&lt;Student&gt;&gt; genders = students.stream()                // 根据断言分成两块                .collect(Collectors.partitioningBy(s -&gt; s.getGender() == Gender.MALE));        System.out.println(&quot;男女学生列表：&quot; + genders);        // 分组（分块是一个特殊的分组）        Map&lt;Grade, List&lt;Student&gt;&gt; grades = students.stream()                .collect(Collectors.groupingBy(Student::getGrade));        System.out.println(&quot;班级学生列表：&quot; + grades);        // 得到所有班级学生个数        Map&lt;Grade, Long&gt; gradesCount = students.stream()                .collect(Collectors.groupingBy(Student::getGrade, Collectors.counting()));        System.out.println(&quot;班级学生个数列表：&quot; + gradesCount);</code></pre><h3 id="Stream-运行机制"><a href="#Stream-运行机制" class="headerlink" title="Stream 运行机制"></a>Stream 运行机制</h3><ol><li><p>所有操作是链式调用，一个元素只迭代一次</p></li><li><p>每一个中间操作返回一个新的流，流里面有一个属性sourceStage指向同一个地方，就是Head</p></li><li><p>Head -&gt; nextStage -&gt; nextStage -&gt; … -&gt; null</p></li><li><p><strong>有状态</strong>（入参一般两个参数）操作会把<strong>无状态操作</strong>截断，单独处理</p></li><li><p>并行环境下，有状态的中间操作不一定能并行操作</p></li><li><p>parallel/sequetial 这两个操作也是中间操作（也是返回stream），但是他们不创建流，他们只修改Head的并行标识（parallel）</p></li></ol><pre><code class="java">public static void main(String[] args) &#123;    Random random = new Random();    // 随机产生数据    Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; random.nextInt())        // 产生500个（无限流需要短路操作）        .limit(500)        // 第一个无状态操作        .peek(s -&gt; print(&quot;peek:&quot; + s))        // 第二个无状态操作        .filter(s -&gt; &#123;            print(&quot;filter:&quot; + s);            return s &gt; 1000000;        &#125;)        // 有状态操作        .sorted((i1,i2)-&gt;&#123;            print(&quot;sort:&quot; + i1 + &quot;,&quot; + i2);            return i1.compareTo(i2);        &#125;)        // 又一个无状态操作        .peek(s-&gt; print(&quot;peek2:&quot; + s))        // .parallel()        ;    // 终止操作    stream.count();&#125;</code></pre><h2 id="第四章-reactive-stream响应式流"><a href="#第四章-reactive-stream响应式流" class="headerlink" title="第四章 reactive stream响应式流"></a>第四章 reactive stream响应式流</h2><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>发布者和订阅者可以交流。</p><p>发布者：自来水公司</p><p>订阅者：家</p><p>背压：相当于水龙头</p><pre><code class="java">import java.util.concurrent.Flow;import java.util.concurrent.SubmissionPublisher;public class FlowDemo &#123;    public static void main(String[] args) &#123;        // 1. 定义发布者，发布的数据类型是Integer        // 直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();        // 2. 定义订阅者        Flow.Subscriber&lt;Integer&gt; subscriber = new Flow.Subscriber&lt;Integer&gt;() &#123;            private Flow.Subscription subscription;            @Override            public void onSubscribe(Flow.Subscription subscription) &#123;                // 保存订阅关系，需要用它来给发布者响应                this.subscription = subscription;                // 请求一个数据                this.subscription.request(1);            &#125;            @Override            public void onNext(Integer item) &#123;                // 接收到一个数据，处理                System.out.println(&quot;接收到数据：&quot; + item);                // 处理完调用request再请求一个数据                this.subscription.request(1);                // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了                // this.subscription.cancel();            &#125;            @Override            public void onError(Throwable throwable) &#123;                // 出现了异常（例如处理数据的时候产生了异常）                throwable.printStackTrace();                // 告诉发布者，后边不接受数据了                this.subscription.cancel();            &#125;            @Override            public void onComplete() &#123;                // 发布者close时触发                System.out.println(&quot;处理完了&quot;);            &#125;        &#125;;        // 3. 发布者和订阅者建立订阅关系        publisher.subscribe(subscriber);        // 4. 生产数据，并发布        // 这里忽略数据生产过程        int data = 111;        // submit是阻塞函数        publisher.submit(data);        publisher.submit(222);        publisher.submit(333);        // 5. 结束后，关闭发布者        // 正式环境应该放finally确保关闭        publisher.close();        // 主线程延迟停止，否则数据没有消费就退出        try &#123;            Thread.currentThread().join(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><pre><code class="java">import java.util.concurrent.Flow;import java.util.concurrent.SubmissionPublisher;public class FlowDemo2 &#123;    public static void main(String[] args) &#123;        // 1. 定义发布者，发布的数据类型是Integer        // 直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();        // 2. 定义处理器，对数据进行过滤，并转换为String类型        MyProcessor processor = new MyProcessor();        // 3. 发布者和处理器建立订阅关系        publisher.subscribe(processor);        // 4. 定义最终订阅者，消费String类型数据        Flow.Subscriber&lt;String&gt; subscriber = new Flow.Subscriber&lt;String&gt;() &#123;            private Flow.Subscription subscription;            @Override            public void onSubscribe(Flow.Subscription subscription) &#123;                // 保存订阅关系，需要用它来给发布者响应                this.subscription = subscription;                // 请求一个数据                this.subscription.request(1);            &#125;            @Override            public void onNext(String item) &#123;                // 接收到一个数据，处理                System.out.println(&quot;接收到数据：&quot; + item);                // 处理完调用request再请求一个数据                this.subscription.request(1);                // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了                // this.subscription.cancel();            &#125;            @Override            public void onError(Throwable throwable) &#123;                // 出现了异常（例如处理数据的时候产生了异常）                throwable.printStackTrace();                // 告诉发布者，后边不接受数据了                this.subscription.cancel();            &#125;            @Override            public void onComplete() &#123;                // 发布者close时触发                System.out.println(&quot;处理完了&quot;);            &#125;        &#125;;        // 5. 处理器和最终订阅者建立订阅关系        processor.subscribe(subscriber);        // 6. 生产数据，并发布        // 这里忽略数据生产过程        publisher.submit(-111);        publisher.submit(111);        // 5. 结束后，关闭发布者        // 正式环境应该放finally确保关闭        // processor.close();        publisher.close();        // 主线程延迟停止，否则数据没有消费就退出        try &#123;            Thread.currentThread().join(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;/** * 输入源数据 Integer，过滤掉小于0的，然后转换成字符串发布出去 */class MyProcessor extends SubmissionPublisher&lt;String&gt; implements Flow.Processor&lt;Integer, String&gt;&#123;    private Flow.Subscription subscription;    @Override    public void onSubscribe(Flow.Subscription subscription) &#123;        // 保存订阅关系，需要用它来给发布者响应        this.subscription = subscription;        // 请求一个数据        this.subscription.request(1);    &#125;    @Override    public void onNext(Integer integer) &#123;        // 接收到一个数据，处理        System.out.println(&quot;处理器接收到数据：&quot; + integer);        // 过滤掉小于0的数据，然后发布出去        if(integer &gt; 0)&#123;            this.submit(&quot;转换后的数据：&quot; + integer);        &#125;        // 处理完成，调用request再请求一个数据        this.subscription.request(1);        // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了        // this.subscription.cancel();    &#125;    @Override    public void onError(Throwable throwable) &#123;        // 出现了异常（例如处理数据的时候产生了异常）        throwable.printStackTrace();        // 告诉发布者，后边不接受数据了        this.subscription.cancel();    &#125;    @Override    public void onComplete() &#123;        // 发布者close时触发        System.out.println(&quot;处理器处理完了&quot;);    &#125;&#125;</code></pre><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><pre><code class="java">// 是阻塞函数。缓冲池满了就不再生产数据publisher.submit(data);</code></pre><h2 id="第五章-RxJava2-响应式编程"><a href="#第五章-RxJava2-响应式编程" class="headerlink" title="第五章  RxJava2-响应式编程"></a>第五章  RxJava2-响应式编程</h2><h3 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h3><p>RxJava = Observer + 异步处理</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;    &lt;artifactId&gt;rxjava&lt;/artifactId&gt;    &lt;version&gt;2.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code class="java">import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.functions.Consumer;import io.reactivex.schedulers.Schedulers;public class HelloRx &#123;    public static void main(String[] args) &#123;        // 事件源(被观察者)        Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;                emitter.onNext(&quot;hello&quot;);                emitter.onNext(&quot;www.monkeykong.github.io&quot;);                emitter.onNext(&quot;let`s study!&quot;);            &#125;        &#125;);        // 消费者（观察者）        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;            public void accept(String s) throws Exception &#123;                System.out.println(Thread.currentThread().getName() + &quot;== consumer == &quot; + s);            &#125;        &#125;;        // 观察者        Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;            @Override            public void onSubscribe(Disposable disposable) &#123;            &#125;            @Override            public void onNext(String s) &#123;                System.out.println(Thread.currentThread().getName() + &quot;== observer == &quot; + s);            &#125;            @Override            public void onError(Throwable throwable) &#123;            &#125;            @Override            public void onComplete() &#123;            &#125;        &#125;;        // 耦合        // observable.subscribe(consumer);        // 异步        observable.observeOn(Schedulers.newThread()).subscribe(consumer);        observable.observeOn(Schedulers.newThread()).subscribe(observer);        for (;;);    &#125;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5b17560e6fb9a01e2862246f">https://juejin.im/post/5b17560e6fb9a01e2862246f</a></p><h2 id="第五章-SpingWebFlux"><a href="#第五章-SpingWebFlux" class="headerlink" title="第五章 SpingWebFlux"></a>第五章 SpingWebFlux</h2><p>待学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 讲义进阶之函数式编程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java讲义" scheme="http://yoursite.com/tags/Java%E8%AE%B2%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 学习(一)</title>
    <link href="http://yoursite.com/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html"/>
    <id>http://yoursite.com/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html</id>
    <published>2020-11-30T14:13:12.000Z</published>
    <updated>2020-12-07T13:46:48.665Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScipt 学习。</p><a id="more"></a><h2 id="环境和-HelloWorld"><a href="#环境和-HelloWorld" class="headerlink" title="环境和 HelloWorld"></a>环境和 HelloWorld</h2><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><pre><code class="shell">-- 安装 node-- 安装 typescriptnpm install typescript -g</code></pre><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><pre><code class="typescript">function jspang() &#123;  let web: string = &quot;Hello World&quot;  console.log(web)&#125;// ts-nodejspang()</code></pre><p><strong>执行：</strong></p><pre><code class="sh"># 编译，完成会生成 Demo1.jstsc Demo1.ts# 执行node Demo1.js</code></pre><p><strong>简易执行：</strong></p><pre><code class="shell"># 安装 ts-nodenpm install -g ts-node# 直接用 ts-node 执行，省去编译命令ts-node Demo1.ts</code></pre><h2 id="TypeScript-静态类型"><a href="#TypeScript-静态类型" class="headerlink" title="TypeScript 静态类型"></a>TypeScript 静态类型</h2><p>一旦定义不可再改变。</p><pre><code class="typescript">let count: number = 1;// 编译报错// count = &#39;alvin&#39;;count = 2;</code></pre><p>自定义静态类型：</p><pre><code class="typescript">// 定义接口,相当于自定义一个静态类型interface XiaoJieJie &#123;  uname: string,  age: number&#125;const xiaohong: XiaoJieJie = &#123;  uname: &#39;xiaohong&#39;,  age: 18&#125;console.log(xiaohong.age)</code></pre><p><strong>对象静态类型：</strong></p><pre><code class="typescript">// 对象类型const xiaojiejie: &#123;  name: string,  age: number&#125; = &#123;  name: &#39;大脚&#39;,  age: 18&#125;// 数组类型const xiaojiejies: string[] = [&#39;谢大脚&#39;, &#39;留影&#39;, &#39;123&#39;]// 对象类型class Person &#123; &#125;const dajiao: Person = new Person()const jianxiaojiejie: () =&gt; string = () =&gt; &#123; return &#39;大叫&#39; &#125;// 对象类型 数组类型 类类型 函数类型</code></pre><h2 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h2><pre><code class="typescript">// type annotation 类型注解// type reference 类型推断// 类型注解。声明变量类型let count1: number;count1 = 123;// 类型推断。自动推断类型let countReference = 1;// 潜规则// 1. 能够自动分析的，无需写类型// 2. 不能自动分析得到类型的，使用类型注解function getTotal(one: number, two: number) &#123;  return one + two;&#125;const total = getTotal(1, 2)</code></pre><h2 id="返回类型注解"><a href="#返回类型注解" class="headerlink" title="返回类型注解"></a>返回类型注解</h2><pre><code class="typescript">// 指定函数返回类型function getTotal2(one: number, two: number): number &#123;  return one + two;&#125;const total2 = getTotal2(1, 2)function sayHello(): void &#123;  console.log(&#39;Hello World&#39;)&#125;function errorFunction(): never &#123;  throw new Error()  console.log(&#39;Hello World&#39;);&#125;function forNeer(): never &#123;  while (true) &#123; &#125;  console.log(&#39;Hi&#39;);&#125;// 指定对象的属性类型，必须这样function add(&#123; one, two &#125;: &#123; one: number, two: number &#125;) &#123;  return one + two&#125;const tatal3 = add(&#123; one: 1, two: 2 &#125;)</code></pre><h2 id="数组类型注解"><a href="#数组类型注解" class="headerlink" title="数组类型注解"></a>数组类型注解</h2><pre><code class="typescript">// 数组类型注解const numberArr = [1, 2, 3]const numberArr2: number[] = [1, 2, 3]const stringArr: string[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]const undefinedArr: undefined[] = [undefined, undefined]const arr: (number | string)[] = [1, &#39;string&#39;, 2]const xiaojiejies6: &#123; name: string, age: number &#125;[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]// type alias 类型别名type Lady = &#123; name: string, age: number &#125;const xiaojiejies61: Lady[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]// class 形式也可以class Madam &#123;  name: string;  age: number;&#125;const xiaojiejies62: Madam[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><pre><code class="typescript">// 元组学习// 数组无法识别数组元素类型的顺序const xiaojiejie7: (string | number)[] = [&#39;dajiao&#39;, &#39;teacher&#39;, 18]// 元组，可以校验顺序const xiaojiejie71: [string, string, number] = [&#39;dajiao&#39;, &#39;teacher&#39;, 18]</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code class="typescript">const screenResume = (name: string, age: number, bust: number) =&gt; &#123;  age &lt; 24 &amp;&amp; bust &gt;= 90 &amp;&amp; console.log(name + &#39;进入面试&#39;)  age &gt;= 23 || bust &lt; 90 &amp;&amp; console.log(name + &#39;你被淘汰&#39;)&#125;const getResume = (name: string, age: number, bust: number) =&gt; &#123;  console.log(name + &#39;年龄是&#39; + age)  console.log(name + &#39;胸围是&#39; + bust)&#125;screenResume(&#39;大脚&#39;, 18, 94)getResume(&#39;大脚&#39;, 18, 94)// 使用接口进行优化interface Girl &#123;  name: string;  age: number;  bust: number;  waistline?: number;&#125;const girl = &#123;  name: &#39;大脚&#39;,  age: 18,  bust: 94,  waistline: 21&#125;const screenResume1 = (girl: Girl) =&gt; &#123;  girl.age &lt; 24 &amp;&amp; girl.bust &gt;= 90 &amp;&amp; console.log(girl.name + &#39;进入面试&#39;)  girl.age &gt;= 23 || girl.bust &lt; 90 &amp;&amp; console.log(girl.name + &#39;你被淘汰&#39;)&#125;const getResume1 = (girl: Girl) =&gt; &#123;  console.log(girl.name + &#39;年龄是&#39; + girl.age)  console.log(girl.name + &#39;胸围是&#39; + girl.bust)  girl.waistline &amp;&amp; console.log(girl.name + &#39;腰围是&#39; + girl.waistline)&#125;screenResume1(girl)getResume1(girl)</code></pre><h2 id="接口约束类"><a href="#接口约束类" class="headerlink" title="接口约束类"></a>接口约束类</h2><pre><code class="typescript">// 定义一个类interface Girl &#123;  name: string,  age: number,  bust: number,  yaowei?: number,  [propname: string]: any,  say(): string&#125;// 用接口来约束类class XiaoJieJie implements Girl &#123;  name: string;  age: number;  bust: number;  say() &#123;    return &quot;欢迎光临，我是&quot; + this.name + &quot;！&quot;  &#125;&#125;// 定义一个对象const xiaohong = new XiaoJieJie();xiaohong.age = 22;xiaohong.name = &#39;小红&#39;;xiaohong.bust = 98;// 使用对象console.info(xiaohong.say());// 类继承class Teacher extends XiaoJieJie &#123;  teach(): string &#123;    return &#39;我来教你做&#39;;  &#125;&#125;const xiaomei = new Teacher();console.info(xiaomei.teach());</code></pre><h2 id="类的继承、重写和-super"><a href="#类的继承、重写和-super" class="headerlink" title="类的继承、重写和 super"></a>类的继承、重写和 super</h2><pre><code class="typescript">// 类的继承、重写和 superclass Lady &#123;  sayHi() &#123;    return &quot;Hi！帅哥。&quot;  &#125;&#125;class Beauty extends Lady &#123;  sayHi() &#123;    return super.sayHi() + &quot;你好。&quot;  &#125;  sayLove() &#123;    return &#39;I love you.&#39;;  &#125;&#125;console.info(new Beauty().sayHi())</code></pre><h2 id="类的访问类型"><a href="#类的访问类型" class="headerlink" title="类的访问类型"></a>类的访问类型</h2><pre><code class="typescript">// 类的访问类型// public 公共的// private 私有的（类内部）// protected 继承类class Person &#123;  public name: string;  private age: number;  protected hobby: string;&#125;class Man extends Person &#123;  say() &#123;    console.info(this.name);    // 报错    //console.info(this.age);    console.info(this.hobby);  &#125;&#125;const p11 = new Person();console.info(p11.name);// 报错//console.info(p11.age);// 报错//console.info(p11.hobby);</code></pre><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><pre><code class="typescript">class Person121 &#123;  public name: string;  constructor(name: string) &#123;    this.name = name;  &#125;&#125;class Person12 &#123;  constructor(public name: string) &#123;    console.info(&quot;111&quot;)  &#125;&#125;class Teacher12 extends Person12 &#123;  constructor() &#123;    console.info(&quot;000&quot;)    // 子类必须调用父类的构造函数    super(&quot;Alvin&quot;);    console.info(&quot;222&quot;)  &#125;&#125;console.log(new Person121(&#39;alvin&#39;).name)console.log(new Person12(&#39;alvin&#39;).name)console.log(new Teacher12().name)</code></pre><h2 id="getter、setter-和静态属性"><a href="#getter、setter-和静态属性" class="headerlink" title="getter、setter 和静态属性"></a>getter、setter 和静态属性</h2><pre><code class="typescript">// getter、setter和静态属性class Person13 &#123;  constructor(private _age: number) &#123; &#125;  get age() &#123;    return this._age;  &#125;  set age(age: number) &#123;    this._age = age;  &#125;  static sayHi() &#123;    console.info(&quot;Hi.&quot;)  &#125;&#125;const p13 = new Person13(20);console.info(p13.age);p13.age = 18;console.info(p13.age);// 报错// p13._age = 10;console.info(Person13.sayHi())</code></pre><h2 id="抽象类和只读属性"><a href="#抽象类和只读属性" class="headerlink" title="抽象类和只读属性"></a>抽象类和只读属性</h2><pre><code class="typescript">// 只读属性、抽象类class Person14 &#123;  public readonly _money: number;  constructor(money: number) &#123;    this._money = money;  &#125;&#125;const p14 = new Person14(123);console.info(p14._money)// 报错//p14._money = 122abstract class Person141 &#123;  abstract say(): string;&#125;class Person1411 extends Person141 &#123;  say() &#123;    return &quot;111&quot;  &#125;&#125;class Person1412 extends Person141 &#123;  say() &#123;    return &quot;222&quot;  &#125;&#125;console.info(new Person1411().say())console.info(new Person1412().say())</code></pre><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><pre><code class="json"># 生成 tsconfig.json 文件tsc -init# 设置编译时取出注释&quot;removeComments&quot;: true,# 执行编译tsc Demo15.ts# 发现生成的 js 还是有注释# 这样就好了tsc</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;TypeScipt 学习。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
</feed>
