<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-21T16:37:05.473Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>悟空</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组装电脑</title>
    <link href="http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85.html"/>
    <id>http://yoursite.com/2020-12-22-12%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85.html</id>
    <published>2020-12-22T14:13:12.000Z</published>
    <updated>2020-12-21T16:37:05.473Z</updated>
    
    <content type="html"><![CDATA[<p>组装电脑</p><a id="more"></a><h2 id="显卡选择"><a href="#显卡选择" class="headerlink" title="显卡选择"></a>显卡选择</h2><table><thead><tr><th>显卡型号</th><th>工艺</th><th>流处理器</th><th>核心基准/游戏加速频率</th><th>位宽</th><th>容量</th><th>频率</th><th>价格</th></tr></thead><tbody><tr><td>RX5500XT</td><td>7nm</td><td>1408</td><td>1670/1717/1845</td><td>128</td><td>8GB GBBR6</td><td>14</td><td></td></tr><tr><td>GTX 1660</td><td>12nm</td><td>1408</td><td>1530</td><td>192</td><td>6GB GDDR5</td><td>8</td><td></td></tr><tr><td>GTX 1650S</td><td>12nm</td><td>1280</td><td>1530</td><td>128</td><td>4GB</td><td>12</td><td>998</td></tr></tbody></table><p>N 卡：NVIDA</p><p>A 卡：AMD</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;组装电脑&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>第 21 章 函数式编程</title>
    <link href="http://yoursite.com/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"/>
    <id>http://yoursite.com/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</id>
    <published>2020-12-21T14:13:12.000Z</published>
    <updated>2020-12-21T16:01:19.293Z</updated>
    
    <content type="html"><![CDATA[<p>Java 讲义进阶之函数式编程。</p><a id="more"></a><h2 id="第一章-函数式编程和-lambda-表达式"><a href="#第一章-函数式编程和-lambda-表达式" class="headerlink" title="第一章 函数式编程和 lambda 表达式"></a>第一章 函数式编程和 lambda 表达式</h2><h3 id="lambda表达式初识"><a href="#lambda表达式初识" class="headerlink" title="lambda表达式初识"></a>lambda表达式初识</h3><pre><code class="java">public class ThreadDemo &#123;    public static void main(String[] args) &#123;        Runnable target = new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;OK&quot;);            &#125;        &#125;;        new Thread(target).start();        // jdk8 lambda        Runnable target1 = () -&gt; System.out.println(&quot;OK&quot;);        // lambda必须返回指定接口实例；并且接口中只有一个需要实现的方法        // Object target2 = () -&gt; System.out.println(&quot;OK&quot;);        new Thread(target1).start();    &#125;&#125;</code></pre><h3 id="lambda表达式常用写法"><a href="#lambda表达式常用写法" class="headerlink" title="lambda表达式常用写法"></a>lambda表达式常用写法</h3><pre><code class="java">public class LambdaDemo2 &#123;    public static void main(String[] args) &#123;        // 其实就是 doubleNum 方法的实现        Interface1 i1 = (i) -&gt; i*2;        System.out.println(i1.add(3,7));        System.out.println(i1.doubleNum(20));        // 这种是最常见写法        Interface1 i2 = i -&gt; i*2;        Interface1 i3 = (int i) -&gt; i*2;        Interface1 i4 = (int i) -&gt; &#123;            System.out.println(&quot;-------&quot;);            return i*2;        &#125;;    &#125;&#125;</code></pre><h3 id="函数接口默认方法"><a href="#函数接口默认方法" class="headerlink" title="函数接口默认方法"></a>函数接口默认方法</h3><pre><code class="java">// 函数接口，只有一个方法，就是一个接口只做一件事情的意思。告诉用户不要再加其他接口方法了@FunctionalInterfaceinterface Interface1&#123;    int doubleNum(int i);    // 默认方法。函数接口是指只有一个需要实现的方法，而不是接口中只有一个方法。    // 很重要的特性。1.8以前，接口中不敢随意增加方法，因为加了方法后，对该接口的所有实现都有影响。    default int add(int x, int y)&#123;        // x = this.doubleNum(x);        return x + y;    &#125;&#125;@FunctionalInterfaceinterface Interface2&#123;    int doubleNum(int i);    default int add(int x, int y)&#123;        return x + y;    &#125;&#125;@FunctionalInterfaceinterface Interface3 extends Interface2, Interface1&#123;    // 函数接口使用默认方法需要注意的地方，当多个接口有相同的默认方法时，需要指定使用哪个    @Override    default int add(int x, int y) &#123;        return Interface1.super.add(x,y);    &#125;&#125;</code></pre><h3 id="函数接口好处"><a href="#函数接口好处" class="headerlink" title="函数接口好处"></a>函数接口好处</h3><ul><li>可以省略接口</li><li>可以进行链式操作</li></ul><pre><code class="java">import java.text.DecimalFormat;import java.util.function.Function;interface IMoneyFormat&#123;    String format(int i);&#125;class MyMoney&#123;    private final int money;    public MyMoney(int money)&#123;        this.money = money;    &#125;    public void printMoney(IMoneyFormat moneyFormat)&#123;        System.out.println(&quot;我的存款：&quot;+moneyFormat.format(this.money));    &#125;    public void printMoney1(Function&lt;Integer, String&gt; moneyFormat)&#123;        System.out.println(&quot;我的存款：&quot;+moneyFormat.apply(this.money));    &#125;&#125;public class MoneyDemo &#123;    public static void main(String[] args) &#123;        MyMoney me = new MyMoney(999999999);        // 接口函数只有一个参数，括号可以省略        me.printMoney(i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i));        // 可以看出，lambda只需要知道接口函数的输入是什么，输出是什么即可。        // 函数接口好处1：所以可以不需要接口，使用jdk自带的function即可，Function 本身就是一个函数式接口        me.printMoney1(i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i));        // 函数接口好处2：链式操作        Function&lt;Integer, String&gt; moneyFormat = i -&gt; new DecimalFormat(&quot;#,###&quot;).format(i);        me.printMoney1(moneyFormat.andThen(s -&gt; &quot;人民币&quot; + s));    &#125;&#125;</code></pre><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><table><thead><tr><th>接口</th><th>输入参数</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td>Predicate<T></td><td>T</td><td>boolean</td><td>断言</td></tr><tr><td>Consumer<T></td><td>T</td><td>/</td><td>消费一个数据</td></tr><tr><td>Function&lt;T,R&gt;</td><td>T</td><td>R</td><td>输入T输出R的函数</td></tr><tr><td>Supplier<T></td><td>/</td><td>T</td><td>提供一个数据</td></tr><tr><td>UnaryOperator<T></td><td>T</td><td>T</td><td>一元函数（输入输出类型相同）</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>(T,U)</td><td>R</td><td>2个输入的函数</td></tr><tr><td>BinaryOperator<T></td><td>(T,T)</td><td>T</td><td>二元函数（输入输出类型相同）</td></tr></tbody></table><pre><code class="java">public class FunctionDemo &#123;    public static void main(String[] args) &#123;        // 断言函数接口        Predicate&lt;Integer&gt; predicate = i -&gt; i&gt;0;        System.out.println(predicate.test(-9));        // 消费函数接口        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);        consumer.accept(&quot;输入的数据&quot;);        // 对于参数是基本类型的，java自带了一些带类型的函数，优先使用        IntPredicate predicate1 = i -&gt; i&gt;0;        // DoubleConsumer    &#125;&#125;</code></pre><h3 id="lambda表达式方法引用"><a href="#lambda表达式方法引用" class="headerlink" title="lambda表达式方法引用"></a>lambda表达式方法引用</h3><pre><code class="java">import java.util.ArrayList;import java.util.List;import java.util.function.*;class Dog&#123;    private String name = &quot;哮天犬&quot;;    private int food = 10;    public Dog()&#123;&#125;    public Dog(String name)&#123;        this.name = name;    &#125;    public static void bark(Dog dog)&#123;        System.out.println(dog.name + &quot;叫了&quot;);    &#125;    /**     * 吃狗粮     * JDK默认会把当前实例传入到非静态方法，参数名称为this，位置是第一个     */    public int eat(Dog this, int num)&#123;        System.out.println(&quot;吃了&quot; + num + &quot;斤狗粮&quot;);        this.food -= num;        return this.food;    &#125;    public String getName()    &#123;        return this.name;    &#125;&#125;public class MethodReferenceDemo &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.eat(3);        Consumer&lt;String&gt; consumerOrg1 = i -&gt; System.out.println(i);        // 方法引用（当输入输出参数相同，可以改写为方法引用）        Consumer&lt;String&gt; consumer1 = System.out::println;        consumer1.accept(&quot;接收的数据&quot;);        // 静态方法的方法引用        Consumer&lt;Dog&gt; consumerOrg2 = i -&gt; Dog.bark(i);        Consumer&lt;Dog&gt; consumer2 = Dog::bark;        consumer2.accept(dog);        // 非静态方法，使用对象实例的方法引用        // Function&lt;Integer, Integer&gt; function = dog::eat;        // 输入输出一样，可以变为一元函数形式        // UnaryOperator&lt;Integer&gt; function = dog::eat;        IntUnaryOperator unaryOrg = i -&gt; dog.eat(i);        IntUnaryOperator unary = dog::eat;        System.out.println(&quot;还剩下：&quot; + unary.applyAsInt(2) + &quot;斤&quot;);        // 使用类名来引用非静态方法        BiFunction&lt;Dog, Integer, Integer&gt; eatFunctionOrg = (T,U) -&gt; T.eat(U);        BiFunction&lt;Dog, Integer, Integer&gt; eatFunction = Dog::eat;        System.out.println(&quot;还剩下&quot; + eatFunction.apply(dog,2)+&quot;斤&quot;);        // 无参构造函数的方法引用        Supplier&lt;Dog&gt; supplierOrg = () -&gt; new Dog();        Supplier&lt;Dog&gt; supplier = Dog::new;        System.out.println(&quot;创建了新对象：&quot; + supplier.get().getName());        // 有参构造函数的方法引用        Function&lt;String, Dog&gt; function2Org = T -&gt; new Dog(T);        Function&lt;String, Dog&gt; function2 = Dog::new;        System.out.println(&quot;创建了新对象：&quot; + function2.apply(&quot;旺财&quot;).getName());        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 传值引用，lambda也是一样的原理。        // 存疑。        MethodReferenceDemo demo = new MethodReferenceDemo();        demo.test(list);        System.out.println(list.size());    &#125;    private void test(List&lt;String&gt; list)&#123;        list = null;    &#125;&#125;</code></pre><h3 id="lambda表达式类型推断"><a href="#lambda表达式类型推断" class="headerlink" title="lambda表达式类型推断"></a>lambda表达式类型推断</h3><pre><code class="java">interface IMath&#123;    int add(int x, int y);&#125;public class TypeDemo &#123;    public static void main(String[] args) &#123;        // 变量类型定义        IMath lambda = (x,y) -&gt; x + y;        // 数组里        IMath[] lambdas = &#123;(x,y) -&gt; x + y&#125;;        // 强转        Object lambda2 = (IMath)(x,y) -&gt; x + y;        // 通过返回类型        IMath createLambda = createLambda();        TypeDemo demo = new TypeDemo();        // 当有二义性时，使用强转对应的接口解决        demo.test((x,y) -&gt; x + y);    &#125;    public void test(IMath math)&#123;    &#125;    public static IMath createLambda()&#123;        return (x,y) -&gt; x+y;    &#125;&#125;</code></pre><h3 id="lambda表达式变量引用"><a href="#lambda表达式变量引用" class="headerlink" title="lambda表达式变量引用"></a>lambda表达式变量引用</h3><pre><code class="java">public class VarDemo &#123;    public static void main(String[] args) &#123;        final String str = &quot;我们的时间&quot;;        // lambda表达式实际上相当于匿名内部类，匿名内部类引用变量时必须是final的。（java参数是传值）        Consumer&lt;String&gt; consumer = s-&gt; System.out.println(s + str);        consumer.accept(&quot;1211&quot;);    &#125;&#125;</code></pre><h3 id="级联表达式和柯里化"><a href="#级联表达式和柯里化" class="headerlink" title="级联表达式和柯里化"></a>级联表达式和柯里化</h3><pre><code class="java">/** * 级联表达式和柯里化 * 柯里化的目的：函数标准化 * 高阶函数：返回函数的函数 */public class CurryDemo &#123;    public static void main(String[] args) &#123;        // 实现了x+y的级联表达式        Function&lt;Integer, Function&lt;Integer,Integer&gt;&gt; fun = x-&gt;y-&gt;x+y;        System.out.println(fun.apply(2).apply(3));        Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; fun2 = x-&gt;y-&gt;z-&gt;x+y+z;        System.out.println(fun2.apply(2).apply(3).apply(4));        // int[] nums = &#123;2,3,4,5,6,7&#125;;        int[] nums = &#123;2,3,4&#125;;        Function f = fun2;        for (int i=0; i&lt;nums.length; i++)&#123;            if(f instanceof Function)&#123;                Object obj = f.apply(nums[i]);                if(obj instanceof Function)&#123;                    f = (Function)obj;                &#125;else&#123;                    System.out.println(&quot;调用结束：结果为&quot; + obj);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="第三章-Stream流编程"><a href="#第三章-Stream流编程" class="headerlink" title="第三章 Stream流编程"></a>第三章 Stream流编程</h2><h3 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a>外部迭代和内部迭代</h3><ul><li>外部迭代：自己编写迭代细节</li><li>内部迭代：告诉需求</li></ul><h3 id="中间操作和终止操作"><a href="#中间操作和终止操作" class="headerlink" title="中间操作和终止操作"></a>中间操作和终止操作</h3><ul><li>中间操作：返回结果还是流</li><li>终止操作：返回的是一个结果</li></ul><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>在终止操作没有调用的情况下，中间操作不会执行</p><pre><code class="java">public class StreamDemo1 &#123;    public static void main(String[] args) &#123;        int[] nums = &#123;1,2,3&#125;;        // 外部迭代        int sum = 0;        for (int i:nums)&#123;            sum += i;        &#125;        System.out.println(&quot;结果为：&quot; + sum);        // 使用stream的内部迭代        // map就是中间操作（返回流的操作）        // sum就是终止操作        int sum2 = IntStream.of(nums).map(StreamDemo1::doubleNum).sum();        System.out.println(&quot;结果为：&quot; + sum2);        System.out.println(&quot;惰性求值就是在终止操作没有调用的情况下，中间操作不会执行&quot;);        IntStream.of(nums).map(StreamDemo1::doubleNum);    &#125;    public static int doubleNum(int i)&#123;        System.out.println(&quot;执行了乘以2&quot;);        return i*2;    &#125;&#125;</code></pre><h3 id="Stream流编程-创建"><a href="#Stream流编程-创建" class="headerlink" title="Stream流编程 - 创建"></a>Stream流编程 - 创建</h3><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>集合</td><td>Collection.stream/parallelStream</td></tr><tr><td>数组</td><td>Arrays.stream</td></tr><tr><td>数字Stream</td><td>IntStream/LongStream.range/rangeClosed String.chars()  Random.ints/longs/doubles</td></tr><tr><td>自己创建</td><td>Stream.generate/iterate</td></tr></tbody></table><pre><code class="java">public class StreamDemo2 &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 从集合创建        list.stream();        list.parallelStream();        // 从数组创建        Arrays.stream(new int[]&#123;2,3,4&#125;);        // 创建数字流        IntStream.of(1,2,3);        IntStream.rangeClosed(1,10);        // 使用random创建一个无限流        new Random().ints().limit(10);        // 自己产生流        Stream.generate(()-&gt; new Random().nextInt()).limit(20);    &#125;&#125;</code></pre><h3 id="Stream流编程-中间操作"><a href="#Stream流编程-中间操作" class="headerlink" title="Stream流编程 - 中间操作"></a>Stream流编程 - 中间操作</h3><p>无状态：当前操作和其他元素没有关系</p><p>有状态：当前操作和其他元素有依赖关系</p><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>无状态操作</td><td>map/mapToXxx （A对象转为B对象）</td></tr><tr><td></td><td>flatMap/flatMapToXxx （A对象下面有B属性，B是集合；得到所有A属下B属性的集合）</td></tr><tr><td></td><td>filter</td></tr><tr><td></td><td>peek （类似each，但是是中间操作）</td></tr><tr><td></td><td>unordered</td></tr><tr><td>有状态操作</td><td>distinct</td></tr><tr><td></td><td>sorted</td></tr><tr><td></td><td>limit/skip</td></tr></tbody></table><pre><code class="java">public class StreamDemo3 &#123;    public static void main(String[] args) &#123;        String str = &quot;my name is 007&quot;;        // 把每个单词的长度打印出来        Stream.of(str.split(&quot; &quot;)).filter(s -&gt; s.length()&gt;2).map(s -&gt; s.length())                // 调用终止操作，否则代码不会执行                .forEach(System.out::println);        // flatMap A-&gt;B属性（是个集合），最终得到所有的A元素里面的所有B属性集合        // intStream/longStream并不是Stream的子类，所以要装箱 boxed        Stream.of(str.split(&quot; &quot;)).flatMap(s-&gt; s.chars().boxed())                .forEach(i -&gt; System.out.println((char)i.intValue()));        // peek是个中间操作，和forEach类似，forEach是终止操作        System.out.println(&quot;------peek----------&quot;);        Stream.of(str.split(&quot; &quot;)).peek(System.out::println).forEach(System.out::println);        // limit,主要终于无限流        new Random().ints().filter(i-&gt; i&gt;100&amp;&amp;i&lt;1000).limit(10)                .forEach(System.out::println);    &#125;&#125;</code></pre><h3 id="Stream流编程-终止操作"><a href="#Stream流编程-终止操作" class="headerlink" title="Stream流编程 - 终止操作"></a>Stream流编程 - 终止操作</h3><table><thead><tr><th></th><th>相关方法</th></tr></thead><tbody><tr><td>非短路操作</td><td>forEach/forEachOrdered</td></tr><tr><td></td><td>collect/toArray</td></tr><tr><td></td><td>reduce</td></tr><tr><td></td><td>min/max/count</td></tr><tr><td>短路操作</td><td>findFirst/findAny</td></tr><tr><td></td><td>allMatch/anyMatch/noneMatch</td></tr></tbody></table><pre><code class="java">public class StreamDemo4 &#123;    public static void main(String[] args) &#123;        String str = &quot;my name is 007&quot;;        // 使用并行流        str.chars().parallel().forEach(i -&gt; System.out.println((char)i));        // 使用forEachOrdered包装顺序        str.chars().parallel().forEachOrdered(i -&gt; System.out.println((char)i));        // 收集到list        List&lt;String&gt; list = Stream.of(str.split(&quot; &quot;)).collect(Collectors.toList());        System.out.println(list);        // 使用reduce拼接字符串        Optional&lt;String&gt; letters = Stream.of(str.split(&quot; &quot;)).reduce((s1, s2)-&gt;s1+&quot;|&quot;+s2);        System.out.println(letters.orElse(&quot;&quot;));        // 带初始值的reduce        String reduce = Stream.of(str.split(&quot; &quot;)).reduce(&quot;&quot;, (s1,s2)-&gt;s1+&quot;|&quot;+s2);        System.out.println(reduce);        // 计算所有单词总长度        Integer length = Stream.of(str.split(&quot; &quot;)).map(s -&gt; s.length())                .reduce(0, (s1,s2)-&gt;s1 + s2);        System.out.println(length);        // max        Optional&lt;String&gt; max = Stream.of(str.split(&quot; &quot;))                .max((s1,s2)-&gt; s1.length() - s2.length());        System.out.println(max.get());        // 使用 findFirst 短路操作        OptionalInt i = new Random().ints().findFirst();        System.out.println(i.getAsInt());    &#125;&#125;</code></pre><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><pre><code class="java">public class StreamDemo5 &#123;    public static void main(String[] args) &#123;        // IntStream.range(1,100).parallel().peek(StreamDemo5::debug).count();        // 现在要实现先并行再串行        // 结论：多次调用parallel/sequential，以最后一次调用为准//        IntStream.range(1,100)//                .parallel().peek(StreamDemo5::debug)//                .sequential().peek(StreamDemo5::debug2)//                .count();        // 并行流使用的线程池：ForkJoinPool.commonPool        // 默认的线程数是当前机器cpu个数        // 使用这个属性修改默认线程数//        System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;5&quot;);//        IntStream.range(1,100).parallel().peek(StreamDemo5::debug).limit(6).count();        // 使用自己的线程池，不使用默认的线程池，防止被其他任务阻塞        ForkJoinPool pool = new ForkJoinPool(20);        pool.submit(()-&gt; IntStream.range(1,100).parallel()            .peek(StreamDemo5::debug).count());        pool.shutdown();        // 让主线程不退出        synchronized (pool)&#123;            try &#123;                pool.wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void debug(int i)&#123;        System.out.println(Thread.currentThread().getName() + &quot;debug &quot; + i);        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void debug2(int i)&#123;        System.err.println(&quot;debug2 &quot; + i);        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><pre><code class="java">        // 得到所有学生的年龄列表        // 尽量使用方法引用（不会多生成一个lambda$0函数），不要使用 s -&gt; s.getAge()。        List&lt;Integer&gt; ages = students.stream().map(Student::getAge)                .collect(Collectors.toList());        Set&lt;Integer&gt; ages1 = students.stream().map(Student::getAge)                .collect(Collectors.toCollection(TreeSet::new));        System.out.println(&quot;所有学生的年龄：&quot; + ages);        System.out.println(&quot;所有学生的年龄：&quot; + ages1);        // 统计汇总信息        IntSummaryStatistics agesSum = students.stream()                .collect(Collectors.summarizingInt(Student::getAge));        System.out.println(&quot;年龄汇总信息：&quot; + agesSum);        // 分块        Map&lt;Boolean, List&lt;Student&gt;&gt; genders = students.stream()                // 根据断言分成两块                .collect(Collectors.partitioningBy(s -&gt; s.getGender() == Gender.MALE));        System.out.println(&quot;男女学生列表：&quot; + genders);        // 分组（分块是一个特殊的分组）        Map&lt;Grade, List&lt;Student&gt;&gt; grades = students.stream()                .collect(Collectors.groupingBy(Student::getGrade));        System.out.println(&quot;班级学生列表：&quot; + grades);        // 得到所有班级学生个数        Map&lt;Grade, Long&gt; gradesCount = students.stream()                .collect(Collectors.groupingBy(Student::getGrade, Collectors.counting()));        System.out.println(&quot;班级学生个数列表：&quot; + gradesCount);</code></pre><h3 id="Stream-运行机制"><a href="#Stream-运行机制" class="headerlink" title="Stream 运行机制"></a>Stream 运行机制</h3><ol><li><p>所有操作是链式调用，一个元素只迭代一次</p></li><li><p>每一个中间操作返回一个新的流，流里面有一个属性sourceStage指向同一个地方，就是Head</p></li><li><p>Head -&gt; nextStage -&gt; nextStage -&gt; … -&gt; null</p></li><li><p><strong>有状态</strong>（入参一般两个参数）操作会把<strong>无状态操作</strong>截断，单独处理</p></li><li><p>并行环境下，有状态的中间操作不一定能并行操作</p></li><li><p>parallel/sequetial 这两个操作也是中间操作（也是返回stream），但是他们不创建流，他们只修改Head的并行标识（parallel）</p></li></ol><pre><code class="java">public static void main(String[] args) &#123;    Random random = new Random();    // 随机产生数据    Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; random.nextInt())        // 产生500个（无限流需要短路操作）        .limit(500)        // 第一个无状态操作        .peek(s -&gt; print(&quot;peek:&quot; + s))        // 第二个无状态操作        .filter(s -&gt; &#123;            print(&quot;filter:&quot; + s);            return s &gt; 1000000;        &#125;)        // 有状态操作        .sorted((i1,i2)-&gt;&#123;            print(&quot;sort:&quot; + i1 + &quot;,&quot; + i2);            return i1.compareTo(i2);        &#125;)        // 又一个无状态操作        .peek(s-&gt; print(&quot;peek2:&quot; + s))        // .parallel()        ;    // 终止操作    stream.count();&#125;</code></pre><h2 id="第四章-reactive-stream响应式流"><a href="#第四章-reactive-stream响应式流" class="headerlink" title="第四章 reactive stream响应式流"></a>第四章 reactive stream响应式流</h2><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>发布者和订阅者可以交流。</p><p>发布者：自来水公司</p><p>订阅者：家</p><p>背压：相当于水龙头</p><pre><code class="java">import java.util.concurrent.Flow;import java.util.concurrent.SubmissionPublisher;public class FlowDemo &#123;    public static void main(String[] args) &#123;        // 1. 定义发布者，发布的数据类型是Integer        // 直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();        // 2. 定义订阅者        Flow.Subscriber&lt;Integer&gt; subscriber = new Flow.Subscriber&lt;Integer&gt;() &#123;            private Flow.Subscription subscription;            @Override            public void onSubscribe(Flow.Subscription subscription) &#123;                // 保存订阅关系，需要用它来给发布者响应                this.subscription = subscription;                // 请求一个数据                this.subscription.request(1);            &#125;            @Override            public void onNext(Integer item) &#123;                // 接收到一个数据，处理                System.out.println(&quot;接收到数据：&quot; + item);                // 处理完调用request再请求一个数据                this.subscription.request(1);                // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了                // this.subscription.cancel();            &#125;            @Override            public void onError(Throwable throwable) &#123;                // 出现了异常（例如处理数据的时候产生了异常）                throwable.printStackTrace();                // 告诉发布者，后边不接受数据了                this.subscription.cancel();            &#125;            @Override            public void onComplete() &#123;                // 发布者close时触发                System.out.println(&quot;处理完了&quot;);            &#125;        &#125;;        // 3. 发布者和订阅者建立订阅关系        publisher.subscribe(subscriber);        // 4. 生产数据，并发布        // 这里忽略数据生产过程        int data = 111;        // submit是阻塞函数        publisher.submit(data);        publisher.submit(222);        publisher.submit(333);        // 5. 结束后，关闭发布者        // 正式环境应该放finally确保关闭        publisher.close();        // 主线程延迟停止，否则数据没有消费就退出        try &#123;            Thread.currentThread().join(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><pre><code class="java">import java.util.concurrent.Flow;import java.util.concurrent.SubmissionPublisher;public class FlowDemo2 &#123;    public static void main(String[] args) &#123;        // 1. 定义发布者，发布的数据类型是Integer        // 直接使用jdk自带的SubmissionPublisher,它实现了Publisher接口        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();        // 2. 定义处理器，对数据进行过滤，并转换为String类型        MyProcessor processor = new MyProcessor();        // 3. 发布者和处理器建立订阅关系        publisher.subscribe(processor);        // 4. 定义最终订阅者，消费String类型数据        Flow.Subscriber&lt;String&gt; subscriber = new Flow.Subscriber&lt;String&gt;() &#123;            private Flow.Subscription subscription;            @Override            public void onSubscribe(Flow.Subscription subscription) &#123;                // 保存订阅关系，需要用它来给发布者响应                this.subscription = subscription;                // 请求一个数据                this.subscription.request(1);            &#125;            @Override            public void onNext(String item) &#123;                // 接收到一个数据，处理                System.out.println(&quot;接收到数据：&quot; + item);                // 处理完调用request再请求一个数据                this.subscription.request(1);                // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了                // this.subscription.cancel();            &#125;            @Override            public void onError(Throwable throwable) &#123;                // 出现了异常（例如处理数据的时候产生了异常）                throwable.printStackTrace();                // 告诉发布者，后边不接受数据了                this.subscription.cancel();            &#125;            @Override            public void onComplete() &#123;                // 发布者close时触发                System.out.println(&quot;处理完了&quot;);            &#125;        &#125;;        // 5. 处理器和最终订阅者建立订阅关系        processor.subscribe(subscriber);        // 6. 生产数据，并发布        // 这里忽略数据生产过程        publisher.submit(-111);        publisher.submit(111);        // 5. 结束后，关闭发布者        // 正式环境应该放finally确保关闭        // processor.close();        publisher.close();        // 主线程延迟停止，否则数据没有消费就退出        try &#123;            Thread.currentThread().join(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;/** * 输入源数据 Integer，过滤掉小于0的，然后转换成字符串发布出去 */class MyProcessor extends SubmissionPublisher&lt;String&gt; implements Flow.Processor&lt;Integer, String&gt;&#123;    private Flow.Subscription subscription;    @Override    public void onSubscribe(Flow.Subscription subscription) &#123;        // 保存订阅关系，需要用它来给发布者响应        this.subscription = subscription;        // 请求一个数据        this.subscription.request(1);    &#125;    @Override    public void onNext(Integer integer) &#123;        // 接收到一个数据，处理        System.out.println(&quot;处理器接收到数据：&quot; + integer);        // 过滤掉小于0的数据，然后发布出去        if(integer &gt; 0)&#123;            this.submit(&quot;转换后的数据：&quot; + integer);        &#125;        // 处理完成，调用request再请求一个数据        this.subscription.request(1);        // 或者已经达到了目标，调用 cancel 告诉发布者不再接收数据了        // this.subscription.cancel();    &#125;    @Override    public void onError(Throwable throwable) &#123;        // 出现了异常（例如处理数据的时候产生了异常）        throwable.printStackTrace();        // 告诉发布者，后边不接受数据了        this.subscription.cancel();    &#125;    @Override    public void onComplete() &#123;        // 发布者close时触发        System.out.println(&quot;处理器处理完了&quot;);    &#125;&#125;</code></pre><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><pre><code class="java">// 是阻塞函数。缓冲池满了就不再生产数据publisher.submit(data);</code></pre><h2 id="第五章-RxJava2-响应式编程"><a href="#第五章-RxJava2-响应式编程" class="headerlink" title="第五章  RxJava2-响应式编程"></a>第五章  RxJava2-响应式编程</h2><h3 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h3><p>RxJava = Observer + 异步处理</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;    &lt;artifactId&gt;rxjava&lt;/artifactId&gt;    &lt;version&gt;2.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code class="java">import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.functions.Consumer;import io.reactivex.schedulers.Schedulers;public class HelloRx &#123;    public static void main(String[] args) &#123;        // 事件源(被观察者)        Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;                emitter.onNext(&quot;hello&quot;);                emitter.onNext(&quot;www.monkeykong.github.io&quot;);                emitter.onNext(&quot;let`s study!&quot;);            &#125;        &#125;);        // 消费者（观察者）        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;            public void accept(String s) throws Exception &#123;                System.out.println(Thread.currentThread().getName() + &quot;== consumer == &quot; + s);            &#125;        &#125;;        // 观察者        Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;            @Override            public void onSubscribe(Disposable disposable) &#123;            &#125;            @Override            public void onNext(String s) &#123;                System.out.println(Thread.currentThread().getName() + &quot;== observer == &quot; + s);            &#125;            @Override            public void onError(Throwable throwable) &#123;            &#125;            @Override            public void onComplete() &#123;            &#125;        &#125;;        // 耦合        // observable.subscribe(consumer);        // 异步        observable.observeOn(Schedulers.newThread()).subscribe(consumer);        observable.observeOn(Schedulers.newThread()).subscribe(observer);        for (;;);    &#125;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5b17560e6fb9a01e2862246f">https://juejin.im/post/5b17560e6fb9a01e2862246f</a></p><h2 id="第五章-SpingWebFlux"><a href="#第五章-SpingWebFlux" class="headerlink" title="第五章 SpingWebFlux"></a>第五章 SpingWebFlux</h2><p>待学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 讲义进阶之函数式编程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java讲义" scheme="http://yoursite.com/tags/Java%E8%AE%B2%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 学习(一)</title>
    <link href="http://yoursite.com/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html"/>
    <id>http://yoursite.com/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html</id>
    <published>2020-11-30T14:13:12.000Z</published>
    <updated>2020-12-07T13:46:48.665Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScipt 学习。</p><a id="more"></a><h2 id="环境和-HelloWorld"><a href="#环境和-HelloWorld" class="headerlink" title="环境和 HelloWorld"></a>环境和 HelloWorld</h2><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><pre><code class="shell">-- 安装 node-- 安装 typescriptnpm install typescript -g</code></pre><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><pre><code class="typescript">function jspang() &#123;  let web: string = &quot;Hello World&quot;  console.log(web)&#125;// ts-nodejspang()</code></pre><p><strong>执行：</strong></p><pre><code class="sh"># 编译，完成会生成 Demo1.jstsc Demo1.ts# 执行node Demo1.js</code></pre><p><strong>简易执行：</strong></p><pre><code class="shell"># 安装 ts-nodenpm install -g ts-node# 直接用 ts-node 执行，省去编译命令ts-node Demo1.ts</code></pre><h2 id="TypeScript-静态类型"><a href="#TypeScript-静态类型" class="headerlink" title="TypeScript 静态类型"></a>TypeScript 静态类型</h2><p>一旦定义不可再改变。</p><pre><code class="typescript">let count: number = 1;// 编译报错// count = &#39;alvin&#39;;count = 2;</code></pre><p>自定义静态类型：</p><pre><code class="typescript">// 定义接口,相当于自定义一个静态类型interface XiaoJieJie &#123;  uname: string,  age: number&#125;const xiaohong: XiaoJieJie = &#123;  uname: &#39;xiaohong&#39;,  age: 18&#125;console.log(xiaohong.age)</code></pre><p><strong>对象静态类型：</strong></p><pre><code class="typescript">// 对象类型const xiaojiejie: &#123;  name: string,  age: number&#125; = &#123;  name: &#39;大脚&#39;,  age: 18&#125;// 数组类型const xiaojiejies: string[] = [&#39;谢大脚&#39;, &#39;留影&#39;, &#39;123&#39;]// 对象类型class Person &#123; &#125;const dajiao: Person = new Person()const jianxiaojiejie: () =&gt; string = () =&gt; &#123; return &#39;大叫&#39; &#125;// 对象类型 数组类型 类类型 函数类型</code></pre><h2 id="类型注解和类型推断"><a href="#类型注解和类型推断" class="headerlink" title="类型注解和类型推断"></a>类型注解和类型推断</h2><pre><code class="typescript">// type annotation 类型注解// type reference 类型推断// 类型注解。声明变量类型let count1: number;count1 = 123;// 类型推断。自动推断类型let countReference = 1;// 潜规则// 1. 能够自动分析的，无需写类型// 2. 不能自动分析得到类型的，使用类型注解function getTotal(one: number, two: number) &#123;  return one + two;&#125;const total = getTotal(1, 2)</code></pre><h2 id="返回类型注解"><a href="#返回类型注解" class="headerlink" title="返回类型注解"></a>返回类型注解</h2><pre><code class="typescript">// 指定函数返回类型function getTotal2(one: number, two: number): number &#123;  return one + two;&#125;const total2 = getTotal2(1, 2)function sayHello(): void &#123;  console.log(&#39;Hello World&#39;)&#125;function errorFunction(): never &#123;  throw new Error()  console.log(&#39;Hello World&#39;);&#125;function forNeer(): never &#123;  while (true) &#123; &#125;  console.log(&#39;Hi&#39;);&#125;// 指定对象的属性类型，必须这样function add(&#123; one, two &#125;: &#123; one: number, two: number &#125;) &#123;  return one + two&#125;const tatal3 = add(&#123; one: 1, two: 2 &#125;)</code></pre><h2 id="数组类型注解"><a href="#数组类型注解" class="headerlink" title="数组类型注解"></a>数组类型注解</h2><pre><code class="typescript">// 数组类型注解const numberArr = [1, 2, 3]const numberArr2: number[] = [1, 2, 3]const stringArr: string[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]const undefinedArr: undefined[] = [undefined, undefined]const arr: (number | string)[] = [1, &#39;string&#39;, 2]const xiaojiejies6: &#123; name: string, age: number &#125;[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]// type alias 类型别名type Lady = &#123; name: string, age: number &#125;const xiaojiejies61: Lady[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]// class 形式也可以class Madam &#123;  name: string;  age: number;&#125;const xiaojiejies62: Madam[] = [  &#123; name: &#39;liuying&#39;, age: 18 &#125;,  &#123; name: &#39;谢大脚&#39;, age: 28 &#125;]</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><pre><code class="typescript">// 元组学习// 数组无法识别数组元素类型的顺序const xiaojiejie7: (string | number)[] = [&#39;dajiao&#39;, &#39;teacher&#39;, 18]// 元组，可以校验顺序const xiaojiejie71: [string, string, number] = [&#39;dajiao&#39;, &#39;teacher&#39;, 18]</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code class="typescript">const screenResume = (name: string, age: number, bust: number) =&gt; &#123;  age &lt; 24 &amp;&amp; bust &gt;= 90 &amp;&amp; console.log(name + &#39;进入面试&#39;)  age &gt;= 23 || bust &lt; 90 &amp;&amp; console.log(name + &#39;你被淘汰&#39;)&#125;const getResume = (name: string, age: number, bust: number) =&gt; &#123;  console.log(name + &#39;年龄是&#39; + age)  console.log(name + &#39;胸围是&#39; + bust)&#125;screenResume(&#39;大脚&#39;, 18, 94)getResume(&#39;大脚&#39;, 18, 94)// 使用接口进行优化interface Girl &#123;  name: string;  age: number;  bust: number;  waistline?: number;&#125;const girl = &#123;  name: &#39;大脚&#39;,  age: 18,  bust: 94,  waistline: 21&#125;const screenResume1 = (girl: Girl) =&gt; &#123;  girl.age &lt; 24 &amp;&amp; girl.bust &gt;= 90 &amp;&amp; console.log(girl.name + &#39;进入面试&#39;)  girl.age &gt;= 23 || girl.bust &lt; 90 &amp;&amp; console.log(girl.name + &#39;你被淘汰&#39;)&#125;const getResume1 = (girl: Girl) =&gt; &#123;  console.log(girl.name + &#39;年龄是&#39; + girl.age)  console.log(girl.name + &#39;胸围是&#39; + girl.bust)  girl.waistline &amp;&amp; console.log(girl.name + &#39;腰围是&#39; + girl.waistline)&#125;screenResume1(girl)getResume1(girl)</code></pre><h2 id="接口约束类"><a href="#接口约束类" class="headerlink" title="接口约束类"></a>接口约束类</h2><pre><code class="typescript">// 定义一个类interface Girl &#123;  name: string,  age: number,  bust: number,  yaowei?: number,  [propname: string]: any,  say(): string&#125;// 用接口来约束类class XiaoJieJie implements Girl &#123;  name: string;  age: number;  bust: number;  say() &#123;    return &quot;欢迎光临，我是&quot; + this.name + &quot;！&quot;  &#125;&#125;// 定义一个对象const xiaohong = new XiaoJieJie();xiaohong.age = 22;xiaohong.name = &#39;小红&#39;;xiaohong.bust = 98;// 使用对象console.info(xiaohong.say());// 类继承class Teacher extends XiaoJieJie &#123;  teach(): string &#123;    return &#39;我来教你做&#39;;  &#125;&#125;const xiaomei = new Teacher();console.info(xiaomei.teach());</code></pre><h2 id="类的继承、重写和-super"><a href="#类的继承、重写和-super" class="headerlink" title="类的继承、重写和 super"></a>类的继承、重写和 super</h2><pre><code class="typescript">// 类的继承、重写和 superclass Lady &#123;  sayHi() &#123;    return &quot;Hi！帅哥。&quot;  &#125;&#125;class Beauty extends Lady &#123;  sayHi() &#123;    return super.sayHi() + &quot;你好。&quot;  &#125;  sayLove() &#123;    return &#39;I love you.&#39;;  &#125;&#125;console.info(new Beauty().sayHi())</code></pre><h2 id="类的访问类型"><a href="#类的访问类型" class="headerlink" title="类的访问类型"></a>类的访问类型</h2><pre><code class="typescript">// 类的访问类型// public 公共的// private 私有的（类内部）// protected 继承类class Person &#123;  public name: string;  private age: number;  protected hobby: string;&#125;class Man extends Person &#123;  say() &#123;    console.info(this.name);    // 报错    //console.info(this.age);    console.info(this.hobby);  &#125;&#125;const p11 = new Person();console.info(p11.name);// 报错//console.info(p11.age);// 报错//console.info(p11.hobby);</code></pre><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><pre><code class="typescript">class Person121 &#123;  public name: string;  constructor(name: string) &#123;    this.name = name;  &#125;&#125;class Person12 &#123;  constructor(public name: string) &#123;    console.info(&quot;111&quot;)  &#125;&#125;class Teacher12 extends Person12 &#123;  constructor() &#123;    console.info(&quot;000&quot;)    // 子类必须调用父类的构造函数    super(&quot;Alvin&quot;);    console.info(&quot;222&quot;)  &#125;&#125;console.log(new Person121(&#39;alvin&#39;).name)console.log(new Person12(&#39;alvin&#39;).name)console.log(new Teacher12().name)</code></pre><h2 id="getter、setter-和静态属性"><a href="#getter、setter-和静态属性" class="headerlink" title="getter、setter 和静态属性"></a>getter、setter 和静态属性</h2><pre><code class="typescript">// getter、setter和静态属性class Person13 &#123;  constructor(private _age: number) &#123; &#125;  get age() &#123;    return this._age;  &#125;  set age(age: number) &#123;    this._age = age;  &#125;  static sayHi() &#123;    console.info(&quot;Hi.&quot;)  &#125;&#125;const p13 = new Person13(20);console.info(p13.age);p13.age = 18;console.info(p13.age);// 报错// p13._age = 10;console.info(Person13.sayHi())</code></pre><h2 id="抽象类和只读属性"><a href="#抽象类和只读属性" class="headerlink" title="抽象类和只读属性"></a>抽象类和只读属性</h2><pre><code class="typescript">// 只读属性、抽象类class Person14 &#123;  public readonly _money: number;  constructor(money: number) &#123;    this._money = money;  &#125;&#125;const p14 = new Person14(123);console.info(p14._money)// 报错//p14._money = 122abstract class Person141 &#123;  abstract say(): string;&#125;class Person1411 extends Person141 &#123;  say() &#123;    return &quot;111&quot;  &#125;&#125;class Person1412 extends Person141 &#123;  say() &#123;    return &quot;222&quot;  &#125;&#125;console.info(new Person1411().say())console.info(new Person1412().say())</code></pre><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><pre><code class="json"># 生成 tsconfig.json 文件tsc -init# 设置编译时取出注释&quot;removeComments&quot;: true,# 执行编译tsc Demo15.ts# 发现生成的 js 还是有注释# 这样就好了tsc</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;TypeScipt 学习。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Flex 布局实战</title>
    <link href="http://yoursite.com/2020-11-15-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98.html"/>
    <id>http://yoursite.com/2020-11-15-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98.html</id>
    <published>2020-11-15T14:13:12.000Z</published>
    <updated>2020-11-24T14:51:11.298Z</updated>
    
    <content type="html"><![CDATA[<p>Flex 布局基础概念和语法。</p><a id="more"></a><pre><code class="css">justify-content: space-between;flex-direction: cloumn;justify-content: space-between;align-items: center;flex-direction: column;align-self: center;flex-wrap: wrap;justify-content: flex-end;align-content: space-between;justify-content: space-between;alignn-content: space-between;.column &#123;    flex-directon: column;    justify-content: space-between;&#125;.item &#123;    justify-content: space-between;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flex 布局基础概念和语法。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="flex" scheme="http://yoursite.com/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（六）</title>
    <link href="http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%806-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%806-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</id>
    <published>2020-11-08T15:13:12.000Z</published>
    <updated>2020-11-24T14:50:37.801Z</updated>
    
    <content type="html"><![CDATA[<p>链表常见问题</p><a id="more"></a><h2 id="1、原则和常用数据结构与技巧"><a href="#1、原则和常用数据结构与技巧" class="headerlink" title="1、原则和常用数据结构与技巧"></a>1、原则和常用数据结构与技巧</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li><p>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p></li><li><p>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p></li></ul><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><ul><li>使用容器（哈希表、数组等）</li><li>快慢指针</li></ul><h2 id="2、-快慢指针"><a href="#2、-快慢指针" class="headerlink" title="2、 快慢指针"></a>2、 快慢指针</h2><p>总体都是快指针一次跳两步，慢指针一次一步。通过调整起始边界解决不同场景。</p><p><strong>如果不在乎空间复杂度，比如笔试时，可以不用快慢指针，直接使用有序表。</strong></p><p>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</p><pre><code class="java">// 奇数长度返回中点，偶数长度返回上中点public static Node midOrUpMidNode(Node h) &#123;    // null、一个、两个节点均返回 h    if (h == null || h.next == null || h.next.next == null) &#123;        return h;    &#125;    // 大于等于三个节点    Node slow = h.next;    Node fast = h.next.next;    while (fast.next != null &amp;&amp; fast.next.next != null) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    return slow;&#125;public static Node right1(Node h) &#123;    if (h == null) &#123;        return null;    &#125;    Node cur = h;    ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();    while (cur != null) &#123;        arr.add(cur);        cur = cur.next;    &#125;    // 6个：(6-1)/2=&gt;2 (7-1)/2=&gt;3    return arr.get((arr.size() - 1)/2);&#125;</code></pre><p>2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</p><pre><code class="java">// 奇数长度返回中点，偶数长度返回下中点public static Node midOrDownMidNode(Node h) &#123;    // null、一个均返回 h    if (h == null || h.next == null) &#123;        return h;    &#125;    // 大于等于两个节点    Node slow = h.next;    Node fast = h.next;    while (fast.next != null &amp;&amp; fast.next.next != null) &#123;        slow = slow.next;        fast = fast.next.next;    &#125;    return slow;&#125;public static Node right2(Node h) &#123;    if (h == null) &#123;        return null;    &#125;    Node cur = h;    ArrayList&lt;Node&gt; arr = new ArrayList&lt;&gt;();    while (cur != null) &#123;        arr.add(cur);        cur = cur.next;    &#125;    // 6个：6/2=&gt;3 7/2=&gt;3    return arr.get(arr.size()/2);&#125;</code></pre><p>3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</p><p>4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</p><h2 id="3、判断链表是否为回文结构"><a href="#3、判断链表是否为回文结构" class="headerlink" title="3、判断链表是否为回文结构"></a>3、判断链表是否为回文结构</h2><p>问题：给定一个单链表的头节点head，请判断该链表是否为回文结构。 </p><p>1）栈方法特别简单（笔试用）</p><p>2）改原链表的方法就需要注意边界了（面试用）</p><h2 id="4、单链表荷兰国旗问题"><a href="#4、单链表荷兰国旗问题" class="headerlink" title="4、单链表荷兰国旗问题"></a>4、单链表荷兰国旗问题</h2><p>问题：将单向链表按某值划分成左边小、中间相等、右边大的形式</p><p>1）把链表放入数组里，在数组上做 partition（笔试用）</p><pre><code class="java">public static Node listPartition1(Node h, int pivot) &#123;    if (h == null || h.next == null) &#123;        return h;    &#125;    // 取链表节点数量    Node cur = h;    int size = 0;    while (cur != null) &#123;        size++;        cur = cur.next;    &#125;    // 链表节点放入数组    cur = h;    Node[] nodeArr = new Node[size];    nodeArr[0] = h;    for (int i = 1; i &lt; size; i++) &#123;        nodeArr[i] = cur.next;        cur = cur.next;    &#125;    // 对数组做 partition    partition(nodeArr, pivot);    // 数组数据构造节点    for (int i = 0; i &lt; size-1; i++) &#123;        nodeArr[i].next = nodeArr[i+1];    &#125;    nodeArr[size-1].next = null;    return nodeArr[0];&#125;private static void partition(Node[] nodeArr, int pivot) &#123;    if (nodeArr == null || nodeArr.length &lt;= 1) &#123;        return;    &#125;    int less = -1;    int more = nodeArr.length;    int i = 0;    while (i&lt;more) &#123;        // 发往小于区        if (nodeArr[i].value &lt; pivot) &#123;            swap(nodeArr, i++, ++less);            // 发往大于区        &#125; else if (nodeArr[i].value &gt; pivot) &#123;            swap(nodeArr, i, --more);        &#125; else &#123;            i++;        &#125;    &#125;&#125;</code></pre><p>2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</p><p>定义六个指针，分别表示三个部分。</p><pre><code class="java">// 定义6个指针public static Node listPartition2(Node h, int pivot) &#123;    if (h == null || h.next == null) &#123;        return h;    &#125;    Node sH = null; // 小于区 head    Node sT = null; // 小于区 tail    Node eH = null; // 等于区 head    Node eT = null; // 等于去 tail    Node mH = null; // 大于区 head    Node mT = null; // 大于区 tail    Node cur = h;    Node next = null;    // 把链表节点分为三个区    while (cur != null) &#123;        next = cur.next;        cur.next = null;        // 加入小于区        if (cur.value &lt; pivot) &#123;            if (sH == null) &#123;                sH = cur;                sT = cur;            &#125; else &#123;                sT.next = cur;                sT = cur;            &#125;            // 加入等于区        &#125; else if (cur.value == pivot) &#123;            if (eH == null) &#123;                eH = cur;                eT = cur;            &#125; else &#123;                eT.next = cur;                eT = cur;            &#125;            // 加入大于区        &#125; else &#123;            if (mH == null) &#123;                mH = cur;                mT = cur;            &#125; else &#123;                mT.next = cur;                mT = cur;            &#125;        &#125;        cur = next;    &#125;    // 三个区连接起来    if (sT != null) &#123; // 有小于区        if (eH != null) &#123; // 有等于区            sT.next = eH;            if (mH != null) &#123; // 有大于区                eT.next = mH;            &#125; // 没有大于区，不做处理        &#125; else if (mH != null) &#123; // 没有等于区，但是有大于区            sT.next = mH;        &#125; // 没有等于区也没有大于区，不做处理    &#125; else if (eH != null) &#123; // 没有小区区，但是有等于区        eT.next = mH; // 有大于区没有大于区一样赋值    &#125;    return sH != null ? sH : (eH != null ? eH : mH);&#125;</code></pre><h2 id="5、深度复制"><a href="#5、深度复制" class="headerlink" title="5、深度复制"></a>5、深度复制</h2><p>一种特殊的单链表节点类描述如下 </p><pre><code class="java">class Node &#123;     int value;     Node next;     Node rand;     Node(int val) &#123;         value = val;     &#125; &#125; </code></pre><p>rand 指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。</p><p>给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。 </p><p>【要求】</p><p>时间复杂度O(N)，额外空间复杂度O(1) </p><pre><code class="java">// 哈希表实现 时间复杂度：O(N) 额外空间复杂度：O(N)public static Node copyListWithRandomByMap(Node head) &#123;    // 1. 遍历链表。把链表数据放进哈希表(key:原节点,value:复制节点)    Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;();    Node cur = head;    while (cur != null) &#123;        map.put(cur, new Node(cur.value));        cur = cur.next;    &#125;    // 2. 再次遍历链表。维护复制节点 next 指针    cur = head;    while (cur != null) &#123;        // 复制节点的 next 为当前节点的 next 的复制节点        map.get(cur).next = map.get(cur.next);        // 复制节点的 rand 为当前节点的 rand 的复制节点        map.get(cur).rand = map.get(cur.rand);        cur = cur.next;    &#125;    // 3. head 的复制节点就是新头部    return map.get(head);&#125;</code></pre><pre><code class="java">// 有限指针实现 时间复杂度：O(N) 额外空间复杂度：O(1)public static Node copyListWithRandomByVar(Node head) &#123;    if (head == null) &#123;        return null;    &#125;    // 1. 遍历链表，把复制节点连接到原节点之后    Node cur = head;    Node next = null;    while (cur != null) &#123;        next = cur.next;        // 新节点插入当前节点之后        // 注意这里是取 cur.value 而不是 next，否则你复制的是下一个节点        cur.next = new Node(cur.value);        cur.next.next = next;        // 注意这里是 cur=next 而不是 cur=cur.next，因为 cur 后面插入了新节点        cur = next;    &#125;    // 2. 遍历链表，维护复制节点的 rand 指针    cur = head;    while (cur != null) &#123;        // 复制节点的 rand = 原节点的 rand 的 next        // 注意要判空        cur.next.rand = cur.rand == null ? null : cur.rand.next;        cur = cur.next.next; // 这里要一次走两步    &#125;    // 3. 遍历链表，还原原来的链表    Node copyHead = head.next;    cur = head;    Node cur2 = null;    while (cur != null) &#123;        // 当前节点的下一跳        next = cur.next.next;        // 当前节点的复制节点        cur2 = cur.next; // cur2 不可能为空，因为 cur 不为空        // 设置当前节点 next        cur.next = next;        // 设置复制节点 next        // 注意判空。        cur2.next = next == null ? null : next.next;        cur = next;    &#125;    return copyHead;&#125;</code></pre><h2 id="6、单链表交叉问题"><a href="#6、单链表交叉问题" class="headerlink" title="6、单链表交叉问题"></a>6、单链表交叉问题</h2><p><a href="https://t.me/proxy?server=47.242.50.61&amp;port=443&amp;secret=eeaac78508e450d9afa37e46eec7d1fee1617a7572652e6d6963726f736f66742e636f6d">https://t.me/proxy?server=47.242.50.61&amp;port=443&amp;secret=eeaac78508e450d9afa37e46eec7d1fee1617a7572652e6d6963726f736f66742e636f6d</a></p><p>给定两个可能有环也可能无环的单链表，头节点 head1 和 head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回 null </p><p>【要求】</p><ul><li>如果两个链表长度之和为 N，时间复杂度请达到 O(N)，额外空间复杂度 请达到 O(1)。 </li></ul><p>【思路】</p><ul><li>要么两个链表都有环，要么两个链表都无环。不存在一个有环和一个无环的单链表进行相交。</li><li>求单链表第一个入环节点，无环返回 null。loop1、loop2<ul><li>n1=head.next n2=head.next.next，n1 为慢指针，n2 为快指针</li><li>n1、n2 第一次相遇时。快指针回到 head，n2 = head</li><li>n1、n2 全部变为慢指针，下一次 n1、n2 相遇肯定是入环点</li></ul></li><li>求无环单链表第一个相交节点，不相交返回 null。（loop1==loop2==null）<ul><li>哈希表实现<ul><li>两个链表节点依次放入 Set 集合中，如果已经存在，则该节点就是第一个交点</li></ul></li><li>指针实现<ul><li>求出两个链表的长度差</li><li>长的链表先走掉长的部分</li><li>然后两个链表一起走，如果存在相等的节点则相交</li></ul></li></ul></li><li>已知两个有环单链表的入环节点 loop1、loop2，求有环单链表第一个相交节点，不相交返回 null。（loop1 != null &amp;&amp; loop2 != null）<ul><li>如果两个有环单链表相交，肯定共用一个环</li><li>在相同节点入环（ loop1 == loop2）：以入环点作为终点，求解过程和两个单链表一样的了</li><li>不相交：如果 loop1 不是链表2 中的节点，说明两个链表不相交，返回 null</li><li>在不同节点入环（loop1 != loop2）:随便返回 loop1、loop2，因为在环上</li></ul></li></ul><h2 id="7、无头删除节点问题"><a href="#7、无头删除节点问题" class="headerlink" title="7、无头删除节点问题"></a>7、无头删除节点问题</h2><p>能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表常见问题&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（五）</title>
    <link href="http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%805-%E5%89%8D%E7%BC%80%E6%A0%91_%E6%A1%B6%E6%8E%92%E5%BA%8F_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"/>
    <id>http://yoursite.com/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%805-%E5%89%8D%E7%BC%80%E6%A0%91_%E6%A1%B6%E6%8E%92%E5%BA%8F_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html</id>
    <published>2020-11-08T14:13:12.000Z</published>
    <updated>2020-11-24T14:50:25.301Z</updated>
    
    <content type="html"><![CDATA[<p>前缀树和桶排序。</p><a id="more"></a><h2 id="1、前缀树"><a href="#1、前缀树" class="headerlink" title="1、前缀树"></a>1、前缀树</h2><p>1）单个字符串中，字符从前到后的加到一棵多叉树上</p><p>2）字符放在路上，节点上有专属的数据项（常见的是 pass 和 end 值）</p><p>3）所有样本都这样添加，如果没有路就新建，如有路就复用</p><p>4）沿途节点的 pass 值增加 1，每个字符串结束时来到的节点 end 值增加 1</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/5/%E5%89%8D%E7%BC%80%E6%A0%91.png"></p><p>1）固定数组实现</p><p>2）哈希表实现</p><pre><code class="java">public static class Node2 &#123;    int p;    int e;    HashMap&lt;Integer, Node2&gt; paths;    public Node2() &#123;        p = 0;        e = 0;        // key：字符串 Acssic 码        // paths[i] == null 表示没路        paths = new HashMap&lt;&gt;();    &#125;&#125;/**     * map 做路劲，可以无数条     */public static class Trie2 &#123;    Node2 root;    public Trie2() &#123;        root = new Node2();    &#125;    public void insertStr(String str) &#123;        if (str == null) &#123;            return;        &#125;        Node2 curNode = root;        curNode.p++;        char[] chars = str.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            // 为null说明是新路            if (!curNode.paths.containsKey((int)chars[i])) &#123;                curNode.paths.put((int) chars[i], new Node2());            &#125;            // 注意先跳到下一个节点，然后再 p++            curNode = curNode.paths.get((int)chars[i]);            curNode.p++;        &#125;        curNode.e++;    &#125;    public int searchStr(String str) &#123;        if (str == null) &#123;            return 0;        &#125;        Node2 curNode = root;        char[] chars = str.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            // 没有路，肯定为 0            if (!curNode.paths.containsKey((int)chars[i])) &#123;                return 0;            &#125;            curNode = curNode.paths.get((int)chars[i]);        &#125;        return curNode.e;    &#125;    public void deleteStr(String str) &#123;        // 树中存在字符串才处理        if (searchStr(str) &gt; 0) &#123;            Node2 curNode = root;            // 要记得 p--            curNode.p--;            char[] chars = str.toCharArray();            for (int i = 0; i &lt; chars.length; i++) &#123;                if(--curNode.paths.get((int)chars[i]).p == 0) &#123;                    // p 为 0 了，后边就无需遍历了，直接设置为 null                    curNode.paths.remove((int)chars[i]);                    return;                &#125;                curNode = curNode.paths.get((int)chars[i]);            &#125;            curNode.e--;        &#125;    &#125;    public int prefixCount(String pre) &#123;        if (pre == null) &#123;            return 0;        &#125;        Node2 curNode = root;        char[] chars = pre.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            if (!curNode.paths.containsKey((int)chars[i])) &#123;                return 0;            &#125;            curNode = curNode.paths.get((int)chars[i]);        &#125;        return curNode.p;    &#125;&#125;</code></pre><h2 id="2、不基于比较的排序"><a href="#2、不基于比较的排序" class="headerlink" title="2、不基于比较的排序"></a>2、不基于比较的排序</h2><p>桶排序思想下的排序：<strong>计数排序和基数排序</strong></p><p>1)桶排序思想下的排序都是不基于比较的排序</p><p>2)时间复杂度为O(N)，额外空间负载度O(M)</p><p>3)应用范围有限，需要样本的数据状况满足桶的划分。一旦要求稍有升级，改写的代价增加是显而易见的。</p><h3 id="2-1-计数排序"><a href="#2-1-计数排序" class="headerlink" title="2.1 计数排序"></a>2.1 计数排序</h3><p><strong>要求：样本是整数，且范围比较窄</strong></p><p>思路：统计词频，然后倒出来。</p><pre><code class="java">// only for 0~200 valuepublic static void countSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    int max = Integer.MIN_VALUE;    for (int i = 0; i &lt; arr.length; i++) &#123;        max = Math.max(max, arr[i]);    &#125;    int[] countArr = new int[max+1];    for (int i = 0; i &lt; arr.length; i++) &#123;        countArr[arr[i]]++;    &#125;    // [0,2,2,3]    // 1 1 2 2 3 3 3    int index = 0;    for (int i = 0; i &lt; countArr.length; i++) &#123;        // 有 countArr[i] 个 i        for (int j = 0; j &lt; countArr[i]; j++) &#123;            arr[index++] = i;        &#125;    &#125;&#125;</code></pre><h3 id="2-2-基数排序"><a href="#2-2-基数排序" class="headerlink" title="2.2 基数排序"></a>2.2 基数排序</h3><p><strong>要求：样本是10进制的正整数</strong></p><p>思路：</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/5/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png"></p><p>不创建十个队列桶，而是用辅助数组实现入桶和出桶操作：</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/5/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A1%B6.png"></p><pre><code class="java">// only for non-nagetivepublic static void radixSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    // 获取最大值位数    int bitCount = getBitCount(arr);    radixSort(arr, 0, arr.length-1, bitCount);&#125;private static void radixSort(int[] arr, int l, int r, int bitCount) &#123;    // 1:个位 2:十位 3:百位 ...    for (int i = 1; i &lt;= bitCount; i++) &#123;        // 构造 count1        int[] countArr = new int[10];        for (int j = l; j &lt;= r; j++) &#123;            int bitValue = getBitValue(arr[j], i);            countArr[bitValue]++;        &#125;        // 推算 count2        for (int j = 1; j &lt; countArr.length; j++) &#123;            countArr[j] += countArr[j-1];        &#125;        // 创建help数组        int[] help = new int[r-l+1];        for (int j = r; j &gt;= l; j--) &#123;            // 得到个位/十位/百位...数是几            int bitValue = getBitValue(arr[j], i);            // 得到个位/十位/百位...小于等于当前数的个数            int lessCurCount = countArr[bitValue];            help[lessCurCount-1] = arr[j];            countArr[bitValue]--;        &#125;        // help 数组还原到 arr        for (int j = 0; j &lt; help.length; j++) &#123;            arr[l+j] = help[j];        &#125;    &#125;&#125;/**     * 获取指定位数     */private static int getBitValue(int value, int bit) &#123;    return (value/((int)Math.pow(10, bit  - 1)))%10;&#125;private static int getBitCount(int[] arr) &#123;    int maxValue = arr[0];    for (int i = 1; i &lt; arr.length; i++) &#123;        if (arr[i] &gt; maxValue) &#123;            maxValue = arr[i];        &#125;    &#125;    int bitCount = 1;    int tmp = maxValue/10;    while (tmp &gt; 0) &#123;        bitCount++;        tmp = tmp/10;    &#125;    return bitCount;&#125;</code></pre><h2 id="3、排序算法的稳定性"><a href="#3、排序算法的稳定性" class="headerlink" title="3、排序算法的稳定性"></a>3、排序算法的稳定性</h2><p>稳定性是指同样大小的样本在排序之后不会改变相对次序。</p><p>对基础类型来说，稳定性毫无意义。</p><p>对非基础类型来说，稳定性有重要意义。</p><p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的。</p><h2 id="4、排序算法总结"><a href="#4、排序算法总结" class="headerlink" title="4、排序算法总结"></a>4、排序算法总结</h2><table><thead><tr><th></th><th>时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td>O(N^2)</td><td>O(1)</td><td>无</td></tr><tr><td>冒泡排序</td><td>O(N^2)</td><td>O(1)</td><td>有</td></tr><tr><td>插入排序</td><td>O(N^2)</td><td>O(1)</td><td>有</td></tr><tr><td>归并排序</td><td>O(N*logN)</td><td>O(N)</td><td>有</td></tr><tr><td>随机快排</td><td>O(N*logN)</td><td>O(logN)</td><td>无</td></tr><tr><td>堆排序</td><td>O(N*logN)</td><td>O(1)</td><td>无</td></tr><tr><td>计数排序</td><td>O(N)</td><td>O(M)</td><td>有</td></tr><tr><td>基数排序</td><td>O(N)</td><td>O(N)</td><td>有</td></tr></tbody></table><ul><li>不基于比较的排序，对样本数据有严格要求，不易改写</li><li>基于比较得到排序，只要规定好两个样本怎么比较大小就可以直接复用</li><li>基于比较的排序，时间复杂度的极限是 O(N*logN)</li><li>时间复杂度为 O(N*logN)，额外空间复杂度低于O(N)，并且稳定的基于比较的排序是不存在的</li><li>为了绝对的速度选择快排、为了省空间选择堆排、为了稳定性选择归并</li></ul><h2 id="5、常见的坑"><a href="#5、常见的坑" class="headerlink" title="5、常见的坑"></a>5、常见的坑</h2><p>1、归并排序的额外空间复杂度可以变为O(1)，“归并排序 内部缓存法”，但是变得不再稳定。那么为啥不直接堆排呢？没意义。</p><p>2、“原地归并排序”是垃圾帖，会让时间复杂度变为 O(N^2)。</p><p>3、快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。</p><p>4、在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始的相对次序不变。要求时间复杂度O(N)、额外空间复杂度O(1)。</p><p>​    无法实现。这里分组和快排是一个道理，分组无法做到稳定性。</p><h2 id="6、工程上对排序的改进"><a href="#6、工程上对排序的改进" class="headerlink" title="6、工程上对排序的改进"></a>6、工程上对排序的改进</h2><h3 id="6-1-稳定性考虑"><a href="#6-1-稳定性考虑" class="headerlink" title="6.1 稳定性考虑"></a>6.1 稳定性考虑</h3><p>如果排序的是基本类型，直接快排；如果是引用类型，归并排序。</p><h3 id="6-2-充分利用-O-N-logN-和O-N-2-排序各自的优势"><a href="#6-2-充分利用-O-N-logN-和O-N-2-排序各自的优势" class="headerlink" title="6.2 充分利用 O(N*logN)和O(N^2)排序各自的优势"></a>6.2 充分利用 O(N*logN)和O(N^2)排序各自的优势</h3><p>快排、归并、堆排调度优秀，所以可以做到时间复杂度O(N*logN)，但是其实常数项很高；插入排序调度不好，但是常数项低。所以可以在排块、归并等排序递归样本数小于某个值比如 60 时，直接用插入排序。这样不会改变时间复杂度，但是可以减少常数项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前缀树和桶排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（三）</title>
    <link href="http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%803-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%803-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-02T14:13:12.000Z</published>
    <updated>2020-11-24T14:49:54.270Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序和快速排序。</p><a id="more"></a><h2 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h2><h3 id="1-1-归并排序流程"><a href="#1-1-归并排序流程" class="headerlink" title="1.1 归并排序流程"></a>1.1 归并排序流程</h3><ol><li>整体是递归，左边排好序+右边排好序+merge让整体有序</li><li>让其整体有序的过程里用了排外序方法</li></ol><p><img src="../../../images/%E7%AE%97%E6%B3%95/3/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png"></p><pre><code class="java">/**     * 递归实现     * 思路：先递归拆分，然后归并。     */public static void mergeSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    process(arr, 0, arr.length - 1);&#125;private static void process(int[] arr, int L, int R) &#123;    int mid = L + ((R - L) &gt;&gt; 1);    if (L == R) &#123; // base case        return;    &#125;    process(arr, L, mid);    process(arr, mid+1, R);    merge(arr, L, mid, R);&#125;/**     * 循环实现     * 思路：循环 logN 次，每次循环从 0~N-1 分组合并。     * 组的长度从 2 开始，4，8，...     * @param arr     */public static void mergeSort2(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    int mergeSize = 1; // 左组长度    while (mergeSize &lt;= arr.length) &#123;        int L = 0;        while (L &lt;= arr.length - 1) &#123;            int mid = L + mergeSize - 1;            // 如果 mid 都已经越界，本次 mergeSize 循环结束            if (mid &gt;= arr.length - 1) &#123;                break;            &#125;            int R = L + (mergeSize&lt;&lt;1) - 1;            // 判断 R 是否越界            if (R &gt; arr.length - 1) &#123;                R = arr.length - 1;            &#125;            merge(arr, L, mid, R);            // 计算下一个 L 位置            L += mergeSize&lt;&lt;1;        &#125;        // 左组长度超过一般就已经排序完成        if (mergeSize &gt; arr.length / 2) &#123;            break;        &#125;        // 每轮乘以2        mergeSize &lt;&lt;= 1;    &#125;&#125;private static void merge(int[] arr, int L, int mid, int R) &#123;    int index = 0;    int[] tmpArr = new int[R - L + 1];    int l = L;    int r = mid + 1;    while (l &lt;= mid &amp;&amp; r &lt;= R) &#123;        tmpArr[index++] = arr[l] &gt; arr[r] ? arr[r++] : arr[l++];    &#125;    // 下面两个循环只会进一个    while (l &lt;= mid) &#123;        // 注意赋值给 tmpArr        tmpArr[index++] = arr[l++];    &#125;    while (r &lt;= R) &#123;        tmpArr[index++] = arr[r++];    &#125;    for (int i = 0; i &lt; tmpArr.length; i++) &#123;        // 注意从 L+i 开始赋值        arr[L+i] = tmpArr[i];    &#125;&#125;</code></pre><h3 id="1-2-归并排序复杂度"><a href="#1-2-归并排序复杂度" class="headerlink" title="1.2 归并排序复杂度"></a>1.2 归并排序复杂度</h3><p>T(N)=2*(T/2)+O(N^1)，所以时间复杂度为 O(N * logN )</p><p>merge 过程需要辅助数组，所以额外空间复杂度为 O(N)</p><p>归并排序的实质是把比较行为变成了有序信息传递，比O(N^2)的排序快。</p><p>O(N^2)的排序在大量浪费比较行为。归并排序没有浪费比较行为，每一轮都把有序行为固定下来了。</p><h3 id="1-3-理解归并排序"><a href="#1-3-理解归并排序" class="headerlink" title="1.3 理解归并排序"></a>1.3 理解归并排序</h3><h4 id="数组小和问题"><a href="#数组小和问题" class="headerlink" title="数组小和问题"></a>数组小和问题</h4><p>在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。</p><p>例子： [1,3,4,2,5] </p><p>1左边比1小的数：没有</p><p>3左边比3小的数：1</p><p>4左边比4小的数：1、3</p><p>2左边比2小的数：1</p><p>5左边比5小的数：1、3、4、 2</p><p>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>暴力方法直接双重循环遍历。归并思想，在 merge 时，左组和右组都是有序的，比较时就可以算出有多少个小和，即左组遍历到 A，右组有多少个数比 A 大，就有多少个 A 小和。</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/3/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C.png"></p><pre><code class="java">public static int smallSum(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return 0;    &#125;    return process(arr, 0, arr.length-1);&#125;// 求数组 arr 中， L...R 段的数组小和public static int process(int[] arr, int L, int R) &#123;    if (L == R) &#123;        return 0;    &#125;    int M = L + ((R-L)&gt;&gt;1);    int lRes = process(arr, L, M);    int rRes = process(arr, M + 1, R);    int mRes = merge(arr, L, M, R);    return lRes+rRes+mRes;&#125;// L...M 和 M+1...R 是有序的，做合并操作让 L...R 有序，并返回 L...R 数组小和public static int merge(int[] arr, int L, int M, int R) &#123;    //System.out.println(&quot;L:&quot;+L+&quot;;M:&quot;+M+&quot;;R:&quot;+R);    int[] tmpArr = new int[R-L+1];    int index = 0;    int l = L;    int r = M + 1;    int res = 0;    while (l &lt;= M &amp;&amp; r &lt;= R) &#123;        if (arr[l] &lt; arr[r]) &#123;            // 注意先计算 res，因为后面一句会改变 l            res += (R - r + 1) * arr[l];            //System.out.println(R - r + 1);            //System.out.println(arr[l]);            //System.out.println(&quot;=====================&quot;);            tmpArr[index++] = arr[l++];        &#125; else &#123;            tmpArr[index++] = arr[r++];        &#125;    &#125;    while (l &lt;= M) &#123;        tmpArr[index++] = arr[l++];    &#125;    while (r &lt;= R) &#123;        tmpArr[index++] = arr[r++];    &#125;    // 这个不能忘记，否则左组、右组没有顺序    for (int i = 0; i &lt; tmpArr.length; i++) &#123;        arr[L+i] = tmpArr[i];    &#125;    return res;&#125;</code></pre><h4 id="数组降序对个数问题"><a href="#数组降序对个数问题" class="headerlink" title="数组降序对个数问题"></a>数组降序对个数问题</h4><p>如果x&lt;y，则(x,y)是一个降序对。比如[3,1,7,0,2]降序对有(3,1)、(3,0)、(3,2)、(1,0)、(7,0)、(7,2)共6个。</p><p>分析：降序对在 merge 时产生，右组遍历到 A，左组中比 A 大的个数就是降序对的个数。</p><pre><code class="java">while (l &lt;= M &amp;&amp; r &lt;= R) &#123;    if (arr[l] &lt;= arr[r]) &#123;        tmpArr[index++] = arr[l++];    &#125; else &#123;        res += (M - l + 1);        tmpArr[index++] = arr[r++];    &#125;&#125;</code></pre><p>所以类似求某个数左侧或者右侧大于或者小于某某的和或者个数的问题可以使用归并排序的思想。</p><h2 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h2><h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><h4 id="小于区"><a href="#小于区" class="headerlink" title="小于区"></a>小于区</h4><p>给定一个数组 arr，和一个整数 num。请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边。要求额外空间复杂度 O(1)，时间复杂度O(N)。</p><p>思路：定义指针 less：小于区的右边界，初始 L - 1。遍历数组，如果 arr[i] 小于 num，把 arr[i] 发货到小于区，即 less++ 然后 less 和 i 交换。</p><pre><code class="java">public static int partition(int[] arr, int L, int R) &#123;    if (L &gt; R) &#123;        return -1;    &#125;    if (L == R) &#123;        return L;    &#125;    int less = L - 1; // 小于区为空    int num = arr[R]; // 基准    for (int i = L; i &lt; R; i++) &#123;        if (arr[i] &lt; num) &#123;            swap(arr, ++less, i);        &#125;    &#125;    swap(arr, ++less, R);    return less;&#125;</code></pre><h4 id="小于区和等于区"><a href="#小于区和等于区" class="headerlink" title="小于区和等于区"></a>小于区和等于区</h4><p>荷兰国旗问题：给定一个数组 arr，和一个整数 num。请把小于 num 的数放在数组的左边，等于num的数放在中间，大于 num 的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。</p><p>思路：和小于区思路一样，再定义一个大于区，遍历数组判断每个数应该发往哪个区。</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/3/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p><pre><code class="java">public static int[] netherlandsFlag(int[] arr, int L, int R) &#123;    if (L &gt; R) &#123;        return new int[]&#123;-1,-1&#125;;    &#125;    if (L == R) &#123;        return new int[]&#123;L,L&#125;;    &#125;    int less = L - 1; // 小于区为空    int more = R + 1; // 大于区为空    int num = arr[R]; // 基准    int index = L; // 从头开始遍历    // index 和 more 碰头时停止    while (index &lt; more) &#123;        // 比基准小，arr[index] 发往小于区，index++，因为arr[less+1]&lt;=num        if (arr[index] &lt; num) &#123;            swap(arr, ++less, index++);            // 比基准大，arr[index] 发往大于区，index不变，因为arr[more-1]?num        &#125; else if (arr[index] &gt; num) &#123;            swap(arr, index, --more);            // 与基准相等，继续下一个        &#125; else &#123;            index++;        &#125;    &#125;    return new int[]&#123;less+1, more-1&#125;;&#125;</code></pre><p>还有什么挖坑法、指针交换法，都是定义左右两个指针，要么去填坑要么去交换，虽然荷兰国旗的解法多了一个index指针，但是我觉得更容易理解。即定义一个小于区，一个大于区，遍历中间所有数字，去发货。</p><h3 id="快速排序-1-0"><a href="#快速排序-1-0" class="headerlink" title="快速排序 1.0"></a>快速排序 1.0</h3><p>在arr[L..R]范围上，进行快速排序的过程：</p><p>1）用 arr[R] 对该范围做 partition，&lt; arr[R] 的数在左部分并且保证 arr[R] 最后来到左部分的最后一个位置，记为 M； &gt;= arr[R] 的数在右部分（arr[M+1..R]）</p><p>2）对 arr[L..M-1] 进行快速排序(递归)</p><p>3）对 arr[M+1..R] 进行快速排序(递归)</p><p>因为每一次 partition 都会搞定一个数的位置且不会再变动，所以排序能完成</p><pre><code class="java">private static void process1(int[] arr, int L, int R) &#123;    // 注意这里是 &gt;=    if (L &gt;= R) &#123;        return;    &#125;    int M = partition(arr, L, R);    System.out.println(&quot;=====&gt;&quot;+M+&quot;;L:&quot;+L+&quot;;R:&quot;+R);    process1(arr, L, M-1);    process1(arr, M+1, R);&#125;</code></pre><h3 id="快速排序-2-0"><a href="#快速排序-2-0" class="headerlink" title="快速排序 2.0"></a>快速排序 2.0</h3><p>在arr[L..R]范围上，进行快速排序的过程：</p><p>1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，== arr[R]的数中间，&gt;arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]</p><p>2）对arr[L..a-1]进行快速排序(递归)</p><p>3）对arr[b+1..R]进行快速排序(递归)</p><p>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="java">private static void process2(int[] arr, int L, int R) &#123;    // 注意这里是 &gt;=    if (L &gt;= R) &#123;        return;    &#125;    int[] ints = netherlandsFlag(arr, L, R);    System.out.println(&quot;=====&gt;less:&quot;+ints[0]+&quot;;more:&quot;+ints[1]+&quot;;L:&quot;+L+&quot;;R:&quot;+R);    process2(arr, L, ints[0]-1);    process2(arr, ints[1]+1, R);&#125;</code></pre><p>数组已经有序的时候就是复杂度最高的时候。因为总体 partition 过程是 O(N)，有序时，每次只能搞定一个数，左边递归深度为 N。</p><p>时间复杂度O(N^2)</p><h3 id="快速排序-3-0"><a href="#快速排序-3-0" class="headerlink" title="快速排序 3.0"></a>快速排序 3.0</h3><p><strong>随机快排+荷兰国旗技巧优化</strong>  </p><p>在arr[L..R]范围上，进行快速排序的过程：</p><p>1）在这个范围上，随机选一个数记为num，</p><p>1）用 num 对该范围做 partition，&lt; num 的数在左部分，== num 的数中间，&gt;num 的数在右部分。假设 == num 的数所在范围是[a,b]</p><p>2）对arr[L..a-1]进行快速排序(递归)</p><p>3）对arr[b+1..R]进行快速排序(递归)</p><p>因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</p><pre><code class="java">private static void process3(int[] arr, int L, int R) &#123;    // 注意这里是 &gt;=    if (L &gt;= R) &#123;        return;    &#125;    // 将 arr[R] 随机交换    swap(arr,R,L+(int)(Math.random() * (R - L + 1)));    int[] ints = netherlandsFlag(arr, L, R);    // System.out.println(&quot;=====&gt;less:&quot;+ints[0]+&quot;;more:&quot;+ints[1]+&quot;;L:&quot;+L+&quot;;R:&quot;+R);    process3(arr, L, ints[0]-1);    process3(arr, ints[1]+1, R);&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差</p><p>2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件</p><p>3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N</p><p>4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</p><p>时间复杂度O(N*logN)，额外空间复杂度O(logN)都是这么来的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;归并排序和快速排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（四）</title>
    <link href="http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%804-%E6%AF%94%E8%BE%83%E5%99%A8_%E5%A0%86%E6%8E%92%E5%BA%8F.html"/>
    <id>http://yoursite.com/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%804-%E6%AF%94%E8%BE%83%E5%99%A8_%E5%A0%86%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-02T14:13:12.000Z</published>
    <updated>2020-11-24T14:50:07.294Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序。</p><a id="more"></a><h2 id="1、比较器"><a href="#1、比较器" class="headerlink" title="1、比较器"></a>1、比较器</h2><p>1)比较器的实质就是重载比较运算符 </p><p>2)比较器可以很好的应用在特殊标准的排序上 </p><p>3)比较器可以很好的应用在根据特殊标准排序的结构上</p><p>4)写代码变得异常容易，还用于范型编程 </p><pre><code class="java">public static class IdAscComparator implements Comparator&lt;Student &gt; &#123;    @Override    public int compare(Student o1, Student o2) &#123;        return o1.id - o2.id;    &#125;&#125;public static class AgeDescComparator implements Comparator&lt;Student &gt; &#123;    @Override    public int compare(Student o1, Student o2) &#123;        return o2.age - o1.age;    &#125;&#125;public static void main(String[] args) &#123;    Student student1 = new Student(&quot;A&quot;, 2, 20);    Student student2 = new Student(&quot;B&quot;, 3, 21);    Student student3 = new Student(&quot;C&quot;, 1, 22);    Student[] students = new Student[]&#123;student1, student2, student3&#125;;    // 自定义排序规则    // Arrays.sort(students, new IdAscComparator());    Arrays.sort(students, new AgeDescComparator());    printStudents(students);    System.out.println(&quot;=====堆==========&quot;);    // 基于 id 的小根堆    // PriorityQueue&lt;Student&gt; heap = new PriorityQueue&lt;&gt;(new IdAscComparator());    // 基于 age 的大根堆    PriorityQueue&lt;Student&gt; heap = new PriorityQueue&lt;&gt;(new AgeDescComparator());    heap.add(student1);    heap.add(student2);    heap.add(student3);    while (!heap.isEmpty()) &#123;        Student student = heap.poll();        System.out.println(&quot;Name : &quot; + student.name + &quot;, Id : &quot; + student.id + &quot;, Age : &quot; + student.age);    &#125;    System.out.println(&quot;=====有序表==========&quot;);    TreeSet&lt;Student&gt; treeAgeDesc = new TreeSet&lt;&gt;(new AgeDescComparator());    treeAgeDesc.add(student1);    treeAgeDesc.add(student2);    treeAgeDesc.add(student3);    Student studentFirst = treeAgeDesc.first();    System.out.println(&quot;Name : &quot; + studentFirst.name + &quot;, Id : &quot; + studentFirst.id + &quot;, Age : &quot; + studentFirst.age);    Student studentLast = treeAgeDesc.last();    System.out.println(&quot;Name : &quot; + studentLast.name + &quot;, Id : &quot; + studentLast.id + &quot;, Age : &quot; + studentLast.age);&#125;</code></pre><h2 id="2、堆结构"><a href="#2、堆结构" class="headerlink" title="2、堆结构"></a>2、堆结构</h2><p>1）堆结构就是用数组实现的完全二叉树结构</p><p>​    完全二叉树：向着全二叉树的过程。</p><p>2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</p><p>3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</p><p>4）堆结构的 heapInsert 与 heapify 操作</p><p>​    heapInsert：插入节点放到堆尾，往上层移动</p><p>​    heapify ：移除头部节点，尾部节点补上，往下层移动</p><p>5）堆结构的增大和减少 </p><p>6）优先级队列结构，就是堆结构 </p><pre><code class="java">public static class MyMaxHeap &#123;    private int size;    private final int limit;    private int[] heap;    public MyMaxHeap(int limit) &#123;        this.limit = limit;        size = 0;        heap = new int[limit];    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    public boolean isFull() &#123;        return size == limit;    &#125;    public void push(int num) &#123;        if (isFull()) &#123;            throw new RuntimeException(&quot;your heap is full.&quot;);        &#125;        // 插入到堆尾        heap[size] = num;        // 堆尾元素向上移动        heapInsert(heap, size++);    &#125;    /**         * heap[curIndex] 向上移动         */    private void heapInsert(int[] arr, int curIndex) &#123;        // 有两种情况？        int parentIndex = (curIndex-1) &gt;&gt; 1;        // 还没有到达堆顶并且还需要往上走。注意这里需要等于号，等于0时刚好是堆顶        while (parentIndex &gt;= 0 &amp;&amp; arr[curIndex] &gt; arr[parentIndex]) &#123;            swap(arr, parentIndex, curIndex);            curIndex = parentIndex;            parentIndex = (curIndex-1) &gt;&gt; 1;        &#125;    &#125;    public int pop() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;your heap is empty.&quot;);        &#125;        int ans = heap[0];        // 把堆尾部放到堆顶        swap(heap, 0, --size);        heapify(heap, 0, size);        return ans;    &#125;    /**         * 从 curIndex 开始，往下移动         */    private void heapify(int[] arr, int curIndex, int size) &#123;        // index 向下层移动 left=2i+1 right=(i+1)*2        int leftChildIndex = (curIndex &lt;&lt; 1) + 1;        int rightChildIndex = (curIndex + 1) &lt;&lt; 1;        // 有子孩子 &amp;&amp; 小于子孩子        while (leftChildIndex &lt;= size-1) &#123;            // rightChildIndex &gt; size-1 表示没有右孩子            int childMax = rightChildIndex &gt; size-1 ? leftChildIndex :            (arr[leftChildIndex] &gt; arr[rightChildIndex]) ? leftChildIndex : rightChildIndex;            // 不小于子孩子的，heapfy 完成            if (arr[curIndex] &gt;= arr[childMax]) &#123;                break;            &#125;            // 往下移动            swap(arr, curIndex, childMax);            curIndex = childMax;            leftChildIndex = (curIndex &lt;&lt; 1) + 1;            rightChildIndex = (curIndex + 1) &lt;&lt; 1;        &#125;    &#125;    private void swap(int[] arr, int pi, int ci) &#123;        int tmp = arr[pi];        arr[pi] = arr[ci];        arr[ci] = tmp;    &#125;&#125;</code></pre><h3 id="语言提供的堆结构-vs-手写的堆结构"><a href="#语言提供的堆结构-vs-手写的堆结构" class="headerlink" title="语言提供的堆结构 vs 手写的堆结构"></a>语言提供的堆结构 vs 手写的堆结构</h3><p>取决于，你有没有动态改信息的需求！</p><p>语言提供的堆结构，如果你动态改数据，不保证依然有序</p><p>手写堆结构，因为增加了对象的位置表，所以能够满足动态改信息的需求</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>1，先让整个数组都变成大根堆结构，建立堆的过程: </p><ol><li><p>从上到下的方法，时间复杂度为 O(N*logN) </p></li><li><p>从下到上的方法，时间复杂度为O(N) </p></li></ol><p>2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)</p><p>3，堆的大小减小成 0 之后，排序完成 </p><pre><code class="java">// 堆排序额外空间复杂度为 O(1)public static void heapSort(int[] arr) &#123;    if (arr == null || arr.length &lt;= 1) &#123;        return;    &#125;    // O(N*logN)    //        for (int i = 0; i &lt; arr.length; i++) &#123;    //            // heap cur    //            heapInsert(arr, i);    //        &#125;    // O(N)    for (int i = arr.length - 1; i &gt;= 0; i--) &#123;        heapify(arr, i, arr.length);    &#125;    // O(N*logN)    int heapSize = arr.length;    for (int i = 0; i &lt; arr.length; i++) &#123;        // 最大元素归位。堆顶元素和堆尾元素交换        swap(arr, heapSize-1, 0);        // heap index size        // heapSize-1        // 堆顶元素是不准的，需要调整        heapify(arr, 0, --heapSize);    &#125;&#125;/**     * 从 curIndex 开始往下移动，把 arr[curIndex] 放在合适的位置     */private static void heapify(int[] arr, int curIndex, int heapSize) &#123;    int leftIndex = (curIndex &lt;&lt; 1) + 1;    int rightIndex = (curIndex + 1) &lt;&lt; 1;    // 下移条件：1. 有儿子 2. 值比儿子中较大值小    while (leftIndex &lt; heapSize) &#123;        int maxIndex = rightIndex &gt;= heapSize ? leftIndex : arr[leftIndex] &gt; arr[rightIndex] ? leftIndex : rightIndex;        if (arr[curIndex] &gt;= arr[maxIndex]) &#123;            break;        &#125;        swap(arr, curIndex, maxIndex);        curIndex = maxIndex;        leftIndex = (curIndex &lt;&lt; 1) + 1;        rightIndex = (curIndex + 1) &lt;&lt; 1;    &#125;&#125;/**     * 新元素插入在 heap[curIndex]，请把 heap[0...curIndex] 组织成大根堆     * 就是新元素不断往上移动     */private static void heapInsert(int[] heap, int curIndex) &#123;    int parentIndex = (curIndex - 1)&gt;&gt;1;    // 上移条件：1. 有 parent 2. 比 parent 大    while (parentIndex &gt;= 0 &amp;&amp; heap[curIndex] &gt; heap[parentIndex]) &#123;        swap(heap, curIndex, parentIndex);        curIndex = parentIndex;        parentIndex = (curIndex - 1)&gt;&gt;1;    &#125;&#125;</code></pre><h3 id="堆相关题目"><a href="#堆相关题目" class="headerlink" title="堆相关题目"></a>堆相关题目</h3><p>已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过 k，并且 k 相对于数组长度来说是比较小的。</p><p>请选择一个合适的排序策略，对这个数组进行排序。 </p><pre><code class="java">public static void distanceLessKSort(int[] arr, int k) &#123;    // k==0，表示本身有序    if (k == 0) &#123;        return;    &#125;    // 默认小根堆    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();    // 把前 k 个元素加入堆中    int i = 0;    for (; i &lt; Math.min(arr.length, k); i++) &#123;        minHeap.add(arr[i]);    &#125;    // 堆逐渐后移    int j = 0;    for (; i &lt; arr.length; i++,j++) &#123;        // 堆里增加一个元素        minHeap.add(arr[i]);        // 把当前堆顶弹出来        arr[j] = minHeap.poll();    &#125;    // 堆中剩下的元素弹出    while (!minHeap.isEmpty()) &#123;        arr[j++] = minHeap.poll();    &#125;&#125;private static int[] generateRandomArrLessK(int maxSize, int maxValue, int k) &#123;    int[] arr = new int[(int)(Math.random() * (maxSize + 1))];    for (int i = 0; i &lt; arr.length; i++) &#123;        arr[i] = (int)(Math.random() * (maxValue + 1)) - (int)(Math.random() * (maxValue + 1));    &#125;    Arrays.sort(arr);    // 随机交换，但是长度不大于k    boolean[] swapArr = new boolean[arr.length];    for (int i = 0; i &lt; arr.length; i++) &#123;        int j = Math.min(arr.length - 1, i + (int)(Math.random() * (k+1)));        if (!swapArr[i] &amp;&amp; !swapArr[j]) &#123;            int tmp = arr[i];            arr[i] = arr[j];            arr[j] = tmp;            swapArr[i] = true;            swapArr[j] = true;        &#125;    &#125;    return arr;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆排序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（二）</title>
    <link href="http://yoursite.com/2020-10-30-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%802.html"/>
    <id>http://yoursite.com/2020-10-30-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%802.html</id>
    <published>2020-10-30T14:13:12.000Z</published>
    <updated>2020-11-24T14:49:29.433Z</updated>
    
    <content type="html"><![CDATA[<p>认识基本数据结构，单向链表、双向链表、栈、队列、哈希表和有序表；认识递归。</p><a id="more"></a><h2 id="1、单向链表和双向链表"><a href="#1、单向链表和双向链表" class="headerlink" title="1、单向链表和双向链表"></a>1、单向链表和双向链表</h2><h3 id="1-1-结构"><a href="#1-1-结构" class="headerlink" title="1.1 结构"></a>1.1 结构</h3><pre><code class="java">public static class Node &#123;    public int value;    public Node next;    public Node(int data) &#123;        value = data;    &#125;&#125;public static class DoubleNode &#123;    public int value;    public DoubleNode pre;    public DoubleNode next;    public DoubleNode(int data) &#123;        value = data;    &#125;&#125;</code></pre><h3 id="1-2-简单练习题"><a href="#1-2-简单练习题" class="headerlink" title="1.2 简单练习题"></a>1.2 简单练习题</h3><h4 id="单链表和双链表如何反转？"><a href="#单链表和双链表如何反转？" class="headerlink" title="单链表和双链表如何反转？"></a>单链表和双链表如何反转？</h4><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC.png"></p><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC.png"></p><pre><code class="java">public static Node reverseLinkedList(Node h) &#123;    Node pre = null;    Node next = null;    while (h != null) &#123;        next = h.next;        h.next = pre;        pre = h;        h = next;    &#125;    return pre;&#125;public static DoubleNode reverseDoubleList(DoubleNode h) &#123;    DoubleNode pre = null;    DoubleNode next = null;    while (h != null) &#123;        next = h.next;        h.next = pre;        h.pre = next;        pre = h;        h = next;    &#125;    return pre;&#125;</code></pre><p>对数器</p><pre><code class="java">public static Node testReverseLinkedList(Node h) &#123;    if (h == null) &#123;        return null;    &#125;    // 把所有 node 装入 list    ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;();    while (h != null) &#123;        nodes.add(h);        h = h.next;    &#125;    // 重新设置每个 node 的 next 指针    nodes.get(0).next = null;    for (int i = 1; i &lt; nodes.size(); i++) &#123;        nodes.get(i).next = nodes.get(i-1);    &#125;    // 返回最后一个节点就是新链表的头节点    return nodes.get(nodes.size() - 1);&#125;public static DoubleNode testReverseDoubleList(DoubleNode h) &#123;    if (h == null) &#123;        return null;    &#125;    // 把所有 node 装入 list    ArrayList&lt;DoubleNode&gt; nodes = new ArrayList&lt;&gt;();    while (h != null) &#123;        nodes.add(h);        h = h.next;    &#125;    // 重新设置每个 node 的 next 指针和 pre 指针    nodes.get(0).next = null;    for (int i = 1; i &lt; nodes.size(); i++) &#123;        nodes.get(i-1).pre = nodes.get(i);        nodes.get(i).next = nodes.get(i-1);    &#125;    nodes.get(nodes.size() - 1).pre = null;    // 返回最后一个节点就是新链表的头节点    return nodes.get(nodes.size() - 1);&#125;</code></pre><h4 id="把给定值都删除"><a href="#把给定值都删除" class="headerlink" title="把给定值都删除"></a>把给定值都删除</h4><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%80%BC.png"></p><pre><code class="java">public static Node removeValue(Node h, int num) &#123;    // 找到新头部    while (h != null) &#123;        if (h.value != num) &#123;            break;        &#125;        h = h.next;    &#125;    if (h == null) &#123;        return null;    &#125;    // head来到 第一个不需要删的位置    Node pre = h;    Node cur = h;    while (cur.next != null) &#123;        cur = cur.next;        if (cur.value == num) &#123;            pre.next = cur.next;        &#125; else &#123;            pre = cur;        &#125;    &#125;    return h;&#125;</code></pre><h2 id="2、栈和队列"><a href="#2、栈和队列" class="headerlink" title="2、栈和队列"></a>2、栈和队列</h2><h3 id="2-1-逻辑概念"><a href="#2-1-逻辑概念" class="headerlink" title="2.1 逻辑概念"></a>2.1 逻辑概念</h3><ul><li>栈：数据先进后出，犹如弹匣</li><li>队列：数据先进先出，好似排队</li></ul><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png"></p><h3 id="2-2-栈和队列实际实现"><a href="#2-2-栈和队列实际实现" class="headerlink" title="2.2 栈和队列实际实现"></a>2.2 栈和队列实际实现</h3><h4 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h4><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.png"></p><p>四个基础方法全部实现，自由组合即可。</p><p>双向链表，维护 head、tail 两个指针的移动。所有操作均是 O(1)。</p><pre><code class="java">public static class Node&lt;T&gt; &#123;    public T value;    public Node&lt;T&gt; next;    public Node&lt;T&gt; pre;    public Node(T value) &#123;        this.value = value;    &#125;&#125;public static class DoubleEndsQueue&lt;T&gt; &#123;    Node&lt;T&gt; head;    Node&lt;T&gt; tail;    public void addFromHead(T value) &#123;        Node&lt;T&gt; cur = new Node&lt;&gt;(value);        if (head == null) &#123;            head = cur;            tail = cur;        &#125; else &#123;            cur.next = head;            head.pre = cur;            head = cur;        &#125;    &#125;    public void addFromTail(T value) &#123;        Node&lt;T&gt; cur = new Node&lt;&gt;(value);        if (head == null) &#123;            head = cur;            tail = cur;        &#125; else &#123;            cur.pre = tail;            tail.next = cur;            tail = cur;        &#125;    &#125;    public T popFromHead() &#123;        if (head == null) &#123;            return null;        &#125;        Node&lt;T&gt; cur = head;        if (head == tail) &#123;            head = null;            tail = null;        &#125; else &#123;            head = head.next;            head.pre = null;            cur.next = null;        &#125;        return cur.value;    &#125;    public T popFromTail() &#123;        if (head == null) &#123;            return null;        &#125;        Node&lt;T&gt; cur = tail;        if (head == tail) &#123;            head = null;            tail = null;        &#125; else &#123;            tail = tail.pre;            tail.next = null;            cur.pre = null;        &#125;        return cur.value;    &#125;    public boolean isEmpty() &#123;        return head == null;    &#125;&#125;</code></pre><h4 id="数组实现（固定大小）"><a href="#数组实现（固定大小）" class="headerlink" title="数组实现（固定大小）"></a>数组实现（固定大小）</h4><p><strong>数组实现固定大小栈</strong></p><pre><code class="java">public static class MyStack &#123;    private int[] arr;    // 下一个入栈位置。也就是下一个出栈前一个位置    private int index;    private final int limit;    public MyStack(int limit) &#123;        this.limit = limit;        index = 0;        arr = new int[limit];    &#125;    public void push(int num) &#123;        if (index &gt;= limit) &#123;            throw new RuntimeException(&quot;栈已满，不能再加！&quot;);        &#125;        arr[index] = num;        index++;    &#125;    public int pop() &#123;        if (index == 0) &#123;            throw new RuntimeException(&quot;栈为空，不能再拿！&quot;);        &#125;        int res = arr[index-1];        index--;        return res;    &#125;&#125;</code></pre><p><strong>环形数组实现固定大小队列</strong></p><pre><code class="java">public static class MyQueue &#123;    // 固定大小数组    private int[] arr;    // 下一个入队位置    private int pushi;    // 下一个出队位置    private int popi;    // 最大大小    private final int limit;    // 当前队列大小    private int size;    public MyQueue(int limit) &#123;        pushi = 0;        popi = 0;        size = 0;        this.limit = limit;        arr = new int[limit];    &#125;    public void push(int num) &#123;        if (limit == size) &#123;            throw new RuntimeException(&quot;队列已满，不能再加！&quot;);        &#125;        arr[pushi] = num;        size++;        pushi = nextIndex(pushi);    &#125;    public int pop() &#123;        if (size == 0) &#123;            throw new RuntimeException(&quot;队列为空，不能再拿！&quot;);        &#125;        int res = arr[popi];        size--;        popi = nextIndex(popi);        return res;    &#125;    public boolean isEmpty() &#123;        return size == 0;    &#125;    // 如果现在的下标是i，返回下一个位置    private int nextIndex(int index) &#123;        // 入队的顺序 012345012345        // 出队的顺序 012345012345        return (index &lt; limit -1) ? index+1 : 0;    &#125;&#125;</code></pre><h3 id="2-3-简单练习题"><a href="#2-3-简单练习题" class="headerlink" title="2.3 简单练习题"></a>2.3 简单练习题</h3><p><strong>1、用数组实现不超过固定大小的队列和栈？</strong></p><p>见 2.2</p><p><strong>2、实现一个特俗的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</strong></p><ul><li>要求 pop、push、getMin 都是 O(1)</li><li>可以使用现有栈结构</li></ul><p>思路：弄两个栈。一个数据栈一个最小栈，两个栈等高。</p><pre><code class="java">public static class MyStack &#123;    private Stack&lt;Integer&gt; dataStack;    private Stack&lt;Integer&gt; minStack;    public MyStack() &#123;        dataStack = new Stack&lt;&gt;();        minStack = new Stack&lt;&gt;();    &#125;    public void push(int num) &#123;        if (minStack.isEmpty()) &#123;            minStack.push(num);        &#125; else &#123;            // 最小栈栈顶和num比较            minStack.push(Math.min(minStack.peek(), num));        &#125;        dataStack.push(num);    &#125;    public int pop() &#123;        if (minStack.isEmpty()) &#123;            throw new RuntimeException(&quot;栈为空，不可拿数据！&quot;);        &#125;        minStack.pop();        return dataStack.pop();    &#125;    public int getMin() &#123;        if (this.minStack.isEmpty()) &#123;            throw new RuntimeException(&quot;栈为空，不可拿数据！&quot;);        &#125;        return minStack.peek();    &#125;&#125;</code></pre><p><strong>3、用栈结构实现队列结构</strong></p><pre><code class="java">public static class MyQueue &#123;    private Stack&lt;Integer&gt; pushStack;    private Stack&lt;Integer&gt; pollStack;    public MyQueue() &#123;        pushStack = new Stack&lt;&gt;();        pollStack = new Stack&lt;&gt;();    &#125;    public void push(Integer num) &#123;        pushStack.push(num);        pushToPoll();    &#125;    public Integer poll() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空，不能再拿数据&quot;);        &#125;        pushToPoll();        return pollStack.pop();    &#125;    public Integer peek() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空，不能再拿数据&quot;);        &#125;        pushToPoll();        return pollStack.peek();    &#125;    public boolean isEmpty() &#123;        return pushStack.isEmpty() &amp;&amp; pollStack.isEmpty();    &#125;    private void pushToPoll() &#123;        if (pollStack.isEmpty()) &#123;            // 一定要遍历完            while (!pushStack.isEmpty()) &#123;                pollStack.push(pushStack.pop());            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>4、用队列结构实现栈结构</strong></p><pre><code class="java">public static class MyStack &#123;    private Queue&lt;Integer&gt; queue;    private Queue&lt;Integer&gt; help;    public MyStack() &#123;        queue = new LinkedList&lt;&gt;();        help = new LinkedList&lt;&gt;();    &#125;    public void push(Integer num) &#123;        queue.offer(num);    &#125;    public Integer pop() &#123;        queueToHelp();        Integer res = queue.poll();        helpToQueue();        return res;    &#125;    public Integer peek() &#123;        queueToHelp();        Integer res = queue.poll();        help.offer(res);        helpToQueue();        return res;    &#125;    public boolean isEmpty() &#123;        return queue.isEmpty();    &#125;    private void queueToHelp() &#123;        while (queue.size() &gt; 1) &#123;            help.offer(queue.poll());        &#125;    &#125;    private void helpToQueue() &#123;        Queue&lt;Integer&gt; tmp = queue;        queue = help;        help = tmp;    &#125;&#125;</code></pre><h2 id="3、递归"><a href="#3、递归" class="headerlink" title="3、递归"></a>3、递归</h2><h3 id="3-1-递归例子"><a href="#3-1-递归例子" class="headerlink" title="3.1 递归例子"></a>3.1 递归例子</h3><p>求数组arr[L..R]中的最大值，怎么用递归方法实现。</p><p>1）将[L..R]范围分成左右两半。左：[L..Mid] 右[Mid+1..R]</p><p>2）左部分求最大值，右部分求最大值</p><p>3） [L..R]范围上的最大值，是 max{左部分最大值，右部分最大值}</p><p>注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了</p><pre><code class="java">public static Integer getMax(int[] arr) &#123;    if (arr == null || arr.length == 0) &#123;        return 0;    &#125;    return process(arr, 0, arr.length - 1);&#125;private static Integer process(int[] arr, int L, int R) &#123;    if (L == R) &#123; // arr[L..R]范围上只有一个数，直接返回，base case        return arr[L];    &#125;    int mid = L + ((R - L) &gt;&gt; 1);    Integer l = process(arr, L, mid);    Integer r = process(arr, mid + 1, R);    return Math.max(l, r);&#125;</code></pre><h3 id="3-2-递归的脑图"><a href="#3-2-递归的脑图" class="headerlink" title="3.2 递归的脑图"></a>3.2 递归的脑图</h3><p>递归的脑图有利于理解和分析递归，递归不是玄学，递归底层是利用系统栈来实现的。任何递归函数都一定可以改成非递归。</p><p><img src="../../../images/%E7%AE%97%E6%B3%95/2/%E9%80%92%E5%BD%92%E8%84%91%E5%9B%BE.png"></p><h3 id="3-3-Master-公式"><a href="#3-3-Master-公式" class="headerlink" title="3.3 Master 公式"></a>3.3 Master 公式</h3><p>形如 *<em>T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)*</em>的递归函数，可以直接通过Master公式来确定时间复杂度</p><ul><li><p>如果 log(b,a) &lt; d，复杂度为O(N^d)</p></li><li><p>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))</p></li><li><p>如果 log(b,a) == d，复杂度为O(N^d * logN)</p></li></ul><p>上面例子：T(N) = 2 * T(N/2) + O(N^0)。所以 log(2,2) &gt; 0，所以复杂度为 O(N^log(2,2)) = O(N)。</p><h2 id="4、哈希表和有序表"><a href="#4、哈希表和有序表" class="headerlink" title="4、哈希表和有序表"></a>4、哈希表和有序表</h2><h3 id="4-1-哈希表"><a href="#4-1-哈希表" class="headerlink" title="4.1 哈希表"></a>4.1 哈希表</h3><ol><li><p>在使用层面上可以理解为一种集合结构</p></li><li><p>如果只有 key，没有伴随数据 value，可以使用 HashSet 结构</p></li><li><p>如果既有 key，又有伴随数据 value，可以使用 HashMap 结构</p></li><li><p>有无伴随数据是 HashMap 和 HashSet 唯一的区别，底层的实际结构是一回事</p></li><li><p>使用哈希表增（put）、删（remove）、改（put）和查（get）操作可以认为时间复杂度为 O(1)，但是常数时间比较大</p></li><li><p>放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小</p></li><li><p>放入哈希表的东西，如果是引用类型，内部按引用传递，内存占用是 8 字节</p></li></ol><h3 id="4-2-有序表"><a href="#4-2-有序表" class="headerlink" title="4.2 有序表"></a>4.2 有序表</h3><ol><li>有序表在使用层面上可以理解为一种集合结构</li><li>有 key 无 value，可以使用 TreeSet</li><li>有 key 有 value，可以使用 TreeMap</li><li>有无 value 是 TreeSet 和 TreeMap 的唯一区别，底层结构一样</li><li>使用有序表增（put）、删（remove）、改（put）和查（get）操作可以认为时间复杂度为  <strong>O(logN)</strong></li><li>放基础类型，按值传递，内存占用同值大小相同</li><li>放引用类型，按引用传递，内存占用8字节</li><li>有序表把 key 按照顺序组织起来，而哈希表完全不组织</li><li>红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 <strong>O(logN)</strong><ul><li>void put(K key, V value)，向有序表添加或更新记录</li><li>V get(K key)，根据 key 查询 value</li><li>void remove(K key)</li><li>boolean containsKey(K key)</li><li>K firstKey()，返回所有键值的排序结果中，最小的那个</li><li>K lastKey()，返回最大那个 key</li><li>K floorKey(K key)，返回 &lt;= key，离 key 最近的那个</li><li>K ceilingKey(K key)，返回 &gt;= key，离 key 最近的那个</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;认识基本数据结构，单向链表、双向链表、栈、队列、哈希表和有序表；认识递归。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础（一）</title>
    <link href="http://yoursite.com/2020-10-28-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%801-%E5%A4%8D%E6%9D%82%E5%BA%A6_%E5%AF%B9%E6%95%B0%E5%99%A8_%E4%BA%8C%E5%88%86%E6%B3%95_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html"/>
    <id>http://yoursite.com/2020-10-28-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%801-%E5%A4%8D%E6%9D%82%E5%BA%A6_%E5%AF%B9%E6%95%B0%E5%99%A8_%E4%BA%8C%E5%88%86%E6%B3%95_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html</id>
    <published>2020-10-28T14:13:12.000Z</published>
    <updated>2020-10-30T15:04:37.344Z</updated>
    
    <content type="html"><![CDATA[<p><strong>评估算法优劣的核心指标</strong></p><ul><li>时间复杂度</li><li>额外空间复杂度</li><li>常数项时间</li></ul><p><strong>二分法</strong></p><p><strong>异或操作</strong></p><a id="more"></a><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><p>什么是时间复杂度？</p><ul><li>常数时间的操作</li><li>确定算法流程的总操作数量与样本数量之间的表达式关系</li><li>只看表达式最高阶项的部分</li></ul><p>什么是常数时间操作？</p><blockquote><p>如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间，那么这个操作就是常数时间的操作。</p><p>linkedList 底层是一个双向链表，通过指针关联，不是连续区间，无法算出偏移量，所以不是常数时间。数组是直接寻址，可以认为是连续内存区间，直接计算偏移量。</p></blockquote><p>常见的常数时间操作有哪些？</p><ul><li>常见的算数运算（+、-、*、/、%）</li><li>常见的位运算（&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;、&amp;、|、~、^）</li><li>赋值、比较、自增、自减</li><li>数组寻址操作</li></ul><p>如何确定总操作数量和样本数量之间的表达式关系？</p><ol><li>分析算法的流程，按照最差情况分析</li><li>把整个流程拆分位一个个基本动作，保证每个动作都是常数时间操作</li><li>如果数据量为 N，看看基本动作的数量和 N 是什么关系</li></ol><h2 id="2、时间复杂度估算实践"><a href="#2、时间复杂度估算实践" class="headerlink" title="2、时间复杂度估算实践"></a>2、时间复杂度估算实践</h2><h3 id="2-1-选择排序"><a href="#2-1-选择排序" class="headerlink" title="2.1 选择排序"></a>2.1 选择排序</h3><p>过程：</p><ul><li><p>arr[0~N-1]范围上，找到最小值所在位置，然后把最小值交换到0位置。</p></li><li><p>arr[1~N-1]范围上，找到最小值所在位置，然后把最小值交换到1位置。</p></li><li><p>arr[2~N-1]范围上，找到最小值所在位置，然后把最小值交换到2位置。</p></li><li><p>…</p></li><li><p>arr[N-1~N-1]范围上，找到最小值所在位置，然后把最小值交换到N-1位置。</p></li></ul><p>估算：</p><ul><li>常数操作数量=(N + N-1 + N-2 + … + 1)<em>(1看操作 + 1比较操作 + 1交换操作)=(1x1+n</em>(n-1)/2)*3=a(N^2)+bN + c。（a、b、c都是常数）</li></ul><p>所以选择排序的时间复杂度为 O(N^2)</p><h3 id="2-2-冒泡排序"><a href="#2-2-冒泡排序" class="headerlink" title="2.2 冒泡排序"></a>2.2 冒泡排序</h3><p>过程：</p><ul><li>arr[0~N-1]范围上，arr[0]和arr[1]比较，谁大谁来到1位置；arr[1]和arr[2]比较，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到 N-1 位置</li><li>arr[0~N-2]范围上，重复上面过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到 N-2 位置</li><li>arr[0~N-3]范围上，重复上面过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到 N-3 位置</li><li>…</li><li>arr[0~1]范围上，重复上面过程，但最后一步是arr[0]和arr[1]，谁大谁来到 1 位置</li></ul><p>估算：</p><ul><li>常数操作数量=(N-1 + N-2 + … + 1)(1看操作+1比较操作+1交换)</li></ul><p>所以冒泡排序的时间复杂度为 O(N^2)</p><h3 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h3><p>过程：</p><ul><li>arr[0~1]范围上，arr[0]和arr[1]比较，谁大谁来到1位置</li><li>arr[0~2]范围上，arr[2]和arr[1]比较，谁大谁来到2位置，如果arr[2]大于arr[1]，比较完成；arr[1]和arr[0]比较，谁大谁来到1位置</li><li>arr[0~3]范围上，arr[3]和arr[2]比较，谁大谁来到3位置，如果arr[3]大于arr[2]，比较完成；arr[2]和arr[1]比较，谁大谁来到2位置；…</li><li>…</li><li>arr[0~N-1]范围上，arr[N-1]和arr[N-2]比较，谁大谁来到 N-1 位置上；</li></ul><p>左神的过程描述：</p><ul><li><p>想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。</p></li><li><p>想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。</p></li><li><p>…</p></li><li><p>想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p></li><li><p>想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</p></li></ul><p>估算：</p><ul><li>按照最坏情况。常数操作=(1 + 2 + 3 + … + N-1) * 3</li></ul><p>所以插入排序的时间复杂度为 O(N^2)</p><h2 id="3、额外空间复杂度"><a href="#3、额外空间复杂度" class="headerlink" title="3、额外空间复杂度"></a>3、额外空间复杂度</h2><p>输入参数的空间和输出结果的空间不算额外空间，因为这些都是必须的，和实现目标有关的。</p><p>但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去，这部分空间就是额外空间。</p><p>如果你的流程只需要开辟有限几个变量，额外空间复杂度就是 O(1)。</p><h2 id="4、常数项"><a href="#4、常数项" class="headerlink" title="4、常数项"></a>4、常数项</h2><p>时间复杂度相同的算法不一定一样好。时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。这时一般放弃理论分析，而是生成随机数据直接测。</p><p>不是不能纯分析，而是没必要，因为虽然都是一个常数操作，但是所花费的时间也可能是不同的。比如，位运算的常数时间远小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。</p><p>所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</p><p><strong>什么是最优解？</strong></p><p>先满足时间复杂度尽可能低，然后使用最少的额外空间。一般忽略常数项这个因素，因为这个因素只决定了实现层次的优化和考虑，而和怎么<strong>解决这个问题的思想</strong>无关。</p><p><strong>常见时间复杂度排序</strong></p><ul><li>O(1)</li><li>O(logN)</li><li>O(N)</li><li>O(N*logN)</li><li>O(N^2) O(N^3) … O(N^K)</li><li>O(2^N) O(3^N) … O(K^N)</li><li>O(N!)</li></ul><h2 id="5、认识对数器"><a href="#5、认识对数器" class="headerlink" title="5、认识对数器"></a>5、认识对数器</h2><p>1，你想要测的方法a</p><p>2，实现复杂度不好但是容易实现的方法b</p><p>3，实现一个随机样本产生器</p><p>4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样</p><p>5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b</p><p>6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。 </p><h2 id="6、二分法"><a href="#6、二分法" class="headerlink" title="6、二分法"></a>6、二分法</h2><p>最常见的是在一个有序数组上，开展二分搜索。但是有序并不是使用二分的必要条件，只要能正确构建左右两侧的淘汰逻辑，你就可以二分。</p><ol><li>在一个有序数组中，找某个数是否存在 </li></ol><p><img src="../../../images/%E7%AE%97%E6%B3%95/1/%E4%BA%8C%E5%88%86%E6%B3%95.png"></p><pre><code class="java">private static boolean bsExist(int[] arr, int target) &#123;    if (arr == null || arr.length == 0) &#123;        return false;    &#125;    int L = 0;    int R = arr.length - 1;    int mid = 0;    // 需要等于，L=R 时也需要判断    while (L &lt;= R) &#123;        // mid = (L + R) / 2 不安全，可能越界        mid = L + (R-L)/2;        // mid = L + ((R-L)&gt;&gt;1);        if (target == arr[mid]) &#123;            return true;        &#125;        // 这里加一减一如何理解？        // mid 已经排除，可以直接跳过        if (arr[mid] &gt; target) &#123;            R = mid - 1;        &#125; else &#123;            L = mid + 1;        &#125;    &#125;    return false;&#125;</code></pre><ol start="2"><li>在一个有序数组中，找&gt;=某个数最左侧的位置 </li></ol><pre><code class="java">    private static int nearestIndex(int[] arr, int num) &#123;        if (arr == null || arr.length == 0) &#123;            return -1;        &#125;        int index=-1;        int L=0;        int R=arr.length-1;        int mid = 0;        while (L &lt;= R) &#123;            mid = L + ((R-L)&gt;&gt;1);            if (arr[mid] &gt;= num) &#123;                R = mid - 1;                index = mid;            &#125; else &#123;                L = mid + 1;            &#125;        &#125;        return index;    &#125;</code></pre><ol start="3"><li>在一个有序数组中，找&lt;=某个数最右侧的位置 </li></ol><p>同2</p><ol start="4"><li>局部最小值问题 </li></ol><blockquote><p>局部最小问题。从数组中找到一个局部最小值。</p><ol><li>arr[1] &gt; arr[0] arr[0]局部最小</li><li>arr[n-1] &gt; arr[n] arr[n]局部最小</li><li>arr[i-1] &gt; arr[i] &amp;&amp; arr[i+1] &gt; arr[i] arr[i] 局部最小</li></ol></blockquote><h2 id="7、异或"><a href="#7、异或" class="headerlink" title="7、异或"></a>7、异或</h2><p>异或运算：相同为0，不同为1</p><p>同或运算：相同为1，不同为0</p><p>能长时间记住的概率接近0%</p><p>所以，异或运算就记成<strong>无进位相加</strong>！</p><h3 id="7-1-异或运算性值"><a href="#7-1-异或运算性值" class="headerlink" title="7.1 异或运算性值"></a>7.1 异或运算性值</h3><ul><li>0^N=N</li><li>N^N=0</li><li>异或满足交换律和结合律</li></ul><h3 id="7-2-异或题目"><a href="#7-2-异或题目" class="headerlink" title="7.2 异或题目"></a>7.2 异或题目</h3><p><strong>1、如何不用额外变量交换两个数?</strong></p><pre><code class="java">// 前提 a、b 位于不指向同一个内存int a = 1, b = 2;a = a ^ b; // a=a^b b=bb = a ^ b; // b=a^b^b=a a=a^ba = a ^ b; // a=a^b^a=bSystem.out.println(a + &quot;======&quot; + b);</code></pre><p><strong>2、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？</strong></p><p>全部异或。因为 N^N=0，0^N=N。</p><p><strong>3、怎么把一个int类型的数，提取出最右侧的1来？</strong></p><pre><code class="json">原数：0001 0010取反：1110 1101加一：1110 1110相与：0000 0010(~a+1)&amp;a</code></pre><p><strong>4、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数？</strong></p><pre><code class="java">// 一个数组中有一种数出现了奇数次，其他数都出现了偶数次private static void printOddTimesNum1(int[] arr) &#123;    int eor = 0;    for (int i = 0; i &lt; arr.length; i++) &#123;        eor ^= arr[i];    &#125;    System.out.println(&quot;======&gt;&quot; + eor);&#125;// 一个数组中有两种数出现了奇数次，其他数都出现了偶数次private static void printOddTimesNum2(int[] arr) &#123;    int eor = 0;    for (int i = 0; i &lt; arr.length; i++) &#123;        eor ^= arr[i];    &#125;    // eor=a^b    // a!=b    // eor中肯定存在1，并且a、b中一个1一个0    // 找到最右侧1    int rightOne = eor &amp; (~eor + 1);    int a = 0;    for (int i = 0; i &lt; arr.length; i++) &#123;        if ((arr[i] &amp; rightOne) &gt; 0) &#123;            a ^= arr[i];        &#125;    &#125;    System.out.println(a+&quot;=========&quot;+(a^eor));&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;评估算法优劣的核心指标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;li&gt;额外空间复杂度&lt;/li&gt;
&lt;li&gt;常数项时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二分法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异或操作&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(八)</title>
    <link href="http://yoursite.com/2020-10-11-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(8)-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html"/>
    <id>http://yoursite.com/2020-10-11-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(8)-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html</id>
    <published>2020-10-11T15:43:12.000Z</published>
    <updated>2020-11-24T14:44:05.123Z</updated>
    
    <content type="html"><![CDATA[<ul><li>分布式事务</li></ul><a id="more"></a><h2 id="1、分布式事务"><a href="#1、分布式事务" class="headerlink" title="1、分布式事务"></a>1、分布式事务</h2><p><strong>事务（Transaction）</strong>，一般是指要做的或所做的事情，由<strong>事务开始(begin transaction)**和</strong>事务结束(end transaction)**之间执行的全体操作组成。</p><p><strong>简单的讲就是，要么全部被执行，要么就全部失败。</strong></p><p>那<strong>分布式事务</strong>，自然就是运行在分布式系统中的事务，是由<strong>多个不同的机器上的事务组合而成</strong>的。同上，只有分布式系统中所有事务执行了才能是成功，否则失败。</p><p>事务的基本特征 ACID：</p><ul><li>原子性（Atomicity）<ul><li>一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li></ul></li><li>一致性（Consistency）<ul><li>指事务执行前和执行后，数据是完整的。</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li></ul></li><li>持久性（Durability）<ul><li>也称为永久性，一个事务一旦提交，它对数据库中数据的改变就应该是永久性的保存下来了。</li></ul></li></ul><hr><p><strong>分布式事务的目标：解决多个独立事务一致性的问题。</strong></p><p>我们遇到的问题：</p><p>分布式事务：一个功能，横跨多个微服务，由于每个微服务不在一个库，没法用数据库事务来保证事务。</p><p>网约车例子：乘客支付订单。支付系统中，支付表更新，订单系统，订单库 订单状态更新为已支付。</p><p>订单，支付表，在不同的库，如何保证两个库之间的事务。</p><p>支付操作：支付修改余额，修改订单状态。</p><p>SCI：销售单和库存、采购单和库存</p><h2 id="2、分布式事务解决方案"><a href="#2、分布式事务解决方案" class="headerlink" title="2、分布式事务解决方案"></a>2、分布式事务解决方案</h2><h3 id="2-1-二阶段提交协议-2PC"><a href="#2-1-二阶段提交协议-2PC" class="headerlink" title="2.1 二阶段提交协议(2PC)"></a>2.1 二阶段提交协议(2PC)</h3><p>基于 XA/JTA 规范，采取强一致性，遵从 ACID。</p><p>XA 是一个分布式事务架构规范，主要定义了 TM 和 RM ，JTA 是 XA 的一个具体 Java 实现。</p><h4 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h4><p>XA 是由 X/Open 组织提出的分布式事务的架构（或者叫协议）。XA 架构主要定义了（全局）事务管理器（<strong>Transaction Manager</strong>）和（局部）资源管理器（<strong>Resource Manager</strong>）之间的接口。XA 接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。也就是说，在基于 XA 的一个事务中，我们可以针对多个资源进行事务管理，例如一个系统访问多个数据库，或既访问数据库、又访问像消息中间件这样的资源。这样我们就能够实现在多个数据库和消息中间件直接实现全部提交、或全部取消的事务。XA 规范不是 java 的规范，而是一种通用的规范。</p><h4 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h4><p>JTA(Java Transaction API)，是 J2EE 的编程接口规范，它是 XA 协议的 JAVA 实现。它主要定义了：</p><p>一个事务管理器的接口 javax.transaction.TransactionManager，定义了有关事务的开始、提交、撤回等操作。<br>一个满足 XA 规范的资源定义接口 javax.transaction.xa.XAResource，一种资源如果要支持 JTA 事务，就需要让它的资源实现该 XAResource 接口，并实现该接口定义的两阶段提交相关的接口。</p><p><img src="../../images/springcloud/8/2PC.png"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1、准备阶段</p><p>TM 给每个 RM 发送  <strong>Prepare</strong> 消息，每个 RM 要么直接返回失败（如<strong>权限验证失败、本地作业执行故障等</strong>），要么在本地执行事务，<strong>写本地的 redo 和 undo 日志，但不提交</strong>，到达一种“万事俱备，只欠东风”的状态。</p><p>2、提交阶段</p><ul><li>TM 接收到 RM 的失败消息或者超时，直接给每个 RM 发送回滚消息（rollback），各个 RM 回滚本地事务，释放事务过程中的锁资源。</li><li>TM 接收到所有 RM 的成功消息，直接给每个 RM 发送提交消息（commit），各个 RM 提交本地事务，释放事务过程中的锁资源。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>单点故障</strong>：事务的发起、提交还是取消，均是由老大协调者管理的，只要协调者宕机，那就凉凉了。</li><li><strong>同步阻塞缺点</strong>：从上面介绍以及例子可看出，我们的参与系统中在没收到老大的真正提交还是取消事务指令的时候，就是锁定当前的资源，并不真正的做些事务相关操作，所以，整个分布式系统环境就是阻塞的。</li><li><strong>数据不一致缺点</strong>：就是说在老大协调者向小弟们发送真正提交事务的时候，部分网路故障，造成部分系统没收到真正的指令，那么就会出现部分提交部分没提交，因此，这就会导致数据的不一致。就是十个 RM 只发了五个 TM 就挂了。</li></ul><h4 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h4><p>当协调者出错，同时参与者也出错时，两阶段无法保证事务执行的完整性。<br>考虑协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使有了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。知道的人已经被灭口了。</p><p>就是说即使新的 TM 上台，也无法知道这个事务应该提交还是回滚。</p><h3 id="2-2-三阶段提交协议-3PC"><a href="#2-2-三阶段提交协议-3PC" class="headerlink" title="2.2 三阶段提交协议(3PC)"></a>2.2 三阶段提交协议(3PC)</h3><p>采取强一致性，遵从 ACID。</p><p>在二阶段上增加了：<strong>超时（TM、RM 均引入超时机制）</strong>和<strong>预提交机制</strong>。</p><p>有这三个主阶段，canCommit、preCommit、doCommit 这三个阶段</p><p><img src="../../images/springcloud/8/3PC.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1、CanCommit 阶段</p><p>TM 向所有 RM 发送 commit 请求，RM 如果可以提交就返回 yes 响应，否则返回 no 响应。</p><p>2、PreCommit 阶段</p><ul><li>所有 RM 返回 yes，执行事务的预执行</li><li>存在 RM 返回 no，或者 RM 响应超时，执行事务的中断</li></ul><p>3、DoCommit 阶段</p><ul><li>TM 发送 commit/rollback 请求</li><li>RM commit/rollback 事务</li><li>RM 事务处理完成向 TM 发送 Ack 响应</li><li>TM 确定事务完成</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>解决了一部分同步阻塞问题（超时时间内还是会阻塞），但是还是有<strong>单点故障、数据不一致性问题</strong>。PreCommit 阶段后，如果 TM 发出的是 rollback 请求，假设只有一个 RM 收到并进行了 rollback 操作，然后 TM 挂了。其他 RM 会根据 3PC 选择继续 Commit，此时系统状态发生不一致性。</p><h4 id="2-和-3-的区别"><a href="#2-和-3-的区别" class="headerlink" title="2 和 3 的区别"></a>2 和 3 的区别</h4><p>1、加了询问，增大成功概率。</p><p>2、对于 TM 和 RM 都设置了超时机制（在2PC中，只有 TM 拥有超时机制，即如果在一定时间内没有收到 RM 的消息则默认失败）。 TM 挂了，RM 等待超时后，默认提交事务。有一丢丢进步。</p><p>3、如果参与者异常了，协调者也异常了，会造成其他参与者提交。<br>PreCommit 是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。</p><h3 id="2-3-柔性事务-最终一致性形式"><a href="#2-3-柔性事务-最终一致性形式" class="headerlink" title="2.3 柔性事务(最终一致性形式)"></a>2.3 柔性事务(最终一致性形式)</h3><p>柔性事务基于 CAP 理论和 BASE 理论。</p><p><strong>BASE</strong>：全称是，Basically Avaliable（基本可用），Soft state（软状态），Eventually consistent（最终一致性）三个短语的缩写，来自 eBay 的架构师提出。</p><ul><li><strong>Basically Avaliable：</strong>就是在分布式系统环境中，允许牺牲掉部分不影响主流程的功能的不可用，将其降级以确保核心服务的正常可用。</li><li><strong>Soft state：</strong>就是指在事务中，我们允许系统存在中间状态，且并不影响我们这个系统。就拿数据库的主从复制来说，是完全允许复制的时候有延时的发生的。</li><li><strong>Eventually consistent：</strong>还是以数据库主从复制为例说，虽然主从复制有小延迟，但是很快最终就数据保持一致了。</li></ul><p>分布式事务不可能 100% 解决，只能提高成功概率。两阶段之间时间，毫秒级别。补救措施：</p><ul><li><p>定时任务补偿。程序或脚本补偿。</p></li><li><p>人工介入。</p></li></ul><p>通常说的柔性事务分为：补偿型、异步确保型、最大努力通知型</p><h4 id="补偿型-TCC"><a href="#补偿型-TCC" class="headerlink" title="补偿型-TCC"></a>补偿型-TCC</h4><p>TCC（Try、Confirm、Cancel），两阶段补偿型方案。</p><p>从名字可以看出，实现一个事务，需要定义三个 API：预先占有资源，确认提交实际操作资源，取消占有（回滚）。</p><ul><li>try：预留，即资源的预留和锁定。</li><li>confirm：确认，其实就是真正的执行。</li><li>cancel：撤销，可以理解为吧预留阶段的动作撤销。</li></ul><p>如果后两个环节执行一半失败了，<strong>记录日志，补偿处理，通知人工</strong>。</p><p>2PC 是资源层面的分布式事务，强一致性，一直会持有资源的锁。TCC 是在业务层面的分布式事务，<strong>可以跨数据库、跨不同业务系统来实现事务</strong>，最终一致性，不会一直持有锁，将锁的粒度变小了，每操作完一个库，就释放了锁。使用哪一种类型都是相对而言的，如果请求量少，跨越的数据库少，用 2PC 比 TCC 性能要高，因为 TCC 多了几次接口调用。而此时的 2PC 不怕占用资源，反正请求少并发低。高并发场景下 TCC 优势更大。<strong>但是 TCC 对业务的侵入较大和业务紧耦合。</strong></p><p>例子：</p><p>飞猪：</p><ul><li>武汉-&gt;西安 南方航空</li><li>西安-&gt;西宁 东方航空</li></ul><p><img src="../../images/springcloud/8/TCC.png"></p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>利用<strong>各个系统本地事务</strong>来实现分布式事务。</p><p> 本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 <strong>将业务的执行和将消息放入消息表中的操作放在同一个事务中</strong>，这样就能保证消息放入本地表中业务肯定是执行成功的。 </p><p>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。</p><p>如果调用失败也没事，会有 <strong>后台任务定时去读取本地消息表</strong>，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。</p><p>这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是<strong>幂等</strong>的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。</p><p>可以看到本地消息表其实实现的是<strong>最终一致性</strong>，容忍了数据暂时不一致的情况。</p><h4 id="异步确保型-MQ"><a href="#异步确保型-MQ" class="headerlink" title="异步确保型-MQ"></a>异步确保型-MQ</h4><p>RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。</p><p>第一步先给 Broker 发送事务消息即半消息，<strong>半消息不是说一半消息，而是这个消息对消费者来说不可见</strong>，然后<strong>发送成功后发送方再执行本地事务</strong>。</p><p>再根据<strong>本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令</strong>。</p><p> 并且 RocketMQ 的发送方会提供一个<strong>反查事务状态接口</strong>，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。 </p><p> 如果<strong>是 Commit 那么订阅方就能收到这条消息</strong>，然后再做对应的操作，做完了之后再消费这条消息即可。 </p><p> 如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。 </p><p> 可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。 </p><p><img src="../../images/springcloud/8/%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D%E5%9E%8B-MQ.png"></p><p> 可以看到消息事务实现的也是最终一致性。 </p><h4 id="最大努力通知型（多次尝试）"><a href="#最大努力通知型（多次尝试）" class="headerlink" title="最大努力通知型（多次尝试）"></a>最大努力通知型（多次尝试）</h4><p>其实我觉得本地消息表也可以算最大努力，异步确保型也可以算最大努力。</p><p>就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。</p><p>事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。</p><p>所以<strong>最大努力通知其实只是表明了一种柔性事务的思想</strong>：我已经尽力我最大的努力想达成事务的最终一致了。</p><p>适用于对时间不敏感的业务，例如短信通知。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。</p><p>而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。</p><p>本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。</p><h2 id="消息中间件实现"><a href="#消息中间件实现" class="headerlink" title="消息中间件实现"></a>消息中间件实现</h2><p>本地事务+定时任务+消息队列+事件表</p><p><img src="../../images/springcloud/8/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1.png"></p><pre><code class="sh">CREATE TABLE `tbl_order_event` (  `id` int(16) NOT NULL,  `order_type` varchar(32) DEFAULT NULL COMMENT &#39;事件类型（支付表支付完成，订单表修改状态）&#39;,  `process` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT &#39;事件环节（new,published,processed)&#39;,  `content` varchar(255) DEFAULT NULL COMMENT &#39;事件内容，保存事件发生时需要传递的数据&#39;,  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</code></pre><pre><code class="sh">http://localhost:8161/index.htmladmin/admin</code></pre><p>service-jms-consumer</p><p>service-jms-produce</p><h2 id="3、seata-框架"><a href="#3、seata-框架" class="headerlink" title="3、seata 框架"></a>3、seata 框架</h2><p>开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。有 AT、TCC、SAGA 和 SA 四种事务模式。</p><pre><code>官网：http://seata.io/zh-cn/docs/overview/what-is-seata.html</code></pre><p><strong>AT 模式和 TCC 模式总体架构图</strong></p><p><img src="../../images/springcloud/8/seata_2pc.png"></p><ul><li>TM：定义全局事务的范围：开始、提交或回滚全局事务</li><li>TC：维护全局事务和分支事务的状态，驱动全局事务的提交或回滚</li><li>RM：与 TC 交谈以注册分支事务和报告分支事务状态，驱动分支事务的提交或回滚</li></ul><h3 id="3-1-AT-模式"><a href="#3-1-AT-模式" class="headerlink" title="3.1 AT 模式"></a>3.1 AT 模式</h3><p><strong>前提</strong></p><ul><li>基于本地 ACID 事务的关系型数据库</li><li>Java 应用，通过 JDBC 访问数据库</li></ul><p><strong>整体机制</strong></p><p>2PC 的演变：</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源</li><li>二阶段：<ul><li>提交异步化，非常快速地完成</li><li>回滚通过一阶段的回滚日志进行反向补偿</li></ul></li></ul><p><strong>单个分支事务执行过程</strong></p><p><img src="../../images/springcloud/8/AT%E6%A8%A1%E5%BC%8F%E5%88%86%E6%94%AF%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png"></p><p><strong>全局事务之间写隔离</strong></p><ul><li>一阶段提交本地事务之前，需要获取<strong>全局锁</strong></li><li>拿不到<strong>全局锁</strong>，不能提交本地事务</li><li>拿<strong>全局锁</strong>的尝试限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁</li></ul><p><img src="../../images/springcloud/8/AT%E5%86%99%E9%9A%94%E7%A6%BB-%E5%85%A8%E5%B1%80%E6%8F%90%E4%BA%A4.png"></p><p><img src="../../images/springcloud/8/AT%E5%86%99%E9%9A%94%E7%A6%BB-%E5%85%A8%E5%B1%80%E5%9B%9E%E6%BB%9A.png"></p><p><strong>读隔离</strong></p><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。 </p><p> 如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。 </p><p><img src="../../images/springcloud/8/AT%E8%AF%BB%E9%9A%94%E7%A6%BB.png"></p><h3 id="3-2-TCC-模式"><a href="#3-2-TCC-模式" class="headerlink" title="3.2 TCC 模式"></a>3.2 TCC 模式</h3><p> 所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。 </p><p>AT 模式：</p><ul><li>prepare：在本地事务中，一并提交业务数据和相应的回滚日志记录</li><li>commit：马上成功结束，<strong>自动</strong>异步批量清理回滚日志</li><li>rollback：通过回滚日志，<strong>自动</strong>生成补偿操作，完成数据回滚</li></ul><p>TCC 模式：</p><ul><li>prepare：调用<strong>自定义</strong>的 prepare 逻辑</li><li>commit：调用<strong>自定义</strong>的 commit 逻辑</li><li>rollback：调用<strong>自定义</strong>的 rollback 逻辑</li></ul><h3 id="3-3-Saga-模式"><a href="#3-3-Saga-模式" class="headerlink" title="3.3 Saga 模式"></a>3.3 Saga 模式</h3><p>长事务解决方案，每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者， 一阶段正向服务和二阶段补偿服务都由业务开发实现。 </p><p><strong>适用场景</strong></p><ul><li>业务流程长、业务流程多</li><li>参与者包含其他公司或遗留系统，无法提供 TCC 模式要求的三个接口</li></ul><p><strong>优势</strong></p><ul><li>一阶段提交本地事务，无锁性能高</li><li>时间驱动架构，参与者可异步执行，高吞吐</li><li>补偿服务易于实现</li></ul><p><strong>缺点</strong></p><ul><li>不保证隔离性</li></ul><h2 id="4、seata-demo"><a href="#4、seata-demo" class="headerlink" title="4、seata demo"></a>4、seata demo</h2><h3 id="4-1-启动-eureka"><a href="#4-1-启动-eureka" class="headerlink" title="4.1 启动 eureka"></a>4.1 启动 eureka</h3><p>不再赘述</p><h3 id="4-2-下载并配置-seata-server"><a href="#4-2-下载并配置-seata-server" class="headerlink" title="4.2 下载并配置 seata server"></a>4.2 下载并配置 seata server</h3><p><strong>创建 seata-server 数据库</strong></p><pre><code class="sql">-- 创建数据库-- 分支事务表CREATE TABLE `branch_table` (  `branch_id` bigint(20) NOT NULL,  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `transaction_id` bigint(20) DEFAULT NULL,  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `status` tinyint(4) DEFAULT NULL,  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  PRIMARY KEY (`branch_id`) USING BTREE,  KEY `idx_xid` (`xid`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;-- 全局事务表CREATE TABLE `global_table` (  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `transaction_id` bigint(20) DEFAULT NULL,  `status` tinyint(4) NOT NULL,  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `timeout` int(11) DEFAULT NULL,  `begin_time` bigint(20) DEFAULT NULL,  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  PRIMARY KEY (`xid`) USING BTREE,  KEY `idx_gmt_modified_status` (`gmt_modified`,`status`) USING BTREE,  KEY `idx_transaction_id` (`transaction_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;-- 全局锁CREATE TABLE `lock_table` (  `row_key` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `xid` varchar(96) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `transaction_id` bigint(20) DEFAULT NULL,  `branch_id` bigint(20) NOT NULL,  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `table_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `pk` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  PRIMARY KEY (`row_key`) USING BTREE,  KEY `idx_branch_id` (`branch_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;</code></pre><p><strong>下载 seata-server</strong></p><pre><code>https://github.com/seata/seata/releases</code></pre><p><strong>修改配置</strong></p><p>1、file.conf</p><pre><code class="json">service &#123;  #transaction service group mapping  #my_test_tx_group 客户端必须和此一致  vgroup_mapping.my_test_tx_group = &quot;default&quot;  #only support when registry.type=file, please don&#39;t set multiple addresses  #seata-server服务的地址  default.grouplist = &quot;127.0.0.1:8091&quot;  #disable seata  disableGlobalTransaction = false&#125;store &#123;  ## store mode: file、db  # 修改  mode = &quot;db&quot;  ## file store property  file &#123;    ## store location dir    dir = &quot;sessionStore&quot;  &#125;  ## database store property  # db信息修改  db &#123;    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.    datasource = &quot;druid&quot;    ## mysql/oracle/h2/oceanbase etc.    db-type = &quot;mysql&quot;    #神坑。必须写 driverClassName，不可写 driver-class-name    driverClassName = &quot;com.mysql.cj.jdbc.Driver&quot;    url = &quot;jdbc:mysql://127.0.0.1:3306/seata-server?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;    user = &quot;root&quot;    password = &quot;root&quot;  &#125;&#125;</code></pre><p>2、registry.conf</p><pre><code class="json">registry &#123;  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa  # 修改  type = &quot;eureka&quot;  nacos &#123;    serverAddr = &quot;localhost&quot;    namespace = &quot;&quot;    cluster = &quot;default&quot;  &#125;  # 注意如果 eureka 需要密码，记得加上 alvin:pass9876@  eureka &#123;    serviceUrl = &quot;http://alvin:pass9876@localhost:8761/eureka&quot;    application = &quot;default&quot;    weight = &quot;1&quot;  &#125;  redis &#123;    serverAddr = &quot;localhost:6379&quot;    db = &quot;0&quot;  &#125;  zk &#123;    cluster = &quot;default&quot;    serverAddr = &quot;127.0.0.1:2181&quot;    session.timeout = 6000    connect.timeout = 2000  &#125;  consul &#123;    cluster = &quot;default&quot;    serverAddr = &quot;127.0.0.1:8500&quot;  &#125;  etcd3 &#123;    cluster = &quot;default&quot;    serverAddr = &quot;http://localhost:2379&quot;  &#125;  sofa &#123;    serverAddr = &quot;127.0.0.1:9603&quot;    application = &quot;default&quot;    region = &quot;DEFAULT_ZONE&quot;    datacenter = &quot;DefaultDataCenter&quot;    cluster = &quot;default&quot;    group = &quot;SEATA_GROUP&quot;    addressWaitTime = &quot;3000&quot;  &#125;  file &#123;    name = &quot;file.conf&quot;  &#125;&#125;config &#123;  # file、nacos 、apollo、zk、consul、etcd3  type = &quot;file&quot;  nacos &#123;    serverAddr = &quot;localhost&quot;    namespace = &quot;&quot;  &#125;  consul &#123;    serverAddr = &quot;127.0.0.1:8500&quot;  &#125;  apollo &#123;    app.id = &quot;seata-server&quot;    apollo.meta = &quot;http://192.168.1.204:8801&quot;  &#125;  zk &#123;    serverAddr = &quot;127.0.0.1:2181&quot;    session.timeout = 6000    connect.timeout = 2000  &#125;  etcd3 &#123;    serverAddr = &quot;http://localhost:2379&quot;  &#125;  file &#123;    name = &quot;file.conf&quot;  &#125;&#125;</code></pre><p><strong>启动 seata-server</strong></p><p><code>D:\seata-server-1.3.0\seata\bin\seata-server.bat</code></p><p>登录 eureka 控制台（<code>http://localhost:8761/</code>），发现 seata-server 已经作为一个服务注册进来。</p><h3 id="4-3-编写测试服务"><a href="#4-3-编写测试服务" class="headerlink" title="4.3 编写测试服务"></a>4.3 编写测试服务</h3><h4 id="创建测试库"><a href="#创建测试库" class="headerlink" title="创建测试库"></a><strong>创建测试库</strong></h4><pre><code class="sql">-- 创建三个数据库-- 创建业务表DROP TABLE IF EXISTS `seate-rm-one`.tbl_one;DROP TABLE IF EXISTS `seate-rm-two`.tbl_two;DROP TABLE IF EXISTS `seate-rm-three`.tbl_three;CREATE TABLE `seate-rm-one`.tbl_one(id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50)) ENGINE INNODB DEFAULT CHARSET utf8;CREATE TABLE `seate-rm-two`.tbl_two(id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50)) ENGINE INNODB DEFAULT CHARSET utf8;CREATE TABLE `seate-rm-three`.tbl_three(id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50)) ENGINE INNODB DEFAULT CHARSET utf8;SELECT * FROM `seate-rm-one`.tbl_one;SELECT * FROM `seate-rm-two`.tbl_two;SELECT * FROM `seate-rm-three`.tbl_three;-- 三个库均创建 undo_log 表，用于 RM 回滚CREATE TABLE `undo_log` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `branch_id` bigint(20) NOT NULL,  `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  `rollback_info` longblob NOT NULL,  `log_status` int(11) NOT NULL,  `log_created` datetime NOT NULL,  `log_modified` datetime NOT NULL,  `ext` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE,  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;</code></pre><p>神坑：</p><ul><li>业务表必须要主键</li></ul><p>seata 相关脚本官网位置：</p><pre><code>https://github.com/seata/seata/tree/1.3.0/script</code></pre><h4 id="创建测试服务"><a href="#创建测试服务" class="headerlink" title="创建测试服务"></a><strong>创建测试服务</strong></h4><p>1、pom</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.monkeykong&lt;/groupId&gt;    &lt;artifactId&gt;seata-rm-one&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;seata-rm-one&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt;        &lt;seata.version&gt;1.3.0&lt;/seata.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- web --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- eureka client --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql:阿里巴巴数据库连接池 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql:connector --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- seata --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-seata&lt;/artifactId&gt;            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;                    &lt;groupId&gt;io.seata&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;!-- seata-all --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.seata&lt;/groupId&gt;            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;            &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>2、properties</p><pre><code class="properties"># 服务名称spring.application.name=seata-rm-oneserver.port=8001# 注册中心eureka.client.enabled=trueeureka.client.service-url.defaultZone=http://alvin:pass9876@localhost:8761/eureka/eureka.instance.hostname=localhost# mybatis 配置## mybatis 配置文件所在路径mybatis.config-location=classpath:mybatis/mybatis.cfg.xml#mybatis.type-aliases-package=## 所有 mapper 映射文件mybatis.mapper-locations[0]=classpath:mybatis/mapper/*.xml# 数据源配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver## sqlyog 客户端连接不上:ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;spring.datasource.url=jdbc:mysql://localhost:3306/seate-rm-one?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=rootspring.datasource.dbcp2.initial-size=5spring.datasource.dbcp2.min-idle=5spring.datasource.dbcp2.max-idle=5spring.datasource.dbcp2.max-wait-millis=200spring.datasource.dbcp2.validation-query=SELECT 1spring.datasource.dbcp2.test-while-idle=truespring.datasource.dbcp2.test-on-borrow=falsespring.datasource.dbcp2.test-on-return=falsespring.cloud.alibaba.seata.tx-service-group=my_test_tx_group</code></pre><p>3、配置数据源代理</p><pre><code class="java">// 排除数据源自动装配@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)/** * 数据源代理 */@Configurationpublic class DataSourceConfiguration &#123;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    public DataSource druidDataSource()&#123;        DruidDataSource druidDataSource = new DruidDataSource();        return druidDataSource;    &#125;    @Primary    @Bean(&quot;dataSource&quot;)    public DataSourceProxy dataSource(DataSource druidDataSource)&#123;        return new DataSourceProxy(druidDataSource);    &#125;    @Bean    public SqlSessionFactory sqlSessionFactory(DataSourceProxy dataSourceProxy)throws Exception&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()                .getResources(&quot;classpath*:/mybatis/mapper/*.xml&quot;));        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());        return sqlSessionFactoryBean.getObject();    &#125;&#125;</code></pre><p>4、启动服务测试</p><pre><code class="java">@GetMapping(&quot;/rm1&quot;)public String rm1() &#123;    rmOneService.rm1();    return &quot;rm1 成功&quot;;&#125;//此注解开启全局事务@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)public void rm1() &#123;    rm2();    rm3();    One o = new One();    o.setName(&quot;rm1&quot;);    mapper.insertSelective(o);    //        int i = 1/0;&#125;private void rm2() &#123;    restTemplate.getForEntity(&quot;http://seata-rm-two/test/rm2&quot;, null);&#125;private void rm3() &#123;    restTemplate.getForEntity(&quot;http://seata-rm-three/test/rm3&quot;, null);&#125;</code></pre><p>seata RM 启动成功日志：</p><pre><code class="json"># TM 要连接的 seata-server 地址NettyClientChannelManager  : will connect to 192.168.238.1:8091# 为 TM 创建 NettyPoolNettyPoolableFactory  : NettyPool create channel to transactionRole:TMROLE,address:192.168.238.1:8091,msg:&lt; RegisterTMRequest&#123;applicationId=&#39;seata-rm-two&#39;, transactionServiceGroup=&#39;my_test_tx_group&#39;&#125; &gt;# TM 注册成功TmNettyRemotingClient    : register TM success. client version:1.3.0, server version:1.3.0,channel:[id: 0xc2bcb0b5, L:/192.168.238.1:55335 - R:/192.168.238.1:8091]# TM 注册成功NettyPoolableFactory  : register success, cost 9 ms, version:1.3.0,role:TMROLE,channel:[id: 0xc2bcb0b5, L:/192.168.238.1:55335 - R:/192.168.238.1:8091]</code></pre><h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>访问：<code>http://localhost:8001/test/rm1</code></p><p><strong>事务失败</strong></p><p>1、全局事务表，有一个全局事务</p><p><img src="../../images/springcloud/8/seata-%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E8%A1%A8.png"></p><p>2、分支事务表，有两个分支事务</p><p><img src="../../images/springcloud/8/seata-%E5%88%86%E6%94%AF%E4%BA%8B%E5%8A%A1%E8%A1%A8.png"></p><p>3、锁定表，两条锁定数据</p><p><img src="../../images/springcloud/8/seata-%E9%94%81%E5%AE%9A%E8%A1%A8.png"></p><p>4、回滚表，两个库各一条记录</p><p><img src="../../images/springcloud/8/seata-%E5%9B%9E%E6%BB%9A%E8%A1%A8.png"></p><p>5、日志信息</p><pre><code class="json"># SeataRmOneApplication 日志## 全局事务开始DefaultGlobalTransaction  : Begin new global transaction [192.168.238.1:8091:63599496698793984]## 全局事务回滚完成DefaultGlobalTransaction  : [192.168.238.1:8091:63599496698793984] rollback status: Rollbacked# SeataRmTwoApplication 日志## 分支事务完成，xid 变为 nullweb.SeataHandlerInterceptor  : xid in change during RPC from 192.168.238.1:8091:63599496698793984 to null## 分支事务回滚RmBranchRollbackProcessor    : rm handle branch rollback process:xid=192.168.238.1:8091:63599496698793984,branchId=63599496786874369,branchType=AT,resourceId=jdbc:mysql://localhost:3306/seate-rm-two,applicationData=null## 分支事务回滚中...AbstractRMHandler            : Branch Rollbacking: 192.168.238.1:8091:63599496698793984 63599496786874369 jdbc:mysql://localhost:3306/seate-rm-two## 通过 undo_log 回滚并删除 undo_logAbstractUndoLogManager       : xid 192.168.238.1:8091:63599496698793984 branch 63599496786874369, undo_log deleted with GlobalFinished## 分支事务回滚完成AbstractRMHandler            : Branch Rollbacked result: PhaseTwo_Rollbacked</code></pre><p>6、业务表均无数据，分布式事务成功</p><pre><code class="sql">SELECT * FROM `seate-rm-one`.tbl_one;SELECT * FROM `seate-rm-two`.tbl_two;SELECT * FROM `seate-rm-three`.tbl_three;</code></pre><p><strong>事务成功</strong></p><p>业务表正常插入数据。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(七)</title>
    <link href="http://yoursite.com/2020-10-10-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(7)-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"/>
    <id>http://yoursite.com/2020-10-10-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(7)-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</id>
    <published>2020-10-10T15:43:12.000Z</published>
    <updated>2020-11-24T14:43:52.598Z</updated>
    
    <content type="html"><![CDATA[<ul><li>分布式锁</li></ul><a id="more"></a><h2 id="1、我们真的需要锁么？"><a href="#1、我们真的需要锁么？" class="headerlink" title="1、我们真的需要锁么？"></a>1、我们真的需要锁么？</h2><p>需要锁的条件：</p><ol><li>多任务环境下。（进程，线程）</li><li>任务都对同一共享资源进行写操作。</li><li>对资源的访问是互斥的。</li></ol><p>操作周期：</p><ol><li>竞争锁。获取锁后才能对资源进行操作。</li><li>占有锁。操作中。</li><li>其他竞争者，任务阻塞。</li><li>占有锁者，释放锁。继续从 1 开始。</li></ol><p>分布式锁应用场景：</p><p>​    服务集群，比如 N 个订单服务，接受到大量司机的发送的对一个订单的抢单请求。如果是单个服务，可以用 jvm 锁控制，但是服务集群，jvm 就不行了。因为不在一个 jvm 中。jvm 锁解决不了分布式环境中的加锁问题。</p><h2 id="2、分布式锁解决方案"><a href="#2、分布式锁解决方案" class="headerlink" title="2、分布式锁解决方案"></a>2、分布式锁解决方案</h2><p>服务启动：</p><p><img src="../../images/springcloud/7/%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1.png"></p><p>jmeter 测试：10个司机同时抢一张订单。</p><p><img src="../../images/springcloud/7/jmeter%E6%B5%8B%E8%AF%951.png"></p><p><img src="../../images/springcloud/7/jmeter%E6%B5%8B%E8%AF%952.png"></p><p><img src="../../images/springcloud/7/jmeter%E6%B5%8B%E8%AF%953.png"></p><h3 id="2-1-无锁情况"><a href="#2-1-无锁情况" class="headerlink" title="2.1 无锁情况"></a>2.1 无锁情况</h3><p>测试结果：全部枪单成了。。。</p><pre><code class="json">@Qualifier(&quot;grabNoLockService&quot;)司机:5 执行抢单逻辑司机:7 执行抢单逻辑司机:1 执行抢单逻辑司机:2 执行抢单逻辑司机:9 执行抢单逻辑司机:5 抢单成功司机:7 抢单成功司机:1 抢单成功司机:2 抢单成功司机:9 抢单成功司机:10 执行抢单逻辑司机:4 执行抢单逻辑司机:6 执行抢单逻辑司机:8 执行抢单逻辑司机:3 执行抢单逻辑司机:10 抢单成功司机:8 抢单成功司机:6 抢单成功司机:4 抢单成功司机:3 抢单成功</code></pre><p>结论：没锁肯定不行的。本来只有一张订单，现在你分出去十张订单了。</p><h3 id="2-1-JVM-锁"><a href="#2-1-JVM-锁" class="headerlink" title="2.1 JVM 锁"></a>2.1 JVM 锁</h3><p>测试结果：有两个司机枪单成功了。</p><pre><code class="json">@Qualifier(&quot;grabJvmLockService&quot;)司机:4 执行抢单逻辑司机:4 抢单成功司机:3 执行抢单逻辑司机:3 抢单失败司机:5 执行抢单逻辑司机:5 抢单失败司机:7 执行抢单逻辑司机:7 抢单失败司机:6 执行抢单逻辑司机:6 抢单失败司机:1 执行抢单逻辑司机:1 抢单成功司机:8 执行抢单逻辑司机:8 抢单失败司机:9 执行抢单逻辑司机:9 抢单失败司机:10 执行抢单逻辑司机:10 抢单失败司机:2 执行抢单逻辑司机:2 抢单失败</code></pre><p>结论：JVM 锁无法解决分布式，集群环境的问题。因为 JVM 锁只能控制单个 JVM 内部同步。所以需要分布式锁。</p><h3 id="2-2-基于-MySQL-实现分布式锁"><a href="#2-2-基于-MySQL-实现分布式锁" class="headerlink" title="2.2 基于 MySQL 实现分布式锁"></a>2.2 基于 MySQL 实现分布式锁</h3><p>测试结果：只有一个司机抢单成功，OK 的。</p><pre><code class="json">加锁对象:OrderLock(orderId=1001, driverId=2)司机:2 执行抢单逻辑司机:2 抢单成功解锁对象:OrderLock(orderId=1001, driverId=2)加锁对象:OrderLock(orderId=1001, driverId=4)司机:4 执行抢单逻辑司机:4 抢单失败解锁对象:OrderLock(orderId=1001, driverId=4)加锁对象:OrderLock(orderId=1001, driverId=10)司机:10 执行抢单逻辑司机:10 抢单失败解锁对象:OrderLock(orderId=1001, driverId=10)加锁对象:OrderLock(orderId=1001, driverId=9)司机:9 执行抢单逻辑司机:9 抢单失败解锁对象:OrderLock(orderId=1001, driverId=9)加锁对象:OrderLock(orderId=1001, driverId=1)司机:1 执行抢单逻辑司机:1 抢单失败解锁对象:OrderLock(orderId=1001, driverId=1)加锁对象:OrderLock(orderId=1001, driverId=8)司机:8 执行抢单逻辑司机:8 抢单失败解锁对象:OrderLock(orderId=1001, driverId=8)加锁对象:OrderLock(orderId=1001, driverId=5)司机:5 执行抢单逻辑司机:5 抢单失败解锁对象:OrderLock(orderId=1001, driverId=5)加锁对象:OrderLock(orderId=1001, driverId=7)司机:7 执行抢单逻辑司机:7 抢单失败解锁对象:OrderLock(orderId=1001, driverId=7)加锁对象:OrderLock(orderId=1001, driverId=3)司机:3 执行抢单逻辑司机:3 抢单失败解锁对象:OrderLock(orderId=1001, driverId=3)加锁对象:OrderLock(orderId=1001, driverId=6)司机:6 执行抢单逻辑司机:6 抢单失败解锁对象:OrderLock(orderId=1001, driverId=6)</code></pre><p>结论：基于 MySQL 可以实现分布式锁。</p><p>存在的问题：</p><ul><li><p>如果中间出现异常了，如何释放锁？比如加锁后服务器断电了，finally 都来不及跑。</p><ul><li>用存储过程可以解决？具体怎么解决？加锁-操作订单-释放锁 放在一个 sp 中？</li></ul></li><li><p>MySQL 的并发是有限制的，不适合高并发场景。<strong>具体并发数要看机器的配置而定。</strong></p><ul><li><p>压测结果：<a href="https://help.aliyun.com/document_detail/150351.html?spm=a2c4g.11186623.6.1463.1e732d02nCMBBa">https://help.aliyun.com/document_detail/150351.html?spm=a2c4g.11186623.6.1463.1e732d02nCMBBa</a></p><p>4核 16GB ：最大连接数 4000，QPS  39766.67  四万左右，TPS  1988.33  两千左右</p><p>8核 16GB ：最大连接数 4000，QPS   64750.34 六万左右，TPS   3237.52 三千左右</p></li><li><p>牛逼点的：<a href="https://help.aliyun.com/document_detail/101100.html?spm=5176.11065259.1996646101.searchclickresult.5a6316bcjenDJn">https://help.aliyun.com/document_detail/101100.html?spm=5176.11065259.1996646101.searchclickresult.5a6316bcjenDJn</a></p></li></ul></li></ul><h3 id="2-3-基于-Redis-实现分布式锁"><a href="#2-3-基于-Redis-实现分布式锁" class="headerlink" title="2.3 基于 Redis 实现分布式锁"></a>2.3 基于 Redis 实现分布式锁</h3><pre><code class="sh">stringRedisTemplate 用法https://blog.csdn.net/zzz127333092/article/details/88742088</code></pre><p>redis：内存存储的数据结构服务器，内存数据库。redis 是单进程单线程的。</p><p>可用于：数据库，高速缓存，消息队列。采用单线程模型，并发能力强大。10 万并发没问题。</p><p>测试结果：只有一个司机抢单成功，OK 的。</p><pre><code class="json">司机:2 执行抢单逻辑司机:2 抢单成功司机:5 执行抢单逻辑司机:5 抢单失败司机:4 执行抢单逻辑司机:4 抢单失败司机:9 执行抢单逻辑司机:9 抢单失败司机:3 执行抢单逻辑司机:3 抢单失败司机:8 执行抢单逻辑司机:8 抢单失败司机:10 执行抢单逻辑司机:10 抢单失败司机:7 执行抢单逻辑司机:7 抢单失败司机:6 执行抢单逻辑司机:6 抢单失败司机:1 执行抢单逻辑司机:1 抢单失败</code></pre><p>结论：如果 redis 是单节点是 OK 的。但是如果是多节点，由于 Redis 的主从复制（replication）是异步的，这可能导致丧失锁的安全性。</p><blockquote><p>《Redis 分布锁》</p></blockquote><h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><p><strong><em>加锁</em></strong></p><pre><code class="shell">SET orderId driverId NX PX 30000set order_1001 driver_001 nx px 30000</code></pre><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p><strong><em>释放锁</em></strong></p><p>关键，判断是不是自己加的锁。</p><p><strong><em>关注点</em></strong>：</p><ol><li><p>orderId，是我们的 key，要锁的目标。一个单只能分配给一个司机，所以以 orderId 作为 key。</p></li><li><p>driverId 是我们的司机ID，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。即一个订单被一个司机抢。</p></li><li><p>NX 表示只有当 orderId 不存在的时候才能 SET 成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</p></li><li><p>PX 30000表示这个锁有一个 30 秒的自动过期时间。当然，这里 30 秒只是一个例子，客户端可以选择合适的过期时间。</p></li><li><p><strong>这个锁必须要设置一个过期时间。</strong>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分区，导致它再也无法和 Redis 节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。antirez在后面的分析中也特别强调了这一点，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p></li><li><p>此操作不能分割。</p><pre><code class="sh">SETNX orderId driverIdEXPIRE orderId 30虽然这两个命令和前面算法描述中的一个 SET 命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX 后崩溃了，那么就没有机会执行 EXPIRE 了，导致它一直持有这个锁。造成死锁。</code></pre></li><li><p>必须给 key 设置一个 value，并且保证每个线程不一样，用于释放锁时判断是否是自己的锁。如果 value 在每个线程间一样。会发生 <strong>误解锁</strong>的问题。</p><pre><code class="sh">1.客户端1获取锁成功。2.客户端1在某个操作上阻塞了很长时间。3.过期时间到了，锁自动释放了。4.客户端2获取到了对应同一个资源的锁。5.客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</code></pre></li><li><p>释放锁的操作，得释放自己加的锁。</p><pre><code class="sh">1.客户端1获取锁成功。2.客户端1访问共享资源。3.客户端1为了释放锁，先执行&#39;GET&#39;操作获取随机字符串的值。4.客户端1判断随机字符串的值，与预期的值相等。5.客户端1由于某个原因阻塞住了很长时间。6.过期时间到了，锁自动释放了。7.客户端2获取到了对应同一个资源的锁。8.客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</code></pre></li><li><p>redis故障问题。</p><p>如果 redis 故障了，所有客户端无法获取锁，服务变得不可用。为了提高可用性，我们给 redis 配置主从，当master不可用时，系统切换到 slave，但是由于 Redis 的主从复制（replication）是异步的，这可能导致丧失锁的安全性。</p><pre><code class="sh">1.客户端1从 Master 获取了锁。2.Master 宕机了，存储锁的 key 还没有来得及同步到Slave上。3.Slave 升级为 Master。4.客户端2从新的Master获取到了对应同一个资源的锁。</code></pre><p>客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p></li><li><p>这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。应该设置稍微短一些，如果线程持有锁，开启线程自动延长有效期（<strong>自动续租锁</strong>）。</p></li></ol><p><strong><em>还有一点，如果在过期时间内，程序没有执行完，是不能让key过期的，所以要延时。</em></strong></p><pre><code class="sh">断点打在：rlock.lock();执行完，之后，等着，去redis查看，看过期时间，是不是一直在变，答案：一直在变。到20时，自动加到30.</code></pre><p>为了解决 9、10 问题。antirez 设计了 Redlock 算法</p><p>Redis 的作者 antirez 给出了一个更好的实现，称为 Redlock，算是 Redis 官方对于实现分布式锁的指导规范。Redlock 的算法描述就放在 Redis 的官网上：</p><p><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p><h4 id="RedLock（多master）"><a href="#RedLock（多master）" class="headerlink" title="RedLock（多master）"></a>RedLock（多master）</h4><p>debug</p><pre><code class="sh">断点达到：rLock.lock()执行完后，看结果，发现如果是 3 个 redis 节点，则有 2 个节点中 设置了值。</code></pre><p>目的：对共享资源做互斥访问。   </p><p>因此 antirez 提出了新的分布式锁的算法 Redlock，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p><p>运行 Redlock 算法的客户端依次执行下面各个步骤，来完成 获取锁 的操作：</p><ol><li>获取当前时间（毫秒数）。</li><li>按顺序依次向 N 个 Redis 节点执行 <strong>获取锁</strong> 的操作。这个获取操作跟前面基于单 Redis 节点的 <strong>获取锁</strong> 的过程相同，包含 value driverId ，也包含<strong>过期时间</strong>(比如 <code>PX 30000</code> ，<strong>即锁的有效时间</strong>)。为了保证在某个Redis 节点不可用的时候算法能够继续运行，这个 <strong>获取锁</strong> 的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用，或者该 Redis 节点上的锁已经被其它客户端持有（注：Redlock 原文中这里只提到了 Redis 节点不可用的情况，但也应该包含其它的失败情况）。</li><li>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</li><li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。</li><li>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起 <strong>释放锁</strong> 的操作（即前面介绍的Redis Lua脚本）。</li></ol><p>当然，上面描述的只是 获取锁 的过程，而 释放锁 的过程比较简单：客户端向所有Redis节点发起 释放锁 的操作，不管这些节点当时在获取锁的时候成功与否。</p><blockquote><p>问题：Redis 节点崩溃重启，是否会对分布式锁造成影响？</p><p>答案：影响肯定是有的。即使持久化方式设置为每次修改都刷盘，也是会收到操作系统刷盘的影响的。antirez 提出延迟重启，让所有锁过期的方案。</p></blockquote><p>由于 N 个 Redis 节点中的大多数能正常工作就能保证 Redlock 正常工作，因此理论上它的可用性更高。我们前面讨论的单 Redis 节点的分布式锁在 failover 的时候锁失效的问题，在 Redlock 中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟 Redis 对数据的持久化程度有关。</p><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><ol><li>客户端1成功锁住了A, B, C， <strong>获取锁</strong> 成功（但D和E没有锁住）。</li><li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li><li>节点C重启后，客户端2锁住了C, D, E， <strong>获取锁</strong> 成功。</li></ol><p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis 的 AOF 持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis 允许设置成每次修改数据都进行 fsync，但这会降低性能。当然，即使执行了 fsync 也仍然有可能丢失数据（这取决于系统而不是 Redis 的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez 又提出了<strong>延迟重启</strong> (delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><blockquote><p>问题：为啥释放锁时要向所有 Redis 节点发送释放消息？</p><p>答案：因为异步通信模型中可能存在客户端向服务器是正常的，但是反方向却有问题。</p></blockquote><p>关于 Redlock 还有一点细节值得拿出来分析一下：在最后 释放锁 的时候，antirez 在算法描述中特别强调，客户端应该向所有 Redis 节点发起<strong>释放锁</strong>的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？设想这样一种情况，客户端发给某个 Redis 节点的 获取锁 的请求成功到达了该Redis节点，这个节点也成功执行了 <code>SET</code> 操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在 Redis 这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些 Redis 节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(六)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(6)-config.html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(6)-config.html</id>
    <published>2020-10-04T15:43:12.000Z</published>
    <updated>2020-11-24T14:43:49.616Z</updated>
    
    <content type="html"><![CDATA[<ul><li>配置中心</li><li>bus 消息总线同步刷新配置</li></ul><a id="more"></a><h2 id="1、配置中心"><a href="#1、配置中心" class="headerlink" title="1、配置中心"></a>1、配置中心</h2><h3 id="1-1-为什么需要配置中心？"><a href="#1-1-为什么需要配置中心？" class="headerlink" title="1.1 为什么需要配置中心？"></a>1.1 为什么需要配置中心？</h3><p>单体应用，配置写在配置文件中，没有什么大问题。如果要切换环境 可以切换不同的 profile（2种方式），但在微服务中。</p><ol><li><p>微服务比较多。成百上千，配置很多，需要集中管理。</p></li><li><p>管理不同环境的配置。</p></li><li><p>需要动态调整配置参数，更改配置不停服。</p></li></ol><h3 id="1-2-配置中心介绍"><a href="#1-2-配置中心介绍" class="headerlink" title="1.2 配置中心介绍"></a>1.2 配置中心介绍</h3><p>分布式配置中心包括 3 个部分：</p><ol><li>存放配置的地方：git ，本地文件 等。</li><li>config  server。从 1 读取配置。</li><li>config client。是 config server 的客户端，消费配置。</li></ol><p><img src="../../images/springcloud/configserver.png"></p><p><a href="https://m.sohu.com/a/116745628_466839">https://m.sohu.com/a/116745628_466839</a></p><p>配置都不会自己更新，都是需要触发 client 才去 git 上拉取的。或者触发在 config-server 上查看配置时，才去 git 上拉取。</p><h3 id="1-3-服务搭建-基于-Github"><a href="#1-3-服务搭建-基于-Github" class="headerlink" title="1.3 服务搭建-基于 Github"></a>1.3 服务搭建-基于 Github</h3><h4 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h4><pre><code class="shell">https://github.com/Monkey-kong/config-center.git</code></pre><p>上传配置 ribbon-consumer.dev.properties</p><pre><code class="properties">myconfig=&quot;config test v1&quot;</code></pre><h4 id="2-创建配置中心服务"><a href="#2-创建配置中心服务" class="headerlink" title="2. 创建配置中心服务"></a>2. 创建配置中心服务</h4><p>pom</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件</p><pre><code class="properties">spring.application.name=config-serverserver.port=9999eureka.client.service-url.defaultZone=http://alvin:pass9876@localhost:8761/eureka/# 拉取配置的仓库地址spring.cloud.config.server.git.uri=https://github.com/Monkey-kong/config-center.git# 仓库的分支spring.cloud.config.label=master</code></pre><p>启动类</p><pre><code class="java">@EnableConfigServer</code></pre><h4 id="3-配置匹配规则"><a href="#3-配置匹配规则" class="headerlink" title="3. 配置匹配规则"></a>3. 配置匹配规则</h4><p><strong>注意文件名称格式必须按照规则来</strong></p><pre><code>获取配置规则：根据前缀匹配/&#123;name&#125;-&#123;profiles&#125;.properties/&#123;name&#125;-&#123;profiles&#125;.yml/&#123;name&#125;-&#123;profiles&#125;.json/&#123;label&#125;/&#123;name&#125;-&#123;profiles&#125;.ymlname 服务名称profile 环境名称，开发、测试、生产：dev qa prdlable 仓库分支、默认master分支匹配原则：从前缀开始。</code></pre><h4 id="4-启动测试拉取"><a href="#4-启动测试拉取" class="headerlink" title="4.启动测试拉取"></a>4.启动测试拉取</h4><p>启动服务后访问服务</p><pre><code class="properties"># 同一分支，不同 profilehttp://localhost:9999/master/ribbon-consumer.dev.propertieshttp://localhost:9999/master/ribbon-consumer.test.propertieshttp://localhost:9999/master/ribbon-consumer.prd.properties# 切换分支http://localhost:9999/v1.0Release/ribbon-consumer.dev.propertieshttp://localhost:9999/v1.0Release/ribbon-consumer.test.propertieshttp://localhost:9999/v1.0Release/ribbon-consumer.prd.properties</code></pre><p>正确配置后能读到来自git的配置文件</p><h3 id="1-4-客户端配置"><a href="#1-4-客户端配置" class="headerlink" title="1.4 客户端配置"></a>1.4 客户端配置</h3><p>配置文件</p><p>修改 application.properties 为 bootstrap.properties</p><pre><code class="properties">#直接URL方式查找配置中心spring.cloud.config.uri=http://localhost:9999/#通过注册中心查找#spring.cloud.config.discovery.enabled=true#spring.cloud.config.discovery.service-id=a-configspring.cloud.config.profile=devspring.cloud.config.label=dev</code></pre><p>引入依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>使用远程配置</p><pre><code class="java">@RestControllerpublic class ConfigCenterTestController &#123;    @Value(&quot;$&#123;myconfig&#125;&quot;)    String myconfig;    @GetMapping    public String getMyConfig() &#123;        return myconfig;    &#125;&#125;</code></pre><p>测试</p><pre><code>http://localhost:9001/</code></pre><h2 id="2、刷新配置"><a href="#2、刷新配置" class="headerlink" title="2、刷新配置"></a>2、刷新配置</h2><h3 id="2-1-重启服务可以刷新"><a href="#2-1-重启服务可以刷新" class="headerlink" title="2.1 重启服务可以刷新"></a>2.1 重启服务可以刷新</h3><h3 id="2-2-actuator-单服务刷新"><a href="#2-2-actuator-单服务刷新" class="headerlink" title="2.2 actuator 单服务刷新"></a>2.2 actuator 单服务刷新</h3><ol><li>开启 actuator 中的 refresh 端点</li><li>Controller 中添加 <code>@RefreshScope</code> 注解</li><li>向客户端 url <code>http://localhost:9001/actuator/refresh</code> 发送Post请求</li><li>测试：<code>http://localhost:9001/</code></li></ol><h3 id="2-3-Bus-多服务刷新"><a href="#2-3-Bus-多服务刷新" class="headerlink" title="2.3 Bus 多服务刷新"></a>2.3 Bus 多服务刷新</h3><p>所有微服务注册到 Bus，有事件时 Bus 通过需要处理的微服务。</p><h4 id="erlang安装"><a href="#erlang安装" class="headerlink" title="erlang安装"></a>erlang安装</h4><p><a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a></p><h4 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h4><p><a href="http://www.rabbitmq.com/install-windows.html">http://www.rabbitmq.com/install-windows.html</a></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>path 中添加 <code>%ERLANG_HOME%\bin</code>，cmd 中输入 <code>erl</code>验证。</p><pre><code class="bash"># 启动服务RabbitMQ Service - start# 开启RabbitMQ节点cd D:\rabbitmq\rabbitmq_server-3.8.9\sbinrabbitmqctl start_app# 开启RabbitMQ管理模块的插件，并配置到RabbitMQ节点上rabbitmq-plugins enable rabbitmq_management</code></pre><h4 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h4><p><a href="http://localhost:15672/">http://localhost:15672</a></p><p>用户名密码均为guest</p><h4 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h4><p>配置文件</p><pre><code class="properties">spring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guest</code></pre><p>依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动两个微服务</p><p>修改配置文件后向其中一个端点发送post请求</p><p><a href="http://localhost:91/actuator/bus-refresh">http://localhost:91/actuator/bus-refresh</a></p><p>观察另一个服务是否也跟着刷新了</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;配置中心&lt;/li&gt;
&lt;li&gt;bus 消息总线同步刷新配置&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话管理(一)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(1).html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(1).html</id>
    <published>2020-10-04T12:43:12.000Z</published>
    <updated>2020-11-24T14:44:08.234Z</updated>
    
    <content type="html"><![CDATA[<p>分布式会话基本概念理解。</p><a id="more"></a><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="1-1-Session、Cookies-与-Token"><a href="#1-1-Session、Cookies-与-Token" class="headerlink" title="1.1 Session、Cookies 与 Token"></a>1.1 Session、Cookies 与 Token</h3><p>我们使用浏览器访问网站，使用的是 http 协议，http 协议是无状态的，即两次不同请求服务器无法知晓是谁请求的。浏览器每次请求 Header 中会带有 UA 信息，服务器根据 UA 信息生成一个唯一字符串(session)，然后下发给浏览器，后边浏览器每次请求都在 Cookies 中带上这个 session。所以使用 Session、Cookies 技术可以实现自动保持会话。</p><p>如果浏览器禁用 Cookies，或者是 app 请求，可以使用 token 代替 session，客户端每次请求手动把 token 加入请求参数或者放入请求 header 中。token 可以实现跨平台。</p><h3 id="1-2-浏览器同源策略与跨域"><a href="#1-2-浏览器同源策略与跨域" class="headerlink" title="1.2 浏览器同源策略与跨域"></a>1.2 浏览器同源策略与跨域</h3><h4 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h4><p>域名、协议、端口都会造成不同源。</p><p>浏览器的同源策略是一种安全功能，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。所以 a.com 下的 js 脚本采用 ajax 读取 b.com 里面的文件数据是会报错的。</p><h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><script>、<img> 、<iframe>、<link>、<video>这些标签都可以发起跨域请求，就是说不受同源策略的限制#### jsonp 跨域访问原理此方法只能发起 GET 请求，通过 jsonp 发送的请求，会随带 cookie 一起发送。#### CORS在浏览器中指定 Origin 来源，如果在服务器接受范围，请求则成功CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 `GET` 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。## 2、ShiroShiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 SpringSecurity，可能没有 Spring Security 做的功能强大，但是在实际工作时 可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。#### 核心功能**Authentication**：身份认证/登录，验证用户是不是拥有相应的身份；**Authorization**：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；**Session Manager**：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；**Cryptography**：加密（解密 摘要算法），保护数据的安全性，如密码加密存储到数据库，而不是明文存储；**Web Support**：Web 支持，可以非常容易的集成到 Web 环境；**Caching**：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；**Concurrency**：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；**Testing**：提供测试支持；**Run As**：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；**Remember Me**：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。#### 组件**Subject**：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；**SecurityManager**：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；**Realm**：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。## 3、Spring securitySpring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于 Spring 的应用程序提供身份验证和授权支持。它与 Spring MVC 有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。### 3.1 基本使用pom```xml<dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-security</artifactId></dependency><dependency>    <groupId>org.springframework.security</groupId>    <artifactId>spring-security-test</artifactId>    <scope>test</scope></dependency>```直接启动，生成默认密码```Using generated security password: 6e86c6e9-d661-41ae-aabc-bea8817c4f7b```使用该密码和用户名 user 来访问系统。### 3.2 自定义用户名和密码使用配置文件：```propertiesspring.security.user.name=111spring.security.user.password=111```使用类配置：```java@Configuration@EnableWebSecuritypublic class MyConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        String pass1 = new BCryptPasswordEncoder().encode("123");        String pass2 = new BCryptPasswordEncoder().encode("123");        System.out.println("pass1:" + pass1);        System.out.println("pass2:" + pass2);        // super.configure(http);        // 哪些地址需要登录        http.authorizeRequests()            // 所有请求都需要验证            .anyRequest().authenticated()            .and()            // 自定义登录页            .formLogin().loginPage("/login.html")            .loginProcessingUrl("/login").permitAll()            // 登录失败跳转页面            .failureUrl("/login.html?error")            // 登录成功跳转页面            .defaultSuccessUrl("/ok", true).permitAll()            // 配置登录页的表单 name            .passwordParameter("oo")            .usernameParameter("xx")            // 根据不同的异常类型，做不同的处理，跳转不同的页面            .failureHandler(new AuthenticationFailureHandler() {                @Override                public void onAuthenticationFailure(HttpServletRequest request,                                                    HttpServletResponse response,                                                    AuthenticationException e) throws IOException, ServletException {                    e.printStackTrace();                    // 判断异常信息                    request.getRequestDispatcher(request.getRequestURL().toString()).forward(request, response);                    // 记录登录失败的次数，禁止登录                }            })            .and()            .csrf() // 默认所有 post 请求都会拦截            //.disable() // 如果 disable 掉，则不会下发 csrf token            .csrfTokenRepository(new HttpSessionCsrfTokenRepository()) // 下发 csrf token            ;    }    // 基于 session 的登录，本身并发量不是很高，如果并发量高，直接用 JWT 代替，并写 redis 了。    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        // 注释掉后，所有默认配置失效。配置文件中的用户名和密码不生效了        // super.configure(auth);        auth.inMemoryAuthentication()            .withUser("123").password(new BCryptPasswordEncoder().encode("123")).roles("admin")            .and()            .withUser("321").password("321").roles("user")        ;    }    @Bean    PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }    // 如果已经配置 configure(AuthenticationManagerBuilder auth)，这里无效果    @Bean    public UserDetailsService userDetailsService() {        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();        User user = new User("4", new BCryptPasswordEncoder().encode("4"), true, true, true, true, Collections.singletonList(new SimpleGrantedAuthority("4")));        manager.createUser(user);        manager.createUser(User.withUsername("5").password(new BCryptPasswordEncoder().encode("5")).roles("5").build());        return manager;    }}```**User 对象**如果需要增加新字段，自己定义一个新类，继承 User 即可。```java    private String password;    private final String username;    private final Set<GrantedAuthority> authorities;    private final boolean accountNonExpired;    private final boolean accountNonLocked;    private final boolean credentialsNonExpired;    private final boolean enabled;```**Session 中存储的对象**?```javaEnumeration<String> attributeNames = request.getSession().getAttributeNames();//        while (attributeNames.hasMoreElements()) {//            String string = (String) attributeNames.nextElement();//            System.out.println(string);//            System.out.println(request.getSession().getAttribute(string));//            //        }SecurityContext attribute = (SecurityContext)request.getSession().getAttribute("SPRING_SECURITY_CONTEXT");System.out.println(attribute.getAuthentication().getAuthorities());```### 3.3 忽略静态请求```java@Overridepublic void configure(WebSecurity web) throws Exception {    web.ignoring().antMatchers("/img/**","/js/**");    //    super.configure(web);}```### 3.4 自定义登录页面和表单属性见 3.2## 4、OauthOAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。- Spring Social- Spring Session- JWT## 5、CSRF CSRF (Cross Site Request Forgery)攻击，中文名：**跨站请求伪造**。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用 POST 方式提交参数的页面。问题解决：- 全站 hash（可以完全禁止，但是一般都不会这么做），token 存放在页面上，每次请求下发这个 token。没有放在 cookies 中，别的 tab 页面获取不到这个数据，所以安全。cookies 中的数据是有可能共享的。- 全站 post 请求- 敏感操作手机验证码二次验证或者图片验证- 外部链接提示免责信息## 6、OpenID系统的第一部分是身份验证，即如何通过 URI 来认证用户身份。目前的网站都是依靠用户名和密码来登录认证，这就意味着大家在每个网站都需要注册用户名和密码，即便你使用的是同样的密码。如果使用 OpenID ，你的网站地址（URI）就是你的用户名，而你的密码安全的存储在一个 OpenID 服务网站上（你可以自己建立一个 OpenID 服务网站，也可以选择一个可信任的 OpenID 服务网站来完成注册）。## 7、CAS中心认证服务（Central Authentication Service）SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式会话基本概念理解。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式会话" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话管理(三)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(3).html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(3).html</id>
    <published>2020-10-04T12:43:12.000Z</published>
    <updated>2020-11-24T14:44:19.263Z</updated>
    
    <content type="html"><![CDATA[<p>SSO、OAuth2 和 JWT。</p><h2 id="1、什么是-SSO"><a href="#1、什么是-SSO" class="headerlink" title="1、什么是 SSO"></a>1、什么是 SSO</h2><p>多个系统使用一套认证服务。SSO 是为了解决一个用户在鉴权服务器登录过一次后，可以在任何应用中畅通无阻，一次登录，多系统访问。</p><h2 id="2、有状态会话与无状态会话"><a href="#2、有状态会话与无状态会话" class="headerlink" title="2、有状态会话与无状态会话"></a>2、有状态会话与无状态会话</h2><p>认证：验证账号密码对不对</p><p>授权：授予的权限</p><p>有状态会话：客户端有 Cookies，服务端有 Session，sessionId 对上了就找到了对应的 User 对象。也就找到了该对象的授权信息。</p><p>无状态会话：服务端不存 User 对象，而是把权限信息下发给客户端（UserID:权限信息）。微服务不主动、不拒绝、不负责。无状态体现在不服务端不存储权限信息（状态信息，以前服务端要存储 session，其实这是一个额外的负担，但是使用无状态会话，服务端完全可以不存储 token，但是服务端可以根据 token 来验证用户登录和权限，只需要把 token 给客户端就行）。这样可以实现在一个地方登录，就可以在整套系统使用。</p><p><img src="../../images/springcloud/jwt/%E6%9C%89%E7%8A%B6%E6%80%81%E4%BC%9A%E8%AF%9D.png"></p><p><img src="../../images/springcloud/jwt/%E6%97%A0%E7%8A%B6%E6%80%81%E4%BC%9A%E8%AF%9D.png"></p><h2 id="3、集群化-Session-共享"><a href="#3、集群化-Session-共享" class="headerlink" title="3、集群化 Session 共享"></a>3、集群化 Session 共享</h2><h3 id="3-1-架构分析"><a href="#3-1-架构分析" class="headerlink" title="3.1 架构分析"></a>3.1 架构分析</h3><p><strong>session 共享明显的缺点就是有会话的，用户客户端越多，产生的 session 也就越多，服务器需要维护 session。好处就是结构足够简单。</strong> </p><p><img src="../../images/springcloud/jwt/%E9%9B%86%E7%BE%A4%E5%8C%96session%E5%85%B1%E4%BA%AB.png"></p><h3 id="3-2-SpringSession-Redis"><a href="#3-2-SpringSession-Redis" class="headerlink" title="3.2 SpringSession + Redis"></a>3.2 SpringSession + Redis</h3><p>配置：</p><pre><code class="properties">spring.redis.host=localhost#spring.redis.password=spring.redis.port=6379spring.security.user.name=123spring.security.user.password=123server.port=81</code></pre><p>依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;            &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>controller:</p><pre><code class="java">@RestControllerpublic class MainController &#123;    @GetMapping    public String list(HttpServletRequest request)&#123;        request.getSession().setAttribute(&quot;list&quot;, &quot;hi&quot;);        return &quot;list&quot;;    &#125;    @GetMapping(&quot;/get&quot;)    public String get(HttpServletRequest request)&#123;        String list = request.getSession().getAttribute(&quot;list&quot;).toString();        return list;    &#125;&#125;</code></pre><p>验证：</p><ol><li>启动服务1，81端口</li><li>启动服务2，82端口</li><li>访问<code>http://localhost:81/</code>，登录</li><li>使用 postman 直接访问<code>http://localhost:82</code>，需要登录。把第三步的 SESSION 加入 cookies 中，无需登录即可访问。</li></ol><h2 id="4、OAuth2-0-原理、应用场景"><a href="#4、OAuth2-0-原理、应用场景" class="headerlink" title="4、OAuth2.0 原理、应用场景"></a>4、OAuth2.0 原理、应用场景</h2><p>统一认证，个性化授权。用户提交无状态 token，token 中可能带有 userid，role，但是针对不同系统，可能 role 对应的权限不同，所以还需要一个权限中心。</p><h2 id="5、OAuth2-0认证服务器资源服务器与第三方服务实现"><a href="#5、OAuth2-0认证服务器资源服务器与第三方服务实现" class="headerlink" title="5、OAuth2.0认证服务器资源服务器与第三方服务实现"></a>5、OAuth2.0认证服务器资源服务器与第三方服务实现</h2><h2 id="6、JWT-原理"><a href="#6、JWT-原理" class="headerlink" title="6、JWT 原理"></a>6、JWT 原理</h2><p>JSON Web Token。JWT 是一种基于 JSON 的令牌安全验证(在某些特定的场合可以替代 Session 或者 Cookie )，一次生成随处校验。<code>https://jwt.io/</code>。</p><h3 id="6-1-JWT组成"><a href="#6-1-JWT组成" class="headerlink" title="6.1 JWT组成"></a>6.1 JWT组成</h3><h4 id="头部信息-header"><a href="#头部信息-header" class="headerlink" title="头部信息(header)"></a>头部信息(header)</h4><p> <strong>作用</strong>：指定该 JWT 使用的签名算法</p><pre><code>  &#123;      “alg”: “HS256”,// 签名算法      “typ”: “JWT” //token类型    &#125;</code></pre><p>将上面的 json，用 Base64URL 算法转成字符串，即为 header。</p><h4 id="消息体playload"><a href="#消息体playload" class="headerlink" title="消息体playload"></a>消息体playload</h4><p><strong>作用</strong>：指定该 JWT 的请求数据</p><p>也就是负载的信息</p><pre><code>&#123;&quot;exp&quot; (expiration time)：过期时间&quot;sub&quot; (subject)：主题,一般用用户id,用来标识用户会话&quot;iat&quot; (Issued At)：签发时间&#125;</code></pre><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h4 id="签名-signature"><a href="#签名-signature" class="headerlink" title="签名( signature)"></a>签名( signature)</h4><p>Signature 部分是对前两部分的签名，<strong>防止数据篡改</strong>。<br>需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><pre><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret) header.payload.signature</code></pre><p><strong>头部、消息体、签名用 . 号连接</strong></p><p>最终：把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔连在一起就得到了我们要的 JWT。</p><h3 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h3><h4 id="JWT-工具类"><a href="#JWT-工具类" class="headerlink" title="JWT 工具类"></a>JWT 工具类</h4><pre><code class="java">public class JwtUtil &#123;    /**     * 密钥，仅服务端存储     */    private static String secret = &quot;ko346134h_we]rg3in_yip1!&quot;;    /**     *     * @param subject     * @param issueDate 签发时间     * @return     */    public static String createToken(String subject, Date issueDate) &#123;        Calendar c = Calendar.getInstance();        c.setTime(issueDate);        c.add(Calendar.DAY_OF_MONTH, 20);        String compactJws = Jwts.builder()                .setSubject(subject)                .setIssuedAt(issueDate)                .setExpiration(c.getTime())                .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, secret)                .compact();        return compactJws;    &#125;    /**     * 解密 jwt     * @param token     * @return     * @throws Exception     */    public static String parseToken(String token) &#123;        try &#123;            Claims claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();            if (claims != null)&#123;                return claims.getSubject();            &#125;        &#125;catch (ExpiredJwtException e)&#123;            e.printStackTrace();            System.out.println(&quot;jwt过期了&quot;);        &#125;        return &quot;&quot;;    &#125;    public static void main(String[] args) &#123;        String token = createToken(&quot;userId:1,role:admin,price:200&quot;, new Date());        System.out.println(&quot;服务器下发token:&quot;+token);        System.out.println(&quot;服务器解密token:&quot;+parseToken(token));        // token = header.payload.sign        // eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VySWQ6MSxyb2xlOmFkbWluLHByaWNlOjIwMCIsImlhdCI6MTYwMTkwOTMxMiwiZXhwIjoxNjAzNjM3MzEyfQ.h6eOdoqKXPpwxr46tiV95xSy4WpVB-HZjERz4G0pGQuZe5L-Mb0jiO7blLP-2fJMShuW5sanJn6wveolbh5UCg        String header = &quot;eyJhbGciOiJIUzUxMiJ9&quot;;        String payload = &quot;eyJzdWIiOiJ1c2VySWQ6MSxyb2xlOmFkbWluLHByaWNlOjIwMCIsImlhdCI6MTYwMTkwOTMxMiwiZXhwIjoxNjAzNjM3MzEyfQ&quot;;        String sign = &quot;h6eOdoqKXPpwxr46tiV95xSy4WpVB-HZjERz4G0pGQuZe5L-Mb0jiO7blLP-2fJMShuW5sanJn6wveolbh5UCg&quot;;        // &#123;&quot;alg&quot;:&quot;HS512&quot;&#125;        System.out.println(&quot;header 解密：&quot;+ new String(Base64.getDecoder().decode(header)));        // &#123;&quot;sub&quot;:&quot;userId:1,role:admin,price:200&quot;,&quot;iat&quot;:1601909312,&quot;exp&quot;:1603637312&#125;        System.out.println(&quot;payload 解密：&quot;+ new String(Base64.getDecoder().decode(payload)));        // sign = doSign(header + &quot;.&quot; + payload)    &#125;&#125;</code></pre><h4 id="pom-依赖"><a href="#pom-依赖" class="headerlink" title="pom 依赖"></a>pom 依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="Filter-校验"><a href="#Filter-校验" class="headerlink" title="Filter 校验"></a>Filter 校验</h4><pre><code class="java">@WebFilter(filterName = &quot;authFilter&quot;, urlPatterns = &quot;/**&quot;)@Componentpublic class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest)request;        String token = req.getHeader(&quot;token&quot;);        if (!StringUtils.isEmpty(token)) &#123;            // 判断请求的 token 是否正常            String payload = JwtUtil.parseToken(token);            if (!StringUtils.isEmpty(payload)) &#123;                System.out.println(&quot;token 验证成功。&quot;);                chain.doFilter(request,response);            &#125; else &#123;                System.out.println(&quot;token 验证失败，请求重新登录获取 token。。。&quot;);            &#125;        &#125; else &#123;            System.out.println(&quot;token 为空，请登录获取 token。。。&quot;);        &#125;    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;authFilter init finish...&quot;);    &#125;&#125;</code></pre><h4 id="请求验证"><a href="#请求验证" class="headerlink" title="请求验证"></a>请求验证</h4><pre><code>http://localhost:8080postman 直接请求，提示 token 为空加上 token，提示 token 校验成功随便修改 token，校验失败</code></pre><p>防止截获 token，https或者二次加密。</p><p>为啥用途广，因为性能高，跨系统。</p><p>服务器端密文如何防止外泄？</p><ul><li>SpringCoud Config 下发配置，控制开发人员 prod</li><li>线上代码 syso -&gt; 日志</li><li>制度，一次直接开除</li></ul><h2 id="7、JWT-在微服务中的应用"><a href="#7、JWT-在微服务中的应用" class="headerlink" title="7、JWT 在微服务中的应用"></a>7、JWT 在微服务中的应用</h2><h2 id="8、使用-JWT-替换-SpringSecurity-Session-认证"><a href="#8、使用-JWT-替换-SpringSecurity-Session-认证" class="headerlink" title="8、使用 JWT 替换 SpringSecurity Session 认证"></a>8、使用 JWT 替换 SpringSecurity Session 认证</h2><p>SpringSecurity 中加入 Filter，拿到 token，解密 token 后拿到 userid，说明登录了，认证完成。</p><p>解密 token，拿到角色，也就拿到了权限。</p><p>所以 SpringSecurity 整合 JWT 意味着放弃了之前的基于 session 登录那一套，原来的一些基于 session 的注解可能不可用了。如果非要用，可以把拿到的无状态 token，包装成有状态的 session，这样也就丢失了 JWT 的无状态的优点，也会有数据不一致问题。</p><h2 id="9、JWT-Token-在浏览器-App-如何防止重放攻击？"><a href="#9、JWT-Token-在浏览器-App-如何防止重放攻击？" class="headerlink" title="9、JWT Token 在浏览器/App 如何防止重放攻击？"></a>9、JWT Token 在浏览器/App 如何防止重放攻击？</h2><p>XSS 攻击。嵌入非法 js 到系统。</p><h2 id="10、OAuth2-0-与-OpenID-对比"><a href="#10、OAuth2-0-与-OpenID-对比" class="headerlink" title="10、OAuth2.0 与 OpenID 对比"></a>10、OAuth2.0 与 OpenID 对比</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SSO、OAuth2 和 JWT。&lt;/p&gt;
&lt;h2 id=&quot;1、什么是-SSO&quot;&gt;&lt;a href=&quot;#1、什么是-SSO&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 SSO&quot;&gt;&lt;/a&gt;1、什么是 SSO&lt;/h2&gt;&lt;p&gt;多个系统使用一套认证服务。SSO </summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式会话" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话管理(四)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(4).html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(4).html</id>
    <published>2020-10-04T12:43:12.000Z</published>
    <updated>2020-11-24T14:44:22.759Z</updated>
    
    <content type="html"><![CDATA[<p>Token/接口安全性问题、XSS 攻击、Oauth2</p><h2 id="1-Token-安全性问题"><a href="#1-Token-安全性问题" class="headerlink" title="1. Token 安全性问题"></a>1. Token 安全性问题</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><ul><li>XSS 重放攻击<ul><li>非法 js 读取 header 中的 token，这就可以发送非法请求了</li><li>用户提交表单（比如发帖子），填入了非法 js，被存入 DB。</li><li>非法 js 被其他用户加载到页面，就执行了非法的 js 请求了，这就是 XSS 攻击。</li><li>hash(url+timestamp+token+盐)=hmac ，服务端重新验证，匹配上则认为是安全的请求。但是这个盐非法 js 也可以读到，不能防止 XSS 攻击。hmac 只能防止数据被篡改。有了 https 为什么还要用 hmac？nginx 和 公网之间使用 https 保证数据不会在公网被篡改。<strong>微服务内部都是 http 协议通信，所以用 hmac 防止内网泄漏。在业务端检查数据是否被篡改。</strong></li></ul></li><li>SCRF 跨域攻击</li></ul><h3 id="1-2-Token-携带方式"><a href="#1-2-Token-携带方式" class="headerlink" title="1.2 Token 携带方式"></a>1.2 Token 携带方式</h3><p><strong>浏览器</strong></p><ul><li>http header<ul><li>js 是否可以读取当前浏览器 header 中的东西？可以</li></ul></li><li>url 上的 Get 请求<ul><li>js 可以读到</li></ul></li><li>Cookies<ul><li>js 可以读到</li></ul></li><li>localstorage<ul><li>js 可以读到</li></ul></li></ul><p><strong>APP</strong></p><p>server 下发 app，通过 https</p><p>app 没有 xss 攻击。app 装在每个手机，抓包只能抓到自己的数据，抓不到别人数据。</p><p>除非 webview 可能存在重放攻击。可以通过本地代理，过滤无效请求。</p><h3 id="1-3-如何防止-XSS-重放攻击"><a href="#1-3-如何防止-XSS-重放攻击" class="headerlink" title="1.3 如何防止 XSS 重放攻击"></a>1.3 如何防止 XSS 重放攻击</h3><p><strong>没用的解决办法：</strong></p><ul><li><p>token 只能用一次。token 用完之后，放入缓存，相当于加入了黑名单。不能防止 XSS 攻击，非法 js 还是可以拿到新的 token。</p></li><li><p>设法先执行非法 js，再加载 token？不行，非法 js 可以死循环一直跑。</p></li><li><p>hmac，即给数据签名。不行，由于盐是在客户端，正常 js 可以读取到，非法 js 也可以读取到，也就可以发送同样的请求。</p></li><li><p>token 有效期设置短一点，有一点点效果。</p></li></ul><p>所以怎么做都没法防止非法 js 获取 token，也就无法防止非法 js 执行 XSS 攻击。</p><p><strong>有用的解决办法：</strong></p><ul><li>加入人机交互：图形验证码，旧密码，删除（confirm 1+1=?）</li><li>防止非法 js 进入系统：表单提交（发帖子）非法字符<strong>转义</strong>处理（URLEncode）</li><li>服务端定期扫描：定期扫描服务器端静态资源、数据库字段。比如扫描所有<code>&lt;script src</code></li><li>记录日志：出现问题时，能够快速追溯到原因</li></ul><p>综合：web 端防不住</p><h3 id="1-4-token-丢了咋办？"><a href="#1-4-token-丢了咋办？" class="headerlink" title="1.4 token 丢了咋办？"></a>1.4 token 丢了咋办？</h3><ul><li><p>转移责任：短音验证码、ip 改变时发出安全提示</p></li><li><p>人机交互：滑动</p></li><li><p>代码混淆：加盐、无法反编译，乱码</p></li></ul><p>物理隔离：</p><p>放内部人员。需要通过制度约束。</p><h2 id="2-oauth2-0"><a href="#2-oauth2-0" class="headerlink" title="2. oauth2.0"></a>2. oauth2.0</h2><p>和 JWT 一样，是一套标准，不是一个具体的框架。<strong>OAuth 的核心就是向第三方应用颁发令牌</strong>。</p><h3 id="2-1-访问流程"><a href="#2-1-访问流程" class="headerlink" title="2.1 访问流程"></a>2.1 访问流程</h3><ol><li>用户访问资源服务器，发现用户没有权限，跳转登录页</li><li>用户访问认证服务器进行登录认证，得到权限</li><li>认证服务器带着该用户的权限通过重定向地址再次访问资源服务器</li><li>资源服务器发送 authentication code、client id、client secret 到认证服务器获取 access token</li><li>用户登录</li></ol><p>中间 authentication 有何作用，为啥要用访问两次认证服务器才拿到 token，第一次直接拿 token 不行吗？</p><h3 id="2-2-角色"><a href="#2-2-角色" class="headerlink" title="2.2 角色"></a>2.2 角色</h3><h4 id="Resource-Owner"><a href="#Resource-Owner" class="headerlink" title="Resource Owner"></a>Resource Owner</h4><p>资源拥有者。对应微信的每个用户微信上设置的个人信息是属于每个用户的，不属于腾讯。</p><h4 id="Resource-Server"><a href="#Resource-Server" class="headerlink" title="Resource Server"></a>Resource Server</h4><p>资源服务器，一般就是用户数据的一些操作（增删改查）的 REST API，比如微信的获取用户基本信息的接口。</p><h4 id="Client-Application"><a href="#Client-Application" class="headerlink" title="Client Application"></a>Client Application</h4><p>第三方客户端，对比微信中就是各种微信公众号开发的应用，第三方应用经过<code>认证服务器</code>授权后即可访问<code>资源服务器</code>的 REST API 来获取用户的头像、性别、地区等基本信息。</p><h4 id="Authorization-Server"><a href="#Authorization-Server" class="headerlink" title="Authorization Server"></a>Authorization Server</h4><p>认证服务器，验证第三方客户端是否合法。如果合法就给客户端颁布 token，第三方通过 token 来调用资源服务器的 API。</p><h3 id="2-3-授权类型"><a href="#2-3-授权类型" class="headerlink" title="2.3 授权类型"></a>2.3 授权类型</h3><h4 id="anthorization-code"><a href="#anthorization-code" class="headerlink" title="anthorization_code"></a>anthorization_code</h4><p>授权码类型，适用于 Web Server Application。</p><p>模式为：</p><ul><li>客户端先调用<code>/oauth/authorize/</code>进到用户授权界面，用户授权后返回 code</li><li>客户端然后根据 code 和 secret 获取 access token</li></ul><h4 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h4><p>简化类型，相对于授权码类型少了授权码获取的步骤。客户端应用授权后认证服务器会直接将access token放在客户端的 url。客户端解析 url 获取 token。这种方式其实是不太安全的，可以通过 <strong>https 安全通道</strong>和<strong>缩短 access token 的有效时间</strong>来较少风险。</p><h4 id="password"><a href="#password" class="headerlink" title="password"></a>password</h4><p>密码类型，客户端应用通过用户的 username 和 password 获 access token。适用于资源服务器、认证服务器与客户端具有完全的信任关系，因为要将用户要将用户的用户名密码直接发送给客户端应用，客户端应用通过用户发送过来的用户名密码获取 token，然后访问资源服务器资源。比如支付宝就可以直接用淘宝用户名和密码登录，因为它们属于同一家公司，彼此<strong>充分信任</strong>。</p><h4 id="client-credentials"><a href="#client-credentials" class="headerlink" title="client_credentials"></a>client_credentials</h4><p>客户端类型，是不需要用户参与的一种方式，用于不同服务之间的对接。比如自己开发的应用程序要调用短信验证码服务商的服务，调用地图服务商的服务、调用手机消息推送服务商的服务。当需要调用服务时可以直接使用服务商给的<code>appID</code>和<code>appSecret</code>来获取token，得到token之后就可以直接调用服务。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><strong>scope</strong>：访问资源服务器的哪些作用域。一组权限，Role</li><li><strong>refresh token</strong>：当 access token 过期后，可以通过 refresh token 重新获取 access token。</li></ul><h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul><li>单点登录</li><li>第三方登录<ul><li>微信授权：<a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html">https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html</a></li></ul></li></ul><h3 id="2-5-实现"><a href="#2-5-实现" class="headerlink" title="2.5 实现"></a>2.5 实现</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="认证服务器"><a href="#认证服务器" class="headerlink" title="认证服务器"></a>认证服务器</h4><pre><code class="java">/** * @author alvin * @date 2020-10-06 10:14 * 认证服务器配置 */@EnableAuthorizationServer@Configurationpublic class AuthorizationServerConfiguration  extends AuthorizationServerConfigurerAdapter &#123;    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;        clients.inMemory()                // 客户端名称                .withClient(&quot;client-postman&quot;)                // 重定向地址                .redirectUris(&quot;http://localhost:81/order&quot;)                // scopes-&gt;role                .scopes(&quot;read&quot;,&quot;write&quot;)                // 密码                .secret(&quot;secret&quot;)                // 授权类型                .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;,&quot;implicit&quot;,&quot;client_credentials&quot;);&#125;    @Override    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;        super.configure(security);    &#125;    @Override    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;        endpoints.authenticationManager(authenticationManager);    &#125;    @Autowired    @Qualifier(&quot;authenticationManagerBean&quot;)    private AuthenticationManager authenticationManager;&#125;</code></pre><h4 id="security-配置"><a href="#security-配置" class="headerlink" title="security 配置"></a>security 配置</h4><pre><code class="java">/** * @author alvin * @date 2020-10-06 10:17 * spring security 配置 */@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http            .formLogin()            // 关闭 csrf            .and().csrf().disable()            // 所有请求需要认证            .authorizeRequests().anyRequest().authenticated();    &#125;    @Override    public void configure(WebSecurity web) throws Exception &#123;        super.configure(web);    &#125;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.inMemoryAuthentication()            .withUser(&quot;111&quot;).password(&quot;222&quot;).authorities(&quot;user&quot;)            .and()            .withUser(&quot;admin&quot;).password(&quot;admin&quot;).authorities(&quot;admin&quot;);    &#125;    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception &#123;        return super.authenticationManagerBean();    &#125;    @Bean    PasswordEncoder passwordEncoder() &#123;        return NoOpPasswordEncoder.getInstance();    &#125;&#125;</code></pre><h4 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h4><pre><code class="java">/** * @author alvin * @date 2020-10-06 10:19 * 资源服务器配置 */@EnableGlobalMethodSecurity(prePostEnabled = true)@EnableResourceServer@Configurationpublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter &#123;    @Override    public void configure(HttpSecurity http) throws Exception &#123;        http            // /oauth2/api/** 全部需要认证            .antMatcher(&quot;/oauth2/api/**&quot;).authorizeRequests()            // /oauth2/api/read/** 需要 read scope            // /oauth2/api/write/** 需要 write scope            .antMatchers(HttpMethod.GET, &quot;/oauth2/api/read/**&quot;).access(&quot;#oauth2.hasScope(&#39;read&#39;)&quot;)            .antMatchers(HttpMethod.GET, &quot;/oauth2/api/write/**&quot;).access(&quot;#oauth2.hasScope(&#39;write&#39;)&quot;)        ;    &#125;&#125;</code></pre><h4 id="第三方服务-资源"><a href="#第三方服务-资源" class="headerlink" title="第三方服务(资源 )"></a>第三方服务(资源 )</h4><pre><code class="java">/** * @author alvin * @date 2020-10-06 10:23 * 第三方服务 */@RestControllerpublic class MainController &#123;    @GetMapping(&quot;/oauth2/api/me&quot;)    public Authentication me() &#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        return authentication;    &#125;    @GetMapping(&quot;/oauth2/api/read/xxoo&quot;)    public Authentication xxoo() &#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        System.out.println(&quot;xxpp&quot;);        return authentication;    &#125;    @GetMapping(&quot;/oauth2/api/write/xxoo&quot;)    public Authentication write() &#123;        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        System.out.println(&quot;write&quot;);        return authentication;    &#125;&#125;</code></pre><h4 id="使用PostMan获取token"><a href="#使用PostMan获取token" class="headerlink" title="使用PostMan获取token"></a>使用PostMan获取token</h4><p>启动服务，访问 <code>http://localhost:8080/oauth2/api/me</code>，正常访问；访问 <code>http://localhost:8080/oauth2/api/read/xxoo</code>，提示需要授权。</p><p><img src="../../images/springcloud/oauth2/%E8%8E%B7%E5%8F%96token.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Token/接口安全性问题、XSS 攻击、Oauth2&lt;/p&gt;
&lt;h2 id=&quot;1-Token-安全性问题&quot;&gt;&lt;a href=&quot;#1-Token-安全性问题&quot; class=&quot;headerlink&quot; title=&quot;1. Token 安全性问题&quot;&gt;&lt;/a&gt;1. Token 安全</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式会话" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>分布式会话管理(二)</title>
    <link href="http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(2).html"/>
    <id>http://yoursite.com/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(2).html</id>
    <published>2020-10-04T12:43:12.000Z</published>
    <updated>2020-11-24T14:44:15.733Z</updated>
    
    <content type="html"><![CDATA[<p>分布式会话入门。</p><h2 id="1、密码存储"><a href="#1、密码存储" class="headerlink" title="1、密码存储"></a>1、密码存储</h2><h3 id="1-1-常见密文存储的几种方式："><a href="#1-1-常见密文存储的几种方式：" class="headerlink" title="1.1 常见密文存储的几种方式："></a>1.1 常见密文存储的几种方式：</h3><p>摘要算法特点：快、不可逆、相同的源加密结果一样</p><ul><li>明文</li><li>hash(明文)</li><li>hash(明文 + 盐)</li></ul><p>盐的几种实现：</p><ul><li><p>统一的盐。密码丢失后，很可能猜到盐是啥。</p></li><li><p>用户名 手机号等 每个账户不一样。还是有一定规律，并且这些加盐的字段不能变。</p></li><li><p>随机盐（保存数据库）</p></li><li><p>随机盐（从密码取），把随机数直接放进 hash 值中</p></li></ul><h3 id="1-2-常见批结方式"><a href="#1-2-常见批结方式" class="headerlink" title="1.2 常见批结方式"></a>1.2 常见批结方式</h3><p><strong>暴力破解/字典/彩虹表</strong></p><h3 id="1-3-防止破解"><a href="#1-3-防止破解" class="headerlink" title="1.3 防止破解"></a>1.3 防止破解</h3><p>没有绝对安全的网络，即使拿不到密码 也可以发送重放攻击</p><ul><li>多次加盐取 hash</li><li>使用更复杂的单向加密算法比如 Bcrypt</li><li>使用 https</li><li>风控系统<ul><li>人机交互，二次安全校验</li><li>接口调用安全校验</li><li>异地登录等</li><li>大额转账</li></ul></li></ul><h3 id="Bcrypt结构"><a href="#Bcrypt结构" class="headerlink" title="Bcrypt结构"></a>Bcrypt结构</h3><p>![img](D:/01_code/05_mashibing/InternetArchitect/20 架构师三期 SpringCloud微服务架构/images/webp)</p><h2 id="2、JDBC-用户存储"><a href="#2、JDBC-用户存储" class="headerlink" title="2、JDBC 用户存储"></a>2、JDBC 用户存储</h2><p>pom</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件</p><pre><code class="properties">spring.datasource.username=rootspring.datasource.password=pass9876spring.datasource.url=jdbc:mysql://node02:3306:mq?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</code></pre><p>建表</p><p>Spring Security 默认情况下需要两张表，用户表和权限表，可以参考</p><p>org.springframework.security.core.userdetails.jdbc.users.ddl</p><pre><code class="sql">SELECT * FROM users;SELECT * FROM `authorities`;</code></pre><p>配置JDBCManager用户</p><pre><code class="java">@Beanpublic UserDetailsService userDetailsService() &#123;    // 基于内存存储用户    //        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();    // 基于 JDBC 村粗用户    JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);    User user = new User(&quot;4&quot;, new BCryptPasswordEncoder().encode(&quot;4&quot;), true, true, true, true, Collections.singletonList(new SimpleGrantedAuthority(&quot;4&quot;)));    manager.createUser(user);    manager.createUser(User.withUsername(&quot;5&quot;).password(new BCryptPasswordEncoder().encode(&quot;5&quot;)).roles(&quot;5&quot;).build());    return manager;&#125;// 或者@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;    // 注释掉后，所有默认配置失效。配置文件中的用户名和密码不生效了    // super.configure(auth);    // 基于内存    //        auth.inMemoryAuthentication()    //            .withUser(&quot;123&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;admin&quot;)    //            .and()    //            .withUser(&quot;321&quot;).password(new BCryptPasswordEncoder().encode(&quot;321&quot;)).roles(&quot;user&quot;)    //        ;    // 基于 JDBC    JdbcUserDetailsManager manager = auth.jdbcAuthentication().dataSource(dataSource).getUserDetailsService();    if (manager.userExists(&quot;alvin&quot;)) &#123;        System.out.println(&quot;用户已经注册&quot;);    &#125; else &#123;        manager.createUser(User.withUsername(&quot;alvin&quot;).password(new BCryptPasswordEncoder().encode(&quot;pass9876&quot;)).roles(&quot;admin&quot;,&quot;sci&quot;).build());    &#125;&#125;</code></pre><h3 id="2-1-自定义用户登录查询"><a href="#2-1-自定义用户登录查询" class="headerlink" title="2.1 自定义用户登录查询"></a>2.1 自定义用户登录查询</h3><pre><code class="java">@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;    // 自定义 UserDetailsService 逻辑    auth.userDetailsService(new MyUserDetailsService());&#125;public class MyUserDetailsService implements UserDetailsService &#123;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        // 在这里执行查询        System.out.println(&quot;=====&gt;开始查询数据源。。。&quot;);        if (new Random().nextBoolean()) &#123;            throw new LockedException(&quot;用户已锁定&quot;);        &#125; else &#123;            throw new BadCredentialsException(&quot;用户名或密码错误，请重试&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="2-2-自定义用户权限校验"><a href="#2-2-自定义用户权限校验" class="headerlink" title="2.2 自定义用户权限校验"></a>2.2 自定义用户权限校验</h3><p><strong>校验器</strong></p><pre><code class="java">@Servicepublic class MyAuthProvider implements AuthenticationProvider &#123;    @Autowired    MyUserDetailsService userDetailsService;    @Override    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;        System.out.println(&quot;====&gt;开始自定义验证。。。&quot;);        System.out.println(authentication);        // 穷举密码，可以在这里做重试限制        String username = authentication.getPrincipal().toString();        String rawPassword = authentication.getCredentials().toString();        // 查询用户信息        UserDetails userDetails = userDetailsService.loadUserByUsername(username);        // 密码校验        if (new BCryptPasswordEncoder().matches(rawPassword, userDetails.getPassword())) &#123;            return new UsernamePasswordAuthenticationToken(username,userDetails.getPassword(),userDetails.getAuthorities());        &#125; else &#123;            throw new BadCredentialsException(&quot;用户名或密码错误。&quot;);        &#125;    &#125;    @Override    public boolean supports(Class&lt;?&gt; authentication) &#123;        return true;    &#125;&#125;</code></pre><p><strong>配置校验器</strong></p><pre><code class="java">@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;    // 自定义 UserDetailsService 逻辑    auth.userDetailsService(userDetailsService)        .and()        .authenticationProvider(authProvider);&#125;</code></pre><h2 id="3、Remember-Me"><a href="#3、Remember-Me" class="headerlink" title="3、Remember Me"></a>3、Remember Me</h2><pre><code class="java">http.    // 哪些 地址需要登录    authorizeRequests()    //所有请求都需要验证    .anyRequest().authenticated()    .and()    .formLogin()    .and()    .rememberMe()    .and()    .csrf().disable()</code></pre><p>其实是往 cookies 中添加了  remember-me ，有一个过期时间。</p><p>为什么不直接延长 JSESSIONID 的过期时间？</p><p>以为请求不一定是浏览器发起的，不一定有 session，remember-me 是基于 token 的。如果是集群，不会用 session，否则服务器压力太大。token 机制是无会话，只在首次登录</p><p>不管是服务器保存 session 还是 第三方保存 session 比如 redis，都是基于会话的，都是有状态的。</p><p>基于 token：</p><pre><code class="java">MTIzOjE2MDMwNzgyMDY2MzU6NTlhZjZjMzJmMWYyYzkwZjVlMDYwZGRjZmJhZDE5YmY    public static void main(String[] args) &#123;        String rememberMe = &quot;MTIzOjE2MDMwNzgyMDY2MzU6NTlhZjZjMzJmMWYyYzkwZjVlMDYwZGRjZmJhZDE5YmY&quot;;        byte[] b = Base64.getDecoder().decode(rememberMe);        // 用户名:过期时间:sign(用于校验签名两个值对不对)        // 用户名+过期时间+secret=&gt;sign(secret 服务器端有，客户端没有)        // 123:1603078206635:59af6c32f1f2c90f5e060ddcfbad19bf        // 好处是不需要任何和数据源的校验        System.out.println(new String(b));    &#125;</code></pre><h2 id="4、同一用户多地点登录"><a href="#4、同一用户多地点登录" class="headerlink" title="4、同一用户多地点登录"></a>4、同一用户多地点登录</h2><p>禁止其他终端登录。此配置和记住我有冲突。</p><h3 id="踢掉其他已登录的用户"><a href="#踢掉其他已登录的用户" class="headerlink" title="踢掉其他已登录的用户"></a>踢掉其他已登录的用户</h3><pre><code class="java">@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    http.authorizeRequests().anyRequest().authenticated()        .and()        .formLogin()        .and()        // 测试 remember me        //.rememberMe()        //.and()        // 测试多地点登录限制        .sessionManagement()        .maximumSessions(1)// 地点个数        .maxSessionsPreventsLogin(true)// 保护登录，即不允许被挤下去        .and()        .and()        .csrf()        .disable()        ;&#125;</code></pre><p>及时清理过期session</p><pre><code class="java">@BeanHttpSessionEventPublisher httpSessionEventPublisher() &#123;    return new HttpSessionEventPublisher();&#125;</code></pre><h2 id="5、Spring-Security-防火前与-Sql-注入"><a href="#5、Spring-Security-防火前与-Sql-注入" class="headerlink" title="5、Spring Security 防火前与 Sql 注入"></a>5、Spring Security 防火前与 Sql 注入</h2><p>SpringSecurity 本身不支持 ip 地址黑白名单。可以使用 SpringBoot filter 拦截。但是一般应该把拦截前置，可直接在 Linux 配置防火墙或者在 Nginx 拦截。</p><p>SQL 注入解决：perparestatement，预编译。</p><p>DDOS：拒绝服务攻击。三次握手完，不发包；三次握手最后一个包不回。</p><h3 id="5-1-指定-ip-可以不登录"><a href="#5-1-指定-ip-可以不登录" class="headerlink" title="5.1 指定 ip 可以不登录"></a>5.1 指定 ip 可以不登录</h3><pre><code class="java">.antMatchers(&quot;/ip1&quot;).hasIpAddress(&quot;127.0.0.1&quot;)</code></pre><h3 id="5-2-禁止ip访问"><a href="#5-2-禁止ip访问" class="headerlink" title="5.2 禁止ip访问"></a>5.2 禁止ip访问</h3><p>用Filter 实现、或者用HandlerInterceptor 实现</p><h3 id="5-3-StrictHttpFirewall"><a href="#5-3-StrictHttpFirewall" class="headerlink" title="5.3 StrictHttpFirewall"></a>5.3 StrictHttpFirewall</h3><p>spring security 默认使用StrictHttpFirewall限制用户请求</p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>缺省被允许的<code>HTTP method</code>有 [<code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, <code>PUT</code>]</p><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p><strong>在其<code>requestURI</code>/<code>contextPath</code>/<code>servletPath</code>/<code>pathInfo</code>中，必须不能包含以下字符串序列之一 :</strong></p><pre><code>[&quot;//&quot;,&quot;./&quot;,&quot;/…/&quot;,&quot;/.&quot;]</code></pre><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><pre><code>;或者%3b或者%3B// 禁用规则setAllowSemicolon(boolean)</code></pre><h4 id="斜杠"><a href="#斜杠" class="headerlink" title="斜杠"></a>斜杠</h4><pre><code>%2f`或者`%2F// 禁用规则setAllowUrlEncodedSlash(boolean)</code></pre><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><pre><code>\或者%5c或者%5B// 禁用规则setAllowBackSlash(boolean)</code></pre><h4 id="英文句号"><a href="#英文句号" class="headerlink" title="英文句号"></a>英文句号</h4><pre><code>%2e或者%2E// 禁用规则setAllowUrlEncodedPeriod(boolean)</code></pre><h4 id="百分号"><a href="#百分号" class="headerlink" title="百分号"></a>百分号</h4><pre><code>%25// 禁用规则setAllowUrlEncodedPercent(boolean)</code></pre><h4 id="防火墙与sql注入"><a href="#防火墙与sql注入" class="headerlink" title="防火墙与sql注入"></a>防火墙与sql注入</h4><p>‘ ; – % 多数非法字符已经在请求的参数上被禁用</p><p>为啥用户名不能有特殊字符</p><p>preparestatement </p><p>awf前端拦截</p><h2 id="6、注销登录"><a href="#6、注销登录" class="headerlink" title="6、注销登录"></a>6、注销登录</h2><pre><code class="java">.and()    .logout()    .logoutUrl(&quot;/out&quot;)</code></pre><h2 id="7、退出登录、登录成功-失败控制器"><a href="#7、退出登录、登录成功-失败控制器" class="headerlink" title="7、退出登录、登录成功/失败控制器"></a>7、退出登录、登录成功/失败控制器</h2><h3 id="增加退出处理器"><a href="#增加退出处理器" class="headerlink" title="增加退出处理器"></a>增加退出处理器</h3><pre><code>        .addLogoutHandler(new LogoutHandler() &#123;            @Override            public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;                // TODO Auto-generated method stub                System.out.println(&quot;退出1&quot;);            &#125;        &#125;)        .addLogoutHandler(new LogoutHandler() &#123;            @Override            public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;                // TODO Auto-generated method stub                System.out.println(&quot;退出2&quot;);            &#125;        &#125;)</code></pre><h3 id="登录成功处理器"><a href="#登录成功处理器" class="headerlink" title="登录成功处理器"></a>登录成功处理器</h3><p>不同角色 跳转到不同页面</p><pre><code>    .successHandler(new AuthenticationSuccessHandler() &#123;        @Override        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,                Authentication authentication) throws IOException, ServletException &#123;            // TODO Auto-generated method stub            System.out.println(&quot;登录成功1&quot;);            // 根据权限不同，跳转到不同页面            request.getSession().getAttribute(name)            request.getRequestDispatcher(&quot;&quot;).forward(request, response);        &#125;    &#125;)</code></pre><p>其中 Authentication 参数包含了 用户权限信息</p><h3 id="登录失败处理器"><a href="#登录失败处理器" class="headerlink" title="登录失败处理器"></a>登录失败处理器</h3><pre><code>        .failureHandler(new AuthenticationFailureHandler() &#123;            @Override            public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,                    AuthenticationException exception) throws IOException, ServletException &#123;                // TODO Auto-generated method stub                exception.printStackTrace();                request.getRequestDispatcher(request.getRequestURL().toString()).forward(request, response);            &#125;        &#125;)</code></pre><p>可以限制登录错误次数</p><h4 id="常见登录异常"><a href="#常见登录异常" class="headerlink" title="常见登录异常"></a>常见登录异常</h4><p><strong>LockedException</strong> 账户被锁定</p><p><strong>CredentialsExpiredException</strong> 密码过期</p><p><strong>AccountExpiredException</strong> 账户过期</p><p><strong>DisabledException</strong> 账户被禁用</p><p><strong>BadCredentialsException</strong> 密码错误</p><p><strong>UsernameNotFoundException</strong> 用户名错误</p><h2 id="8、Ant-风格路径表达式"><a href="#8、Ant-风格路径表达式" class="headerlink" title="8、Ant 风格路径表达式"></a>8、Ant 风格路径表达式</h2><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>?</td><td>匹配任何单字符</td></tr><tr><td>*</td><td>匹配0或者任意数量的字符</td></tr><tr><td>**</td><td>匹配0或者更多的目录</td></tr></tbody></table><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><table><thead><tr><th>URL路径</th><th>说明</th></tr></thead><tbody><tr><td>/app/*.x</td><td>匹配(Matches)所有在app路径下的.x文件</td></tr><tr><td>/app/p?ttern</td><td>匹配(Matches) /app/pattern 和 /app/pXttern,但是不包括/app/pttern</td></tr><tr><td>/**/example</td><td>匹配(Matches) /app/example, /app/foo/example, 和 /example</td></tr><tr><td>/app/*<em>/dir/file.</em></td><td>匹配(Matches) /app/dir/file.jsp, /app/foo/dir/file.html,/app/foo/bar/dir/file.pdf, 和 /app/dir/file.java</td></tr><tr><td>/*<em>/</em>.jsp</td><td>匹配(Matches)任何的.jsp 文件</td></tr></tbody></table><h4 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h4><p>最长匹配原则(has more characters)<br>说明，URL请求 /app/dir/file.jsp，现在存在两个路径匹配模式/*<em>/</em>.jsp和/app/dir/<em>.jsp，那么会根据模式/app/dir/</em>.jsp来匹配</p><h4 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h4><p>security 像 shiro 一样，权限匹配有顺序，比如不能把 .anyRequest().authenticated() 写在其他规则前面</p><h2 id="9、基于角色的权限控制与继承"><a href="#9、基于角色的权限控制与继承" class="headerlink" title="9、基于角色的权限控制与继承"></a>9、基于角色的权限控制与继承</h2><pre><code class="java">    http.authorizeRequests()    .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)    .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;)@Bean        RoleHierarchy roleHierarchy() &#123;    RoleHierarchyImpl impl = new RoleHierarchyImpl();    impl.setHierarchy(&quot;ROLE_admin &gt; ROLE_user&quot;);    return impl;&#125;</code></pre><h2 id="10、细粒度方法级权限控制"><a href="#10、细粒度方法级权限控制" class="headerlink" title="10、细粒度方法级权限控制"></a>10、细粒度方法级权限控制</h2><p><strong>配置开启</strong></p><pre><code class="java">@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</code></pre><p><strong>使用</strong></p><pre><code class="java">@RestControllerpublic class TestController &#123;    @GetMapping(&quot;/admin/hi&quot;)    @Secured(&quot;ROLE_admin&quot;)    public String hi1() &#123;        System.out.println(&quot;=====&gt;来啦,老弟...&quot;);        return &quot;hi admin...&quot;;    &#125;    @GetMapping(&quot;/user/hi&quot;)    // 或者关系，@Secured 没法实现并且关系    @Secured(&#123;&quot;ROLE_admin&quot;,&quot;ROLE_user&quot;&#125;)    public String hi2() &#123;        System.out.println(&quot;=====&gt;来啦,老弟...&quot;);        return &quot;hi user...&quot;;    &#125;    @GetMapping(&quot;/admin/hi3&quot;)    // 并且关系    @PreAuthorize(&quot;hasRole(&#39;ROLE_admin&#39;) AND hasRole(&#39;ROLE_user&#39;)&quot;)    public String hi3() &#123;        System.out.println(&quot;=====&gt;来啦,老弟...&quot;);        return &quot;hi admin 3...&quot;;    &#125;    @GetMapping(&quot;/admin/hi4&quot;)    // 可以写 spel 表达式，根据返回值判断是否有权限。    @PostAuthorize(&quot;returnObject==1&quot;)    public Integer hi4() &#123;        System.out.println(&quot;=====&gt;来啦,老弟...&quot;);        // 访问子系统，把当前用户角色带过去，让子系统校验是否有权限        return new Random().nextInt(2);    &#125;&#125;</code></pre><p><strong>获取当前用户权限信息和 UserDetails</strong></p><p>自己写权限校验时可能会用到。</p><pre><code class="java">Authentication authentication = SecurityContextHolder.getContext().getAuthentication();authentication.getPrincipal()</code></pre><h2 id="11、自定义前置-Filter-及图形验证码"><a href="#11、自定义前置-Filter-及图形验证码" class="headerlink" title="11、自定义前置 Filter 及图形验证码"></a>11、自定义前置 Filter 及图形验证码</h2><p>目的：防机器暴力登陆</p><p>人机交互/手机验证码：机器基本没法破解</p><p>数字图形机器识别简单一点，图片机器识别稍微麻烦一点，但是图形验证码现在基本上是不安全的了，因为机器学习算法给它点时间就能破解。</p><h3 id="Kaptcha"><a href="#Kaptcha" class="headerlink" title="Kaptcha"></a>Kaptcha</h3><table><thead><tr><th>Constant</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>kaptcha.border</td><td>图片边框，合法值：yes , no</td><td>yes</td></tr><tr><td>kaptcha.border.color</td><td>边框颜色，合法值： r,g,b (and optional alpha) 或者 white,black,blue.</td><td>black</td></tr><tr><td>kaptcha.image.width</td><td>图片宽</td><td>200</td></tr><tr><td>kaptcha.image.height</td><td>图片高</td><td>50</td></tr><tr><td>kaptcha.producer.impl</td><td>图片实现类</td><td>com.google.code.kaptcha.impl.DefaultKaptcha</td></tr><tr><td>kaptcha.textproducer.impl</td><td>文本实现类</td><td>com.google.code.kaptcha.text.impl.DefaultTextCreator</td></tr><tr><td>kaptcha.textproducer.char.string</td><td>文本集合，验证码值从此集合中获取</td><td>abcde2345678gfynmnpwx</td></tr><tr><td>kaptcha.textproducer.char.length</td><td>验证码长度</td><td>5</td></tr><tr><td>kaptcha.textproducer.font.names</td><td>字体</td><td>Arial, Courier</td></tr><tr><td>kaptcha.textproducer.font.size</td><td>字体大小</td><td>40px.</td></tr><tr><td>kaptcha.textproducer.font.color</td><td>字体颜色，合法值： r,g,b  或者 white,black,blue.</td><td>black</td></tr><tr><td>kaptcha.textproducer.char.space</td><td>文字间隔</td><td>2</td></tr><tr><td>kaptcha.noise.impl</td><td>干扰实现类</td><td>com.google.code.kaptcha.impl.DefaultNoise</td></tr><tr><td>kaptcha.noise.color</td><td>干扰 颜色，合法值： r,g,b 或者 white,black,blue.</td><td>black</td></tr><tr><td>kaptcha.obscurificator.impl</td><td>图片样式：<br />水纹 com.google.code.kaptcha.impl.WaterRipple <br /> 鱼眼 com.google.code.kaptcha.impl.FishEyeGimpy <br /> 阴影 com.google.code.kaptcha.impl.ShadowGimpy</td><td>com.google.code.kaptcha.impl.WaterRipple</td></tr><tr><td>kaptcha.background.impl</td><td>背景实现类</td><td>com.google.code.kaptcha.impl.DefaultBackground</td></tr><tr><td>kaptcha.background.clear.from</td><td>背景颜色渐变，开始颜色</td><td>light grey</td></tr><tr><td>kaptcha.background.clear.to</td><td>背景颜色渐变， 结束颜色</td><td>white</td></tr><tr><td>kaptcha.word.impl</td><td>文字渲染器</td><td>com.google.code.kaptcha.text.impl.DefaultWordRenderer</td></tr><tr><td>kaptcha.session.key</td><td>session key</td><td>KAPTCHA_SESSION_KEY</td></tr><tr><td>kaptcha.session.date</td><td>session date</td><td>KAPTCHA_SESSION_DATE</td></tr></tbody></table><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;    &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;    &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="添加一个前置Filter"><a href="#添加一个前置Filter" class="headerlink" title="添加一个前置Filter"></a>添加一个前置Filter</h3><pre><code class="java">http.addFilterBefore(new CodeFilter(), UsernamePasswordAuthenticationFilter.class);</code></pre><pre><code class="java">public class CodeFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)            throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest)request;        HttpServletResponse resp = (HttpServletResponse)response;        String uri = req.getServletPath();        if(uri.equals(&quot;/login&quot;) &amp;&amp; req.getMethod().equalsIgnoreCase(&quot;post&quot;)) &#123;            String sessionCode = req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY).toString();            String formCode = req.getParameter(&quot;code&quot;).trim();            if(StringUtils.isEmpty(formCode)) &#123;                throw new RuntimeException(&quot;验证码不能为空&quot;);            &#125;            if(sessionCode.equalsIgnoreCase(formCode)) &#123;                System.out.println(&quot;验证通过&quot;);            &#125;                            System.out.println(req.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY));            throw new AuthenticationServiceException(&quot;xx&quot;);        &#125;        chain.doFilter(request, response);    &#125;</code></pre><p>显示验证码的Controller</p><pre><code class="java">    @GetMapping(&quot;/kaptcha&quot;)    public void getKaptchaImage(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;        HttpSession session = request.getSession();        response.setDateHeader(&quot;Expires&quot;, 0);        response.setHeader(&quot;Cache-Control&quot;, &quot;no-store, no-cache, must-revalidate&quot;);        response.addHeader(&quot;Cache-Control&quot;, &quot;post-check=0, pre-check=0&quot;);        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);        response.setContentType(&quot;image/jpeg&quot;);        String capText = captchaProducer.createText();        session.setAttribute(Constants.KAPTCHA_SESSION_KEY, capText);        BufferedImage bi = captchaProducer.createImage(capText);        ServletOutputStream out = response.getOutputStream();        ImageIO.write(bi, &quot;jpg&quot;, out);        try &#123;            out.flush();        &#125; finally &#123;            out.close();        &#125;    &#125;</code></pre><p><strong>配置类</strong></p><pre><code class="java">package com.mashibing.admin;import java.util.Properties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;@Configurationpublic class Kaconfig &#123;    @Bean    public DefaultKaptcha getDefaultKaptcha()&#123;        DefaultKaptcha captchaProducer = new DefaultKaptcha();        Properties properties = new Properties();        properties.setProperty(&quot;kaptcha.border&quot;, &quot;yes&quot;);        properties.setProperty(&quot;kaptcha.border.color&quot;, &quot;105,179,90&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;blue&quot;);        properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;310&quot;);        properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;240&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;30&quot;);        properties.setProperty(&quot;kaptcha.session.key&quot;, &quot;code&quot;);        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);    //    properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;678&quot;);        properties.setProperty(&quot;kaptcha.obscurificator.impl&quot;, &quot;com.google.code.kaptcha.impl.ShadowGimpy&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.names&quot;, &quot;宋体,楷体,微软雅黑&quot;);        Config config = new Config(properties);        captchaProducer.setConfig(config);        return captchaProducer;    &#125;&#125;</code></pre><h2 id="12、集群化服务之-Session-共享-SpringSession-Redis"><a href="#12、集群化服务之-Session-共享-SpringSession-Redis" class="headerlink" title="12、集群化服务之 Session 共享 SpringSession + Redis"></a>12、集群化服务之 Session 共享 SpringSession + Redis</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分布式会话入门。&lt;/p&gt;
&lt;h2 id=&quot;1、密码存储&quot;&gt;&lt;a href=&quot;#1、密码存储&quot; class=&quot;headerlink&quot; title=&quot;1、密码存储&quot;&gt;&lt;/a&gt;1、密码存储&lt;/h2&gt;&lt;h3 id=&quot;1-1-常见密文存储的几种方式：&quot;&gt;&lt;a href=&quot;#1-1-常</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式会话" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(五)</title>
    <link href="http://yoursite.com/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(5)-zuul.html"/>
    <id>http://yoursite.com/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(5)-zuul.html</id>
    <published>2020-10-03T15:43:12.000Z</published>
    <updated>2020-11-24T14:43:42.441Z</updated>
    
    <content type="html"><![CDATA[<ul><li>网关</li><li>链路追踪</li><li>SpringCloud Admin</li></ul><a id="more"></a><h2 id="1、网关概念"><a href="#1、网关概念" class="headerlink" title="1、网关概念"></a>1、网关概念</h2><p>服务治理，服务注册发现，服务调用，熔断。已经学完。</p><p>微服务基本模块已经有了，也可以做微服务了。但完成一个复杂的业务，可能需要多个微服务合作来完成，比如下单，需要用户服务，支付服务，地图服务，订单服务。一般是我们对外服务的窗口，进行服务内外隔离。一般微服务都在内网，不做安全验证。</p><p>就好像：很多明星，可以独立开演唱会（独立提供服务）。也可以去春晚（微服务群提供服务）。但一台春晚就不能让 观众一个一个调用了。观众要调用，需要检票啥的，检票就类似于网关，进来之后，界面随便看，不会说你 看个小品，还需要再检票。</p><p>微服务没有网关，会有下面的问题：</p><ol><li><p>客户端请求多个微服务，增加了客户端复杂性，每个微服务都要做用户认证，限流等，避免和多个微服务打交道的复杂性。</p></li><li><p>有跨域问题，不在同一个域。</p></li><li><p>认证复杂，每个服务都要独立认证，服务要求的权限不一致。</p></li><li><p>难以重构。因为微服务被客户端调用着，重构难以实施。</p></li></ol><p>网关是介于客户端（外部调用方比如app，h5）和微服务的中间层。</p><p>Zuul 是 Netflix 开源的微服务网关，核心是一系列<strong>过滤器</strong>。这些过滤器可以完成以下功能。</p><ol><li>是所有微服务入口，进行分发。</li><li>身份认证与安全。识别合法的请求，拦截不合法的请求。</li><li>监控。在入口处监控，更全面。</li><li>动态路由。动态将请求分发到不同的后端集群。</li><li>压力测试。可以逐渐增加对后端服务的流量，进行测试。</li><li>负载均衡。也是用ribbon。</li><li>限流（望京超市）。比如我每秒只要1000次，10001次就不让访问了。</li><li>服务熔断</li></ol><p>网关和服务的关系：演员和剧场检票人员的关系。</p><p>zuul默认集成了：ribbon 和 hystrix。</p><p>前后端分离的服务器端渲染。如果客户端渲染打开页面可能非常慢，因为浏览器还需要不停解析各种东西，而且还要请求不同的接口。一是解析时间，而是二次网络请求时间。</p><p>基于隧道模式的网关就是业务网关。Nginx 也是隧道模式。</p><p>可优化的点：使用单点登录实现无状态；通过异步优化线程。</p><p>瓶颈在吞吐量。</p><p>路由模式（DR）：LVS</p><p>流量网关：</p><p>业务网关：</p><p>所有拒绝策略尽量前置。</p><h2 id="2、启用网关"><a href="#2、启用网关" class="headerlink" title="2、启用网关"></a>2、启用网关</h2><h3 id="2-1-服务搭建"><a href="#2-1-服务搭建" class="headerlink" title="2.1 服务搭建"></a>2.1 服务搭建</h3><p>新建项目引入依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件</p><pre><code class="properties">server.port=80spring.application.name=zuul-servereureka.client.service-url.defaultZone=http://alvin:pass9876@localhost:8761/eureka/</code></pre><p>启动类</p><pre><code class="java">@EnableZuulProxy</code></pre><p>测试访问。网关会将服务名转换成具体服务的ip和端口，实际进行访问</p><pre><code class="shell"># 通过 网关ip:网关端口/服务名/资源名 访问资源http://localhost/ribbon-consumer/test/user/1http://localhost/hello-service/user/2</code></pre><h3 id="2-2-配置负载均衡"><a href="#2-2-配置负载均衡" class="headerlink" title="2.2 配置负载均衡"></a>2.2 配置负载均衡</h3><p>启动两个Consumer</p><p>轮询访问上面地址，会看到返回结果中，端口一直轮询在变。说明负载均衡生效了，默认是轮询</p><pre><code class="properties">consumer.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule</code></pre><p>访问测试：</p><pre><code class="shell">http://localhost/ribbon-consumer/zuul/1</code></pre><h3 id="2-3-路由端点"><a href="#2-3-路由端点" class="headerlink" title="2.3 路由端点"></a>2.3 路由端点</h3><p>调试的时候，看网关请求的地址，以及映射是否正确。网关请求有误时，可以通过此处排查错误。</p><p>配置</p><pre><code class="properties">management.endpoints.web.exposure.include=*# 默认是nevermanagement.endpoint.health.show-details=alwaysmanagement.endpoint.health.enabled=truemanagement.endpoint.routes.enabled=true</code></pre><p>通过端点查看路由映射：</p><pre><code class="shell"># 访问地址：http://localhost/actuator/routes&#123;  &quot;/xxoo/**&quot;: &quot;ribbon-consumer&quot;,  &quot;/xx/**&quot;: &quot;http://mashibing.com&quot;,  &quot;/oo/**&quot;: &quot;hello-service&quot;,  &quot;/ribbon-consumer/**&quot;: &quot;ribbon-consumer&quot;&#125;</code></pre><h3 id="2-4-微服务路由-routes"><a href="#2-4-微服务路由-routes" class="headerlink" title="2.4 微服务路由(routes)"></a>2.4 微服务路由(routes)</h3><ol><li>通过服务名配置（虚拟主机名）</li></ol><pre><code class="properties"># 方法一zuul.routes.ribbon-consumer=/xxoo/**# 方法二zuul.routes.ooxx.path=/ooxx/**zuul.routes.ooxx.service-id=ribbon-consumer# 正常访问http://localhost/xxoo/zuul/1http://localhost/ooxx/zuul/1http://localhost/ribbon-consumer/zuul/1</code></pre><ol start="2"><li>自定义命名配置</li></ol><pre><code class="properties">zuul.routes.xx.path=/xx/**zuul.routes.xx.url=http://mashibing.com# 成功跳转到 http://mashibing.com/vip.htmlhttp://localhost/xx/vip.html</code></pre><ol start="3"><li>自定义下的负载均衡</li></ol><pre><code class="properties"># 自定义负载均衡cuid.ribbon.listOfServers=localhost:82,localhost:83ribbon.eureka.enabled=false</code></pre><h3 id="2-5-忽略微服务-ignored-services"><a href="#2-5-忽略微服务-ignored-services" class="headerlink" title="2.5 忽略微服务(ignored-services)"></a>2.5 忽略微服务(ignored-services)</h3><p><strong>根据服务名忽略</strong></p><pre><code class="properties"># 设置忽略的微服务# 就是把默认的 &quot;/ribbon-consumer/**&quot;: &quot;ribbon-consumer&quot; 条目去掉zuul.ignored-services=ribbon-consumer# 访问失败http://localhost/ribbon-consumer/zuul/1# 访问成功http://localhost/ooxx/zuul/1</code></pre><p><strong>正则匹配忽略</strong></p><pre><code class="properties"># 忽略正则，不能通过 zuul-api-driver 和 api-driver访问。zuul.ignored-patterns=/*-driver/**</code></pre><h3 id="2-6-前缀"><a href="#2-6-前缀" class="headerlink" title="2.6 前缀"></a>2.6 前缀</h3><p>接口一般命名：/api/v1/xxxx。</p><p>可以在网关配置前缀，访问时带上前缀，实际请求会将前缀去掉。</p><pre><code class="properties">zuul.prefix=/api/v1# 是否脱去前缀zuul.strip-prefix=true# 访问失败 404http://localhost/ooxx/zuul/1# 访问成功http://localhost/api/v1/ooxx/zuul/1# 指定服务配置zuul.routes.ribbon-consumer.strip-prefix=true</code></pre><h3 id="2-7-查看路由日志"><a href="#2-7-查看路由日志" class="headerlink" title="2.7 查看路由日志"></a>2.7 查看路由日志</h3><p>修改日志级别</p><pre><code>logging.level.com.netflix=debuglogging.level.org.springframework=debug</code></pre><p>访问接口，然后查看后台日志</p><p><img src="../../images/springcloud/5/%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%85%B3%E6%97%A5%E5%BF%97.png"></p><h3 id="2-8-敏感-Header"><a href="#2-8-敏感-Header" class="headerlink" title="2.8 敏感 Header"></a>2.8 敏感 Header</h3><pre><code class="java">@WebFilter(filterName = &quot;zuulTestFilter&quot;, urlPatterns = &quot;/**&quot;)@Componentpublic class ZuulSensitiveHeaderTestFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest)servletRequest;        String token = req.getHeader(&quot;token&quot;);        System.out.println(&quot;====&gt;token:&quot;+token);        filterChain.doFilter(servletRequest, servletResponse);    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;zuulTestFilter init....&quot;);    &#125;&#125;</code></pre><pre><code class="properties"># 敏感 header，不向下游传递。header 中为 token 的条目不向下传递zuul.sensitive-headers=token# 测试 postman 增加 header tokenhttp://localhost/ooxx/zuul/1</code></pre><h3 id="2-9-过滤器"><a href="#2-9-过滤器" class="headerlink" title="2.9 过滤器"></a>2.9 过滤器</h3><p>Zuul 的大部分功能都是有过滤器实现的。</p><p><strong>4 种过滤器</strong></p><ul><li>PRE：在请求被路由之前调用，可利用这种过滤器<strong>实现身份验证</strong>。选择微服务，记录日志。</li><li>ROUTING：在将请求路由到微服务调用，用于构建发送给微服务的请求，并用 http clinet（或者ribbon）请求微服务。</li><li>POST：在调用微服务执行后。可用于<strong>添加 header，记录日志</strong>，将响应发给客户端。</li><li>ERROR：在其他阶段发生错误时，走此过滤器。</li></ul><p><strong>自定义过滤器</strong></p><p>继承 <strong>ZuulFilter</strong> 即可。4 个注意点。</p><ul><li>filterType：pre，routing,post,error</li><li>filterOrder：执行顺序，在谁前，在谁后，可以+1，-1</li><li>shouldFilter：此过滤器是否执行，true  false，可以写过滤器是否执行的判断条件。</li><li>run：具体执行逻辑。</li></ul><pre><code class="java">@Componentpublic class PreFilter extends ZuulFilter &#123;    /**     * 当前过滤器是否生效     */    @Override    public boolean shouldFilter() &#123;        //获取上下文（重要，贯穿 所有filter，包含所有参数）        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletRequest request = requestContext.getRequest();        String uri = request.getRequestURI();        System.out.println(&quot;pre来源uri：&quot;+uri);        // 实际中应该根据具体业务，判断返回 true 还是 false        return true;    &#125;    @Override    public Object run() throws ZuulException &#123;        System.out.println(&quot;pre拦截&quot;);        //获取上下文        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletRequest request = requestContext.getRequest();        String token = request.getHeader(&quot;token&quot;);        System.out.println(&quot;pre 业务逻辑 token:&quot;+token);        return null;    &#125;    @Override    public String filterType() &#123;        return FilterConstants.PRE_TYPE;    &#125;    /**     * 相同类型，值越小越先执行     */    @Override    public int filterOrder() &#123;        return 4;    &#125;&#125;</code></pre><p><strong>测试</strong></p><pre><code class="json">http://localhost/ooxx/zuul/1pre来源uri：/ooxx/zuul/1pre拦截pre 业务逻辑 token:test sensitive headers</code></pre><p><strong>利用 filter 实现鉴权</strong></p><p>为啥<code>setSendZuulResponse(false)</code>后，还是会走后边的 filter？</p><pre><code class="java">@Componentpublic class AuthFilter extends ZuulFilter &#123;    @Override    public Object run() throws ZuulException &#123;        System.out.println(&quot;auth 拦截&quot;);        //获取上下文（重要，贯穿 所有filter，包含所有参数）        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletRequest request = requestContext.getRequest();        String token = request.getHeader(&quot;token&quot;);        try &#123;            String parseToken = JwtUtil.parseToken(token);            if(StringUtils.isNotBlank(parseToken)) &#123;                System.out.println(&quot;auth filter:校验通过&quot;);                request.getSession().setAttribute(&quot;t1&quot;, &quot;t1attr&quot;);                requestContext.setSendZuulResponse(true);            &#125; else &#123;                // 不往下的过滤器继续了                requestContext.setSendZuulResponse(false);                requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());                requestContext.setResponseBody(&quot;认证失败&quot;);            &#125;        &#125; catch (Exception e) &#123;            System.out.println(&quot;auth filter:token校验失败&quot;);            // 不往下的过滤器继续了            requestContext.setSendZuulResponse(false);            requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());            requestContext.setResponseBody(&quot;认证失败&quot;);        &#125;        return null;    &#125;    @Override    public boolean shouldFilter() &#123;        //获取上下文        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletRequest request = requestContext.getRequest();        String uri = request.getRequestURI();        String token = request.getHeader(&quot;token&quot;);        System.out.println(&quot;auth 来源uri：&quot;+uri + &quot;；token：&quot;+token);        // 自己测试用，实际应该根据业务来处理        if (StringUtils.isEmpty(token)) &#123;            return false;        &#125;        return true;    &#125;    @Override    public String filterType() &#123;        return FilterConstants.PRE_TYPE;    &#125;    @Override    public int filterOrder() &#123;        return 1;    &#125;&#125;</code></pre><h3 id="2-10-接口容错"><a href="#2-10-接口容错" class="headerlink" title="2.10 接口容错"></a>2.10 接口容错</h3><p><strong>Fallback组件</strong></p><pre><code class="java">@Componentpublic class ZuulFallback implements FallbackProvider &#123;    /**     * 表明为哪个微服务提供回退     * 服务Id ，若需要所有服务调用都支持回退，返回null 或者 * 即可     */    @Override    public String getRoute() &#123;        return &quot;*&quot;;        // 下面是单独的微服务        // return &quot;api-passenger&quot;;    &#125;    @Override    public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123;        if (cause instanceof HystrixTimeoutException) &#123;            return response(HttpStatus.GATEWAY_TIMEOUT);        &#125; else &#123;            return response(HttpStatus.INTERNAL_SERVER_ERROR);        &#125;    &#125;    private ClientHttpResponse response(final HttpStatus status) &#123;        return new ClientHttpResponse() &#123;            @Override            public HttpStatus getStatusCode() throws IOException &#123;                //return status;                return HttpStatus.BAD_REQUEST;            &#125;            @Override            public int getRawStatusCode() throws IOException &#123;                //return status.value();                return HttpStatus.BAD_REQUEST.value();            &#125;            @Override            public String getStatusText() throws IOException &#123;                //return status.getReasonPhrase();                //return HttpStatus.BAD_REQUEST.name();                return HttpStatus.BAD_REQUEST.getReasonPhrase();            &#125;            @Override            public void close() &#123;            &#125;            @Override            public InputStream getBody() throws IOException &#123;                String msg = &quot;&#123;\&quot;msg\&quot;:\&quot;服务故障\&quot;&#125;&quot;;                return new ByteArrayInputStream(msg.getBytes());            &#125;            @Override            public HttpHeaders getHeaders() &#123;                HttpHeaders headers = new HttpHeaders();                headers.setContentType(MediaType.APPLICATION_JSON);                return headers;            &#125;        &#125;;    &#125;&#125;</code></pre><p>停止 user-consumer 服务。访问 <code>http://localhost/ooxx/zuul/1</code>，成功进入 fallback。</p><pre><code class="json">&#123;  &quot;msg&quot;: &quot;服务故障&quot;&#125;</code></pre><h3 id="2-11-限流"><a href="#2-11-限流" class="headerlink" title="2.11 限流"></a>2.11 限流</h3><p><img src="../../images/springcloud/5/%E7%BD%91%E5%85%B3%E6%B5%81%E7%A8%8B.png"></p><p>保护自己，用 ratelimit。</p><p>令牌桶</p><pre><code class="sh">假设进入高速公路的车辆需要在入口处领取到通行卡才能进入高速公路。为了节约人力成本，入口处放置自动出卡机。按照国家高速公路交通安全法的规定，在高速公路上行驶的车辆，车速超过 100km/h 时，应与同车道前车保持 100 米以上距离。为了保持最小安全行车距离 100 米，按车速 100km/h 计算，需要间隔至少 3.6 秒才能放行一辆车，因此出卡机每隔 3.6 秒出一张通行卡。在自动出卡机下放置一个盒子，自动出卡机按照 3.6 秒的间隔向盒子中投放通行卡。每辆进入高速公路的车辆，从盒子中领取通行卡之后才可以进入高速公路。令牌桶可以看作是一个存放一定数量令牌的容器。系统按设定的速度向桶中放置令牌。当桶中令牌满时，多出的令牌溢出，桶中令牌不再增加。在使用令牌桶对流量规格进行评估时，是以令牌桶中的令牌数量是否足够满足报文的转发为依据的。每个需要被转发的报文，都要从令牌桶中领取一定数量的令牌（具体数量视报文大小而定），才可以被正常转发。如果桶中存在足够的令牌可以用来转发报文，称流量遵守或符合约定值，否则称为不符合或超标。</code></pre><p><strong>使用令牌限流 filter</strong></p><pre><code class="java">@Componentpublic class RateFilter extends ZuulFilter &#123;    private static int count = 0;    /**     * 如果是1，表示每秒1个令牌，实际通过压测获得     * 1、创建一个稳定输出令牌的RateLimiter，保证了平均每秒不超过permitsPerSecond个请求     * 2、当请求到来的速度超过了permitsPerSecond，保证每秒只处理permitsPerSecond个请求     * 3、当这个RateLimiter使用不足(即请求到来速度小于permitsPerSecond)，会囤积最多permitsPerSecond个请求     */    private static final RateLimiter RATE_LIMITER  = RateLimiter.create(5);    @Override    public boolean shouldFilter() &#123;        // 此处可以写判断地址        return false;    &#125;    @Override    public Object run() throws ZuulException &#123;        //获取上下文        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletRequest request = requestContext.getRequest();        requestContext.set(&quot;f&quot;, false);        /**         * 拿不到令牌马上返回。尝试获取桶里的令牌，如果有，则返回true，         *并且，总的令牌数减1。没有则返回false。         */        if(!RATE_LIMITER.tryAcquire()) &#123;            System.out.println(&quot;rate filter 拿不到令牌，被限流了&quot;+count++);            requestContext.setSendZuulResponse(false);            requestContext.setResponseStatusCode(HttpStatus.TOO_MANY_REQUESTS.value());        &#125; else &#123;            System.out.println(&quot;rate filter OK&quot;);        &#125;        return null;    &#125;    @Override    public String filterType() &#123;        return FilterConstants.PRE_TYPE;    &#125;    /**     * 限流要最早     */    @Override    public int filterOrder() &#123;        return -10;    &#125;&#125;</code></pre><ol><li><p>启动jmeter，双击：jmeter.bat</p></li><li><p>右击TestPlan,add ,Threads,Thread Group</p></li><li><p>右击测试令牌桶线程组，add，sampler, http request。</p></li><li><p>在线程组：</p><p>1、Number of Threads（users）：用户个数</p><p>2、Ramp-up Period（in seconds）：在多长时间内，加载指定的用户个数，单位为s。</p><p>假如需加载 100 个用户，在5s中之内加载完成，那么平均每秒钟加载20个用户。</p><p>3、Loop Count（循环次数）：用户执行操作的循环次数，如果选择forever，则永远循环下去。</p></li></ol><p><strong>测试点：</strong></p><p>   令牌桶设置成 5，jemter 设置 40 个用户 10 秒完成。全部正常。</p><p>   令牌桶设置成 5，jemter 设置 60 个用户 10 秒完成。部分请求被限流</p><pre><code class="json">rate filter OKrate filter OKrate filter 拿不到令牌，被限流了21</code></pre><h3 id="2-12-高可用"><a href="#2-12-高可用" class="headerlink" title="2.12 高可用"></a>2.12 高可用</h3><p>一般做法</p><p>前面架上nginx。</p><p>zuul 作为普通的服务。对外访问。前面加一层（nginx+keepalived）</p><h2 id="3、网关原理和源码"><a href="#3、网关原理和源码" class="headerlink" title="3、网关原理和源码"></a>3、网关原理和源码</h2><p>让我们做，如何实现？</p><p>方案：请求过来-&gt;pre（一组，鉴权，限流之类的。）-&gt;route（一组，路由到别的服务，具体微服务。）-&gt;post（一组，处理响应）。</p><p>zuul 本质就是 filter。</p><p>通过 filter 解析 url 来决定我们去访问哪个微服务。</p><p>发请求访问微服务，也是通过 filter 实现。</p><p>响应数据，也是通过 filter 实现。</p><h2 id="3、链路追踪"><a href="#3、链路追踪" class="headerlink" title="3、链路追踪"></a>3、链路追踪</h2><h3 id="3-1-分布式计算八大误区"><a href="#3-1-分布式计算八大误区" class="headerlink" title="3.1 分布式计算八大误区"></a>3.1 分布式计算八大误区</h3><ul><li><p>网络可靠。</p></li><li><p>延迟为零。</p></li><li><p>带宽无限。</p></li><li><p>网络绝对安全。</p></li><li><p>网络拓扑不会改变。</p></li><li><p>必须有一名管理员。</p></li><li><p>传输成本为零。</p></li><li><p>网络同质化。（操作系统，协议）</p></li></ul><h3 id="3-2-链路追踪的必要性"><a href="#3-2-链路追踪的必要性" class="headerlink" title="3.2 链路追踪的必要性"></a>3.2 链路追踪的必要性</h3><p>如果能跟踪每个请求，中间请求<strong>经过哪些微服务，请求耗时，网络延迟，业务逻辑耗时</strong>等。我们就能更好地分析系统瓶颈、解决系统问题。因此链路跟踪很重要。</p><p>我们自己思考解决方案：在调用前后加时间戳。捕获异常。</p><p>链路追踪目的：解决错综复杂的服务调用中<strong>链路的查看</strong>。<strong>排查慢服务</strong>。</p><p>市面上链路追踪产品，大部分基于 google 的 Dapper 论文。</p><pre><code class="sh">zipkin,twitter 开源的。是严格按照谷歌的 Dapper 论文来的。pinpoint 韩国的 Naver 公司的。Cat 美团点评的EagleEye 淘宝的</code></pre><h3 id="3-3-链路追踪要考虑的几个问题"><a href="#3-3-链路追踪要考虑的几个问题" class="headerlink" title="3.3 链路追踪要考虑的几个问题"></a>3.3 链路追踪要考虑的几个问题</h3><ol><li>探针的性能消耗。尽量不影响服务本尊。</li><li>易用。开发可以很快接入，别浪费太多精力。</li><li>数据分析。要实时分析。维度足够。</li></ol><h3 id="3-4-Sleuth-简介"><a href="#3-4-Sleuth-简介" class="headerlink" title="3.4 Sleuth 简介"></a>3.4 Sleuth 简介</h3><p>Sleuth 是 Spring cloud 的分布式跟踪解决方案。</p><ol><li><p>span(跨度)，基本工作单元。一次链路调用，创建一个 span，</p><p>span 用一个 64 位 id 唯一标识。包括：id，描述，时间戳事件，spanId,span 父 id。</p><p>span 被启动和停止时，记录了时间信息，初始化 span 叫：root span，它的 span id 和 trace id 相等。</p></li><li><p>trace(跟踪)，一组共享“root span”的span组成的树状结构 称为 trace，trace 也有一个 64 位 ID，trace 中所有 span 共享一个 trace id。类似于一颗 span 树。</p></li><li><p>annotation（标签），annotation用来记录事件的存在，其中，核心 annotation 用来定义请求的开始和结束。</p><ul><li>CS(Client Send客户端发起请求)。客户端发起请求描述了span开始。</li><li>SR(Server Received服务端接到请求)。服务端获得请求并准备处理它。SR-CS=网络延迟。</li><li>SS（Server Send服务器端处理完成，并将结果发送给客户端）。表示服务器完成请求处理，响应客户端时。SS-SR=服务器处理请求的时间。</li><li>CR（Client Received 客户端接受服务端信息）。span结束的标识。客户端接收到服务器的响应。CR-CS=客户端发出请求到服务器响应的总时间。</li></ul></li></ol><p>其实数据结构是一颗树，从root span 开始。</p><h3 id="3-5-Sleuth-单独使用"><a href="#3-5-Sleuth-单独使用" class="headerlink" title="3.5 Sleuth 单独使用"></a>3.5 Sleuth 单独使用</h3><p>每个需要监控的系统引入依赖：</p><pre><code class="xml">&lt;!-- 引入sleuth依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>测试点：</p><ol><li>启动 userserver-8001，userserverconsumer-9001，zuul-server-80</li><li>访问一次。看日志结果。</li></ol><pre><code class="sh">[api-driver,1a409c98e7a3cdbf,1a409c98e7a3cdbf,true] [服务名称，traceId（一条请求调用链中 唯一ID），spanID（基本的工作单元，获取数据等），是否让zipkin收集和展示此信息]看下游[service-sms,1a409c98e7a3cdbf,b3d93470b5cf8434,true]traceId，是一样的。服务名必须得写。</code></pre><h3 id="3-6-zipkin"><a href="#3-6-zipkin" class="headerlink" title="3.6 zipkin"></a>3.6 zipkin</h3><p>上面拍错看日志，很原始。刀耕火种，加入利器 zipkin。zipkin 是twitter 开源的分布式跟踪系统。</p><p>原理是收集系统的时序数据，从而追踪微服务架构中系统延时等问题。还有一个友好的界面。</p><p><strong>组成</strong>：Collector、Storage、Restful API、Web UI组成。采集器，存储器，接口，UI。</p><p><strong>原理</strong>：sleuth 收集跟踪信息通过 http 请求发送给 zipkin server，zipkin 将跟踪信息存储，以及提供 RESTful API 接口，zipkin ui 通过调用 api 进行数据展示。默认内存存储，可以用 mysql，ES 等存储。</p><p><strong>操作步骤</strong>：</p><ol><li>每个需要监听的服务的pom中添加。</li></ol><pre><code class="xml">&lt;!-- zipkin --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>每个需要监听的服务yml中</li></ol><pre><code class="sh">spring:  #zipkin  zipkin:    base-url: http://localhost:9411/    #采样比例1  sleuth:    sampler:      rate: 1  # zipkin 服务地址spring.zipkin.base-url=http://localhost:9411/# 采用比例spring.sleuth.sampler.rate=1      </code></pre><ol start="3"><li>启动zipkin。</li></ol><pre><code class="sh">jar包下载：curl -sSL https://zipkin.io/quickstart.sh | bash -s我放到了目录：D:\01_code\03_springbasic\spring-cloudjava -jar zipkin.jar或者docker：docker run -d -p 9411:9411 openzipkin/zipkin</code></pre><ol start="4"><li>验证</li></ol><pre><code class="shell"># 浏览器访问http://localhost/ribbon-consumer/test/user/alive# 后台日志[zuul-server,ba8d3dcdf72e8a07,ba8d3dcdf72e8a07,true][ribbon-consumer,ba8d3dcdf72e8a07,14b7b2c2a541aa03,true]# zipkinzuul-server -&gt; ribbon-consumer -&gt; hello-service</code></pre><h2 id="4、SpringCloud-Admin-健康检查"><a href="#4、SpringCloud-Admin-健康检查" class="headerlink" title="4、SpringCloud Admin 健康检查"></a>4、SpringCloud Admin 健康检查</h2><h3 id="4-1-Admin-服务搭建"><a href="#4-1-Admin-服务搭建" class="headerlink" title="4.1 Admin 服务搭建"></a>4.1 Admin 服务搭建</h3><p>pom 依赖</p><pre><code class="xml">&lt;!-- Admin 服务 --&gt;&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Admin 界面 --&gt;&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>启动类：</p><pre><code>@EnableAdminServer</code></pre><h3 id="4-2-微服务端"><a href="#4-2-微服务端" class="headerlink" title="4.2 微服务端"></a>4.2 微服务端</h3><p>pom 依赖</p><pre><code class="xml">&lt;!-- Admin 服务 --&gt;&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;    &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置</p><pre><code class="properties">management.endpoints.web.exposure.include=*management.endpoint.health.show-details=alwaysspring.boot.admin.client.url=http://localhost:8080</code></pre><p>测试</p><pre><code>http://localhost:8080/</code></pre><h3 id="4-3-邮件通知"><a href="#4-3-邮件通知" class="headerlink" title="4.3 邮件通知"></a>4.3 邮件通知</h3><ol><li><p>pom</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置</p><pre><code class="sh">spring.mail.host=smtp.qq.comspring.mail.username=1109075867spring.mail.password=edsgbgljwlxfgjgaspring.mail.properties.mail.smpt.auth=truespring.mail.properties.mail.smpt.starttls.enable=truespring.mail.properties.mail.smpt.starttls.required=true#收件邮箱spring.boot.admin.notify.mail.to=1109075867@qq.com# 发件邮箱spring.boot.admin.notify.mail.from=1109075867@qq.com</code></pre></li></ol><h3 id="4-4-钉钉群通知"><a href="#4-4-钉钉群通知" class="headerlink" title="4.4 钉钉群通知"></a>4.4 钉钉群通知</h3><h4 id="启动类ding"><a href="#启动类ding" class="headerlink" title="启动类ding"></a>启动类ding</h4><pre><code class="java">@SpringBootApplication@EnableAdminServerpublic class AdminServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(AdminServerApplication.class, args);    &#125;    @Bean    public DingDingNotifier dingDingNotifier(InstanceRepository repository) &#123;        return new DingDingNotifier(repository);    &#125;&#125;</code></pre><h4 id="通知类"><a href="#通知类" class="headerlink" title="通知类"></a>通知类</h4><pre><code class="java">public class DingDingNotifier extends AbstractStatusChangeNotifier &#123;    public DingDingNotifier(InstanceRepository repository) &#123;        super(repository);    &#125;    @Override    protected Mono&lt;Void&gt; doNotify(InstanceEvent event, Instance instance) &#123;        String serviceName = instance.getRegistration().getName();        String serviceUrl = instance.getRegistration().getServiceUrl();        String status = instance.getStatusInfo().getStatus();        Map&lt;String, Object&gt; details = instance.getStatusInfo().getDetails();        StringBuilder str = new StringBuilder();        str.append(&quot;服务预警 : 【&quot; + serviceName + &quot;】&quot;);        str.append(&quot;【服务地址】&quot; + serviceUrl);        str.append(&quot;【状态】&quot; + status);        str.append(&quot;【详情】&quot; + JSONObject.toJSONString(details));        return Mono.fromRunnable(() -&gt; &#123;            DingDingMessageUtil.sendTextMessage(str.toString());        &#125;);    &#125;&#125;</code></pre><h4 id="发送工具类"><a href="#发送工具类" class="headerlink" title="发送工具类"></a>发送工具类</h4><pre><code class="java">public class DingDingMessageUtil &#123;    // 群设置-&gt;只能群助手-&gt;添加机器人-&gt;Token    public static String access_token = &quot;Token&quot;;    public static void sendTextMessage(String msg) &#123;        try &#123;            Message message = new Message();            message.setMsgtype(&quot;text&quot;);            message.setText(new MessageInfo(msg));            URL url = new URL(&quot;https://oapi.dingtalk.com/robot/send?access_token=&quot; + access_token);            // 建立 http 连接            HttpURLConnection conn = (HttpURLConnection) url.openConnection();            conn.setDoOutput(true);            conn.setDoInput(true);            conn.setUseCaches(false);            conn.setRequestMethod(&quot;POST&quot;);            conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);            conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/Json; charset=UTF-8&quot;);            conn.connect();            OutputStream out = conn.getOutputStream();            String textMessage = JSONObject.toJSONString(message);            byte[] data = textMessage.getBytes();            out.write(data);            out.flush();            out.close();            InputStream in = conn.getInputStream();            byte[] data1 = new byte[in.available()];            in.read(data1);            System.out.println(new String(data1));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="消息类"><a href="#消息类" class="headerlink" title="消息类"></a>消息类</h4><pre><code class="java">public class Message &#123;    private String msgtype;    private MessageInfo text;    public String getMsgtype() &#123;        return msgtype;    &#125;    public void setMsgtype(String msgtype) &#123;        this.msgtype = msgtype;    &#125;    public MessageInfo getText() &#123;        return text;    &#125;    public void setText(MessageInfo text) &#123;        this.text = text;    &#125;&#125;public class MessageInfo &#123;    private String content;    public MessageInfo(String content) &#123;        this.content = content;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;&#125;</code></pre><h3 id="微信通知"><a href="#微信通知" class="headerlink" title="微信通知"></a>微信通知</h3><p>服务号 模板消息</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;网关&lt;/li&gt;
&lt;li&gt;链路追踪&lt;/li&gt;
&lt;li&gt;SpringCloud Admin&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud学习(四)</title>
    <link href="http://yoursite.com/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(4)-Hystrix.html"/>
    <id>http://yoursite.com/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(4)-Hystrix.html</id>
    <published>2020-10-03T15:33:12.000Z</published>
    <updated>2020-11-24T14:43:39.013Z</updated>
    
    <content type="html"><![CDATA[<ul><li>RestTemplate 基本使用</li><li>Ribbon 客户端负载均衡</li></ul><a id="more"></a><h2 id="1、Hystrix-和相关概念"><a href="#1、Hystrix-和相关概念" class="headerlink" title="1、Hystrix 和相关概念"></a>1、Hystrix 和相关概念</h2><h3 id="舱壁模式"><a href="#舱壁模式" class="headerlink" title="舱壁模式"></a>舱壁模式</h3><p>舱壁模式（Bulkhead）隔离了每个工作负载或服务的关键资源，如连接池、内存和CPU，硬盘。每个工作单元都有独立的 连接池，内存，CPU。</p><p>使用舱壁避免了单个服务消耗掉所有资源，从而导致其他服务出现故障的场景。<br>这种模式主要是通过防止由一个服务引起的级联故障来增加系统的弹性。</p><p>据说泰坦尼克原因：泰坦尼克号上有16个防水舱，设计可以保障如果只有4个舱进水，密闭和隔离可以阻止水继续进入下一个防水舱，从而保证船的基本浮力。</p><p>但是当时冰山从侧面划破了船体，从而导致有5个防水舱同时进水，而为了建造豪华的头等舱大厅，也就是电影里杰克和罗斯约会的地方，5号舱的顶部并未达到密闭所需要的高度，水就一层层进入了船体，隔离的失败导致了泰坦尼克的沉没。</p><p>给我们的思路：可以对每个请求设置，单独的连接池，配置连接数，不要影响 别的请求。就像一个一个的防水舱。</p><p>对在公司中的管理也一样：给每个独立的 小组，分配独立的资源，比如产品，开发，测试。在小公司，大多数情况 这些资源都是共享的，有一个好处是充分利用资源，坏处是，如果一个项目延期，会影响别的项目推进。自己权衡利弊。</p><p><img src="../../images/springcloud/4/%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F.png"></p><p>最近比较火的一句话： 真正的知识，是 产品提高一个等级和成本提高0.2元的 痛苦抉择。</p><h3 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h3><p>​        每个服务 发出一个HTTP请求都会 在 服务中 开启一个新线程。而下游服务挂了或者网络不可达，通常线程会阻塞住，直到 Timeout。如果并发量多一点，这些阻塞的线程就会占用大量的资源，很有可能把自己本身这个微服务所在的机器资源耗尽，导致自己也挂掉。</p><p>​        如果服务提供者响应非常缓慢，那么服务消费者调用此提供者就会一直等待，直到提供者响应或超时。在高并发场景下，此种情况，如果不做任何处理，就会导致服务消费者的资源耗竭甚至整个系统的崩溃。一层一层的崩溃，导致所有的系统崩溃。</p><p><img src="../../images/springcloud/4/%E9%9B%AA%E5%B4%A9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>​        <strong>雪崩</strong>：由基础服务故障导致级联故障的现象。描述的是：提供者不可用 导致消费者不可用，并将不可用逐渐放大的过程。像滚雪球一样，不可用的服务越来越多。影响越来越恶劣。</p><p>雪崩三个流程：</p><ul><li><p>服务提供者不可用</p></li><li><p>重试会导致网络流量加大，更影响服务提供者。</p></li><li><p>导致服务调用者不可用，由于服务调用者 一直等待返回，一直占用系统资源。</p></li></ul><p>（不可用的范围 被逐步放大）</p><p>服务不可用原因：</p><ul><li><p>服务器宕机</p></li><li><p>网络故障</p></li><li><p>宕机</p></li><li><p>程序异常</p></li><li><p>负载过大，导致服务提供者响应慢</p></li><li><p>缓存击穿导致服务超负荷运行</p></li></ul><p>总之 ： 基础服务故障  导致 级联故障   就是  雪崩。</p><h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><ol><li><p>为网络请求设置超时。</p><p>必须为网络请求设置超时。一般的调用一般在几十毫秒内响应。如果服务不可用，或者网络有问题，那么响应时间会变很长。长到几十秒。</p><p>每一次调用，对应一个线程或进程，如果响应时间长，那么线程就长时间得不到释放，而线程对应着系统资源，包括CPU,内存，得不到释放的线程越多，资源被消耗的越多，最终导致系统崩溃。</p><p>因此必须设置超时时间，让资源尽快释放。</p></li><li><p>使用断路器模式。</p><p>想一下家里的保险丝，跳闸。如果家里有短路或者大功率电器使用，超过电路负载时，就会跳闸，如果不跳闸，电路烧毁，波及到其他家庭，导致其他家庭也不可用。通过跳闸保护电路安全，当短路问题，或者大功率问题被解决，在合闸。</p><p>自己家里电路，不影响整个小区每家每户的电路。</p></li></ol><h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><pre><code>     如果对某个微服务请求有大量超时（说明该服务不可用），再让新的请求访问该服务就没有意义，只会无谓的消耗资源。例如设置了超时时间1s，如果短时间内有大量的请求无法在1s内响应，就没有必要去请求依赖的服务了。</code></pre><ol><li><p>断路器是对容易导致错误的操作的代理。这种代理能统计一段时间内的失败次数，并依据次数决定是正常请求依赖的服务还是直接返回。</p></li><li><p>断路器可以实现快速失败，如果它在一段时间内检测到许多类似的错误（超时），就会在之后的一段时间，强迫对该服务的调用快速失败，即不再请求所调用的服务。这样对于消费者就无须再浪费 CPU 去等待长时间的超时。</p></li><li><p>断路器也可自动诊断依赖的服务是否恢复正常。如果发现依赖的服务已经恢复正常，那么就会恢复请求该服务。通过重置时间来决定断路器的重新闭合。</p><p>这样就实现了微服务的“自我修复”：当依赖的服务不可用时，打开断路器，让服务快速失败，从而防止雪崩。当依赖的服务恢复正常时，又恢复请求。</p></li></ol><p><img src="../../images/springcloud/4/%E6%96%AD%E8%B7%AF%E5%99%A8%E5%BC%80%E5%85%B3%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p><pre><code class="sh">第一次正常第二次提供者异常提供者多次异常后，断路器打开后续请求，则直接降级，走备用逻辑。</code></pre><p>​    断路器状态转换的逻辑：</p><pre><code>关闭状态：正常情况下，断路器关闭，可以正常请求依赖的服务。打开状态：当一段时间内，请求失败率达到一定阈值，断路器就会打开。服务请求不会去请求依赖的服务。调用方直接返回。不发生真正的调用。重置时间过后，进入半开模式。半开状态：断路器打开一段时间后，会自动进入“半开模式”，此时，断路器允许一个服务请求访问依赖的服务。如果此请求成功(或者成功达到一定比例)，则关闭断路器，恢复正常访问。否则，则继续保持打开状态。断路器的打开，能保证服务调用者在调用异常服务时，快速返回结果，避免大量的同步等待，减少服务调用者的资源消耗。并且断路器能在打开一段时间后继续侦测请求执行结果，判断断路器是否能关闭，恢复服务的正常调用。</code></pre><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>为了在整体资源不够的时候，适当放弃部分服务，将主要的资源投放到核心服务中，待渡过难关之后，再重启已关闭的服务，保证了系统核心服务的稳定。当服务停掉后，自动进入 fallback 替换主方法。</p><p>用 fallback 方法代替主方法执行并返回结果，对失败的服务进行降级。当调用服务失败次数在一段时间内超过了断路器的阈值时，断路器将打开，不再进行真正的调用，而是快速失败，直接执行 fallback 逻辑。服务降级保护了服务调用者的逻辑。</p><pre><code class="sh">熔断和降级：共同点：    1、为了防止系统崩溃，保证主要功能的可用性和可靠性。    2、用户体验到某些功能不能用。不同点：    1、熔断由下级故障触发，主动惹祸。    2、降级由调用方从负荷角度触发，无辜被抛弃。</code></pre><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>spring cloud 用的是 hystrix，是一个容错组件。</p><p>Hystrix 实现了超时机制和断路器模式。</p><p>目的：**<em>当我自身 依赖的服务不可用时，服务自身不会被拖垮。防止微服务级联异常**</em>。</p><p>Hystrix 是 Netflix 开源的一个类库，用于隔离远程系统、服务或者第三方库，防止级联失败，从而提升系统的<strong>可用性与容错性</strong>。主要有以下几点功能：</p><ol><li>为系统提供保护机制。在依赖的服务出现高延迟或失败时，为系统提供保护和控制。</li><li>防止雪崩。</li><li>包裹请求：使用 HystrixCommand（或 HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中运行。</li><li><strong>跳闸机制-熔断</strong>：当某服务失败率达到一定的阈值时，Hystrix 可以自动跳闸，停止请求该服务一段时间。</li><li><strong>资源隔离</strong>：Hystrix 为每个请求的资源都维护了一个小型线程池，如果该线程池已满，发往该资源的请求就被立即拒绝，而不是排队等候，从而加速失败判定。防止级联失败。</li><li>快速失败：Fail Fast。同时能快速恢复。侧重点是：（不去真正的请求服务，发生异常再返回），而是直接失败。</li><li>监控：Hystrix 可以实时监控运行指标和配置的变化，提供近实时的监控、报警、运维控制。</li><li>回退机制：fallback，当请求失败、超时、被拒绝，或当断路器被打开时，执行回退逻辑。回退逻辑我们自定义，提供优雅的服务降级。</li><li>自我修复：断路器打开一段时间后，会自动进入“半开”状态，可以进行打开，关闭，半开状态的转换。前面有介绍。</li></ol><h2 id="2、Hystrix-单独使用"><a href="#2、Hystrix-单独使用" class="headerlink" title="2、Hystrix 单独使用"></a>2、Hystrix 单独使用</h2><pre><code class="java">public class HystrixTest extends HystrixCommand &#123;    protected HystrixTest(HystrixCommandGroupKey group) &#123;        super(group);    &#125;    public static void main(String[] args) &#123;        HystrixTest hystrixTest = new HystrixTest(HystrixCommandGroupKey.Factory.asKey(&quot;ext&quot;));        /**         * execute()：以同步阻塞方式执行run()。以demo为例，调用execute()后，         * hystrix 先创建一个新线程运行 run()，         * 接着调用程序要在 execute() 调用处一直阻塞着，直到 run() 运行完成         */        // System.out.println(&quot;result:&quot; + hystrixTest.execute());        /**         * queue()：以异步非阻塞方式执行run()。以demo为例，         *     一调用queue()就直接返回一个Future对象，         *     同时hystrix创建一个新线程运行run()，         *     调用程序通过Future.get()拿到run()的返回结果，         *     而Future.get()是阻塞执行的         */        Future&lt;String&gt; futureResult = hystrixTest.queue();        String result = &quot;&quot;;        try &#123;            result = futureResult.get();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;程序结果：&quot;+result);    &#125;    @Override    protected Object run() throws Exception &#123;        System.out.println(&quot;执行逻辑&quot;);        int i = 1/0;        return &quot;ok&quot;;    &#125;    @Override    protected Object getFallback() &#123;        return &quot;getFallbackgetFallback&quot;;    &#125;&#125;</code></pre><h2 id="3、Hystrix-和-RestTemplate-整合"><a href="#3、Hystrix-和-RestTemplate-整合" class="headerlink" title="3、Hystrix 和 RestTemplate 整合"></a>3、Hystrix 和 RestTemplate 整合</h2><p>RestTemplate 不带有 Hystrix，需要在<strong>启动类</strong>上加注解手动开启。<code>@EnableCircuitBreaker</code></p><pre><code class="java">@RequestMapping(value = &quot;/testRestHystrix&quot;, method = RequestMethod.GET)@HystrixCommand(fallbackMethod = &quot;fallback&quot;)public Person testRestHystrix() &#123;    Map&lt;String, String&gt; param = new HashMap&lt;&gt;();    param.put(&quot;id&quot;, &quot;2&quot;);    param.put(&quot;name&quot;, &quot;getObjectByPost&quot;);    ResponseEntity&lt;Person&gt; entity = restTemplate.postForEntity(&quot;http://HELLO-SERVICE/testRestHystrix&quot;,                                                               param, Person.class);    System.out.println(&quot;返回结果 Body：&quot;+entity);    return entity.getBody();&#125;public Person fallback() &#123;    return new Person(1,&quot;testRestHystrix 请求失败...&quot;);&#125;</code></pre><h2 id="4、Hystrix-和-Feign-整合"><a href="#4、Hystrix-和-Feign-整合" class="headerlink" title="4、Hystrix 和 Feign 整合"></a>4、Hystrix 和 Feign 整合</h2><p>Feign 本身集成了 Hystrix，但是默认是关闭的。需要在配中中手动开启。</p><p><strong>配置</strong>：<code>feign.hystrix.enabled=true</code></p><h3 id="4-1-fallback-形式"><a href="#4-1-fallback-形式" class="headerlink" title="4.1 fallback 形式"></a>4.1 fallback 形式</h3><p>API：</p><pre><code class="java">@FeignClient(name = &quot;hello-service&quot;, fallback = UserConsumerApiFallback.class)public interface UserConsumerApi extends UserApi &#123;    // 这里的映射是给 Feign 看的,用于拼接地址    @GetMapping(&quot;/getMap&quot;)    Map&lt;Integer, String&gt; getMap(@RequestParam(&quot;id&quot;) Integer id);    @GetMapping(&quot;/getMap2&quot;)    Map&lt;Integer, String&gt; getMap2(@RequestParam(&quot;id&quot;) Integer id,@RequestParam(&quot;name&quot;) String name);    @GetMapping(&quot;/getMap3&quot;)    Map&lt;Integer, String&gt; getMap3(@RequestParam Map&lt;String, Object&gt; map);    @PostMapping(&quot;/postMap&quot;)    Map&lt;Integer, String&gt; postMap(@RequestBody Map&lt;String, Object&gt; map);&#125;</code></pre><p>Fallback:</p><pre><code class="java">@Component// 不加会报错...@RequestMapping(value = &quot;userfallback&quot;)public class UserConsumerApiFallback implements UserConsumerApi &#123;    @Override    public String alive() &#123;        return &quot;熔断了&quot;;    &#125;&#125;</code></pre><h3 id="4-2-fallback-factory-形式"><a href="#4-2-fallback-factory-形式" class="headerlink" title="4.2 fallback factory 形式"></a>4.2 fallback factory 形式</h3><p>这种形式可以获取到报错的具体信息。</p><p>API:</p><pre><code class="java">@FeignClient(name = &quot;hello-service&quot;, fallbackFactory = UserConsumerApiFallbackFactory.class)public interface UserConsumerApi extends UserApi &#123;&#125;</code></pre><p>FallbackFactoty:</p><pre><code class="java">@Componentpublic class UserConsumerApiFallbackFactory implements FallbackFactory&lt;UserConsumerApi&gt; &#123;    @Override    public UserConsumerApi create(Throwable throwable) &#123;        return new UserConsumerApi() &#123;            @Override            public String alive() &#123;                // 捕获异常                System.out.println(&quot;====&gt;&quot;+throwable);                if(throwable instanceof HttpServerErrorException.InternalServerError) &#123;                    System.out.println(&quot;InternalServerError&quot;);                    return &quot;远程服务报错&quot;;                &#125;else if(throwable instanceof RuntimeException) &#123;                    return &quot;请求时异常：&quot; + throwable;                &#125;else if (throwable instanceof HystrixTimeoutException)&#123;                    return &quot;远程服务器处理超时&quot;;                &#125; else &#123;                    return &quot;FallbackFactory 熔断、降级、限流、隔离&quot;;                &#125;            &#125;        &#125;;    &#125;&#125;</code></pre><h2 id="5、Hystrix-Dashboard"><a href="#5、Hystrix-Dashboard" class="headerlink" title="5、Hystrix Dashboard"></a>5、Hystrix Dashboard</h2><h3 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h3><p>启动类：</p><pre><code>@EnableHystrixDashboard</code></pre><p>引入依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>开放 actuator 端点：</p><pre><code class="properties">management.endpoints.web.exposure.include=*</code></pre><p>健康上报请求查看：</p><pre><code>http://localhost:9001/actuator/hystrix.stream</code></pre><p>图形化页面：</p><pre><code>http://localhost:9001/hystrix</code></pre><p>界面说明：</p><pre><code>https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki</code></pre><h3 id="集中可视化-turbine"><a href="#集中可视化-turbine" class="headerlink" title="集中可视化-turbine"></a>集中可视化-turbine</h3><p>上面的方法只能监控一个服务。实际生产中不方便。</p><p><img src="../../images/springcloud/4/Turbine%E5%8E%9F%E7%90%86.png"></p><p>创建study-hystrix-turbine</p><p>pom</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka客户端 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>yml</p><pre><code class="sh">turbine:  app-config: api-driver,api-passenger  cluster-name-expression: &quot;&#39;default&#39;&quot;</code></pre><p>启动类</p><pre><code class="sh">@EnableTurbine</code></pre><p>地址：<a href="http://localhost:6102/turbine.stream,%E4%B9%9F%E6%98%AF%E4%B8%80%E7%9B%B4ping%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%8E%9F%E6%9D%A5%E7%9A%84hystrix.stream,%E4%B8%8D%E8%BF%87%E6%AD%A4%E5%A4%84%E6%98%AF%E7%BB%BC%E5%90%88%E4%BA%86%E6%89%80%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E3%80%82">http://localhost:6102/turbine.stream,也是一直ping，相当于原来的hystrix.stream,不过此处是综合了所有的项目。</a></p><p>启动 hystrix-dashboard。</p><p>访问：<a href="http://localhost:6101/hystrix">http://localhost:6101/hystrix</a></p><p>填上上面的地址：<a href="http://localhost:6102/turbine.stream">http://localhost:6102/turbine.stream</a></p><h2 id="6、Hystrix-捕获-忽略异常"><a href="#6、Hystrix-捕获-忽略异常" class="headerlink" title="6、Hystrix 捕获/忽略异常"></a>6、Hystrix 捕获/忽略异常</h2><h3 id="6-1-捕获异常"><a href="#6-1-捕获异常" class="headerlink" title="6.1 捕获异常"></a>6.1 捕获异常</h3><p>即获取熔断的原因。</p><p><strong>restTemplate 中 fallback</strong></p><pre><code class="java">public Person fallback(Throwable throwable) &#123;    System.out.println(&quot;异常信息：&quot;+throwable);    return new Person(1,&quot;testRestHystrix 请求失败...&quot;);&#125;</code></pre><p><strong>feign 中 FallbackFactory</strong></p><pre><code class="java">@Overridepublic UserConsumerApi create(Throwable throwable) &#123;&#125;</code></pre><h3 id="6-2-忽略异常"><a href="#6-2-忽略异常" class="headerlink" title="6.2 忽略异常"></a>6.2 忽略异常</h3><p>即有些异常不让其走熔断，而是直接报错。</p><p><strong>继承 HystrixBadRequestException</strong></p><pre><code class="java">/** * @author alvin * @date 2020-10-07 20:55 * 继承 HystrixBadRequestException，如果抛出该异常，Hystrix 不会走备用逻辑。 */public class HystrixAutoIgnoreException extends HystrixBadRequestException &#123;    public HystrixAutoIgnoreException(String message) &#123;        super(message);    &#125;    public HystrixAutoIgnoreException(String message, Throwable cause) &#123;        super(message, cause);    &#125;    private static final long serialVersionUID = 1L;&#125;</code></pre><p><strong>ignoreExceptions</strong></p><pre><code class="java">    @HystrixCommand(fallbackMethod = &quot;fallback&quot;,        ignoreExceptions = &#123;HystrixIgnoreException.class&#125;,        commandProperties = &#123;@HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;)&#125;)</code></pre><h2 id="7、Feign-客户端禁用-hystrix"><a href="#7、Feign-客户端禁用-hystrix" class="headerlink" title="7、Feign 客户端禁用 hystrix"></a>7、Feign 客户端禁用 hystrix</h2><p>直接不写 fallback 不就行了？</p><p>为 @feignclient 单独配置 Feign.Builder</p><p>配置类</p><pre><code class="java">@Configuration@ScanIgnorepublic class FeignDisableHystrixConfig &#123;    /**     *     singleton 表示在spring容器中的单例，通过spring容器获得该bean时总是返回唯一的实例     *    prototype表示每次获得bean都会生成一个新的对象     *    request表示在一次http请求内有效（只适用于web应用）     *    session表示在一个用户会话内有效（只适用于web应用）     *    globalSession表示在全局会话内有效（只适用于web应用）     *    在多数情况，我们只会使用singleton和prototype两种scope，如果在spring配置文件内未指定scope属性，默认为singleton。     * @return     */    @Bean    @Scope(&quot;prototype&quot;)    public Feign.Builder feignBuilder()&#123;        return Feign.builder();    &#125;&#125;</code></pre><p>注解</p><pre><code class="java">@FeignClient(name = &quot;hello-service&quot;, configuration = FeignDisableHystrixConfig.class)</code></pre><p>测试点：发现不再走熔断。</p><h2 id="8、Hystrix-配置"><a href="#8、Hystrix-配置" class="headerlink" title="8、Hystrix 配置"></a>8、Hystrix 配置</h2><p>点击 @HystrixCommand 进去。可以看到很多配置项。</p><p>官网说明：<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">https://github.com/Netflix/Hystrix/wiki/Configuration</a></p><h3 id="8-1-commandProperties-配置"><a href="#8-1-commandProperties-配置" class="headerlink" title="8.1 commandProperties 配置"></a>8.1 commandProperties 配置</h3><p>源码：HystrixCommandProperties.java</p><pre><code class="properties">##1、Execution 相关，控制 HystrixCommand.run() 执行# HystrixCommand.run() 执行的隔离策略。默认为 ExecutionIsolationStrategy.THREAD。# Thread 通过线程数量来限制并发请求数，可以提供额外的保护，但有一定的延迟。一般用于网络调用# Semaphore 通过 semaphore count 来限制并发请求数，适用于无网络的高并发请求execution.isolation.strategy=THREAD# HystrixCommand 执行的超时时间，单位为毫秒。execution.isolation.thread.timeoutInMilliseconds=1000# HystrixCommand.run() 的执行是否启用超时时间。默认为true。execution.timeout.enabled=true# HystrixCommand.run() 执行超时的时候是否要它中断。execution.isolation.thread.interruptOnTimeout=true# HystrixCommand.run()执行取消时是否要它中断。execution.isolation.thread.interruptOnCancel=false# 当 HystrixCommand 命令的隔离策略使用信号量时，该属性用来配置信号量的大小。当最大并发请求达到该设置值时，后续的请求将被拒绝。execution.isolation.semaphore.maxConcurrentRequests=10##2、Fallback 相关，控制 HystrixCommand.getFallback() 的执行# HystrixCommand.getFallback()方法执行的最大并发请求数。当达到最大并发请求时，后续的请求将会被拒绝并抛出异常。fallback.isolation.semaphore.maxConcurrentRequests=10# 设置服务降级策略是否启用。如果为false 当请求失败或者拒绝发生时，将不会调用 HystrixCommand.getFallback() 来执行服务降级逻辑。fallback.enabled=true##3、Circuit Breaker：用来控制HystrixCircuitBreaker的行为。# 是否启动熔断器，确定当服务请求命令失败时，是否使用断路器来跟踪其健康指标和熔断请求。默认为true。circuitBreaker.enabled=true# 用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为20的时候，如果滚动时间窗（默认10秒）内仅收到19个请求，即使这19个请求都失败了，断路器也不会打开。#10秒内20次失败，断路器打开circuitBreaker.requestVolumeThreshold=20# 熔断时间窗口，用来设置当断路器打开之后的休眠时间窗。休眠时间窗结束之后，会将断路器设置为“半开”状态，尝试熔断的请求命令，如果请求失败就将断路器继续设置为“打开”状态，如果请求成功，就管关闭熔断器circuitBreaker.sleepWindowInMilliseconds=5000# 开启熔断器阈值百分比。该属性用来设置断路器打开的错误百分比条件。默认值为50，表示在滚动时间窗中，在请求值超过requestVolumeThreshold阈值的前提下，如果错误请求数百分比超过50，就把断路器设置为“打开”状态，否则就设置为“关闭”状态。circuitBreaker.errorThresholdPercentage=50#该属性默认为false。如果该属性设置为true，断路器将强制进入“打开”状态，它会拒绝所有请求。该属性优于forceClosed属性。circuitBreaker.forceOpen=false#该属性默认为false。如果该属性设置为true，断路器强制进入“关闭”状态，它会接收所有请求。如果forceOpen属性为true，该属性不生效。circuitBreaker.forceClosed=false##4、Metrics：该属性与HystrixCommand和HystrixObservableCommand执行中捕获的指标相关。# 该属性用来设置滚动时间窗的长度，单位为毫秒。该时间用于断路器判断健康度时需要收集信息的持续时间。断路器在收集指标信息时会根据设置的时间窗长度拆分成多个桶来累计各度量值，每个桶记录了一段时间的采集指标。例如，当为默认值10000毫秒时，断路器默认将其分成10个桶，每个桶记录1000毫秒内的指标信息。metrics.rollingStats.timeInMilliseconds=10000# 用来设置滚动时间窗统计指标信息时划分“桶”的数量。默认值为10。metrics.rollingStats.numBuckets=10# 用来设置对命令执行延迟是否使用百分位数来跟踪和计算。默认为true，如果设置为false，那么所有的概要统计都将返回-1。metrics.rollingPercentile.enabled=true# 用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。metrics.rollingPercentile.timeInMilliseconds=60000# 用来设置百分位统计滚动窗口中使用桶的数量。metrics.rollingPercentile.numBuckets=6# 用来设置每个“桶”中保留的最大执行数。metrics.rollingPercentile.bucketSize=100# 用来设置采集影响断路器状态的健康快照的间隔等待时间。metrics.healthSnapshot.intervalInMilliseconds=500##5、Request Context：涉及HystrixCommand使用HystrixRequestContext的设置。# 用来配置是否开启请求缓存。requestCache.enabled=true# 用来设置HystrixCommand的执行和事件是否打印到日志的HystrixRequestLog中。requestLog.enabled=true</code></pre><h3 id="8-2-threadPoolProperties-配置"><a href="#8-2-threadPoolProperties-配置" class="headerlink" title="8.2 threadPoolProperties 配置"></a>8.2 threadPoolProperties 配置</h3><p>源码：HystrixThreadPoolProperties.java</p><pre><code class="properties"># 配置线程池大小 core size of thread poolcoreSize=10# maximum size of thread poolmaximumSize=10# minutes to keep a thread alivekeepAliveTimeMinutes=1# size of queue (this can&#39;t be dynamically changed so we use &#39;queueSizeRejectionThreshold&#39; to artificially limit and reject)# -1 turns it off and makes us use SynchronousQueuemaxQueueSize=-1# number of items in queuequeueSizeRejectionThreshold=5</code></pre><p>通过下面例子，说一下配置方法。大家下去可以参考上面 看需要试试。</p><pre><code class="java">@RequestMapping(value = &quot;/sendFail&quot;, method = RequestMethod.GET)@HystrixCommand(fallbackMethod = &quot;fallback&quot;,                ignoreExceptions = &#123;HystrixIgnoreException.class&#125;,                commandProperties = &#123;@HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;false&quot;)&#125;)public Person sendFail() &#123;    Map&lt;String, String&gt; param = new HashMap&lt;&gt;();    param.put(&quot;id&quot;, &quot;2&quot;);    param.put(&quot;name&quot;, &quot;getObjectByPost&quot;);    ResponseEntity&lt;Person&gt; entity = restTemplate.postForEntity(&quot;http://HELLO-SERVICE/testRestHystrix&quot;,                                                               param, Person.class);    System.out.println(&quot;返回结果 Body：&quot;+entity);    return entity.getBody();&#125;public Person fallback() &#123;    return new Person(1,&quot;testRestHystrix 请求失败...&quot;);&#125;</code></pre><h2 id="9、测试断路器开启-CIRCUIT-OPEN"><a href="#9、测试断路器开启-CIRCUIT-OPEN" class="headerlink" title="9、测试断路器开启-CIRCUIT_OPEN"></a>9、测试断路器开启-CIRCUIT_OPEN</h2><h3 id="jmeter-简单使用"><a href="#jmeter-简单使用" class="headerlink" title="jmeter 简单使用"></a>jmeter 简单使用</h3><p>下载地址：</p><pre><code>https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-5.3.zip</code></pre><p>安装：解压并设置 classpath 环境遍历</p><pre><code class="json"># JMETER_HOMED:\apache-jmeter-5.3# classpath%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib/logkit-2.0.jar;</code></pre><p>运行：</p><pre><code class="json"># 管理员方式运行D:\apache-jmeter-5.3\bin\jmeter.bat</code></pre><h3 id="测试-断路器开启、半开和关闭"><a href="#测试-断路器开启、半开和关闭" class="headerlink" title="测试-断路器开启、半开和关闭"></a>测试-断路器开启、半开和关闭</h3><p><img src="../../images/springcloud/4/%E6%B5%8B%E8%AF%95Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8%E5%BC%80%E5%90%AF%E5%8D%8A%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD.png"></p><pre><code class="json">http://localhost:9001/actuator/healthhystrix: &#123;    status: &quot;UP&quot;&#125;# 多次访问，多次失败，测试断路器开启# 打开 jmeter，设置1秒访问15次(配置10秒 10次，开始熔断计算)。错误，熔断。查看开关.http://localhost:9001/sendFail3# 观察异常信息的变化异常信息：java.lang.IllegalStateException: No instances available for HELLO-SERVICE异常信息：java.lang.RuntimeException: Hystrix circuit short-circuited and is OPENhttp://localhost:9001/actuator/health&quot;hystrix&quot;: &#123;    &quot;status&quot;:&quot;CIRCUIT_OPEN&quot;,    &quot;details&quot;:&#123;&quot;openCircuitBreakers&quot;:[&quot;RestTempleteTestController::sendFail&quot;]&#125;&#125;# 等待五秒钟，再次跑一次 jmeter# 发现第一次尝试去请求了 user-server 服务，但是失败了# 断路器再次开启，后面 14 次请求直接熔断# 访问成功一次，状态变为 UP# 用浏览器访问</code></pre><h2 id="10、-Hystrix-原理"><a href="#10、-Hystrix-原理" class="headerlink" title="10、 Hystrix 原理"></a>10、 Hystrix 原理</h2><p>了解前面一些概念：舱壁模式，命令模式（下面），雪崩，容错，断路器，降级。</p><p>熔断降级：北京去武汉招大学生的例子。</p><p>资源隔离：类似于高铁高架桥，并不是一个整体，而是一块一块的拼装的，一段路坏了，不会影响整条路。</p><h3 id="隔离策略-线程池隔离、信号量隔离"><a href="#隔离策略-线程池隔离、信号量隔离" class="headerlink" title="隔离策略-线程池隔离、信号量隔离"></a>隔离策略-线程池隔离、信号量隔离</h3><p>概念中的舱壁模式。想一下货船上，每个货仓中间的隔离。两个好处：</p><ol><li>服务提供者高延迟或异常，不会影响到整个系统的失败。</li><li>能够控制每个调用者的并发度。因为有独立的线程池。</li></ol><p>两种线程隔离策略：线程池隔离（默认）-THREAD、信号量隔离-SEMAPHORE。</p><p><img src="../../images/springcloud/4/Hystrix%E9%9A%94%E7%A6%BB%E7%AD%96%E7%95%A5.png"></p><p>@HystrixCommand 注释修饰一个服务时，HystrixCommand 的运行逻辑有可能是在该请求的主线程(<strong>Tomcat 线程</strong>)上一并执行，也有可能是单独起一个线程来执行，这取决于我们如何设置 Hystrix 线程的隔离策略（<code>execution.isolation.strategy</code>）。</p><p><strong>THREAD(线程隔离）</strong>：使用该方式，HystrixCommand 将会在单独的线程上执行，并发请求受线程池中线程数量的限制。不同服务通过使用不同线程池，彼此间将不受影响，达到隔离效果。</p><p>此种隔离方式：将调用服务线程与服务访问的执行线程分割开来，调用线程能够空出来去做其他工作，而不至于因为服务调用的执行，阻塞过长时间。</p><p>hystrix 将使用独立的线程池对应每一个服务提供者，用于隔离和限制这些服务。于是某个服务提供者的高延迟或者资源受限只会发生在该服务提供者对应的线程池中。</p><p><strong>SEMAPHORE（信号量隔离）</strong>：其实就是个计数器，使用该方式，HystrixCommand 将会在调用线程上执行，通过信号量限制单个服务提供者的并发量，开销相对较小（因为不用那么多线程池），并发请求受到信号量个数的限制。 线程隔离会带来线程开销，有些场景（比如无网络请求场景）可能会因为用开销换隔离得不偿失，为此 hystrix 提供了信号量隔离，当服务的并发数大于信号量阈值时将进入 fallback。</p><p>信号量隔离不需要内部线程池，更加轻量级，但是需要保证程序的健壮性或者低延迟处理，否则会影响其他服务的使用，因为 Tomcat 的 worker 线程不仅仅负责调用 Service1，也可能调用 Service2。不需要内部线程池，更加轻量级，但是需要保证程序的健壮性或者低延迟处理，否则会影响其他服务的使用，因为 Tomcat 的 worker 线程不仅仅负责调用 Service1，也可能调用 Service2。</p><p>一般来说，只有当<strong>调用负载异常高</strong>时（例如每个实例每秒调用数百次）才需要信号量隔离，因为这种场景下使用 THREAD 开销会比较高。信号量隔离一般仅适用于<strong>非网络调用</strong>的隔离。 正常情况下，默认为线程隔离, 保持默认即可。</p><p>线程池和信号量都支持熔断和限流。相比线程池，信号量不需要线程切换，因此避免了不必要的开销。但是信号量不支持异步，也不支持超时，也就是说当所请求的服务不可用时，信号量会控制超过限制的请求立即返回，但是已经持有信号量的线程只能等待服务响应或从超时中返回，即可能出现长时间等待。线程池模式下，当超过指定时间未响应的服务，Hystrix 会通过响应中断的方式通知线程立即结束并返回。</p><p>线程池隔离优点：</p><ol><li>可以根据不同的业务，用不同的拒绝策略</li><li>可以异步请求，解放 worker 的线程阻塞</li><li>只会影响线程池内部，服务异常隔离</li></ol><p>信号量隔离优点：</p><ol><li>效率更高，无需维护额为线程池</li><li>适合于计算密集型的请求，即速度快低延迟</li><li>要求代码非常健壮，基本不会出现问题，否则会影响 Tomcat 调用其他服务，因为信号量隔离用的是 Tomcat  的 worker 线程。</li></ol><h3 id="Hystrix实现思路"><a href="#Hystrix实现思路" class="headerlink" title="Hystrix实现思路"></a>Hystrix实现思路</h3><ol><li><p>请求过来时，将请求的远程调用逻辑，封装到 HystrixCommand 或者 HystrixObservableCommand 对象（并在构造方法配置请求被执行需要的参数）中，这些远程调用将会在独立的线程中执行。（资源隔离、命令模式）。</p><pre><code class="sh">https://www.runoob.com/design-pattern/command-pattern.html介绍意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。何时使用：在某些场合，比如要对行为进行&quot;记录、撤销/重做、事务&quot;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将&quot;行为请求者&quot;与&quot;行为实现者&quot;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。缺点：使用命令模式可能会导致某些系统有过多的具体命令类。使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</code></pre></li><li><p>Hystrix 对访问耗时超过设置阈值的请求采用自动超时的策略。该策略对所有的命令都有效。（如果是信号量隔离方式，则此特性失效），超时的阈值可以通过命令配置进行自定义。</p></li><li><p>为每个服务提供者维护一个线程池（信号量），当线程池（信号量）被占满时，对于该服务提供者的请求将会被直接拒绝（快速失败，走回滚）而不是排队等待，减少系统等待资源。</p></li><li><p>针对请求服务提供者划分出成功、失效、超时和线程池被占满等情况。</p></li><li><p>断路器将在请求服务提供者失败次数超过一定阈值后手动或自动切断服务一段时间。</p></li><li><p>当请求服务提供者出现服务拒绝、超时和 短路（多个服务提供者依次顺序请求，前面的服务提供者请求失败，后面的请求将不再发出）等情况，执行器 fallback 方法，服务降级。</p></li><li><p>提供近乎实时的监控和配置变更服务。</p></li></ol><h3 id="hystrix实现流程"><a href="#hystrix实现流程" class="headerlink" title="hystrix实现流程"></a>hystrix实现流程</h3><ol><li>构建 HystrixCommand 或者 HystrixObservableCommand 对象，用于封装请求，并在构造方法配置请求被执行需要的参数。</li><li>执行命令，Hystrix 提供了 4 种执行命令的方法。</li><li>检查是否有相同命令执行的缓存，若启用了缓存，且缓存可用，直接使用缓存响应请求。Hystrix 支持请求缓存，但需要用户自定义启动。</li><li>检查断路器是否打开，如果打开走 第8步。</li><li>检查<strong>线程池或者信号量</strong>是否被消耗完，如果已满，走第 8 步。</li><li>调用 HystrixCommand 的 run 或者 HystrixObservableCommand 的 construct 执行被封装的调用逻辑，如果执行失败或超时，走第 8 步。</li><li>计算链路的健康情况</li><li>在命令执行失败时获取 fallback 逻辑。</li><li>返回响应。</li></ol><p><img src="../../images/springcloud/4/%E6%96%AD%E8%B7%AF%E5%99%A8%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p><h2 id="11、-Hystrix-源码"><a href="#11、-Hystrix-源码" class="headerlink" title="11、 Hystrix 源码"></a>11、 Hystrix 源码</h2><h3 id="11-1-包裹请求"><a href="#11-1-包裹请求" class="headerlink" title="11.1 包裹请求"></a>11.1 包裹请求</h3><p>@HystrixCommand、HystrixCommandAspect 。</p><p>被注解 @HystrixCommand 修饰的方法，会被 HystrixCommand 包装执行，通过切面来实现。</p><p>命令模式</p><pre><code>HystrixInvokable 是被 HystrixCommand 标记的接口，继承了它的类，都是可以被执行的HystrixCommand。提供具体方法的为 HystrixExecutable。</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;RestTemplate 基本使用&lt;/li&gt;
&lt;li&gt;Ribbon 客户端负载均衡&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习(三)</title>
    <link href="http://yoursite.com/2020-10-02-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(3)-Feign.html"/>
    <id>http://yoursite.com/2020-10-02-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(3)-Feign.html</id>
    <published>2020-10-02T15:33:12.000Z</published>
    <updated>2020-11-24T14:43:35.863Z</updated>
    
    <content type="html"><![CDATA[<ul><li>RestTemplate 基本使用</li><li>Ribbon 客户端负载均衡</li></ul><a id="more"></a><h2 id="1-Feigin-声明式服务调用"><a href="#1-Feigin-声明式服务调用" class="headerlink" title="1. Feigin-声明式服务调用"></a>1. Feigin-声明式服务调用</h2><p>OpenFeign 是 Netflix  开发的<strong>声明式、模板化</strong>的 HTTP 请求客户端。可以更加便捷、优雅地调用 http api。</p><p>OpenFeign 会根据带有注解的函数信息构建出网络请求的模板，在发送网络请求之前，OpenFeign 会将函数的参数值设置到这些请求模板中。</p><p>feign 主要是构建微服务消费端。只要使用 OpenFeign 提供的注解修饰定义网络请求的接口类，就可以使用该接口的实例发送 RESTful的 网络请求。还可以集成 Ribbon 和 Hystrix，提供负载均衡和断路器。</p><p>英文表意为“假装，伪装，变形”， 是一个 Http 请求调用的轻量级框架，可以以 Java 接口注解的方式调用 Http 请求，而不用像 Java 中通过封装 HTTP 请求报文的方式直接调用。通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。Feign 封装 了 HTTP 调用流程，面向接口编程，回想第一节课的 SOP。</p><h2 id="2、Feign-和-OpenFeign-关系"><a href="#2、Feign-和-OpenFeign-关系" class="headerlink" title="2、Feign 和 OpenFeign 关系"></a>2、Feign 和 OpenFeign 关系</h2><p>Feign 本身不支持 Spring MVC 的注解，它有一套自己的注解</p><p>OpenFeign 是 Spring Cloud 在 Feign 的基础上支持了 Spring MVC 的注解，如 @RequesMapping 等等。<br>OpenFeign 的 <code>@FeignClient</code> 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，<br>并通过<strong>动态代理</strong>的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><h2 id="3、Feign-的使用"><a href="#3、Feign-的使用" class="headerlink" title="3、Feign 的使用"></a>3、Feign 的使用</h2><h3 id="3-1-创建接口服务"><a href="#3-1-创建接口服务" class="headerlink" title="3.1 创建接口服务"></a>3.1 创建接口服务</h3><pre><code class="java">@RequestMapping(value = &quot;user&quot;)public interface UserApi &#123;    @GetMapping(&quot;/alive&quot;)    String alive();    @GetMapping(&quot;/&#123;id&#125;&quot;)    Person getUserById(@PathVariable Integer id);&#125;</code></pre><p>接口服务安装。mvn install user-api。</p><h3 id="3-2-创建-Provider-服务"><a href="#3-2-创建-Provider-服务" class="headerlink" title="3.2 创建 Provider 服务"></a>3.2 创建 Provider 服务</h3><p>pom.xml 中依赖接口服务。</p><pre><code class="xml">&lt;!-- user-api --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.monkeykong&lt;/groupId&gt;    &lt;artifactId&gt;user-api&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接口实现</p><pre><code class="java">@RestController@RequestMapping(value = &quot;user&quot;)public class UserController implements UserApi &#123;    @RequestMapping(value = &quot;alive&quot;, method = RequestMethod.GET)    public String alive() &#123;        return &quot;ok, I am alive&quot;;    &#125;    @RequestMapping(value = &quot;&#123;id&#125;&quot;, method = RequestMethod.GET)    public Person getUserById(@PathVariable Integer id) &#123;        return new Person(id, &quot;alvin&quot;);    &#125;&#125;</code></pre><p>个人不喜欢这么做，也有的企业这么用，不喜欢是因为这样<strong>服务端和客户端就耦合</strong>了，这么用，会方便编码。自己权衡取舍。没有对错。</p><h3 id="3-3-创建-Consumer-服务"><a href="#3-3-创建-Consumer-服务" class="headerlink" title="3.3 创建 Consumer 服务"></a>3.3 创建 Consumer 服务</h3><p>pom.xml 中依赖接口服务。</p><pre><code class="xml">&lt;!-- openfeign --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- user-api --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.monkeykong&lt;/groupId&gt;    &lt;artifactId&gt;user-api&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>feign 接口定义，继承 UserApi</p><pre><code class="java">@FeignClient(name = &quot;hello-service&quot;)public interface UserConsumerApi extends UserApi &#123;&#125;</code></pre><p><strong>重要：声明允许使用 Feign</strong></p><pre><code class="java">@EnableFeignClients</code></pre><p>编写测试 Controller</p><pre><code class="java">@RestController@RequestMapping(value = &quot;test/user&quot;)public class FeignTestController &#123;    @Autowired    UserConsumerApi userConsumerApi;    @RequestMapping(value = &quot;/alive&quot;, method = RequestMethod.GET)    public String alive() &#123;        return userConsumerApi.alive();    &#125;    @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)    public Person getUserById(@PathVariable Integer id) &#123;        return userConsumerApi.getUserById(id);    &#125;&#125;</code></pre><p>浏览器测试：</p><pre><code># 9001 为 consumer 端口http://localhost:9001/test/user/alivehttp://localhost:9001/test/user/1</code></pre><h3 id="3-4-基本测试"><a href="#3-4-基本测试" class="headerlink" title="3.4 基本测试"></a>3.4 基本测试</h3><pre><code class="java">@FeignClient(name = &quot;hello-service&quot;)public interface UserConsumerApi extends UserApi &#123;    // 这里的映射是给 Feign 看的,用于拼接地址    @GetMapping(&quot;getMap&quot;)    Map&lt;Integer, String&gt; getMap(@RequestParam(&quot;id&quot;) Integer id);    @GetMapping(&quot;/getMap2&quot;)    Map&lt;Integer, String&gt; getMap2(@RequestParam(&quot;id&quot;) Integer id,@RequestParam(&quot;name&quot;) String name);    @GetMapping(&quot;/getMap3&quot;)    Map&lt;Integer, String&gt; getMap3(@RequestParam Map&lt;String, Object&gt; map);    @PostMapping(&quot;/postMap&quot;)    Map&lt;Integer, String&gt; postMap(@RequestBody Map&lt;String, Object&gt; map);&#125;</code></pre><h2 id="4、Fegin-自定义配置"><a href="#4、Fegin-自定义配置" class="headerlink" title="4、Fegin 自定义配置"></a>4、Fegin 自定义配置</h2><p>通过 user-service 增加权限的例子来学习自定义配置。</p><p>服务提供者。上述例子开放service-valuation的权限 后，访问。</p><pre><code class="java">开放权限：&lt;!-- 安全认证 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        // 关闭csrf        http.csrf().disable();        // 表示所有的访问都必须认证，认证处理后才可以正常进行        http.httpBasic().and().authorizeRequests().anyRequest().fullyAuthenticated();        // 所有的rest服务一定要设置为无状态，以提升操作效率和性能        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);    &#125;&#125;spring.security.user.name=rootspring.security.user.password=root </code></pre><p>继续feign原来访问，报错。401。</p><h3 id="4-1-自定义配置类方式"><a href="#4-1-自定义配置类方式" class="headerlink" title="4.1 自定义配置类方式"></a>4.1 自定义配置类方式</h3><pre><code class="java">@Configuration// 扫描时忽略掉，否则配置信息会被所有 @FeignClient 共享@ScanIgnorepublic class FeignAuthConfig &#123;    @Bean    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() &#123;        return new BasicAuthRequestInterceptor(&quot;root&quot;, &quot;root&quot;);    &#125;&#125;@FeignClient(name = &quot;hello-service&quot;, fallbackFactory = UserConsumerApiFallbackFactory.class, configuration = FeignAuthConfig.class)</code></pre><h3 id="4-2-拦截器方式"><a href="#4-2-拦截器方式" class="headerlink" title="4.2 拦截器方式"></a>4.2 拦截器方式</h3><pre><code class="java">/** * @author alvin * @date 2020-10-07 18:10 * 测试拦截器实现 feign 请求时，自动配置 security 信息 */public class FeignAuthInterceptor implements RequestInterceptor &#123;    @Override    public void apply(RequestTemplate template) &#123;        // root root =&gt; Basic cm9vdDpyb290        template.header(&quot;Authorization&quot;, &quot;Basic cm9vdDpyb290&quot;);    &#125;&#125;</code></pre><p>配置拦截器</p><pre><code class="properties">feign.client.config.hello-service.request-interceptors[0]=cn.monkeykong.interceptor.FeignAuthInterceptor</code></pre><h2 id="5、Feign-压缩"><a href="#5、Feign-压缩" class="headerlink" title="5、Feign 压缩"></a>5、Feign 压缩</h2><p>开启压缩可以有效节约网络资源，但是会增加 CPU 压力，建议把最小<strong>压缩的文档大小适度调大一点</strong>，进行 gzip 压缩。</p><pre><code class="properties"># feign 压缩feign.compression.request.enabled=truefeign.compression.request.mime-types=text/xml# 单位是 Bfeign.compression.request.min-request-size=2048# 设置返回值后，接受参数要改一下。feign.compression.response.enabled=true</code></pre><p>源码</p><pre><code class="sh">org.springframework.cloud.openfeign.encoding.FeignContentGzipEncodingInterceptor方法 判断内容是否超过配置的大小private boolean contentLengthExceedThreshold(Collection&lt;String&gt; contentLength) &#123;        try &#123;            if (contentLength == null || contentLength.size() != 1) &#123;                return false;            &#125;            final String strLen = contentLength.iterator().next();            final long length = Long.parseLong(strLen);            return length &gt; getProperties().getMinRequestSize();        &#125;        catch (NumberFormatException ex) &#123;            return false;        &#125;    &#125;在HTTP协议中，有Content-Length的详细解读。Content-Length用于描述HTTP消息实体的传输长度the transfer-length of the message-body。在HTTP协议中，消息实体长度和消息实体的传输长度是有区别，比如说gzip压缩下，消息实体长度是压缩前的长度，消息实体的传输长度是gzip压缩后的长度。</code></pre><p>一般不需要设置压缩，如果系统流量浪费比较多，可以考虑一下。</p><h2 id="6、超时和重试"><a href="#6、超时和重试" class="headerlink" title="6、超时和重试"></a>6、超时和重试</h2><p>Feign 默认支持 Ribbon；Ribbon 的重试机制和 Feign 的重试机制有冲突，所以源码中默认关闭 Feign 的重试机制，使用 Ribbon 的重试机制。</p><pre><code class="properties">#连接超时时间(ms)ribbon.ConnectTimeout=1000#业务逻辑超时时间(ms)ribbon.ReadTimeout=6000#同一台实例最大重试次数,不包括首次调用ribbon.MaxAutoRetries=1#重试负载均衡其他的实例最大重试次数,不包括首次调用ribbon.MaxAutoRetriesNextServer=1#是否所有操作都重试（POST 重试可能引发问题）ribbon.OkToRetryOnAllOperations=false</code></pre><p>使用 ribbon 重试机制，请求失败后，每个6秒会重新尝试。</p><h2 id="7、原理"><a href="#7、原理" class="headerlink" title="7、原理"></a>7、原理</h2><p><img src="../../images/springcloud/3/feign%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><ol><li>主程序入口添加 @EnableFeignClients 注解开启对 Feign Client 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加 @FeignClient 注解。</li><li>当程序启动时，会进行包扫描，扫描所有 @FeignClient 注解的类，并将这些信息注入Spring IoC 容器中。当定义的 Feign 接口中的方法被调用时，通过 JDK 的代理方式，来生成具体的 RequestTemplate。<strong>当生成代理时，Feign 会为每个接口方法创建一个 RequestTemplate 对象</strong>，该对象封装了 HTTP 请求需要的全部信息，如请求参数名、请求方法等信息都在这个过程中确定。</li><li>然后由 RequestTemplate 生成 Request，然后把这个 Request 交给 client 处理，这里指的 Client 可以是 JDK 原生的 URLConnection、Apache 的 Http Client，也可以是 Okhttp。最后 Client 被封装到LoadBalanceClient 类，这个类结合 Ribbon 负载均衡发起服务之间的调用。</li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;RestTemplate 基本使用&lt;/li&gt;
&lt;li&gt;Ribbon 客户端负载均衡&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
</feed>
