<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟空</title>
  
  <subtitle>悟空的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-27T15:18:48.893Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>monkey-kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之 - 从代理模式到 Spring AOP</title>
    <link href="http://yoursite.com/2020-06-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%B0%20AOP.html"/>
    <id>http://yoursite.com/2020-06-27-设计模式/设计模式-从代理模式到 AOP.html</id>
    <published>2020-06-27T14:13:12.000Z</published>
    <updated>2020-06-27T15:18:48.893Z</updated>
    
    <content type="html"><![CDATA[<p>静态代理到动态代理到 AOP。</p><p>模式定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>模式引入：我们有一辆坦克，坦克有 move 行为，现在接到一个需求，我们需要测试 move 方法的性能，并在 move 执行前后记录日志。</p><a id="more"></a><h2 id="1-直接修改坦克源码"><a href="#1-直接修改坦克源码" class="headerlink" title="1. 直接修改坦克源码"></a>1. 直接修改坦克源码</h2><p>这种方式可能是最容易想到也最容易实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">    System.out.println(<span class="string">"Tank moving claclacla..."</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 模拟坦克 move</span></div><div class="line">        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">    System.out.println(end - start);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，我们面临一个问题，tank 的源码可能是第三方代码不允许修改。</p><h2 id="2-使用继承"><a href="#2-使用继承" class="headerlink" title="2. 使用继承"></a>2. 使用继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeTank</span> <span class="keyword">extends</span> <span class="title">Tank</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">super</span>.move();</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用继承的确可以实现这个功能。但是这样我们代码耦合度和 Tank 太高，因为性能测试、日志记录等功能可能不仅仅坦克的 move 需要，很可能其他 Movable 对象也是需要的，比如卡车的 move，如果都使用继承实现，我们系统肯定会类爆炸。</p><h2 id="3-使用静态代理"><a href="#3-使用静态代理" class="headerlink" title="3. 使用静态代理"></a>3. 使用静态代理</h2><p>我们新建一个代理，这个代理和 Tank 实现相同的 Movable 接口，并且持有一个 Movable 成员变量，表示需要代理的对象。这样所有的 Movable 类型的对象都可以传给这个代理来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 代理 Movable 对象</span></div><div class="line">    Movable movable;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Movable movable)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.movable = movable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 代理插入的逻辑</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="comment">// 被代理对象原逻辑</span></div><div class="line">        movable.move();</div><div class="line">        <span class="comment">// 代理插入的逻辑</span></div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(end - start);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们使用时，只需要把需要代理的对象传给代理，就可以像使用原对象一样了。并且由于代理中持有的成员变量是 Movable 类型，所以可以代理所有的 Movable 对象。这就是我们常说的<strong>依赖倒置原则</strong>，即依赖抽象而并不是具体或者说面向接口编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 把 tank 做为代理对象传给 TankTimeProxy 代理</span></div><div class="line">    <span class="comment">// 然后把 TankTimeProxy 作为代理对象传给 TankLogProxy 代理然后执行</span></div><div class="line">    <span class="keyword">new</span> TankLogProxy(<span class="keyword">new</span> TankTimeProxy(<span class="keyword">new</span> Tank())).move();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时程序看上去非常完美了，但是其实我们现在的代理其实只能代理 Movable 类型的对象，而没法代理其他类型对象，如果需要代理其他类型对象就需要使用动态代理了。所谓的动态代理就是我们不再需要手动写代理类了，系统会自动生成代理类，这个代理类我们看不到（可以配置系统参数 <strong>saveGeneratedFiles</strong> 保存文件然后反编译看到）。</p><h2 id="4-使用-JDK-自带的动态代理"><a href="#4-使用-JDK-自带的动态代理" class="headerlink" title="4. 使用 JDK 自带的动态代理"></a>4. 使用 JDK 自带的动态代理</h2><p>jdk  Proxy 类提供了动态代理的功能，但是 jdk 代理是基于接口的，也就是说被代理的对象必须实现某个接口，否则没法代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Tank tank = <span class="keyword">new</span> Tank();</div><div class="line"></div><div class="line">    <span class="comment">// 保存一下动态生成的那个代理类</span></div><div class="line">    <span class="comment">// System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");</span></div><div class="line">    System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 动态生成代理对象</span></div><div class="line">    Movable m = (Movable) Proxy.newProxyInstance(</div><div class="line">        Tank.class.getClassLoader(), <span class="comment">// 代理对象的 classLoader，和被代理对象一致即可</span></div><div class="line">        <span class="keyword">new</span> Class[]&#123;Movable.class&#125;,  <span class="comment">// 代理对象应该实现哪些接口</span></div><div class="line">        <span class="keyword">new</span> LogHandler(tank)); <span class="comment">// 被代理对象那个方法被调用时，我们怎么做处理</span></div><div class="line">    m.move();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    Tank tank;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Tank tank)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.tank = tank;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 生成的代理对象（m）</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理的方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method "</span>  + method.getName() + <span class="string">" start..."</span>);</div><div class="line">        <span class="comment">// 调用被代理对象的方法（tank.move()）</span></div><div class="line">        Object o = method.invoke(tank, args);</div><div class="line">        System.out.println(<span class="string">"method "</span> + method.getName() + <span class="string">" end"</span>);</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-JDK-动态代理实现原理"><a href="#5-JDK-动态代理实现原理" class="headerlink" title="5. JDK 动态代理实现原理"></a>5. JDK 动态代理实现原理</h2><h3 id="5-1-JDK-代理类"><a href="#5-1-JDK-代理类" class="headerlink" title="5.1 JDK 代理类"></a>5.1 JDK 代理类</h3><p>其实用上面代码就大致可以看出，它的实现原理应该静态代理类似，只是这个代理类是运行时动态生成的。我设置了 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code> 属性，保存了这个代理类（<strong>$Proxy0.class</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line"></div><div class="line">    <span class="comment">// 构造函数，就是我们外边传入的 LogHandler 对象</span></div><div class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</div><div class="line">        <span class="comment">// Proxy：this.h = h; </span></div><div class="line">        <span class="keyword">super</span>(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 代理类的 move 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 调用 LogHandler 的 move 方法</span></div><div class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</div><div class="line">            m4 = Class.forName(<span class="string">"com.monkeykong.proxy.v05.Movable"</span>).getMethod(<span class="string">"move"</span>);</div><div class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</div><div class="line">            m3 = Class.forName(<span class="string">"com.monkeykong.proxy.v05.Movable"</span>).getMethod(<span class="string">"go"</span>);</div><div class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-2-ASM"><a href="#5-2-ASM" class="headerlink" title="5.2 ASM"></a>5.2 ASM</h3><p>还有一个问题，我们发现 <code>$Proxy0</code> 这个类没有源文件就直接生成了对象给我们使用，这是怎么实现的呢？这是通过 ASM 实现的，一个字节码操作和分析框架。 <strong>ASM</strong> is an all purpose Java bytecode manipulation and analysis framework.  ASM 官网： <a href="https://asm.ow2.io/" target="_blank" rel="external">https://asm.ow2.io/</a> </p><p>比如我们使用 ASM api 直接生成一个 Comparable 类例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriteTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</div><div class="line">        cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,</div><div class="line">                <span class="string">"pkg/Comparable"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>,</div><div class="line">                <span class="keyword">null</span>);</div><div class="line">        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">"LESS"</span>, <span class="string">"I"</span>,</div><div class="line">                <span class="keyword">null</span>, -<span class="number">1</span>).visitEnd();</div><div class="line">        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">"EQUAL"</span>, <span class="string">"I"</span>,</div><div class="line">                <span class="keyword">null</span>, <span class="number">0</span>).visitEnd();</div><div class="line">        cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">"GREATER"</span>, <span class="string">"I"</span>,</div><div class="line">                <span class="keyword">null</span>, <span class="number">1</span>).visitEnd();</div><div class="line">        cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class="string">"compareTo"</span>,</div><div class="line">                <span class="string">"(Ljava/lang/Object;)I"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>).visitEnd();</div><div class="line">        cw.visitEnd();</div><div class="line">        <span class="keyword">byte</span>[] b = cw.toByteArray();</div><div class="line"></div><div class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</div><div class="line">        Class c = myClassLoader.defineClass(<span class="string">"pkg.Comparable"</span>, b);</div><div class="line">        <span class="comment">// 输出 compareTo，可以看出 pkg.Comparable 这个类已经存在于 JVM 中。</span></div><div class="line">        System.out.println(c.getMethods()[<span class="number">0</span>].getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-3-整体时序图"><a href="#5-3-整体时序图" class="headerlink" title="5.3 整体时序图"></a>5.3 整体时序图</h3><p><img src="../../images/dp/jdk动态代理原理.png" alt=""></p><h2 id="6-使用-cglib-的动态代理"><a href="#6-使用-cglib-的动态代理" class="headerlink" title="6. 使用 cglib 的动态代理"></a>6. 使用 cglib 的动态代理</h2><p>除了使用 JDK 自带的动态代理功能，cglib 也提供了动态代理的功能，不同的是 cglib 不需要被代理的对象实现什么接口，普通的类也可以被代理。cglib 的底层实现也是 <strong>ASM</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        <span class="comment">// 这里就可以看出，cglib 的代理类会继承被代理类</span></div><div class="line">        enhancer.setSuperclass(Tank.class);</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> TimeMethodInterceptor());</div><div class="line">        Tank tank = (Tank)enhancer.create();</div><div class="line">        tank.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// 所以生成的代理类是 Tank 类的一个子类。所以 final 类不能使用 cglib 实现动态代理</span></div><div class="line">        <span class="comment">// System.out.println(o.getClass().getSuperclass().getName());</span></div><div class="line">        System.out.println(<span class="string">"before"</span>);</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        result = methodProxy.invokeSuper(o, objects);</div><div class="line">        System.out.println(<span class="string">"after"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-Spring-AOP"><a href="#7-Spring-AOP" class="headerlink" title="7. Spring AOP"></a>7. Spring AOP</h2><p>我们都知道 Spring 的核心之一就是 AOP，AOP 就是动态代理的典型应用。下面就写一下基本的例子。</p><h3 id="7-1-schema-based-approach"><a href="#7-1-schema-based-approach" class="headerlink" title="7.1 schema-based approach"></a>7.1 schema-based approach</h3><p>业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Tank moving claclacla..."</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method start..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method end..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 加载 Spring 容器</span></div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"app.xml"</span>);</div><div class="line">        <span class="comment">// 从容器中取出一个 bean</span></div><div class="line">        Tank tank = (Tank) context.getBean(<span class="string">"tank"</span>);</div><div class="line">        tank.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>额，发现什么都没写啊，怎么就动态代理了？别急，Spring 的理念就是让你发现用了就跟没用一样，主要在 Spring 的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tank"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v1.Tank"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeProxy"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v1.TimeProxy"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 切面：插什么。需要插入的内容 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">ref</span>=<span class="string">"timeProxy"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 切点：插到哪里。需要被代理的方法 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"tankPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.monkeykong.proxy.springaop.v1.Tank.move())"</span>/&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 通知：什么时候插 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"tankPointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"tankPointcut"</span> <span class="attr">method</span>=<span class="string">"after"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="7-2-AspectJ-annotation-style"><a href="#7-2-AspectJ-annotation-style" class="headerlink" title="7.2 @AspectJ annotation style"></a>7.2 @AspectJ annotation style</h3><p>使用注解配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span> <span class="comment">// 插入什么</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个方法什么时候插入（before），插入到哪里（move）</span></div><div class="line">    <span class="meta">@Before</span>(<span class="string">"execution(void com.monkeykong.proxy.springaop.v2.Tank.move())"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method start..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@After</span>(<span class="string">"execution(void com.monkeykong.proxy.springaop.v2.Tank.move())"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"method end..."</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 xml 中启用 aop：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tank"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v2.Tank"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeProxy"</span> <span class="attr">class</span>=<span class="string">"com.monkeykong.proxy.springaop.v2.TimeProxy"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 启用 aop --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></div></pre></td></tr></table></figure><h2 id="1-8-代理模式类图"><a href="#1-8-代理模式类图" class="headerlink" title="1.8 代理模式类图"></a>1.8 代理模式类图</h2><p><img src="../../images/dp/代理模式类图.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态代理到动态代理到 AOP。&lt;/p&gt;
&lt;p&gt;模式定义：为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;p&gt;模式引入：我们有一辆坦克，坦克有 move 行为，现在接到一个需求，我们需要测试 move 方法的性能，并在 move 执行前后记录日志。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Proxy" scheme="http://yoursite.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-06-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-factory.html"/>
    <id>http://yoursite.com/2020-06-22-设计模式/设计模式-factory.html</id>
    <published>2020-06-22T14:36:55.850Z</published>
    <updated>2020-06-22T15:49:20.018Z</updated>
    
    <content type="html"><![CDATA[<p>简单工厂</p><p>静态工厂</p><p>工厂方法：方便单一产品的扩展</p><p>抽象工厂：方便产品族的扩展，但是单一产品扩展不方便。</p><p>任何可以产生对象的方法或类，都可以称之为工厂。单例也是一种工厂。</p><p>为什么有了 new 之后，还要工厂？</p><ul><li>灵活控制生产过程</li><li>权限、修饰、日志…</li></ul><p>更好的解决方案？</p><ul><li>Spring ioc</li><li>bean 工厂</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单工厂&lt;/p&gt;
&lt;p&gt;静态工厂&lt;/p&gt;
&lt;p&gt;工厂方法：方便单一产品的扩展&lt;/p&gt;
&lt;p&gt;抽象工厂：方便产品族的扩展，但是单一产品扩展不方便。&lt;/p&gt;
&lt;p&gt;任何可以产生对象的方法或类，都可以称之为工厂。单例也是一种工厂。&lt;/p&gt;
&lt;p&gt;为什么有了 new 之后，还要工厂
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IO学习（七）</title>
    <link href="http://yoursite.com/2020-06-21-IO/IO%E5%AD%A6%E4%B9%A07.html"/>
    <id>http://yoursite.com/2020-06-21-IO/IO学习7.html</id>
    <published>2020-06-21T14:13:12.000Z</published>
    <updated>2020-06-21T15:37:27.779Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。<br><a id="more"></a></p><h2 id="1-混杂模式服务"><a href="#1-混杂模式服务" class="headerlink" title="1. 混杂模式服务"></a>1. 混杂模式服务</h2><p>一个服务监听只有一个线程负责 accept，每个都会被分配 client，进行 R/W。</p><h3 id="1-1-MainThread"><a href="#1-1-MainThread" class="headerlink" title="1.1 MainThread"></a>1.1 MainThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 入口，这里不做关于 IO 和业务的事情</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1. 创建 IO Thread（一个或者多个）</span></div><div class="line">    SelectorThreadGroup stg = <span class="keyword">new</span> SelectorThreadGroup(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 2. 应该把监听的 server 注册到某一个 selector 上</span></div><div class="line">    stg.bind(<span class="number">9999</span>);</div><div class="line">    <span class="comment">// stg.bind(8888);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-SelectorThreadGroup"><a href="#1-2-SelectorThreadGroup" class="headerlink" title="1.2 SelectorThreadGroup"></a>1.2 SelectorThreadGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorThreadGroup</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 线程集合</span></div><div class="line">    SelectorThread[] sts;</div><div class="line">    <span class="comment">// 服务端</span></div><div class="line">    ServerSocketChannel server = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 轮询器</span></div><div class="line">    AtomicInteger xid = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">    <span class="comment">// 线程组构造器</span></div><div class="line">    SelectorThreadGroup (<span class="keyword">int</span> num) &#123;</div><div class="line">        <span class="comment">// num 线程数</span></div><div class="line">        sts = <span class="keyword">new</span> SelectorThread[num];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</div><div class="line">            sts[i] = <span class="keyword">new</span> SelectorThread(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">new</span> Thread(sts[i]).start(); <span class="comment">// 启动线程</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = ServerSocketChannel.open();</div><div class="line">            server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">            <span class="comment">// server 注册到哪个 selector 呢？</span></div><div class="line">            nextSelector(server);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 无论 ServerSocketChannel 还是 SocketChannel 都复用这个方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSelector</span><span class="params">(Channel c)</span> </span>&#123;</div><div class="line">        <span class="comment">// 在 main 线程中，取到堆里的 selectorThread 对象</span></div><div class="line">        SelectorThread st = next();</div><div class="line"></div><div class="line">        <span class="comment">// 1. 通过队列传递数据，消息。让 SelectorThread 自己去注册</span></div><div class="line">        st.lbq.add(c);</div><div class="line">        <span class="comment">// 2. 通过打断阻塞，让对应的线程去自己在打断后完成注册 selector</span></div><div class="line">        st.selector.wakeup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> SelectorThread <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 轮询，可能会倾斜</span></div><div class="line">        <span class="keyword">int</span> index = xid.incrementAndGet() % sts.length;</div><div class="line">        <span class="keyword">return</span> sts[index];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-SelectorThread"><a href="#1-3-SelectorThread" class="headerlink" title="1.3 SelectorThread"></a>1.3 SelectorThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="comment">// 每个线程对应一个 selector，</span></div><div class="line">    <span class="comment">// 多线程情况下，该主机/该程序的并发客户端被分配到多个 selector 上</span></div><div class="line">    <span class="comment">// 注意，每个客户端只绑定到其中一个 selector</span></div><div class="line">    <span class="comment">// 其实不会有交互问题</span></div><div class="line"></div><div class="line">    Selector selector = <span class="keyword">null</span>;</div><div class="line">    LinkedBlockingQueue&lt;Channel&gt; lbq = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">    <span class="comment">// 线程所属组</span></div><div class="line">    SelectorThreadGroup stg;</div><div class="line"></div><div class="line">    <span class="comment">// 构造器</span></div><div class="line">    SelectorThread(SelectorThreadGroup stg) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.stg = stg;</div><div class="line">            selector = Selector.open();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// loop</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 1. 阻塞的 select</span></div><div class="line">                <span class="comment">// System.out.println(Thread.currentThread().getName() + " ==&gt;before select......" + selector.keys().size());</span></div><div class="line">                <span class="keyword">int</span> nums = selector.select();</div><div class="line">                <span class="comment">// System.out.println(Thread.currentThread().getName() + " ==&gt;after select......" + selector.keys().size());</span></div><div class="line"></div><div class="line">                <span class="comment">// 2. 处理 selectkeys</span></div><div class="line">                <span class="keyword">if</span> (nums &gt; <span class="number">0</span>) &#123;</div><div class="line">                    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</div><div class="line">                    <span class="comment">// 线性处理 keys</span></div><div class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                        SelectionKey key = iter.next();</div><div class="line">                        iter.remove();</div><div class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                            <span class="comment">// 复杂，接收客户端的过程（接收之后要注册，多线程情况下，注册到哪里？）</span></div><div class="line">                            <span class="comment">// 轮询注册</span></div><div class="line">                            acceptHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                            readHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">                            <span class="comment">// <span class="doctag">TODO:</span></span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 3. 处理一些 task</span></div><div class="line">                <span class="keyword">if</span> (!lbq.isEmpty()) &#123;</div><div class="line">                    Channel c = lbq.take();</div><div class="line">                    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</div><div class="line">                        ServerSocketChannel server = (ServerSocketChannel) c;</div><div class="line">                        server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" register accept......"</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SocketChannel) &#123;</div><div class="line">                        SocketChannel client = (SocketChannel) c;</div><div class="line">                        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);</div><div class="line">                        client.register(selector, SelectionKey.OP_READ, buffer);</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" register read......"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" ==&gt;readHandler.... "</span>);</div><div class="line">        ByteBuffer buffer = (ByteBuffer)key.attachment();</div><div class="line">        SocketChannel client = (SocketChannel)key.channel();</div><div class="line">        buffer.clear();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> num = client.read(buffer);</div><div class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</div><div class="line">                    buffer.flip(); <span class="comment">// 将读到的内容翻转，然后直接写出</span></div><div class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                        client.write(buffer);</div><div class="line">                    &#125;</div><div class="line">                    buffer.clear();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 客户端断开了(异常情况)</span></div><div class="line">                    System.out.println(<span class="string">"client: "</span> + client.getRemoteAddress() + <span class="string">" closed......"</span>);</div><div class="line">                    key.cancel();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" ==&gt;acceptHandler.... "</span>);</div><div class="line">        ServerSocketChannel server = (ServerSocketChannel)key.channel();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// accept client</span></div><div class="line">            SocketChannel client = server.accept();</div><div class="line">            client.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            <span class="comment">// choose a selector and register</span></div><div class="line">            stg.nextSelector(client);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="../../images/io/7/混杂模型.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。&lt;br&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>IO学习（五）</title>
    <link href="http://yoursite.com/2020-06-16-IO/IO%E5%AD%A6%E4%B9%A05.html"/>
    <id>http://yoursite.com/2020-06-16-IO/IO学习5.html</id>
    <published>2020-06-16T14:13:12.000Z</published>
    <updated>2020-06-15T16:16:26.106Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。<br><a id="more"></a></p><h2 id="1-NIO-优势和问题"><a href="#1-NIO-优势和问题" class="headerlink" title="1. NIO 优势和问题"></a>1. NIO 优势和问题</h2><p>NIO 优势：<br><strong>1.  使用一个或者有限几个线程就可以处理 N 个客户端的请求。</strong></p><p>NIO 问题：</p><p><strong>1. 需要不停的询问（accpet）,是否有新的连接进来</strong><br><strong>2. 需要不停的循环所有客户端,查看（read）是否有客户端发来数据。即使 10K 个客户端中只有一个客户端返回了数据。</strong></p><p> <strong>3. accept、read 都会触发系统调用，所以都存在用户态和内核态之间的切换</strong> </p><h2 id="2-同步、异步、阻塞、非阻塞"><a href="#2-同步、异步、阻塞、非阻塞" class="headerlink" title="2. 同步、异步、阻塞、非阻塞"></a>2. 同步、异步、阻塞、非阻塞</h2><p>处理的同步和异步和 IO 模型的同步和异步是不同的概念。前面说的多线程 BIO 模型，虽然连接上客户端后，是通过新开一个线程来处理，看上去是异步的，但实际上，对于 IO 来说，它还是自己调用 read 方法获取数据，实际上就是同步的。</p><p>针对 IO 模型（不关注从 IO 读写完成之后的事情）</p><ul><li>同步：只要是 app 自己调用内核进行读写就是同步的</li><li><p>异步：内核完成读写，数据放在指定的 buffer，app 就像没有访问 IO 一样，直接从 buffer 读写数据。目前 linux 没有异步 IO 模型，Windows 的 IOCP 是异步的 IO 模型。</p></li><li><p>阻塞：blocking，调用阻塞方法后，必须等待对方返回，否则程序卡在该位置不往下走</p></li><li>非阻塞：nonblocking，调用非阻塞方法后，对方会立即返回</li></ul><p>组合起来就有：</p><ul><li>同步阻塞：app 自己读取，调用了阻塞方法后一直等待有效的返回结果</li><li>同步非阻塞：app 自己读取，调用方法的瞬间，给出是否读到（自己要解决下一次啥时候再去读取，一般都是死循环）</li><li>异步非阻塞：尽量不要取讨论，因为现在我们只讨论 IO 模型下，Linux 目前没有通用内核的异步处理方案。异步一般不存在阻塞。</li></ul><h2 id="3-select-poll-模型"><a href="#3-select-poll-模型" class="headerlink" title="3. select/poll 模型"></a>3. select/poll 模型</h2><h3 id="3-1-select-poll-模型和-nio-的区别"><a href="#3-1-select-poll-模型和-nio-的区别" class="headerlink" title="3.1 select/poll 模型和 nio 的区别"></a>3.1 select/poll 模型和 nio 的区别</h3><p>其实无论 NIO，还是多路复用器 SELECT、POLL，都是要遍历所有的 IO，询问状态。</p><p>只不过，NIO 这个遍历的过程成本在用户态内核态之间的切换。</p><p>多路复用器 SELECT、POLL 这个遍历的过程只触发了一次系统调用，用户态内核态的切换只进行一次。app 把 fds 传递给内核，内核重新根据用户这次调用传过来的 fds 进行遍历，修改状态。</p><p>select 和 poll 几乎一样。唯一区别是 select 中有 FD_SETSIZE(1024) 这个限制，而 poll 中没有这个限制。</p><h3 id="3-2-select-poll-的问题"><a href="#3-2-select-poll-的问题" class="headerlink" title="3.2 select/poll 的问题"></a>3.2 select/poll 的问题</h3><ol><li>每次都要重新，重复传递 fds，内核开辟空间</li><li>每次内核被调用后，针对这次调用会触发一个遍历 fds 的全量复杂度</li></ol><p>个人问题：</p><ol><li>阻塞是指具体哪个系统调用是阻塞就算阻塞模型？比如我 accept 是阻塞的，但是 read 不阻塞；或者 accept 不阻塞，但是我 read 阻塞。</li><li>nio 和 select/poll 在程序上看都有一个死循环不停的调用系统调用，有本质区别吗？</li></ol><h2 id="4-中断"><a href="#4-中断" class="headerlink" title="4. 中断"></a>4. 中断</h2><p>有中断就会有中断号，有中断号就会有 event 事件，有 event 事件就会有回调，在回调中处理业务。</p><p>在 epoll 之前的回调：只是完成了将网卡发来的数据走内核网络协议栈（2 链路层，3 网络层，4 传输控制层）最终关联到 FD 的缓冲区（buffer）中。所以你某一时间如果从 APP 循环内核某一个或者某些 FD 是否可 R/W，就会有状态返回。</p><p>如果内核在回调处理中再加入一些额外的处理，比如当客户端连接进来时，除了把服务端 listen 的 fd 状态修改为 Acceptable，或者当有客户端发送数据时，除了把服务端中对应该客户端的 fd 状态修改为 readable 外，同时在内核中使用一个区域保存这些 fd，并且当这些事件发生时，把这些有状态的 fd 放入另外一个链表中。</p><p><img src="../../images/io/5/中断.png" alt=""></p><h2 id="5-EPOLL"><a href="#5-EPOLL" class="headerlink" title="5. EPOLL"></a>5. EPOLL</h2><ul><li>epoll_create  在内核为 server 创建红黑树空间，用生成的文件描述符描述</li><li>epoll_ctl 向红黑树空间增加、删除、修改文件描述符</li><li>epoll_wait 获取有状态的文件描述符</li></ul><p><img src="../../images/io/5/epollandpoll.png" alt=""></p><h2 id="6-Java-多路复用-API"><a href="#6-Java-多路复用-API" class="headerlink" title="6. Java 多路复用 API"></a>6. Java 多路复用 API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></div><div class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = ServerSocketChannel.open();</div><div class="line">            server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line"></div><div class="line">            <span class="comment">// 如果在 epoll 模型下，open 就是 epoll_create -&gt; fd3</span></div><div class="line">            <span class="comment">// select 可以是 poll、select、epoll 等各种多路复用器，优先选择：epoll  但是可以使用 JVM 参数 -D 修正</span></div><div class="line">            selector = Selector.open();</div><div class="line"></div><div class="line">            <span class="comment">//server 约等于 listen状态的 fd4</span></div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">            register</span></div><div class="line"><span class="comment">            如果：</span></div><div class="line"><span class="comment">            select/poll：jvm里开辟一个数组 fd4 放进去</span></div><div class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd4,EPOLLIN</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        initServer();</div><div class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">//死循环</span></div><div class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</div><div class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</div><div class="line"></div><div class="line">                <span class="comment">//1,调用多路复用器(select,poll  or  epoll  (epoll_wait))</span></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                select()是啥意思：</span></div><div class="line"><span class="comment">                1，select，poll  其实就是调用内核的select（fd4）  poll(fd4)</span></div><div class="line"><span class="comment">                2，epoll：  其实就是调用内核的 epoll_wait()</span></div><div class="line"><span class="comment">                3， 参数可以带时间：如果没有时间或者时间为 0 则阻塞；如果有时间该时间就是一个超时时间</span></div><div class="line"><span class="comment">                4，在阻塞过程中可以调用 selector.wakeup() 来取消阻塞，不过结果可能返回0</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">while</span> (selector.select(<span class="number">500</span>) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></div><div class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</div><div class="line">                    <span class="comment">// 所以不管什么多路复用器，内核只能给我状态，我还是得一个一个的去处理他们的 R/W。同步好辛苦！！！！！！！！</span></div><div class="line">                    <span class="comment">// NIO  自己对着每一个 fd 调用系统调用，浪费资源，那么你看，这里是不是调用了一次 select 方法，知道具体的那些可以R/W了？</span></div><div class="line">                    <span class="comment">// 我前边刻意强调过，socket 有 listen 的等待 accept 和通信的等待 R/W，所以拿到 key 后，要判断它是 acceptable 还是 readable</span></div><div class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                        SelectionKey key = iter.next();</div><div class="line">                        iter.remove(); <span class="comment">// set  不移除会重复循环处理</span></div><div class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                            <span class="comment">// 看代码的时候，这里是重点，如果要去接受一个新的连接</span></div><div class="line">                            <span class="comment">// 语义上，accept 接受连接且返回新连接的 FD 对吧？</span></div><div class="line">                            <span class="comment">// 那新的 FD 怎么办？</span></div><div class="line">                            <span class="comment">// select/poll：因为他们内核没有空间，那么只能在 jvm 中保存和前边的 fd4 那个 listen 的放在一起</span></div><div class="line">                            <span class="comment">// epoll： 我们希望通过 epoll_ctl 把新的客户端 fd 注册到内核空间</span></div><div class="line">                            acceptHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                            <span class="comment">// 假设同时来了十个可读的</span></div><div class="line">                            <span class="comment">// 在当前线程，这个方法可能会阻塞，如果阻塞了十年，其他的IO早就没电了。。。</span></div><div class="line">                            <span class="comment">// 所以，为什么提出了 IO THREADS</span></div><div class="line">                            <span class="comment">// redis  是不是用了epoll，redis 是不是有个 io threads 的概念 ，redis 是不是单线程的</span></div><div class="line">                            <span class="comment">// tomcat 8,9 以后也提出了异步的处理方式，在 IO 和处理上解耦</span></div><div class="line">                            readHandler(key);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</div><div class="line">            SocketChannel client = ssc.accept(); <span class="comment">// 来啦，目的是调用 accept 接受客户端  fd7</span></div><div class="line">            client.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);  <span class="comment">//前边讲过了</span></div><div class="line"></div><div class="line">            <span class="comment">//你看，调用了 register</span></div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd7 放进去</span></div><div class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd7,EPOLLIN</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        SocketChannel client = (SocketChannel) key.channel();</div><div class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</div><div class="line">        buffer.clear();</div><div class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                read = client.read(buffer);</div><div class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</div><div class="line">                    buffer.flip();</div><div class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                        client.write(buffer);</div><div class="line">                    &#125;</div><div class="line">                    buffer.clear();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    client.close();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</div><div class="line">        service.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。&lt;br&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>IO学习（六）</title>
    <link href="http://yoursite.com/2020-06-16-IO/IO%E5%AD%A6%E4%B9%A06.html"/>
    <id>http://yoursite.com/2020-06-16-IO/IO学习6.html</id>
    <published>2020-06-16T14:13:12.000Z</published>
    <updated>2020-06-16T15:43:44.881Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。<br><a id="more"></a></p><h2 id="1-strace-追踪-poll"><a href="#1-strace-追踪-poll" class="headerlink" title="1. strace 追踪 poll"></a>1. strace 追踪 poll</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></div><div class="line">strace -ff -o poll java -Djava.nio.channels.spi.SelectorProvider=sun.nio.ch.PollSelectorProvider SocketltiplexingSingleThreadv1</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 启动客户端</span></div><div class="line">nc localhost 9090</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 分析结果</span></div><div class="line"><span class="meta">#</span><span class="bash"> 1. socket 系统调用，获取到 fd4</span></div><div class="line">2507 socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = 4</div><div class="line">2511 fcntl(4, F_SETFL, O_RDWR|O_NONBLOCK)    = 0</div><div class="line">2532 bind(4, &#123;sa_family=AF_INET6, sin6_port=htons(9090), inet_pton(AF_INET6, "::", &amp;sin6_addr), sin6_flowinfo=0, sin6_scope_id=0&#125;,      28) = 0</div><div class="line">2533 listen(4, 50)                           = 0</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 2. poll/select 询问是否有状态</span></div><div class="line">2675 poll([&#123;fd=5, events=POLLIN&#125;, &#123;fd=4, events=POLLIN&#125;], 2, 500) = 0 (Timeout)</div><div class="line">2680 poll([&#123;fd=5, events=POLLIN&#125;, &#123;fd=4, events=POLLIN&#125;], 2, 500) = 1 ([&#123;fd=4, revents=POLLIN&#125;])</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 3. 客户端连入，得到 fd7</span></div><div class="line">2702 accept(4, &#123;sa_family=AF_INET6, sin6_port=htons(33711), inet_pton(AF_INET6, "::1", &amp;sin6_addr), sin6_flowinfo=0, sin6_scope_id=     0&#125;, [28]) = 7</div><div class="line">2737 fcntl(7, F_SETFL, O_RDWR|O_NONBLOCK)    = 0</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 4. 可以看出 poll 中参数越来越多</span></div><div class="line">2764 poll([&#123;fd=5, events=POLLIN&#125;, &#123;fd=4, events=POLLIN&#125;, &#123;fd=7, events=POLLIN&#125;], 3, 500) = 1 ([&#123;fd=7, revents=POLLIN&#125;])</div></pre></td></tr></table></figure><h2 id="2-strace-追踪-epoll"><a href="#2-strace-追踪-epoll" class="headerlink" title="2. strace 追踪 epoll"></a>2. strace 追踪 epoll</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></div><div class="line">javac SocketMultiplexingSingleThreadv1.java &amp;&amp; strace -ff -o poll java SocketMultiplexingSingleThreadv1</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 启动客户端</span></div><div class="line">nc localhost 9090</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 分析结果</span></div><div class="line"><span class="meta">#</span><span class="bash"> 1. socket 系统调用，获取到 fd4</span></div><div class="line">2654 socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = 4</div><div class="line"><span class="meta">#</span><span class="bash"> 2. fd4 设置为 非阻塞</span></div><div class="line">2658 fcntl(4, F_SETFL, O_RDWR|O_NONBLOCK)    = 0</div><div class="line"><span class="meta">#</span><span class="bash"> 3. fd4 绑定 9090 端口</span></div><div class="line">2679 bind(4, &#123;sa_family=AF_INET6, sin6_port=htons(9090), inet_pton(AF_INET6, "::", &amp;sin6_addr), sin6_flowinfo=0, sin6_scope_id=0&#125;,      28) = 0</div><div class="line"><span class="meta">#</span><span class="bash"> 4. 监听</span></div><div class="line">2680 listen(4, 50)</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 5. 得到 fd7 用于描述 epoll 红黑树内存空间</span></div><div class="line">2737 epoll_create(256)                       = 7</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 6. fd4 fd5 加入红黑树。fd5 是啥？</span></div><div class="line">2747 epoll_ctl(7, EPOLL_CTL_ADD, 5, &#123;EPOLLIN, &#123;u32=5, u64=139895674765317&#125;&#125;) = 0</div><div class="line">2772 epoll_ctl(7, EPOLL_CTL_ADD, 4, &#123;EPOLLIN, &#123;u32=4, u64=139895674765316&#125;&#125;) = 0</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 7. 询问有状态 fd。这里触发了 epoll_ctl 的懒加载</span></div><div class="line">2773 epoll_wait(7, &#123;&#125;, 4096, 500)            = 0</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 8. 监听到客户端连入，得到 fd8</span></div><div class="line">3714 accept(4, &#123;sa_family=AF_INET6, sin6_port=htons(33710), inet_pton(AF_INET6, "::1", &amp;sin6_addr), sin6_flowinfo=0, sin6_scope_id=     0&#125;, [28]) = 8</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 9. fd8 设置为非阻塞</span></div><div class="line">3753 fcntl(8, F_SETFL, O_RDWR|O_NONBLOCK)    = 0</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 10. fd8 加入红黑树空间</span></div><div class="line">3760 epoll_ctl(7, EPOLL_CTL_ADD, 8, &#123;EPOLLIN, &#123;u32=8, u64=139895674765320&#125;&#125;) = 0</div><div class="line">3761 epoll_wait(7, &#123;&#125;, 4096, 500)            = 0</div></pre></td></tr></table></figure><h2 id="3-处理向多线程演进"><a href="#3-处理向多线程演进" class="headerlink" title="3. 处理向多线程演进"></a>3. 处理向多线程演进</h2><p>在一个线程中处理，如果某一个 key 或者说某一个客户端处理的时间比较久，就会比较慢，因为在一个线程中处理就是线性处理的。使用 cancel 来规避事件的重复调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll epoll） nginx  event&#123;&#125;</span></div><div class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = ServerSocketChannel.open();</div><div class="line">            server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll</span></div><div class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        initServer();</div><div class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</div><div class="line"><span class="comment">//                System.out.println(keys.size()+"   size");</span></div><div class="line">                <span class="keyword">while</span> (selector.select(<span class="number">500</span>) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</div><div class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</div><div class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                        SelectionKey key = iter.next();</div><div class="line">                        iter.remove();</div><div class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line"></div><div class="line">                            acceptHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                            key.cancel(); <span class="comment">// 多线程处理方式，必须要取消</span></div><div class="line">                            readHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</div><div class="line">                            <span class="comment">// 写事件，只要 send-queue 有空间，就一定会给你返回可以写的事件</span></div><div class="line">                            <span class="comment">// 需要明确的是：什么时候写，不是依赖 send-queue 是不是有空间，而是：</span></div><div class="line">                            <span class="comment">// 1. 你准备好要写什么了，这是第一步</span></div><div class="line">                            <span class="comment">// 2. 第二步你才关心 send-queue 是否有空间</span></div><div class="line">                            <span class="comment">// 3. 所以，读 read 一开始就要注册，但是 write 是依赖以上关系，什么时候用什么时候注册</span></div><div class="line">                            <span class="comment">// 4. 如果一开始就注册了 write 事件，进入死循环，一直调起，没有意义。</span></div><div class="line">                            key.cancel();</div><div class="line">                            writeHandler(key);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            System.out.println(<span class="string">"write handler..."</span>);</div><div class="line">            SocketChannel client = (SocketChannel) key.channel();</div><div class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</div><div class="line"></div><div class="line">            buffer.flip();</div><div class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                    client.write(buffer);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            buffer.clear();</div><div class="line">            key.cancel();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                client.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</div><div class="line">            SocketChannel client = ssc.accept();</div><div class="line">            client.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</div><div class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            System.out.println(<span class="string">"read handler....."</span>);</div><div class="line">            SocketChannel client = (SocketChannel) key.channel();</div><div class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</div><div class="line">            buffer.clear();</div><div class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    read = client.read(buffer);</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + read);</div><div class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">                        client.register(key.selector(),SelectionKey.OP_WRITE,buffer);</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        client.close();</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SocketMultiplexingSingleThreadv2 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv2();</div><div class="line">        service.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>流程图</p><p><img src="../../images/io/6/多线程处理模型.png" alt=""></p><p>问题：这样子就会频繁触发系统调用，频繁的进行用户态和内核态的切换。频繁的把事件注册进入多路复用器又频繁的取消。</p><p><strong>我们为啥提出这个模型？</strong></p><ol><li><p>考虑资源利用，充分利用 cpu 核数</p></li><li><p>考虑有一个 fd 执行耗时，在一个线性里会阻塞后续FD的处理</p></li></ol><p>当有 N 个 fd 有 R/W 处理的时候：</p><p>将 N 个 FD 分组，每一组一个 selector，将一个 selector 压到一个线程上</p><p>最好的线程数量是：cpu cpu*2</p><p>其实单看一个线程：里面有一个 selector，有一部分 FD，且他们是线性的</p><p>多个线程，他们在自己的 cpu 上执行，代表会有多个 selector 在并行，且线程内是线性的，最终是并行的 fd 被处理</p><p>但是，你得明白，还是一个 selector 中的 fd 要放到不同的线程并行，从而造成 canel 调用嘛？ <strong>不需要了！！！</strong></p><p>上边的逻辑其实就是分治，我的程序如果有 100W 个连接，如果有 4 个线程（selector），每个线程处理 250000</p><p>那么，可不可以拿出一个线程的 selector 就只关注 accpet ，然后把接受的客户端的 FD，分配给其他线程的selector</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。&lt;br&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>IO学习（三）</title>
    <link href="http://yoursite.com/2020-06-14-IO/IO%E5%AD%A6%E4%B9%A03.html"/>
    <id>http://yoursite.com/2020-06-14-IO/IO学习3.html</id>
    <published>2020-06-14T14:13:12.000Z</published>
    <updated>2020-06-21T10:56:32.892Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。前面说的都是文件 IO，这节学习网络 IO。<br><a id="more"></a></p><p>工具： </p><p>lsof -p：查看进程文件描述符相关信息</p><p>netstat -natp：查看网络连接信息</p><p>tcpdump：tcp 抓包工具</p><p>TCP 是面向连接的可靠的传输协议。三次握手连接，双方内核级开辟资源。</p><p>socket 是一个四元组：CIP CPORT + SIP SPORT，唯一标识一个 socket 连接。也是内核级的，即便你不调用 accept，也会有 socket 连接的建立。</p><h2 id="1-启动服务端"><a href="#1-启动服务端" class="headerlink" title="1. 启动服务端"></a>1. 启动服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIOPropertites</span> </span>&#123;</div><div class="line">    <span class="comment">//server socket listen property:</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVE_BUFFER = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> REUSE_ADDR = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACK_LOG = <span class="number">2</span>;</div><div class="line">    <span class="comment">//client socket listen property on server endpoint:</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_KEEPALIVE = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_OOB = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_REC_BUF = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_REUSE_ADDR = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_SEND_BUF = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_LINGER = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_LINGER_N = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_TIMEOUT = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_NO_DELAY = <span class="keyword">false</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    StandardSocketOptions.TCP_NODELAY</span></div><div class="line"><span class="comment">    StandardSocketOptions.SO_KEEPALIVE</span></div><div class="line"><span class="comment">    StandardSocketOptions.SO_LINGER</span></div><div class="line"><span class="comment">    StandardSocketOptions.SO_RCVBUF</span></div><div class="line"><span class="comment">    StandardSocketOptions.SO_SNDBUF</span></div><div class="line"><span class="comment">    StandardSocketOptions.SO_REUSEADDR</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ServerSocket server = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = <span class="keyword">new</span> ServerSocket();</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>), BACK_LOG);</div><div class="line">            server.setReceiveBufferSize(RECEIVE_BUFFER);</div><div class="line">            server.setReuseAddress(REUSE_ADDR);</div><div class="line">            server.setSoTimeout(SO_TIMEOUT);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"server up use 9090!"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    <span class="comment">// 阻塞,如果不往下走,这里只是开启了监听,可以完成三次握手,但是文件描述符还没有建立连接,没法传输数据</span></div><div class="line">System.in.read(); </div><div class="line">Socket client = server.accept();  <span class="comment">//阻塞的，没有 -1  一直卡着不动  accept(4,</span></div><div class="line">System.out.println(<span class="string">"client port: "</span> + client.getPort());</div><div class="line"></div><div class="line">client.setKeepAlive(CLI_KEEPALIVE);</div><div class="line">client.setOOBInline(CLI_OOB);</div><div class="line">client.setReceiveBufferSize(CLI_REC_BUF);</div><div class="line">client.setReuseAddress(CLI_REUSE_ADDR);</div><div class="line">client.setSendBufferSize(CLI_SEND_BUF);</div><div class="line">client.setSoLinger(CLI_LINGER, CLI_LINGER_N);</div><div class="line">client.setSoTimeout(CLI_TIMEOUT);</div><div class="line">client.setTcpNoDelay(CLI_NO_DELAY);</div><div class="line"></div><div class="line"><span class="comment">//client.read   //阻塞   没有  -1 0</span></div><div class="line"><span class="keyword">new</span> Thread(</div><div class="line">() -&gt; &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">InputStream in = client.getInputStream();</div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line"><span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"></div><div class="line"><span class="keyword">int</span> num = reader.read(data);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</div><div class="line">System.out.println(<span class="string">"client read some data is :"</span> + num + <span class="string">" val :"</span> + <span class="keyword">new</span> String(data, <span class="number">0</span>, num));</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">System.out.println(<span class="string">"client readed nothing!"</span>);</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">System.out.println(<span class="string">"client readed -1..."</span>);</div><div class="line">System.in.read();</div><div class="line">client.close();</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">).start();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">server.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>启动</li></ul><p><code>javac SocketIOPropertites.java &amp;&amp; java SocketIOPropertites</code></p><ul><li>查看端口，9090 处于监听状态</li></ul><p><code>netstat -natp</code></p><p><img src="../../images/io/3/服务端启动端口监听.png" alt=""></p><ul><li>启动抓包</li></ul><p><code>tcpdump -nn -i eth0 port 9090</code></p><ul><li>查看服务端进程文件描述符信息</li></ul><p><code>lsof -p 3631</code></p><p><img src="../../images/io/3/服务端启动文件描述符.png" alt=""></p><h2 id="2-启动客户端"><a href="#2-启动客户端" class="headerlink" title="2. 启动客户端"></a>2. 启动客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Socket client = <span class="keyword">new</span> Socket(<span class="string">"192.168.150.11"</span>,<span class="number">9090</span>);</div><div class="line"></div><div class="line">            client.setSendBufferSize(<span class="number">20</span>);</div><div class="line">            client.setTcpNoDelay(<span class="keyword">true</span>);</div><div class="line">            OutputStream out = client.getOutputStream();</div><div class="line"></div><div class="line">            InputStream in = System.in;</div><div class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                String line = reader.readLine();</div><div class="line">                <span class="keyword">if</span>(line != <span class="keyword">null</span> )&#123;</div><div class="line">                    <span class="keyword">byte</span>[] bb = line.getBytes();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bb) &#123;</div><div class="line">                        out.write(b);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>服务端抓包工具监控到成功完成三次握手</li></ul><p><img src="../../images/io/3/客户端连接服务端三次握手成功.png" alt=""></p><ul><li>tcp 连接已经建立，但是没有分配进程</li></ul><p><img src="../../images/io/3/socket连接已经建立但没有分配进程.png" alt=""></p><ul><li>服务端进程文件描述符信息</li></ul><p>没有变化，说明还没有创建文件描述符。Java 中 socket 就是文件描述符的抽象。</p><h2 id="3-客户端发送数据"><a href="#3-客户端发送数据" class="headerlink" title="3. 客户端发送数据"></a>3. 客户端发送数据</h2><ul><li>抓包工具监控到数据正常传输</li></ul><p><img src="../../images/io/3/客户端发送数据.png" alt=""></p><ul><li>连接信息和服务端进程文件描述符信息均不变</li></ul><h2 id="4-服务端开始接收请求"><a href="#4-服务端开始接收请求" class="headerlink" title="4. 服务端开始接收请求"></a>4. 服务端开始接收请求</h2><ul><li>服务端成功接收到客户端发送的数据</li></ul><p><img src="../../images/io/3/服务端接收连接.png" alt=""></p><ul><li>抓包工具没有变化</li></ul><p>说明数据传输只传输一次。服务端直接从 socket 连接的内核内存中取数据。</p><ul><li>tcp 连接已经被分配给指定进程</li></ul><p><img src="../../images/io/3/连接被分配给指定进程.png" alt=""></p><ul><li>服务端进程创建了文件描述符（socket）</li></ul><p><img src="../../images/io/3/服务端进程创建了文件描述符.png" alt=""></p><p><img src="../../images/io/3/tcp总体示意图.png" alt=""></p><p>一个客户端和一个服务端可以有超过 655535 个连接吗？</p><p>答案：可以的。一台主机可以配置多个 IP：<code>ifconfig eth0:11 192.168.238.66/24</code> 总之只要<strong>四元组</strong>不同就可以建立连接。</p><h2 id="5-BACK-LOG"><a href="#5-BACK-LOG" class="headerlink" title="5. BACK_LOG"></a>5. BACK_LOG</h2><p><code>server.bind(new InetSocketAddress(9090), BACK_LOG);</code></p><p>从上面例子可以看出，连接的使用和连接建立与否没有必然关系。那么内核会不会一直赞连接？赞多少连接？</p><p>答案：BACK_LOG 配置最多可以有多少个没有分配进程的连接。</p><p>比如配置 BACK_LOG 为 2，最多有三个未接收的连接，第四个客户端连接时连接不上。</p><p><img src="../../images/io/3/back-log.png" alt=""></p><h2 id="6-窗口和拥塞"><a href="#6-窗口和拥塞" class="headerlink" title="6. 窗口和拥塞"></a>6. 窗口和拥塞</h2><p>三次握手时，会商量窗口信息。如果一个数据包一个数据包的发送，那么就没有窗口的概念。</p><p>数据包多大？MTU 指定数据包大小，和网卡相关联，ifconfig 可以查看。</p><p><img src="../../images/io/3/数据包大小MTU.png" alt=""></p><p><img src="../../images/io/3/窗口.png" alt=""></p><p>MSS：数据包<strong>数据内容</strong>大小（1500-20报文头-20端口号 = 1460） 。如果传输的数据比较大，肯定会拆分为多个 MTU 进行传输。可以发送一个确认一个，这样比较慢，所以在三次握手时，可以协商一个窗口大小，这样就可以一次发送多个数据包，两边的窗口可能都不一样，但在发送数据时都会告诉对方剩余的窗口大小，这样对象就可以根据剩余窗口大小不停发包，减少了很多阻塞等待和确认包的过程，这就是所谓的窗口机制，它解决了拥塞。</p><p>什么是拥塞？</p><p>答案：拥塞就是如果对方窗口被填满了，那么回复的数据包中会告诉对方没有余量了，这时候客户端就会阻塞自己，不发数据包了。等到服务端处理掉一些包后，再补一个包告诉客户端有窗口余量了，这个时候客户端再发数据包，这就是所谓的拥塞控制，就是既要提高性能，又要保证不要把对方法爆了。</p><p>如果服务端还没有接收连接，客户端就不停的发送数据，这时内核中接收队列是有限的，如果队列满了，后边的数据直接被内核丢弃。其实没有丢弃，好像是客户端拥塞了。</p><p><img src="../../images/io/3/拥塞.png" alt=""></p><p><img src="../../images/io/3/拥塞2.png" alt=""></p><h2 id="7-客户端配置"><a href="#7-客户端配置" class="headerlink" title="7. 客户端配置"></a>7. 客户端配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置客户端缓冲器大小为 20 字节</span></div><div class="line">client.setSendBufferSize(<span class="number">20</span>);</div><div class="line"><span class="comment">// 设置开启优化,默认就是 false,即开启优化</span></div><div class="line">client.setTcpNoDelay(<span class="keyword">false</span>);</div><div class="line"><span class="comment">// 设置是否第一个字节直接发送(着急发送，如果第一个字节对方没有反应，后边的就不用发了)</span></div><div class="line">client.setOOBInline(<span class="keyword">false</span>);</div></pre></td></tr></table></figure><p>由于开启了优化，虽然定义的缓冲器大小为 20 字节，但是当发送 23 个字节时，先发送一个字节，后边 22 个字节直接一次发送了，并没有拆分。</p><p><img src="../../images/io/3/TCPNoDelay.png" alt=""></p><p>所以一个包大下是可能大于缓冲区的。</p><p>关闭优化：</p><p><img src="../../images/io/3/关闭优化.png" alt=""></p><h2 id="8-服务端配置"><a href="#8-服务端配置" class="headerlink" title="8. 服务端配置"></a>8. 服务端配置</h2><p>TCP 如果双方建立了连接，很久都没有交换数据，不能确定对方是否还是活跃的。keepalive 开启后会开启心跳，如果没有收到心跳，可以把连接剔除。</p><p><code>client.setKeepAlive(CLI_KEEPALIVE);</code></p><h2 id="9-系统调用帮助文档"><a href="#9-系统调用帮助文档" class="headerlink" title="9. 系统调用帮助文档"></a>9. 系统调用帮助文档</h2><p>使用 strace 追踪 java 程序和内核之间的系统调用。</p><p>Linux 帮助文档：</p><ul><li>安装帮助文档：<code>yum install man-pages</code></li><li><code>man 2 socket</code>、<code>man 2 bind</code>、<code>man 2 listen</code></li></ul><p>任何 IO 模型都会有如下三个步骤：</p><ul><li><p>socket=fd3</p></li><li><p>bind(fd3,8090)</p></li><li><p>listen(fd3)</p></li></ul><p>以上三个调用完成后，netstat -natp 才能看到 <code>0.0.0.0:8090 0.0.0.0:* LISTEN</code></p><p>BIO：</p><p>accept(fd3, –&gt;得到 fd5 // 阻塞</p><p>recv(fd5, –&gt; // 又有一个阻塞 （通过多线程处理，clone）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。前面说的都是文件 IO，这节学习网络 IO。&lt;br&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-06-13-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20200613.html"/>
    <id>http://yoursite.com/2020-06-13-算法与数据结构/20200613.html</id>
    <published>2020-06-13T06:15:08.694Z</published>
    <updated>2020-06-13T06:27:54.189Z</updated>
    
    <content type="html"><![CDATA[<p>有序表</p><p>AVL、SB 树、红黑树，都是平衡搜索二叉树，O(logN)</p><p>AVL：任意一个节点，|左高 - 右高| &lt; 2</p><p>SB：任何树节点的节点数不少于它的任何一个侄子节点。</p><p>红黑：</p><ul><li>每个节点不是红就是黑</li><li>头节点是黑，叶节点黑</li><li>红节点的子必须是黑。（红节点不相邻）</li></ul><p>底层只会使用到左旋和右旋的基本动作，具体怎么组合，各种树的细节不一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有序表&lt;/p&gt;
&lt;p&gt;AVL、SB 树、红黑树，都是平衡搜索二叉树，O(logN)&lt;/p&gt;
&lt;p&gt;AVL：任意一个节点，|左高 - 右高| &amp;lt; 2&lt;/p&gt;
&lt;p&gt;SB：任何树节点的节点数不少于它的任何一个侄子节点。&lt;/p&gt;
&lt;p&gt;红黑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Https 实战</title>
    <link href="http://yoursite.com/2020-06-12-Spring%20Cloud/Https%E4%B9%8B%E5%AE%9E%E6%88%98.html"/>
    <id>http://yoursite.com/2020-06-12-Spring Cloud/Https之实战.html</id>
    <published>2020-06-12T14:13:12.000Z</published>
    <updated>2020-06-14T06:06:18.992Z</updated>
    
    <content type="html"><![CDATA[<ul><li>自建 CA 签名，配置 https</li><li>免费浏览器认可的 CA 签名，配置 https</li><li>SS 搭建</li></ul><a id="more"></a><h2 id="1-OPenSSL-证书生成、自建-CA"><a href="#1-OPenSSL-证书生成、自建-CA" class="headerlink" title="1. OPenSSL 证书生成、自建 CA"></a>1. OPenSSL 证书生成、自建 CA</h2><h3 id="1-1-OPenSSL-证书生成"><a href="#1-1-OPenSSL-证书生成" class="headerlink" title="1.1 OPenSSL 证书生成"></a>1.1 OPenSSL 证书生成</h3><ul><li>生成私钥<ul><li><code>.\openssl.exe genrsa -des3 -out d:/dev/server.key</code></li></ul></li><li>由私钥创建待签名证书<ul><li><code>.\openssl.exe req -new -key D:\dev\server.key -out D:\dev\server.csr</code></li></ul></li><li>查看证书中内容<ul><li><code>.\openssl.exe req -text -in D:\dev\server.csr</code></li></ul></li></ul><h3 id="1-2-自建-CA"><a href="#1-2-自建-CA" class="headerlink" title="1.2 自建 CA"></a>1.2 自建 CA</h3><ul><li>创建 CA 私钥<ul><li><code>.\openssl.exe genrsa -out D:\dev\myca.key 2048</code></li></ul></li><li>生成 CA 证书<ul><li><code>.\openssl.exe req -new -key D:\dev\myca.key -out D:\dev\myca.csr</code></li></ul></li><li>生成 CA 根证书<ul><li><code>.\openssl.exe x509 -req -in D:\dev\myca.csr -extensions v3_ca -signkey D:\dev\myca.key -out D:\dev\mycat.crt</code></li></ul></li><li>对服务器证书签名<ul><li><code>.\openssl.exe x509 -days 365 -req -in D:\dev\server.csr -extensions v3_req -CAkey D:\dev\myca.key -CA D:\dev\mycat.crt -CAcreateserial -out D:\dev\server.crt</code></li></ul></li><li>查看系统预置的证书<ul><li><code>certmgr.msc</code></li></ul></li></ul><h3 id="1-3-xca-图形化工具生成证书"><a href="#1-3-xca-图形化工具生成证书" class="headerlink" title="1.3 xca 图形化工具生成证书"></a>1.3 xca 图形化工具生成证书</h3><p>生成证书的图形工具。</p><h2 id="2-nginx-配置自签名-https"><a href="#2-nginx-配置自签名-https" class="headerlink" title="2. nginx 配置自签名 https"></a>2. nginx 配置自签名 https</h2><ul><li><p>把服务器私钥（server.key）和自签名证书(server.crt)上传到服务器</p></li><li><p>修改 nginx 配置</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta"> #</span><span class="bash"> HTTPS server</span></div><div class="line">server &#123;</div><div class="line">    listen       443 ssl;</div><div class="line">    server_name  monkeykong.com;</div><div class="line">    # 配置证书</div><div class="line">    ssl_certificate     /data/server.crt; # cert.pem;</div><div class="line">    # 配置私钥</div><div class="line">    ssl_certificate_key /data/server.key; # cert.key;</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">    ssl_session_cache    shared:SSL:1m;</span></div><div class="line"><span class="meta">#</span><span class="bash">    ssl_session_timeout  5m;</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">    ssl_ciphers  HIGH:!aNULL:!MD5;</span></div><div class="line"><span class="meta">#</span><span class="bash">    ssl_prefer_server_ciphers  on;</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">    location / &#123;</span></div><div class="line"><span class="meta">#</span><span class="bash">        root   html;</span></div><div class="line"><span class="meta">#</span><span class="bash">        index  index.html index.htm;</span></div><div class="line"><span class="meta">#</span><span class="bash">    &#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>重启 nginx。<code>service nginx restart</code></p><ul><li>这时需要输入私钥密码验证</li><li><code>lsof -i:443</code>：验证 443 端口是否处于监听状态</li></ul></li><li><p>使用 https 访问网站：<a href="https://192.168.238.66/" target="_blank" rel="external">https://192.168.238.66/</a>。提示无法访问网站。原因是没有开放 443 端口。</p><ul><li><code>vi /etc/sysconfig/iptables</code></li><li><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT</code></li><li><code>service iptables restart</code></li></ul></li><li><p>开放端口后，可以访问了，但是提示不是私密连接，如下图。原因是服务器的待签名证书是用我们自己的 CA 来签名的，浏览器不认可你这个 CA，所以提示不安全。必须要点击高级中的继续访问。</p></li></ul><p><img src="../../images/springcloud/session/自签名证书.png" alt=""></p><ul><li>怎么去掉这个中间页呢？很简单，把我们自己的 CA 根证书安装到本机就可以了。</li></ul><p><img src="../../images/springcloud/session/安装CA根证书.png" alt=""></p><ul><li>重启浏览器，再次访问<code>&lt;https://192.168.238.66/&gt;</code>，不再提示不安全，因为自己的 CA 根证书已经被本机信任。但是这个访问还是不安全的，因为这个证书只是你自己信任了，但是浏览器并没有信任该证书，浏览器只信任公认的大的 CA 机构的证书。</li></ul><p><img src="../../images/springcloud/session/自签名证书安装成功.png" alt=""></p><h2 id="3-真实域名解析到-VPS-并配置-https-访问"><a href="#3-真实域名解析到-VPS-并配置-https-访问" class="headerlink" title="3. 真实域名解析到 VPS 并配置 https 访问"></a>3. 真实域名解析到 VPS 并配置 https 访问</h2><h3 id="3-1-购买线上服务器（VPS）"><a href="#3-1-购买线上服务器（VPS）" class="headerlink" title="3.1 购买线上服务器（VPS）"></a>3.1 购买线上服务器（VPS）</h3><p>购买 VPS：</p><ul><li><p><a href="https://www.gigsgigscloud.com/" target="_blank" rel="external">https://www.gigsgigscloud.com/</a></p></li><li><p><a href="https://my.vultr.com/" target="_blank" rel="external">https://my.vultr.com/</a></p></li></ul><p>CN2 GIA 和普通 CN2 区别？</p><h3 id="3-2-线上服务器域名解析"><a href="#3-2-线上服务器域名解析" class="headerlink" title="3.2 线上服务器域名解析"></a>3.2 线上服务器域名解析</h3><ul><li>购买域名</li><li>域名解析，将域名绑定到刚刚买的 VPS 主机</li></ul><p><img src="../../images/springcloud/session/域名解析.png" alt=""></p><ul><li>验证能否正常访问域名：<code>ping jingjing5201314.top</code></li></ul><h3 id="3-3-线上服务器-SSL-免费证书申请以及认证过程"><a href="#3-3-线上服务器-SSL-免费证书申请以及认证过程" class="headerlink" title="3.3 线上服务器 SSL 免费证书申请以及认证过程"></a>3.3 线上服务器 SSL 免费证书申请以及认证过程</h3><ul><li><p>生成 key 和 crt</p></li><li><p>免费签名：<a href="https://freessl.cn" target="_blank" rel="external">https://freessl.cn</a></p></li></ul><h3 id="3-4-安装-nginx-并配置-https"><a href="#3-4-安装-nginx-并配置-https" class="headerlink" title="3.4 安装 nginx 并配置 https"></a>3.4 安装 nginx 并配置 https</h3><h4 id="安装-OpenResty"><a href="#安装-OpenResty" class="headerlink" title="安装 OpenResty:"></a>安装 OpenResty:</h4><ul><li><p>安装：<a href="http://openresty.org/en/installation.html" target="_blank" rel="external">http://openresty.org/en/installation.html</a></p></li><li><p>上传服务器密钥和证书到 /data 目录</p></li><li>配置 https：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       443 ssl;</div><div class="line">    server_name  jingjing5201314.top;</div><div class="line">    ssl_certificate      /data/full_chain.pem;</div><div class="line">    ssl_certificate_key  /data/ukvps.key;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>启动：<code>sbin/nginx</code></li><li>访问域名验证：<code>&lt;https://jingjing5201314.top/&gt;</code></li></ul><p><img src="../../images/springcloud/session/VPS-https.png" alt=""></p><ul><li>关闭：<code>sbin/nginx -s stop</code></li></ul><h3 id="3-5-443-端口和-80-端口的关系"><a href="#3-5-443-端口和-80-端口的关系" class="headerlink" title="3.5 443 端口和 80 端口的关系"></a>3.5 443 端口和 80 端口的关系</h3><p>http 协议默认走 80 端口；ssl 协议默认走 443 端口；</p><p>nginx 配置启动 443 后，既可以通过 http 80 端口直接访问服务器资源也可以通过 https 443 端口访问服务器资源。</p><p>他们是两个不用的进程，没有什么必然联系，即使把 80 端口禁用，还是可以通过 443 端口正常访问资源。</p><p>实际使用过程中，一般都是把 80 的请求通过 302、307 跳转到 443 上进行安全访问。</p><h2 id="4-SS-服务端以及客户端安装"><a href="#4-SS-服务端以及客户端安装" class="headerlink" title="4. SS 服务端以及客户端安装"></a>4. SS 服务端以及客户端安装</h2><h3 id="4-1-安装谷歌-BBR-加速"><a href="#4-1-安装谷歌-BBR-加速" class="headerlink" title="4.1 安装谷歌 BBR 加速"></a>4.1 安装谷歌 BBR 加速</h3><p><code>wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</code></p><p>重启 VPS 后，<code>lsmod | grep bbr</code> 验证 bbr 是否已经启动</p><h3 id="4-2-安装-SS-服务端"><a href="#4-2-安装-SS-服务端" class="headerlink" title="4.2 安装 SS 服务端"></a>4.2 安装 SS 服务端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget — no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</div><div class="line">chmod +x shadowsocks.sh</div><div class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure><p>启动完成后就可以看到连接信息啦。</p><p>查看运行状态：<code>service shadowsocks status</code></p><h3 id="4-3-安装-SS-客户端"><a href="#4-3-安装-SS-客户端" class="headerlink" title="4.3 安装 SS 客户端"></a>4.3 安装 SS 客户端</h3><ul><li><p><strong>安卓：</strong><a href="https://github.com/shadowsocks/shadowsocks-android/releases?utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article" target="_blank" rel="external"><strong>shadowsocks-android</strong> </a></p></li><li><p><strong>Windows：</strong><a href="https://github.com/shadowsocks/shadowsocks-windows/releases?utm_source=textarea.com&amp;utm_medium=textarea.com&amp;utm_campaign=article" target="_blank" rel="external"><strong>shadowsocks-windows</strong></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;自建 CA 签名，配置 https&lt;/li&gt;
&lt;li&gt;免费浏览器认可的 CA 签名，配置 https&lt;/li&gt;
&lt;li&gt;SS 搭建&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>IO学习（二）</title>
    <link href="http://yoursite.com/2020-06-10-IO/IO%E5%AD%A6%E4%B9%A02.html"/>
    <id>http://yoursite.com/2020-06-10-IO/IO学习2.html</id>
    <published>2020-06-10T14:13:12.000Z</published>
    <updated>2020-06-21T09:16:57.415Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。</p><ul><li><p>VFS、FD、pageache</p></li><li><p>文件系统的 IO</p></li><li><p>内存和 IO 的关系</p></li><li><p>网络 IO</p><a id="more"></a></li></ul><h2 id="1-理解-PageCache"><a href="#1-理解-PageCache" class="headerlink" title="1. 理解 PageCache"></a>1. 理解 PageCache</h2><ul><li><p>系统中有虚拟的线性地址（逻辑地址）和物理地址映射，线性地址可能是连续的，但是指向的真实物理地址可能不连续。通过 cpu 的 mmu（内存管理单元）来管理映射。映射的最小单位是 4kb。</p></li><li><p>page 是随用随分配的，每页大小 4kb。比如当某个程序申请 40kb 内存，系统不会一次性分配 40kb。当程序访问某个地址发现没有该地址映射的 page 时，系统会产生<strong>缺页异常</strong>，触发软中断，cpu 就会对该地址进行映射，映射后程序再去访问该地址。</p></li><li>多个程序可以同时访问一个物理文件，这时就体现出 page 的好处了，多个程序可以访问同一个 page，通过文件描述符来记录偏移量，而不用每个程序都把物理文件 load 到内存中。这是一种内存优化机制。</li><li>page 刚分配时是脏页，脏页写入磁盘后，就不是脏页了，这时可以被 LRU、LFU 清理。</li><li>pagecache 的好处是优化 IO 性能，但是异常断电时会有丢失数据的风险。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 查询脏页相关配置</span></div><div class="line">sysctl -a | grep dirty</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 程序向系统写入数据时，基本都是先写内存，再写磁盘。写磁盘有触发时机。</span></div><div class="line"><span class="meta">#</span><span class="bash"> pagecache 大小达到内核可用内存的 10% 时</span></div><div class="line"><span class="meta">#</span><span class="bash"> 内核后台启动一个线程把 pagecache 中数据写入到磁盘，这时程序不会阻塞</span></div><div class="line">vm.dirty_background_ratio = 10</div><div class="line"><span class="meta">#</span><span class="bash"> 程序再往内核写的时候，分配 page 分配到内存的 20% 时，阻塞程序</span></div><div class="line">vm.dirty_ratio = 20:</div><div class="line"><span class="meta">#</span><span class="bash"> 500 * 1/100 秒做一次脏页写回</span></div><div class="line">vm.dirty_writeback_centisecs = 500</div><div class="line"><span class="meta">#</span><span class="bash"> 脏页的生命周期，就是脏页可以存多久</span></div><div class="line">vm.dirty_expire_centisecs = 3000</div><div class="line"></div><div class="line">vm.dirty_background_bytes = 0</div><div class="line">vm.dirty_bytes = 0</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 修改默认配置</span></div><div class="line">vi /etc/sysctl.conf</div><div class="line"><span class="meta">#</span><span class="bash"> 90% 才开始回写脏页</span></div><div class="line">vm.dirty_background_ratio = 90</div><div class="line"><span class="meta">#</span><span class="bash"> 90% 才阻塞程序</span></div><div class="line">vm.dirty_ratio = 90</div><div class="line"><span class="meta">#</span><span class="bash"> 50 秒才写回脏页</span></div><div class="line">vm.dirty_writeback_centisecs = 5000</div><div class="line"><span class="meta">#</span><span class="bash"> 脏页可以存在 300 秒</span></div><div class="line">vm.dirty_expire_centisecs = 30000</div></pre></td></tr></table></figure><p><img src="../../images/io/pagecache1.png" alt=""></p><p>由上图可以看出 out.txt 的脏页数达到 27826，脏页数是 100%。这时如果服务器断点，该文件所有数据将丢失。</p><p>画一个图，解释内核 page cache 机制。回写、缺页、脏页、淘汰。</p><p>dma（协处理器）：如果没有 dma，内核向磁盘写回 page 时，cpu 需要先把 page 转移到寄存器，然后由寄存器写回磁盘，转移期间 cpu 被占用，如法处理其他事情；如果有 dma，dma 负责把 page 写回磁盘，dma 处理期间，cpu 可以继续工作。</p><p>程序（进程）有缓存 buffer，内核有 page cache 缓存，磁盘也有缓存，都有可能丢数据。</p><p>strace 追踪程序对内核的系统调用，一行就是一次系统调用，也是一次用户态到内核态的切换。</p><h2 id="2-MMAP"><a href="#2-MMAP" class="headerlink" title="2. MMAP"></a>2. MMAP</h2><p>FileChannel.map() 可以得到 MappedByteBuffer。</p><p>map.force()</p><p>mmap 是一个<strong>堆外</strong>的和文件映射的 ByteBuffer。</p><p>在使用 MappedByteBuffer 之前，必须使用 out.write() 这样的系统调用，才能让程序的数据进入内核的 pagecache，也就是说曾经必须有用户态和内核态的切换。但是 MappedByteBuffer.put() 也会把程序数据通过<strong>映射</strong>写入内核的 pagecache，但是没有调用系统调用。</p><p>mmap 的内存映射，依然受内核的 pagecache 体系所约束的。换言之，同时有丢数据的风险。目前 Java 没有能力让你逃离 pagecache，所有的 Java api 都不行。你可以去 github 上找一些 jni 扩展，使用 Linux 内核的 Direct IO（直接 IO），Direct IO 是忽略 Linux 的 pagecache 的，是把 pagecache 交给了程序自己开辟一个字节数组作为 pagecache，动用代码逻辑来会维护一致性/dirty 等等一系列复杂问题。自己实现还是同样可能丢失数据，但是可以自己更加细粒度的控制各个参数，因为 Linux 系统的配置参数是全局的，一改全改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSFileIO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] data = <span class="string">"123456789\n"</span>.getBytes();</div><div class="line">    <span class="keyword">static</span> String path =  <span class="string">"/root/testfileio/out.txt"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">switch</span> ( args[<span class="number">0</span>]) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"0"</span> :</div><div class="line">                testBasicFileIO();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"1"</span>:</div><div class="line">                testBufferedFileIO();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"2"</span> :</div><div class="line">                testRandomAccessFileWrite();</div><div class="line">            <span class="keyword">case</span> <span class="string">"3"</span>:</div><div class="line"><span class="comment">//                whatByteBuffer();</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 最基本的file写(无 buffer)</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testBasicFileIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        File file = <span class="keyword">new</span> File(path);</div><div class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            Thread.sleep(<span class="number">10</span>);</div><div class="line">            out.write(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试buffer文件IO</span></div><div class="line">    <span class="comment">// 1. 有缓存，默认 8kb 大小，可以通过构造函数自定义缓冲区大小</span></div><div class="line">    <span class="comment">// 2. 有 flush 方法，调用 OutputStream 的 write 方法，把缓冲区数据写入内核</span></div><div class="line">    <span class="comment">// 3. write 方法是将数据写入缓冲区，缓冲区满了时才将数据写入内核</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBufferedFileIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        File file = <span class="keyword">new</span> File(path);</div><div class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            Thread.sleep(<span class="number">10</span>);</div><div class="line">            out.write(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//测试文件NIO</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRandomAccessFileWrite</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</div><div class="line"></div><div class="line">        RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(path, <span class="string">"rw"</span>);</div><div class="line">        raf.write(<span class="string">"hello mashibing\n"</span>.getBytes());</div><div class="line">        raf.write(<span class="string">"hello seanzhou\n"</span>.getBytes());</div><div class="line">        System.out.println(<span class="string">"write------------"</span>);</div><div class="line">        System.in.read();</div><div class="line"></div><div class="line">        raf.seek(<span class="number">4</span>);</div><div class="line">        raf.write(<span class="string">"ooxx"</span>.getBytes());</div><div class="line">        System.out.println(<span class="string">"seek---------"</span>);</div><div class="line">        System.in.read();</div><div class="line"></div><div class="line">        FileChannel rafchannel = raf.getChannel();</div><div class="line">        <span class="comment">//mmap  堆外  和文件映射的   byte  not  objtect</span></div><div class="line">        MappedByteBuffer map = rafchannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">4096</span>);</div><div class="line">        map.put(<span class="string">"@@@"</span>.getBytes());</div><div class="line">        System.out.println(<span class="string">"map--put--------"</span>);</div><div class="line">        System.in.read();</div><div class="line"></div><div class="line">        <span class="comment">// map.force(); //  flush</span></div><div class="line">        raf.seek(<span class="number">0</span>);</div><div class="line"></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</div><div class="line">        <span class="comment">// ByteBuffer buffer = ByteBuffer.allocateDirect(1024);</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> read = rafchannel.read(buffer);   <span class="comment">//buffer.put()</span></div><div class="line">        System.out.println(buffer);</div><div class="line">        buffer.flip();</div><div class="line">        System.out.println(buffer);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++) &#123;</div><div class="line">            Thread.sleep(<span class="number">200</span>);</div><div class="line">            System.out.print(((<span class="keyword">char</span>)buffer.get(i)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">whatByteBuffer</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// ByteBuffer buffer = ByteBuffer.allocate(1024);</span></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"postition: "</span> + buffer.position());</div><div class="line">        System.out.println(<span class="string">"limit: "</span> +  buffer.limit());</div><div class="line">        System.out.println(<span class="string">"capacity: "</span> + buffer.capacity());</div><div class="line">        System.out.println(<span class="string">"mark: "</span> + buffer);</div><div class="line"></div><div class="line">        buffer.put(<span class="string">"123"</span>.getBytes());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-------------put:123......"</span>);</div><div class="line">        System.out.println(<span class="string">"mark: "</span> + buffer);</div><div class="line"></div><div class="line">        buffer.flip();   <span class="comment">//读写交替</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-------------flip......"</span>);</div><div class="line">        System.out.println(<span class="string">"mark: "</span> + buffer);</div><div class="line"></div><div class="line">        buffer.get();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-------------get......"</span>);</div><div class="line">        System.out.println(<span class="string">"mark: "</span> + buffer);</div><div class="line"></div><div class="line">        buffer.compact();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-------------compact......"</span>);</div><div class="line">        System.out.println(<span class="string">"mark: "</span> + buffer);</div><div class="line"></div><div class="line">        buffer.clear();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-------------clear......"</span>);</div><div class="line">        System.out.println(<span class="string">"mark: "</span> + buffer);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java OSFileIO 2 运行程序。</p><p><img src="../../images/io/mmap0.png" alt=""></p><p>观察各个阶段变化：</p><p><img src="../../images/io/mmap1.png" alt=""></p><p><img src="../../images/io/mmap2.png" alt=""></p><p><img src="../../images/io/mmap3.png" alt=""></p><h2 id="3-总结图"><a href="#3-总结图" class="headerlink" title="3. 总结图"></a>3. 总结图</h2><p><img src="../../images/io/pagecache_mmap.png" alt=""></p><p>问题：buffer io 为什么快？</p><p>答案：buffer io 每次处理一批字节，普通 io 每次处理提交的字节。buffer 默认大小 8kb，既到达 8kb 的数据后才会调用系统调用，而普通的 io 每次 write 都是调用系统调用。</p><p>  书籍推荐：《深入理解 Linux 内核》、《深入理解计算机系统》</p><p>  epoll 是怎么知道数据到达的？</p><p>  答案：中断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;VFS、FD、pageache&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件系统的 IO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存和 IO 的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络 IO&lt;/p&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>IO学习（一）</title>
    <link href="http://yoursite.com/2020-06-08-IO/IO%E5%AD%A6%E4%B9%A01.html"/>
    <id>http://yoursite.com/2020-06-08-IO/IO学习1.html</id>
    <published>2020-06-08T14:13:12.000Z</published>
    <updated>2020-06-21T07:05:58.657Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习（一）。Linux 基础。</p><ul><li>df、mount、ln</li><li>dd、losetup、mke2fs</li><li>lsof 和文件描述符</li><li>socket</li><li>重定向</li><li>管道（前面的输出作为后面的输入）</li><li>进程的父子关系</li><li>证明管道子进程机制</li></ul><a id="more"></a><h2 id="1-1-df、mount、ln"><a href="#1-1-df、mount、ln" class="headerlink" title="1.1 df、mount、ln"></a>1.1 df、mount、ln</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 查看文件系统（磁盘）用量和各个文件设备的挂载目录</span></div><div class="line">df -h</div><div class="line"><span class="meta">#</span><span class="bash"> 卸载</span></div><div class="line">umount /boot</div><div class="line"><span class="meta">#</span><span class="bash"> 重新挂载</span></div><div class="line">mount /dev/sda1 /boot</div><div class="line"><span class="meta">#</span><span class="bash"> 硬链接(相当于 Java 引用)</span></div><div class="line">ln /root/1.txt /root/2.txt</div><div class="line"><span class="meta">#</span><span class="bash"> 软链接（相当于 Windows 快捷方式）</span></div><div class="line">ln -s /root/1.txt /root/3.txt</div></pre></td></tr></table></figure><ul><li><p>VFS 虚拟文件系统。树结构。</p></li><li><p>df -h 命令，查看文件系统挂载情况和使用情况</p><ul><li>系统先挂载根目录（/），再挂载（/boot）目录，会覆盖目录下的（/boot）。其实当我们数据增大，硬盘不够用，我们可以增加新硬盘挂载到指定目录。</li></ul><p><img src="../../images/io/虚拟文件系统挂载.png" alt=""></p></li></ul><ul><li><p>冯诺伊曼计算机系统：计算器、控制器、主存储器、输入输出设备（I/0）。抽象出<strong>一切皆文件</strong>的概念。有了文件就可以通过输入输出流来和 I/O 设备来交换数据。</p></li><li><p>文件类型：</p><ul><li><p>-：普通文件（可执行、图片、文本）</p></li><li><p>d：目录</p></li><li><p>l：硬链接（ln）</p><ul><li>修改任意一方，另外一方跟随变化。</li><li><p><code>ln /root/linktest.txt /root/linktest2.txt</code>；相当于是两个变量名指向了同一个物理文件，文件只有一份。</p></li><li><p><code>rm -f linktest.txt</code> 另一个文件变量还在。</p></li></ul></li></ul><p><img src="../../images/io/链接.png" alt=""></p><ul><li>l：软链接（ln -s）<ul><li>修改任意一方，另外一方跟随变化。</li><li>相当于 windows 的快捷方式</li><li><code>rm -f linktest.txt</code> 另一个文件标红，说明链接失效</li></ul></li></ul><p><img src="../../images/io/软链接.png" alt=""></p></li></ul><h2 id="1-2-dd、losetup、mke2fs"><a href="#1-2-dd、losetup、mke2fs" class="headerlink" title="1.2 dd、losetup、mke2fs"></a>1.2 dd、losetup、mke2fs</h2><ul><li>b：块设备（硬盘）</li><li>c：字符设备（键盘）</li><li>s：socket</li><li>p：pipeline</li><li>[eventpoll]</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> dd 可以把数据块从一个地方复制到另一个地方</span></div><div class="line"><span class="meta">#</span><span class="bash"> dd: 创建文件；<span class="keyword">if</span>：input file of：output file bs：block size count：bs size</span></div><div class="line"><span class="meta">#</span><span class="bash"> 就是创建了一个 mydisk.img 文件，大小为 1M * 100 = 100M，文件用 0 填充。</span></div><div class="line"><span class="meta">#</span><span class="bash"> 相当于创建了一个软盘</span></div><div class="line">dd if=/dev/zero of=mydisk.img bs=1048576 count=100</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 将 mydisk.img 挂载到 /dev/loop0 设备上</span></div><div class="line">losetup /dev/loop0 mydisk.img</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 格式化为 ext2 文件类型</span></div><div class="line">mke2fs /dev/loop0</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 将 loop0 挂载到虚拟目录上</span></div><div class="line">mount -t ext2 /dev/loop0 /mnt/ooxx/</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 从 df 可以看出，未来人或程序访问操作系统 /mnt/ooxx 目录的时候，这个目录再也不是访问曾经在 sda3 分区创建的 /mnt/ooxx 目录，而是访问 loop0 挂载的虚拟文件里去了。</span></div><div class="line">df -h</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 把 bash 程序拷贝到 /mnt/ooxx/bin</span></div><div class="line">mkdir bin</div><div class="line">cp /bin/bash bin</div></pre></td></tr></table></figure><p><img src="../../images/io/一脸懵逼1.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 分析 bash 的动态链接库有哪些，并把这些库拷贝过来</span></div><div class="line">ldd bash</div><div class="line">mkdir lib64</div><div class="line">cp /lib64/&#123;libtinfo.so.5,libdl.so.2,libc.so.6,ld-linux-x86-64.so.2&#125; ./lib64/</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 根目录切换到当前目录</span></div><div class="line">chroot ./</div><div class="line"><span class="meta">#</span><span class="bash"> 当前程序进程号</span></div><div class="line">echo $$</div><div class="line"><span class="meta">#</span><span class="bash"> 并没有 ls 命令</span></div><div class="line">ls</div><div class="line"><span class="meta">#</span><span class="bash"> 虚拟文件系统根目录下创建 alvin.txt 文件</span></div><div class="line">echo "hello alvin" &gt; /alvin.txt</div><div class="line"><span class="meta">#</span><span class="bash"> 退出当前程序</span></div><div class="line">exit</div><div class="line"><span class="meta">#</span><span class="bash"> / 目录下并没有 alvin.txt</span></div><div class="line">cd /</div><div class="line">ll</div></pre></td></tr></table></figure><p><img src="../../images/io/一脸懵逼2.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 找到文件</span></div><div class="line">cd /mnt/ooxx/</div><div class="line">ll</div><div class="line"><span class="meta">#</span><span class="bash"> 实际上，最终文件 alvin.txt 是存在 mydisk.img 中</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 卸载挂载目录，alvin.txt 文件不见了</span></div><div class="line">umount /mnt/ooxx/</div><div class="line">cd /mnt/ooxx/</div><div class="line">ll</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 实际上文件还在 mydisk.img 中，如果重新挂载还是可以看到</span></div><div class="line">mount -t ext2 /dev/loop0 /mnt/oooo/</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 这个 mydisk.img 和 docker 类似</span></div></pre></td></tr></table></figure><p><img src="../../images/io/一脸懵逼3.png" alt=""></p><h2 id="1-3-lsof-和文件描述符"><a href="#1-3-lsof-和文件描述符" class="headerlink" title="1.3 lsof 和文件描述符"></a>1.3 lsof 和文件描述符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> lsof 可以查看进程打开了哪些文件</span></div><div class="line"><span class="meta">#</span><span class="bash"> 比如当前 bash 进程</span></div><div class="line">lsof -p $$</div></pre></td></tr></table></figure><p><img src="../../images/io/lsof.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建文件描述符 8，用来读取 linktest.txt 的输入</span></div><div class="line">exec 8&lt; linktest.txt</div><div class="line"><span class="meta">#</span><span class="bash"> 查看当前进程描述符信息</span></div><div class="line">cd /proc/$$/fd</div><div class="line">lsof -op $$</div><div class="line"><span class="meta">#</span><span class="bash"> 查看文件状态</span></div><div class="line">stat ~/linktest.txt</div><div class="line"><span class="meta">#</span><span class="bash"> 读取 8 这个文件描述符的内容放入到 a 这个变量</span></div><div class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span> 读取到换行符停止</span></div><div class="line">read a 0&lt;&amp; 8</div><div class="line">echo $a</div><div class="line"><span class="meta">#</span><span class="bash"> 再看文件描述符，发现偏移量已经变化</span></div><div class="line">lsof -op $$</div></pre></td></tr></table></figure><p><img src="../../images/io/文件描述符.png" alt=""></p><p>文件描述符就是描述了打开的文件的信息，比如名称、偏移、NODE 号。</p><p>系统多个进程可以同时打开一个文件，用不同的文件描述符分别记录各个进程对该文件的信息。如下例子，重新打开一个 bash，同样创建 linktest.txt 文件文件描述符，发现偏移量是 0。</p><p><img src="../../images/io/可以打开同一个文件.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建文件描述符 9，用于写入 write.txt 文件</span></div><div class="line">exec 9&gt; ~/write.txt</div><div class="line">lsof -op $$</div><div class="line"><span class="meta">#</span><span class="bash"> 查看系统脏页</span></div><div class="line">cat /proc/vmstat | grep dirty</div><div class="line">echo "alalalala" &gt;&amp; 9</div><div class="line">cat /proc/vmstat | grep dirty</div><div class="line">cat ~/write.txt</div><div class="line">cat /proc/vmstat | grep dirty</div><div class="line"><span class="meta">#</span><span class="bash"> 查看脏页预值</span></div><div class="line">sysctl -a | grep dirty</div></pre></td></tr></table></figure><p><img src="../../images/io/脏页.png" alt=""></p><h2 id="1-4-socket"><a href="#1-4-socket" class="headerlink" title="1.4 socket"></a>1.4 socket</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建一个输入输出文件描述符 8，指向百度 80 端口</span></div><div class="line">exec 8&lt;&gt; /dev/tcp/www.baidu.com/80</div></pre></td></tr></table></figure><p><img src="../../images/io/socket.png" alt=""></p><h2 id="1-5-重定向"><a href="#1-5-重定向" class="headerlink" title="1.5 重定向"></a>1.5 重定向</h2><ul><li><p>/proc ：开机后，进程的一些变量和属性映射在这里。开机前这个目录是没有东西的。</p></li><li><p>$$：当前 bash 的 pid。$BASHPID 也是</p></li><li><p>/proc/$$/fd：当前进程的文件描述符</p></li><li><p>lsof -op $$：查看文件描述符细节</p></li><li><p>重定向：不是命令而是一种机制。输入（&lt;）、输出（&gt;）</p><ul><li><p>ls 标准输出默认指向屏幕，重定向为指定文件.<code>ls -l 1&gt; ~/ls.txt</code></p></li><li><p>cat 标准输入输出到指定文件。<code>cat 0&lt; ~/ls.txt 1&gt; ~/cat.txt</code></p></li><li>read 标准输入默认为键盘，重定向到指定文件。<code>read a 0&lt; ~/cat.txt</code></li></ul></li></ul><p><img src="../../images/io/输入输出.png" alt=""></p><ul><li><p>文件描述符重定向到文件描述符</p><ul><li>标准输出和错误输出分别指向不同文件<ul><li><code>ls ./ /lalal 1&gt; 1.txt 2&gt; 2.txt</code></li></ul></li><li>指向同一个文件，会覆盖<ul><li><code>ls ./ /lalal 1&gt; 3.txt 2&gt; 3.txt</code></li></ul></li><li>指向另外一个文件描述符<ul><li><code>ls ./ /lalal 1&gt; 5.txt 2&gt;&amp; 1</code></li></ul></li></ul><p><img src="../../images/io/重定向.png" alt=""></p></li></ul><h2 id="1-6-管道（前面的输出作为后面的输入）"><a href="#1-6-管道（前面的输出作为后面的输入）" class="headerlink" title="1.6 管道（前面的输出作为后面的输入）"></a>1.6 管道（前面的输出作为后面的输入）</h2><ul><li>head 读取文件前多少行。<code>head -n</code></li><li>tail 读物文件末尾多少行。<code>tail -n</code></li><li>读取文件第八行？</li></ul><p><img src="../../images/io/headtail.png" alt=""></p><h2 id="1-7-进程的父子关系"><a href="#1-7-进程的父子关系" class="headerlink" title="1.7 进程的父子关系"></a>1.7 进程的父子关系</h2><ul><li>查看进程树。<code>pstree</code></li><li>查看指定 pid 父子进程关系。<code>ps -ef | grep 6996</code></li></ul><p><img src="../../images/io/父子进程.png" alt=""></p><ul><li>子进程无法读取父进程变量</li><li>父进程导出变量为环境变量后，子进程可以读取</li><li>所以我们安装软件时，比如 JDK，都需要再 <code>/etc/profile</code> export 环境变量。</li></ul><p><img src="../../images/io/进程隔离.png" alt=""></p><h2 id="1-8-证明管道子进程机制"><a href="#1-8-证明管道子进程机制" class="headerlink" title="1.8 证明管道子进程机制"></a>1.8 证明管道子进程机制</h2><ul><li>执行指令块：<code>{ echo &quot;123&quot;; echo &quot;456&quot;; }</code></li><li>管道命令会新开两个子进程来处理两边命令</li></ul><p><img src="../../images/io/管道与子进程.png" alt=""></p><ul><li>进一步证明管道子进程机制和 pipe<ul><li>左边输出作为右边 cat 输入：<code>{ echo $BASHPID; read x; } | { cat; echo $BASHPID; read y; }</code></li></ul></li></ul><p><img src="../../images/io/PIPE.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习（一）。Linux 基础。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;df、mount、ln&lt;/li&gt;
&lt;li&gt;dd、losetup、mke2fs&lt;/li&gt;
&lt;li&gt;lsof 和文件描述符&lt;/li&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;重定向&lt;/li&gt;
&lt;li&gt;管道（前面的输出作为后面的输入）&lt;/li&gt;
&lt;li&gt;进程的父子关系&lt;/li&gt;
&lt;li&gt;证明管道子进程机制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Https 之 SSL/TLS 协议</title>
    <link href="http://yoursite.com/2020-06-06-Spring%20Cloud/Https%E4%B9%8BSSLTLS%20%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://yoursite.com/2020-06-06-Spring Cloud/Https之SSLTLS 协议.html</id>
    <published>2020-06-06T14:13:12.000Z</published>
    <updated>2020-06-14T05:56:46.716Z</updated>
    
    <content type="html"><![CDATA[<p>互联网的通信安全，建立在 SSL/TLS 协议之上。TLS 是 SSL 的升级。下面将简单介绍 SSL/TLS 协议基本原理。这里只说设计思想和运行过程，不涉及具体实现细节，如果需要了解具体实现细节，请参阅读<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="external">RFC文档</a>。</p><a id="more"></a><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>明文传播即不使用 SSL/TLS 的 HTTP 通信有三大风险：</p><ul><li><strong>窃听风险</strong>（eavesdropping）:第三方获取通信内容</li><li><strong>篡改风险</strong>（tampering）：第三方可以修改通信内容</li><li><strong>冒充风险</strong>（pretending）：第三方可以冒充他们身份参与通信</li></ul><p>SSL/TLS 协议是为了解决这三大风险而设计的：</p><ul><li>所有信息都是<strong>加密传播</strong>，第三方无法窃听</li><li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现</li><li>配备<strong>身份证书</strong>，防止身份被冒充</li></ul><h2 id="2-基本运行过程"><a href="#2-基本运行过程" class="headerlink" title="2. 基本运行过程"></a>2. 基本运行过程</h2><p>SSL/TLS 协议的基本思路是采用公钥加密算法。客户端用服务器公钥加密数据，服务器用自己的私钥解密。这里有两个问题：</p><ol><li><p><strong>如何保证公钥不被篡改</strong>？</p><p>将公钥放在<strong>数字证书</strong>中，只要证书是可信的，公钥就是可信的</p></li><li><p>公钥加密计算量太大，如何减少耗用时间？</p><p>解决方法：每次对话（session），客户端和服务器端都生成一个“对话密钥”（session key），用它来加密信息。这个“对话密钥”是<strong>对称加密</strong>，服务器公钥只用于加密“对话密钥”本身，这样就提高了加密运算的消耗时间。</p></li></ol><p>因此 SSL/TLS 协议的基本过程是这样的：</p><ol><li>客户端向服务器端索要并验证公钥。</li><li>双方协商生成“对话密钥”</li><li>双方采用“对话密钥”进行加密通信</li></ol><p>上面过程的1、2步又称为“<strong>握手阶段</strong>”（handshake）</p><h2 id="3-握手阶段的详细过程"><a href="#3-握手阶段的详细过程" class="headerlink" title="3. 握手阶段的详细过程"></a>3. 握手阶段的详细过程</h2><p><img src="../../images/springcloud/session/SSL、TLS协议四次握手.png" alt=""></p><h3 id="3-1-客户端发出请求（ClientHello）"><a href="#3-1-客户端发出请求（ClientHello）" class="headerlink" title="3.1 客户端发出请求（ClientHello）"></a>3.1 客户端发出请求（ClientHello）</h3><p>客户端提供的信息：</p><ol><li>支持的协议版本，比如 TLS 1.0 版</li><li>客户端生成的随机数，稍后用于生成“对话密钥”</li><li>支持的加密算法，比如 RSA 公钥加密</li><li>支持的压缩方法</li></ol><p>这里注意客户端发送的信息中不包含服务器的域名。也就是说理论上服务器只能包含一个网站，否则会分不清楚应该向客户端提供哪个网站的数字证书，这就是为什么通常一台服务器只能有一张数字证书发原因。</p><p>2006 年 TLS 协议中加入了一个 <a href="https://tools.ietf.org/html/rfc4366" target="_blank" rel="external">Server Name Indication</a>  扩展，允许客户端向服务器提供它所请求的域名。</p><h3 id="3-2-服务器响应（ServerHello）"><a href="#3-2-服务器响应（ServerHello）" class="headerlink" title="3.2 服务器响应（ServerHello）"></a>3.2 服务器响应（ServerHello）</h3><p>服务器响应信息：</p><ol><li>确认使用的加密通信协议版本，比如 TLS 1.0。如果浏览器与服务器支持的版本不一致，则服务器关闭加密通信。</li><li><p>服务器生成的随机数，稍后用于生成“对话密钥”</p></li><li><p>确认使用的加密方法，比如 RSA 公钥加密</p></li><li>服务器证书</li><li>客户端证书请求（如果服务器需要确认客户端的身份，如金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供 USB 密钥，里边就包含一张客户端证书）</li></ol><h3 id="3-3-客户端回应"><a href="#3-3-客户端回应" class="headerlink" title="3.3 客户端回应"></a>3.3 客户端回应</h3><p>客户收到服务器回应后，首先<strong>验证服务器证书</strong>。如果证书不是可信的 CA 机构颁布或者证书中的域名与实际域名不一致或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会<strong>从证书中取出服务器的公钥</strong>，然后向服务器发送下面三项信息。</p><ol><li>客户端生成的随机数。<strong>该随机数用服务器公钥加密</strong>，防止被窃听。</li><li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器检验。</li><li>客户端证书（如果前一步，服务器要求客户端证书）</li></ol><p>上面第一项的随机数是整个握手阶段出现的第三个随机数，又称“pre-master key”。所以客户端和服务端同时有了三个随机数，接着双方就用实现商定的加密方法，各自生成本次会话所用的同一把“会话密钥”。</p><p>问：为什么一定要用三个随机数来生成“会话密钥”？</p><p>答：pre master 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre master secret 就有可能被猜测出来，那么仅仅用 pre master secret 最为密钥就不和适了，因此必须引入新的随机因素。所以客户端和服务端加上 pre master secret 三个随机数一同生成的密钥就不容易被猜出来了，一个伪随机可能不完全随机，可是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。这里注意，因为第一个和第二个随机数都是明文传输的，如果客户端随机是一个伪随机，那么第三方通过第一个随机数猜出 pre master key 的几率就大大增加，所以用三个随机数混合加密出一个“会话密钥”。</p><h3 id="3-4-服务器的最后回应"><a href="#3-4-服务器的最后回应" class="headerlink" title="3.4 服务器的最后回应"></a>3.4 服务器的最后回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><ol><li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li></ol><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><h2 id="4-为什么需要-SSL-TSL-协议？"><a href="#4-为什么需要-SSL-TSL-协议？" class="headerlink" title="4. 为什么需要 SSL\TSL 协议？"></a>4. 为什么需要 SSL\TSL 协议？</h2><p>下图一步步解释了传输一步步加密的过程，最后衍生出较为安全的版本，也就是现在的 SSL\TSL 协议。</p><p><img src="../../images/springcloud/session/SSL、TLS协议由来.png" alt=""></p><h2 id="5-HTTPS-真的安全吗？"><a href="#5-HTTPS-真的安全吗？" class="headerlink" title="5. HTTPS 真的安全吗？"></a>5. HTTPS 真的安全吗？</h2><p>HTTPS 并不是绝对安全的，主要有以下两方面原因：</p><ol><li>CA 要靠法律约束。</li><li>目前浏览器默认都是 HTTP 协议访问，所以代理服务器拦截到请求后，直接返回钓鱼网站，甚至都没有机会跳转 302 来使用 https 进行安全通信。</li></ol><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="external">阮一峰老师 https 相关博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互联网的通信安全，建立在 SSL/TLS 协议之上。TLS 是 SSL 的升级。下面将简单介绍 SSL/TLS 协议基本原理。这里只说设计思想和运行过程，不涉及具体实现细节，如果需要了解具体实现细节，请参阅读&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC文档&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>IO学习（四）</title>
    <link href="http://yoursite.com/2020-06-06-IO/IO%E5%AD%A6%E4%B9%A04.html"/>
    <id>http://yoursite.com/2020-06-06-IO/IO学习4.html</id>
    <published>2020-06-06T14:13:12.000Z</published>
    <updated>2020-06-21T11:29:33.159Z</updated>
    
    <content type="html"><![CDATA[<p>IO 学习。<br><a id="more"></a></p><h2 id="1-例子演示各个-IO-模型的差异"><a href="#1-例子演示各个-IO-模型的差异" class="headerlink" title="1. 例子演示各个 IO 模型的差异"></a>1. 例子演示各个 IO 模型的差异</h2><h3 id="1-1-网络拓扑分析"><a href="#1-1-网络拓扑分析" class="headerlink" title="1.1 网络拓扑分析"></a>1.1 网络拓扑分析</h3><ul><li>本机物理网络：IP-&gt;192.168.0.5 网关-&gt;192.168.0.1</li><li>VMware 虚拟网络：192.168.238.2</li><li>本机 VMnet8 地址：192.168.238.1</li><li>Linux 主机网络：192.168.238.66</li></ul><p>可以看出，本机有两个 IP，一个真实的物理网络网卡，一个是 VMware 虚拟的网卡。一台主机有多个网卡时，可以随机找一个网卡的 IP 作为发送数据的源 IP。</p><p><img src="../../images/io/本机网络物理.png" alt=""></p><p><img src="../../images/io/VMware虚拟网络.png" alt=""></p><h3 id="1-2-模拟客户端"><a href="#1-2-模拟客户端" class="headerlink" title="1.2 模拟客户端"></a>1.2 模拟客户端</h3><p>模拟一个客户端开启 11 万个连接连接同一个服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C10Kclient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        InetSocketAddress serverAddr = <span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.150.11"</span>, <span class="number">9090</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10000</span>; i &lt; <span class="number">65000</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                SocketChannel client1 = SocketChannel.open();</div><div class="line"></div><div class="line">                SocketChannel client2 = SocketChannel.open();</div><div class="line"></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                linux中你看到的连接就是：</span></div><div class="line"><span class="comment">                client...port: 10508</span></div><div class="line"><span class="comment">                client...port: 10508</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                client1.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.150.1"</span>, i));</div><div class="line">                <span class="comment">//  192.168.150.1：10000   192.168.150.11：9090</span></div><div class="line">                client1.connect(serverAddr);</div><div class="line">                <span class="keyword">boolean</span> c1 = client1.isOpen();</div><div class="line">                clients.add(client1);</div><div class="line"></div><div class="line">                client2.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.110.100"</span>, i));</div><div class="line">                <span class="comment">//  192.168.110.100：10000  192.168.150.11：9090</span></div><div class="line">                client2.connect(serverAddr);</div><div class="line">                <span class="keyword">boolean</span> c2 = client2.isOpen();</div><div class="line">                clients.add(client2);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"clients "</span>+ clients.size());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.in.read();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-模拟-BIO（多线程）服务端"><a href="#1-3-模拟-BIO（多线程）服务端" class="headerlink" title="1.3 模拟 BIO（多线程）服务端"></a>1.3 模拟 BIO（多线程）服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIOPropertites</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//server socket listen property:</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVE_BUFFER = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> REUSE_ADDR = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACK_LOG = <span class="number">2</span>;</div><div class="line">    <span class="comment">//client socket listen property on server endpoint:</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_KEEPALIVE = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_OOB = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_REC_BUF = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_REUSE_ADDR = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_SEND_BUF = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_LINGER = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_LINGER_N = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_TIMEOUT = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_NO_DELAY = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ServerSocket server = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = <span class="keyword">new</span> ServerSocket();</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>), BACK_LOG);</div><div class="line">            server.setReceiveBufferSize(RECEIVE_BUFFER);</div><div class="line">            server.setReuseAddress(REUSE_ADDR);</div><div class="line">            server.setSoTimeout(SO_TIMEOUT);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"server up use 9090!"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Socket client = server.accept();  <span class="comment">//阻塞的，没有 -1  一直卡着不动  accept(4,</span></div><div class="line">                System.out.println(<span class="string">"client port: "</span> + client.getPort());</div><div class="line"></div><div class="line">                client.setKeepAlive(CLI_KEEPALIVE);</div><div class="line">                client.setOOBInline(CLI_OOB);</div><div class="line">                client.setReceiveBufferSize(CLI_REC_BUF);</div><div class="line">                client.setReuseAddress(CLI_REUSE_ADDR);</div><div class="line">                client.setSendBufferSize(CLI_SEND_BUF);</div><div class="line">                client.setSoLinger(CLI_LINGER, CLI_LINGER_N);</div><div class="line">                client.setSoTimeout(CLI_TIMEOUT);</div><div class="line">                client.setTcpNoDelay(CLI_NO_DELAY);</div><div class="line"></div><div class="line">                <span class="comment">//client.read   //阻塞   没有  -1 0</span></div><div class="line">                <span class="keyword">new</span> Thread(</div><div class="line">                        () -&gt; &#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                InputStream in = client.getInputStream();</div><div class="line">                                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line">                                <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"></div><div class="line">                                    <span class="keyword">int</span> num = reader.read(data);</div><div class="line"></div><div class="line">                                    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</div><div class="line">                                        System.out.println(<span class="string">"client read some data is :"</span> + num + <span class="string">" val :"</span> + <span class="keyword">new</span> String(data, <span class="number">0</span>, num));</div><div class="line">                                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">                                        System.out.println(<span class="string">"client readed nothing!"</span>);</div><div class="line">                                        <span class="keyword">continue</span>;</div><div class="line">                                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                        System.out.println(<span class="string">"client readed -1..."</span>);</div><div class="line">                                        System.in.read();</div><div class="line">                                        client.close();</div><div class="line">                                        <span class="keyword">break</span>;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line"></div><div class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                ).start();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                server.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抓包验证连接请求是否进来了：<code>tcpdump -nn -i eth0 port 9090</code></p><p>启动服务：<code>javac SocketIOPropertites.java &amp;&amp; java SocketIOPropertites</code></p><p>本地启动客户端。</p><p>netstat -natp 查看连接。</p><p>结果：</p><ul><li>192.168.238.1 的连接请求打进来了，但是连接没有建立上</li><li>192.168.0.5 连接请求都没有进来</li></ul><p>分析：</p><ul><li><p>linux 防火墙没有关闭。<code>service iptables stop</code></p></li><li><p>查询路由表：route -n。发现 Linux 主机和 92.168.0.5 不在一个网段，所以 192.168.0.5 返回包时，会走默认网关即 192.168.238.2，即以 192.168.238.2 作为源地址发出去， 所以虽然这个包可以返回 windows，但是这个包无人认领，导致丢弃，所以没能握手成功。所以可以手动添加一个路由，让 192.168.0.5 的包返回时直接返回 windows 的路由。</p><ul><li>sudo route add 192.168.0.1/32 dev eth0</li><li>sudo route add -host 192.168.0.5 gw 192.168.238.1</li></ul></li></ul><p><img src="../../images/io/4/问题.png" alt=""></p><p>问题：</p><ul><li>为什么慢？</li></ul><p>慢在 clone 系统调用。</p><h3 id="1-4-模拟-NIO-服务端"><a href="#1-4-模拟-NIO-服务端" class="headerlink" title="1.4 模拟 NIO 服务端"></a>1.4 模拟 NIO 服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIO</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">        ServerSocketChannel ss = ServerSocketChannel.open();</div><div class="line">        ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</div><div class="line">        ss.configureBlocking(<span class="keyword">false</span>); <span class="comment">//重点  OS  NONBLOCKING!!!</span></div><div class="line"></div><div class="line"><span class="comment">//        ss.setOption(StandardSocketOptions.TCP_NODELAY, false);</span></div><div class="line"><span class="comment">//        StandardSocketOptions.TCP_NODELAY</span></div><div class="line"><span class="comment">//        StandardSocketOptions.SO_KEEPALIVE</span></div><div class="line"><span class="comment">//        StandardSocketOptions.SO_LINGER</span></div><div class="line"><span class="comment">//        StandardSocketOptions.SO_RCVBUF</span></div><div class="line"><span class="comment">//        StandardSocketOptions.SO_SNDBUF</span></div><div class="line"><span class="comment">//        StandardSocketOptions.SO_REUSEADDR</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">//接受客户端的连接</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            SocketChannel client = ss.accept(); <span class="comment">//不会阻塞？  -1 NULL</span></div><div class="line">            <span class="comment">//accept  调用内核了：1，没有客户端连接进来，返回值？在BIO 的时候一直卡着，但是在NIO ，不卡着，返回-1，NULL</span></div><div class="line">            <span class="comment">//如果来客户端的连接，accept 返回的是这个客户端的fd  5，client  object</span></div><div class="line">            <span class="comment">//NONBLOCKING 就是代码能往下走了，只不过有不同的情况</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"null....."</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                client.configureBlocking(<span class="keyword">false</span>); <span class="comment">//重点  socket（服务端的listen socket&lt;连接请求三次握手后，往我这里扔，我去通过accept 得到  连接的socket&gt;，连接socket&lt;连接后的数据读写使用的&gt; ）</span></div><div class="line">                <span class="keyword">int</span> port = client.socket().getPort();</div><div class="line">                System.out.println(<span class="string">"client...port: "</span> + port);</div><div class="line">                clients.add(client);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);  <span class="comment">//可以在堆里   堆外</span></div><div class="line"></div><div class="line">            <span class="comment">//遍历已经链接进来的客户端能不能读写数据</span></div><div class="line">            <span class="keyword">for</span> (SocketChannel c : clients) &#123;   <span class="comment">//串行化！！！！  多线程！！</span></div><div class="line">                <span class="keyword">int</span> num = c.read(buffer);  <span class="comment">// &gt;0  -1  0   //不会阻塞</span></div><div class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</div><div class="line">                    buffer.flip();</div><div class="line">                    <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</div><div class="line">                    buffer.get(aaa);</div><div class="line"></div><div class="line">                    String b = <span class="keyword">new</span> String(aaa);</div><div class="line">                    System.out.println(c.socket().getPort() + <span class="string">" : "</span> + b);</div><div class="line">                    buffer.clear();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>javac SocketNIO.java &amp;&amp; strace -ff -o out java SocketNIO</code></p><p><img src="../../images/io/4/NIOaccept不阻塞.png" alt=""></p><p>客户端连接：<code>nc localhost 9090</code></p><p><img src="../../images/io/4/NIO2.png" alt=""></p><p>可以看出，NIO 不再需要抛出线程。一个线程既可以监听其他客户端的连入，也可以接收客户端的数据。</p><p>再用 C10k 进行压测。速度和 BIO 相比速度块一点，但还是有点慢。</p><p>报错：Too many open files。</p><p>查看：ulimit -a </p><p>调大：ulimit -SHn 500000</p><h3 id="1-4-模拟-select-poll-模型"><a href="#1-4-模拟-select-poll-模型" class="headerlink" title="1.4 模拟 select/poll 模型"></a>1.4 模拟 select/poll 模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//马老师的坦克 一 二期</span></div><div class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></div><div class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            server = ServerSocketChannel.open();</div><div class="line">            server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line"></div><div class="line"></div><div class="line">            <span class="comment">//如果在epoll模型下，open--》  epoll_create -&gt; fd3</span></div><div class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll  优先选择：epoll  但是可以 -D修正</span></div><div class="line"></div><div class="line">            <span class="comment">//server 约等于 listen状态的 fd4</span></div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">            register</span></div><div class="line"><span class="comment">            如果：</span></div><div class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd4 放进去</span></div><div class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd4,EPOLLIN</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        initServer();</div><div class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">//死循环</span></div><div class="line"></div><div class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</div><div class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">//1,调用多路复用器(select,poll  or  epoll  (epoll_wait))</span></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                select()是啥意思：</span></div><div class="line"><span class="comment">                1，select，poll  其实  内核的select（fd4）  poll(fd4)</span></div><div class="line"><span class="comment">                2，epoll：  其实 内核的 epoll_wait()</span></div><div class="line"><span class="comment">                *, 参数可以带时间：没有时间，0  ：  阻塞，有时间设置一个超时</span></div><div class="line"><span class="comment">                selector.wakeup()  结果返回0</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">while</span> (selector.select(<span class="number">500</span>) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></div><div class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</div><div class="line">                    <span class="comment">//so，管你啥多路复用器，你呀只能给我状态，我还得一个一个的去处理他们的R/W。同步好辛苦！！！！！！！！</span></div><div class="line">                    <span class="comment">//  NIO  自己对着每一个fd调用系统调用，浪费资源，那么你看，这里是不是调用了一次select方法，知道具体的那些可以R/W了？</span></div><div class="line">                    <span class="comment">//幕兰，是不是很省力？</span></div><div class="line">                    <span class="comment">//我前边可以强调过，socket：  listen   通信 R/W</span></div><div class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">                        SelectionKey key = iter.next();</div><div class="line">                        iter.remove(); <span class="comment">//set  不移除会重复循环处理</span></div><div class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                            <span class="comment">//看代码的时候，这里是重点，如果要去接受一个新的连接</span></div><div class="line">                            <span class="comment">//语义上，accept接受连接且返回新连接的FD对吧？</span></div><div class="line">                            <span class="comment">//那新的FD怎么办？</span></div><div class="line">                            <span class="comment">//select，poll，因为他们内核没有空间，那么在jvm中保存和前边的fd4那个listen的一起</span></div><div class="line">                            <span class="comment">//epoll： 我们希望通过epoll_ctl把新的客户端fd注册到内核空间</span></div><div class="line">                            acceptHandler(key);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                            readHandler(key);</div><div class="line">                            <span class="comment">//在当前线程，这个方法可能会阻塞  ，如果阻塞了十年，其他的IO早就没电了。。。</span></div><div class="line">                            <span class="comment">//所以，为什么提出了 IO THREADS</span></div><div class="line">                            <span class="comment">//redis  是不是用了epoll，redis是不是有个io threads的概念 ，redis是不是单线程的</span></div><div class="line">                            <span class="comment">//tomcat 8,9  异步的处理方式  IO  和   处理上  解耦</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</div><div class="line">            SocketChannel client = ssc.accept(); <span class="comment">//来啦，目的是调用accept接受客户端  fd7</span></div><div class="line">            client.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);  <span class="comment">//前边讲过了</span></div><div class="line"></div><div class="line">            <span class="comment">// 0.0  我类个去</span></div><div class="line">            <span class="comment">//你看，调用了register</span></div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd7 放进去</span></div><div class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd7,EPOLLIN</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</div><div class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</div><div class="line">        SocketChannel client = (SocketChannel) key.channel();</div><div class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</div><div class="line">        buffer.clear();</div><div class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                read = client.read(buffer);</div><div class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</div><div class="line">                    buffer.flip();</div><div class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                        client.write(buffer);</div><div class="line">                    &#125;</div><div class="line">                    buffer.clear();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    client.close();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</div><div class="line">        service.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>========================</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 内核级别最大文件描述符数量</span></div><div class="line">/proc/sys/fs/file-max</div><div class="line"><span class="meta">#</span><span class="bash"> 进程级别？用户级别？</span></div><div class="line">ulimit</div><div class="line">/proc/sys/fs/epoll/max_user_watches</div><div class="line">vi /etc/security/limits.conf</div></pre></td></tr></table></figure><p>参考文章：</p><ul><li><a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">http://www.kegel.com/c10k.html</a></li></ul><p>假设最开始只有两个桶（0，1），当每个桶数量大于 6 时，扩容，这样就保证每个桶只有 6 个数量。</p><p>当桶中的数据大于某个数量时，会经历扩容。</p><p>当有 n 个数时，扩容次数基本时：log2N 。</p><p>所以 O(N) * logN/N，即如果考虑平均扩容开销，复杂度应该是 log(N)</p><p>优化：</p><ol><li>扩容时在用户无感时操作，即离线扩容。</li><li>桶里放入有序表，而不是单链表，这样就可以极大减少扩容次数，因为有序表效率极高。可以用 hash 值排序。</li></ol><p>所以，可以认为 hash 表在使用时复杂度是 O(1)，但是实际理论上不是的。</p><p>布隆过滤器：</p><p>比如爬虫。有 100 亿 url，</p><p>每个爬虫节点爬完一个 url 加入黑名单系统，告诉其他节点不用再爬这个 url 了。</p><p>还有一种就是事先维护一个黑名单系统，访问时查看 url 是否在黑名单中。</p><p>支持极大的黑名单系统，并且节省内存空间。</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>如果需要在一个 key 上做大量的关系查询，则更适合用关系型数据库。</p><p>hashkey：可以做到 0、1、2 三台机器负载均衡，每台机器均匀分布高频、中频、低频。</p><p>比如 key：国家名，中美非常高频。如果有三台，势必导致负载不均衡。所以设计 hashkey 时应该设置更多一点更合理一点。比如身份 ID。</p><p>扩展机器不方便。</p><p>比如 三台 扩展到 六台。迁移的代价是全量的。必须所有数据全部重新取模。</p><p>一致性哈希既可以做到负载均衡又可以做到迁移代价很低。</p><p>=============</p><p>网约车8：</p><p>放入内存还是 redis？</p><p>数据量大放入 redis，数据量小放内存</p><p>// 81B * 10</p><p>先存 redis 还是先发短信</p><p>服务端怎么把司机剔掉怎么做？</p><p>只有长连接才能主动剔除。（极光）</p><p>青云。</p><p>网关鉴权，黑白名单。</p><p>网关后边有很多服务，这些服务一般在同一个局域网内，这些服务之间的调用不需要鉴权。</p><p>怎么保证客户端和服务端时间一致？</p><p>以服务端时间为准，用接口同步时间。运维保证服务端时间。</p><p>app 端和服务端时间不同步问题。</p><p>加个精度问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO 学习。&lt;br&gt;
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>算法基础之 Morris</title>
    <link href="http://yoursite.com/2020-05-31-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E6%9C%9F/Morris%E7%AE%97%E6%B3%95.html"/>
    <id>http://yoursite.com/2020-05-31-算法与数据结构/训练营一期/Morris算法.html</id>
    <published>2020-05-31T14:13:12.000Z</published>
    <updated>2020-05-31T15:05:27.981Z</updated>
    
    <content type="html"><![CDATA[<p>算法基础之 Morris</p><a id="more"></a><h2 id="1-算法规则"><a href="#1-算法规则" class="headerlink" title="1. 算法规则"></a>1. 算法规则</h2><ol><li>cur 无左子树， cur = cur.right（<strong>当前节点右移</strong>）</li><li>cur 有左子树，找到左子树<strong>最右节点</strong>，most right<ol><li>如果 most right 的右指针指向 null。most right.right = cur, cur = cur.left（<strong>最右节点右指针指向当前节点，当前节点左移</strong>）</li><li>如果 most right 的右指针指向当前节点（cur）。most right.right=null,cur=cur.right（<strong>最右节点右指针指向 null，当前节点右移</strong>）</li></ol></li></ol><p>例如有如下二叉树(红色 cur 表示当前节点，绿色 cur 表示下一个 cur 节点)：</p><p><img src="../../../images/算法/Morris_1.png" alt=""></p><p><img src="../../../images/算法/Morris_2.png" alt=""></p><p><img src="../../../images/算法/Morris_3.png" alt=""></p><p><img src="../../../images/算法/Morris_4.png" alt=""></p><p><img src="../../../images/算法/Morris_5.png" alt=""></p><p>所以生成的 Morris 序列为： <strong>1,2,4,2,5,1,3,6,3,7</strong> </p><p>例图2：</p><p><img src="../../../images/算法/Morris.png" alt=""></p><p>可以发现有如下特点：</p><ul><li>有左子树的节点肯定会碰到两次</li><li>当当前节点的左子树最右节点的右指针指向自己时，表示时第二次碰到了</li><li>时间复杂度为 O(N)，因为每个节点最多遍历两次</li></ul><h2 id="2-Morris-算法代码实现"><a href="#2-Morris-算法代码实现" class="headerlink" title="2. Morris 算法代码实现"></a>2. Morris 算法代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Morris</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Node d = <span class="keyword">new</span> Node(<span class="number">1</span>);</div><div class="line">        d.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</div><div class="line">        d.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</div><div class="line">        d.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</div><div class="line">        d.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</div><div class="line">        d.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</div><div class="line">        d.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</div><div class="line">        morris(d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</div><div class="line">        <span class="keyword">public</span> Node left;</div><div class="line">        <span class="keyword">public</span> Node right;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">            value = v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        Node cur = head;</div><div class="line">        Node mostRight = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(cur.value);</div><div class="line">            <span class="comment">// 左子树为空,cur 右移</span></div><div class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</div><div class="line">                cur = cur.right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 查找左子树最右节点</span></div><div class="line">                mostRight = cur.left;</div><div class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</div><div class="line">                    mostRight = mostRight.right;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 最右节点右指针为 null</span></div><div class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</div><div class="line">                    mostRight.right = cur;</div><div class="line">                    cur = cur.left;</div><div class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 最右节点右指针为 cur</span></div><div class="line">                    mostRight.right = <span class="keyword">null</span>;</div><div class="line">                    cur = cur.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-使用-Morris-实现前、中、后序遍历"><a href="#3-使用-Morris-实现前、中、后序遍历" class="headerlink" title="3. 使用 Morris 实现前、中、后序遍历"></a>3. 使用 Morris 实现前、中、后序遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ul><li>访问根节点</li><li>左子树</li><li>右子树</li></ul><p>实现：有左子树的节点，<strong>第二次访问时不打印即可</strong></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul><li>左子树</li><li>根节点</li><li>右子树</li></ul><p>实现：有左子树的节点，<strong>第一次访问时不打印即可</strong></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul><li>左子树</li><li>右子树</li><li>根节点</li></ul><p>实现：有左子树的节点，<strong>第二次访问时，逆序打印左子树的右边界</strong>，最后单独逆序打印<strong>整树的右边界</strong>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最右节点右指针为 null</span></div><div class="line"><span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</div><div class="line">    mostRight.right = cur;</div><div class="line">    cur = cur.left;</div><div class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 最右节点右指针为 cur</span></div><div class="line">    mostRight.right = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 这里注意需要在最右节点右指针设置为 null 后再打印</span></div><div class="line">    printRightBorderRev(cur.left);</div><div class="line">    cur = cur.right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 反转左子树右边界输出后还原</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRightBorderRev</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 反转列表</span></div><div class="line">    Node pre = reverseNode(node);</div><div class="line">    Node preBak = pre;</div><div class="line">    <span class="comment">// 遍历输出</span></div><div class="line">    <span class="keyword">while</span> (pre != <span class="keyword">null</span>) &#123;</div><div class="line">        System.out.print(pre.value + <span class="string">","</span>);</div><div class="line">        pre = pre.right;</div><div class="line">    &#125;</div><div class="line">    node = reverseNode(preBak);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">reverseNode</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    Node pre = <span class="keyword">null</span>;</div><div class="line">    Node cur = node;</div><div class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">        Node tmp = cur.right;</div><div class="line">        cur.right = pre;</div><div class="line">        pre = cur;</div><div class="line">        cur = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pre;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-验证是否为搜索二叉树"><a href="#4-验证是否为搜索二叉树" class="headerlink" title="4. 验证是否为搜索二叉树"></a>4. 验证是否为搜索二叉树</h2><p>线索二叉树：每个节点左节点小于根节点，右节点大于跟节点。</p><p>思路：</p><ul><li>通常的验证流程就是中序遍历，验证每个节点的值比前一个大即可。</li></ul><p>实现：</p><ul><li><strong>中序遍历打印的地方修改为判断即可</strong></li></ul><h2 id="5-二叉树最小高度"><a href="#5-二叉树最小高度" class="headerlink" title="5. 二叉树最小高度"></a>5. 二叉树最小高度</h2><h3 id="5-1-使用-Morris-实现思路"><a href="#5-1-使用-Morris-实现思路" class="headerlink" title="5.1 使用 Morris 实现思路"></a>5.1 使用 Morris 实现思路</h3><ul><li>维护一个变量用于保存最小高度</li><li>记录当前节点的高度<ul><li>cur 无左树，cur 右移动，直接 level++</li><li>cur 有左树<ul><li>第一次访问：cur 左移，也是直接 level++</li><li>第二次访问：cur 右移，level = level - 左子树右边界的高度</li></ul></li></ul></li><li>如果当前节点为叶子节点，尝试更新最小高度<ul><li>cur 有左数，并且第二次访问时，如果前面节点左指针为 null，说明为叶子节点。</li></ul></li><li>最后单独计算整棵树的最右节点是否为叶子节点，如果是则尝试更新最小高度</li></ul><h3 id="5-2-代码"><a href="#5-2-代码" class="headerlink" title="5.2 代码"></a>5.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minHeight</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    Node cur = head;</div><div class="line">    Node mostRight = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> minHeight = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 左子树为空,cur 右移</span></div><div class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</div><div class="line">            cur = cur.right;</div><div class="line">            level++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 查找左子树最右节点</span></div><div class="line">            mostRight = cur.left;</div><div class="line">            <span class="comment">// 左子树有边界</span></div><div class="line">            <span class="keyword">int</span> rightBorder = <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</div><div class="line">                mostRight = mostRight.right;</div><div class="line">                rightBorder++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 最右节点右指针为 null</span></div><div class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</div><div class="line">                mostRight.right = cur;</div><div class="line">                level++;</div><div class="line">                cur = cur.left;</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 最右节点右指针为 cur</span></div><div class="line">                <span class="keyword">if</span> (mostRight.left == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 此时的 level 就是叶子节点的 level</span></div><div class="line">                    minHeight = Math.min(minHeight, level);</div><div class="line">                &#125;</div><div class="line">                level -= rightBorder;</div><div class="line">                mostRight.right = <span class="keyword">null</span>;</div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 单独计算整数最右节点</span></div><div class="line">    Node t = head;</div><div class="line">    <span class="keyword">int</span> fullRightBorder = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (t.right != <span class="keyword">null</span>) &#123;</div><div class="line">        fullRightBorder++;</div><div class="line">        t = t.right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (t.left == <span class="keyword">null</span>) &#123;</div><div class="line">        minHeight = Math.min(minHeight, fullRightBorder);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> minHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法基础之 Morris&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-05-31-%E6%95%B0%E6%8D%AE%E5%BA%93/mycat/mycat_01.html"/>
    <id>http://yoursite.com/2020-05-31-数据库/mycat/mycat_01.html</id>
    <published>2020-05-31T12:02:07.641Z</published>
    <updated>2020-05-31T12:02:07.641Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020-05-31-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E6%9C%9F/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"/>
    <id>http://yoursite.com/2020-05-31-算法与数据结构/训练营一期/线段树.html</id>
    <published>2020-05-31T01:10:05.820Z</published>
    <updated>2020-05-31T01:12:17.304Z</updated>
    
    <content type="html"><![CDATA[<p>int[] arr [1…1000]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;int[] arr [1…1000]&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>122_买卖股票最佳时机||</title>
    <link href="http://yoursite.com/2020-05-28-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/20200529_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html"/>
    <id>http://yoursite.com/2020-05-28-算法与数据结构/每日一题/20200529_买卖股票最佳时机II.html</id>
    <published>2020-05-28T14:13:12.000Z</published>
    <updated>2020-05-29T17:09:30.203Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 第 122 题，买卖股票最佳时机||</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> prePoint = prices[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(prices[i] &gt; prePoint) &#123;</div><div class="line">            maxProfit = maxProfit + (prices[i] - prePoint);</div><div class="line">        &#125;</div><div class="line">        prePoint = prices[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxProfit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode 第 122 题，买卖股票最佳时机||&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>123_买卖股票最佳时机|||</title>
    <link href="http://yoursite.com/2020-05-28-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/20200530_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html"/>
    <id>http://yoursite.com/2020-05-28-算法与数据结构/每日一题/20200530_买卖股票最佳时机III.html</id>
    <published>2020-05-28T14:13:12.000Z</published>
    <updated>2020-05-29T23:54:30.840Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 第 123 题，买卖股票最佳时机|||</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h3><p>计算每次出现低点时的增长大小，其中最大的两个相加就是需要的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m2 = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 一段增长利润</span></div><div class="line">        <span class="keyword">int</span> mtmp = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lowPoint = prices[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++) &#123;</div><div class="line">            <span class="comment">// 出现低点</span></div><div class="line">            <span class="keyword">if</span>(prices[i] &lt; prices[i-<span class="number">1</span>]) &#123;</div><div class="line">                lowPoint = prices[i];</div><div class="line">                <span class="keyword">if</span>(mtmp &gt; m1) &#123; <span class="comment">// 出现第一高利润段</span></div><div class="line">                    m2 = m1;</div><div class="line">                    m1 = mtmp;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mtmp &gt; m2) &#123; <span class="comment">// 出现第二高利润段</span></div><div class="line">                    m2 = mtmp;</div><div class="line">                &#125;</div><div class="line">                mtmp = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mtmp = prices[i] - lowPoint;</div><div class="line">                <span class="comment">// mtmp = Math.max(mtmp, prices[i] - lowPoint);</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(i == prices.length -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(mtmp &gt; m1) &#123; <span class="comment">// 出现第一高利润段</span></div><div class="line">                    m2 = m1;</div><div class="line">                    m1 = mtmp;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mtmp &gt; m2) &#123; <span class="comment">// 出现第二高利润段</span></div><div class="line">                    m2 = mtmp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> m1 + m2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样想思路出现了问题，最大的利润段不一定是连续增长的。比如<code>{1,2,4,2,5,7,2,4,9}</code>，按照上面的思路算出来结果是12，即<code>(2,5,7)、(2,4,9)</code>。但实际上应该是<code>(1,2,4,2,5,7)、(2,4,9)</code>才对。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode 第 123 题，买卖股票最佳时机|||&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>121_买卖股票最佳时机</title>
    <link href="http://yoursite.com/2020-05-28-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/20200528_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html"/>
    <id>http://yoursite.com/2020-05-28-算法与数据结构/每日一题/20200528_买卖股票最佳时机.html</id>
    <published>2020-05-28T14:13:12.000Z</published>
    <updated>2020-05-29T17:03:34.723Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 第 121 题，买卖股票最佳时机</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T121_maxProfit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//        int[] prices = &#123;7,1,5,3,6,4&#125;; // 5</span></div><div class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>&#125;; <span class="comment">// 0</span></div><div class="line">        System.out.println(maxProfit(prices));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 不管如何 ,在低价格的时候买入就可以获得最大利润</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(prices[i] &lt; minPrice) &#123;</div><div class="line">                minPrice = prices[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                maxProfit = Math.max(maxProfit, prices[i] - minPrice);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxProfit;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode 第 121 题，买卖股票最佳时机&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Manacher 算法</title>
    <link href="http://yoursite.com/2020-05-26-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E6%9C%9F/Manacher%E7%AE%97%E6%B3%95.html"/>
    <id>http://yoursite.com/2020-05-26-算法与数据结构/训练营一期/Manacher算法.html</id>
    <published>2020-05-26T14:13:12.000Z</published>
    <updated>2020-05-31T15:56:28.581Z</updated>
    
    <content type="html"><![CDATA[<p>Manacher 算法</p><a id="more"></a><p>回文算法。</p><p>求最大回文子串。</p><h2 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h2><p>思路1：直接遍历字符串，以当前节点为中心向两边扩。遇到虚轴为中心时有问题。</p><p>思路2：增加辅助虚轴 <code>31211214 ==&gt; #3#1#2#1#1#2#1#4#</code></p><p>分析复杂度：最差情况 “aaaaaaa” 复杂度 O(N²)。子串长度 2n+1，在中心之前，每次要比较到最左边，在中心之后，每次要比较到最右。</p><h2 id="2-Manacher"><a href="#2-Manacher" class="headerlink" title="2. Manacher"></a>2. Manacher</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li>回文半径、直径、区域</li><li>回文半径数组 pArr[]。类似动态规划，看能否加速</li><li>回文最右边界（int R=-1），R 更新 C 必定也会更新</li><li>中心（int C=-1）</li></ul><h3 id="2-2-算法思路"><a href="#2-2-算法思路" class="headerlink" title="2.2 算法思路"></a>2.2 算法思路</h3><ol><li>i 在 R 外，就是暴力破解，没有任何优化</li><li>i 在 R 内，分为三种小情况<ol><li>i’ 的回文区域彻底在 [L,R] 中，<strong>pArr[i] = pArr[i’]</strong></li><li>i’ 的回文区域在[L,R]外，<strong>pArr[i] = R - i</strong></li><li>i’ 的回文区域左边界等于左边界，<strong>[R’,R]肯定是回文区域，只需从 R+1 开始验证即可</strong>。</li></ol></li></ol><h3 id="2-3-复杂度分析"><a href="#2-3-复杂度分析" class="headerlink" title="2.3 复杂度分析"></a>2.3 复杂度分析</h3><p>时间复杂度：O(N)</p><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manacher</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(manacher(<span class="string">"a12321aaba"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">manacher</span><span class="params">(String strOrg)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(strOrg == <span class="keyword">null</span> || strOrg == <span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxC = -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 转换为 manacher 字符串</span></div><div class="line">        String str = changeToManacher(strOrg);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] strArr = str.toCharArray();</div><div class="line">        <span class="keyword">int</span> R = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> C = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()]; <span class="comment">// 回文半径数组</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</div><div class="line">            <span class="comment">// i 在 R 外</span></div><div class="line">            <span class="keyword">if</span> (i &gt; R) &#123;</div><div class="line">                <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 向两边的偏移量</span></div><div class="line">                <span class="keyword">while</span> ((i + j) &lt; str.length() &amp;&amp; j &lt;= i) &#123;</div><div class="line">                    <span class="keyword">if</span> (strArr[i-j] == strArr[i+j]) &#123;</div><div class="line">                        pArr[i]++;</div><div class="line">                        j++;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= R) &#123; <span class="comment">// i 在 R 内</span></div><div class="line">                <span class="comment">// i' 回文左边界大于 L（R-i =&gt; i'）</span></div><div class="line">                <span class="keyword">if</span> (((R-i)-pArr[R-i])&gt;(R-<span class="number">2</span>*C)) &#123;</div><div class="line">                    pArr[i] = pArr[R-i];</div><div class="line">                <span class="comment">// i' 回文左边界小于 L</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((R-i)-pArr[R-i])&lt;(R-<span class="number">2</span>*C)) &#123;</div><div class="line">                    pArr[i] = R - i;</div><div class="line">                <span class="comment">// i' 回文左边界等于 L</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    pArr[i] = R - i;</div><div class="line">                    <span class="keyword">int</span> j = R - i;</div><div class="line">                    <span class="keyword">while</span> ((i + j) &lt; str.length() &amp;&amp; j &lt;= i) &#123;</div><div class="line">                        <span class="keyword">if</span>(strArr[i-<span class="number">1</span>] == strArr[i+<span class="number">1</span>]) &#123;</div><div class="line">                            pArr[i]++;</div><div class="line">                            j++;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            C = i;</div><div class="line">            R = C + pArr[i] - <span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(pArr[i] &gt; maxLen) &#123;</div><div class="line">                maxLen = pArr[i];</div><div class="line">                maxC = C;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"C:"</span> + maxC + <span class="string">"; len:"</span> + maxLen);</div><div class="line">        <span class="keyword">final</span> String finStr = str.substring(maxC - (maxLen - <span class="number">1</span>), maxC + (maxLen - <span class="number">1</span>) + <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> finStr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">changeToManacher</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"#"</span>);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</div><div class="line">            sb.append(chars[i]).append(<span class="string">"#"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-5-应用题"><a href="#2-5-应用题" class="headerlink" title="2.5 应用题"></a>2.5 应用题</h3><p>给定一个字符串 str，要求在后边至少给其补充多少个字符串使得它变为一个回文字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Manacher 算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>70_爬楼梯问题</title>
    <link href="http://yoursite.com/2020-05-26-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/20200526_%E7%88%AC%E6%A5%BC%E6%A2%AF.html"/>
    <id>http://yoursite.com/2020-05-26-算法与数据结构/每日一题/20200526_爬楼梯.html</id>
    <published>2020-05-26T14:13:12.000Z</published>
    <updated>2020-05-26T15:14:28.448Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 第 70 题，爬楼梯问题。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T70_climbStairs</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</div><div class="line">        System.out.println(String.format(<span class="string">"[动态规划法]爬到第&#123;%s&#125;级楼梯有&#123;%s&#125;种方法。"</span>, n, climbStairs1(n)));</div><div class="line">        System.out.println(String.format(<span class="string">"[暴力法]爬到第&#123;%s&#125;级楼梯有&#123;%s&#125;种方法。"</span>, n, climbStairs2(<span class="number">0</span>, n)));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// dp数组</span></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="comment">// dp 公式</span></div><div class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i&gt;n) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i == n) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 爬到第 n 阶等于从第一阶到第n阶段+从第二阶到第n阶</span></div><div class="line">        <span class="keyword">return</span> climbStairs2(i+<span class="number">1</span>, n) + climbStairs2(i+<span class="number">2</span>, n);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode 第 70 题，爬楼梯问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
