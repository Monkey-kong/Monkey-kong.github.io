<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>第 17 章 网络编程 | 悟空</title>
  <meta name="keywords" content=" Java讲义 ">
  <meta name="description" content="第 17 章 网络编程 | 悟空">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="悟空">
<meta property="og:url" content="http://yoursite.com/404.html">
<meta property="og:site_name" content="悟空">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-11-16T00:43:02.436Z">
<meta property="article:modified_time" content="2019-11-08T14:02:36.972Z">
<meta property="article:author" content="悟空">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="悟空" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>悟空</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/Monkey-kong" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/wukong-16" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:lixianfu1@outlook.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1109075867&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(109)</small></div></li>
    
        
            
            <li><div data-rel="Java基础">Java基础<small>(18)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="JVM">JVM<small>(11)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="多线程">多线程<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="OS">OS<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="IO">IO<small>(9)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="高并发">高并发<small>(9)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="MySQL">MySQL<small>(14)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="分布式">分布式<small>(13)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计模式">设计模式<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="其他">其他<small>(6)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="109">
<input type="hidden" id="yelog_site_word_count" value="316k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://www.chenuon.cn/">程忧点滴</a></li>
            
            <li><a target="_blank" href="https://blog.jamespan.me/">小鶸の道场</a></li>
            
            <li><a target="_blank" href="http://www.ruanyifeng.com/home.html">阮一峰</a></li>
            
            <li><a target="_blank" href="https://www.haomwei.com/">屠城</a></li>
            
            <li><a target="_blank" href="https://hasaik.com/">hasaik</a></li>
            
            <li><a target="_blank" href="https://www.imalan.cn/">三无计划</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式会话</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>内网穿透</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>其他</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>网络</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>远程连接</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Blog</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Eureka</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>flex</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>frp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>https</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java讲义</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LVS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Nginx</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NIO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Observer</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>OS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Proxy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RSC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sia</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Singleton</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring Cloud</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>TypeScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>uni-app</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>webpack</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ZooKeeper</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 Java基础 "
           href="/2020-12-25-13Spring%E5%9F%BA%E7%A1%80/springmvc.html"
           data-tag="sia"
           data-author="" >
            <span class="post-title" title="第 5 章 构建 Spring Web 应用程序">第 5 章 构建 Spring Web 应用程序</span>
            <span class="post-date" title="2020-12-25 22:13:12">2020/12/25</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-12-22-12%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85.html"
           data-tag="其他"
           data-author="" >
            <span class="post-title" title="组装电脑">组装电脑</span>
            <span class="post-date" title="2020-12-22 22:13:12">2020/12/22</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-12-22-12%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html"
           data-tag="frp,内网穿透,远程连接"
           data-author="" >
            <span class="post-title" title="使用 frp 实现远程连接和内网穿透">使用 frp 实现远程连接和内网穿透</span>
            <span class="post-date" title="2020-12-22 22:13:12">2020/12/22</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 21 章 函数式编程">第 21 章 函数式编程</span>
            <span class="post-date" title="2020-12-21 22:13:12">2020/12/21</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html"
           data-tag="TypeScript"
           data-author="" >
            <span class="post-title" title="TypeScript 学习(一)">TypeScript 学习(一)</span>
            <span class="post-date" title="2020-11-30 22:13:12">2020/11/30</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-11-15-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98.html"
           data-tag="flex"
           data-author="" >
            <span class="post-title" title="Flex 布局实战">Flex 布局实战</span>
            <span class="post-date" title="2020-11-15 22:13:12">2020/11/15</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%806-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（六）">算法基础（六）</span>
            <span class="post-date" title="2020-11-08 23:13:12">2020/11/08</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%805-%E5%89%8D%E7%BC%80%E6%A0%91_%E6%A1%B6%E6%8E%92%E5%BA%8F_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（五）">算法基础（五）</span>
            <span class="post-date" title="2020-11-08 22:13:12">2020/11/08</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%803-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（三）">算法基础（三）</span>
            <span class="post-date" title="2020-11-02 22:13:12">2020/11/02</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%804-%E6%AF%94%E8%BE%83%E5%99%A8_%E5%A0%86%E6%8E%92%E5%BA%8F.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（四）">算法基础（四）</span>
            <span class="post-date" title="2020-11-02 22:13:12">2020/11/02</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-10-30-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%802.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（二）">算法基础（二）</span>
            <span class="post-date" title="2020-10-30 22:13:12">2020/10/30</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-10-28-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%801-%E5%A4%8D%E6%9D%82%E5%BA%A6_%E5%AF%B9%E6%95%B0%E5%99%A8_%E4%BA%8C%E5%88%86%E6%B3%95_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（一）">算法基础（一）</span>
            <span class="post-date" title="2020-10-28 22:13:12">2020/10/28</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-11-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(8)-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(八)">Spring Cloud学习(八)</span>
            <span class="post-date" title="2020-10-11 23:43:12">2020/10/11</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-10-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(7)-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(七)">Spring Cloud学习(七)</span>
            <span class="post-date" title="2020-10-10 23:43:12">2020/10/10</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(6)-config.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(六)">Spring Cloud学习(六)</span>
            <span class="post-date" title="2020-10-04 23:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(1).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(一)">分布式会话管理(一)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(3).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(三)">分布式会话管理(三)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(4).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(四)">分布式会话管理(四)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(2).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(二)">分布式会话管理(二)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(5)-zuul.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(五)">Spring Cloud学习(五)</span>
            <span class="post-date" title="2020-10-03 23:43:12">2020/10/03</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(4)-Hystrix.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(四)">Spring Cloud学习(四)</span>
            <span class="post-date" title="2020-10-03 23:33:12">2020/10/03</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-02-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(3)-Feign.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="SpringCloud学习(三)">SpringCloud学习(三)</span>
            <span class="post-date" title="2020-10-02 23:33:12">2020/10/02</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-02-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(2).html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(二)">Spring Cloud学习(二)</span>
            <span class="post-date" title="2020-10-02 23:13:12">2020/10/02</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-01-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(1).html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(一)">Spring Cloud学习(一)</span>
            <span class="post-date" title="2020-10-01 22:13:12">2020/10/01</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-20-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（五）">操作系统学习（五）</span>
            <span class="post-date" title="2020-09-20 22:13:12">2020/09/20</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-19-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（四）">操作系统学习（四）</span>
            <span class="post-date" title="2020-09-19 22:13:12">2020/09/19</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-18-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（三）">操作系统学习（三）</span>
            <span class="post-date" title="2020-09-18 22:13:12">2020/09/18</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-16-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（二）">操作系统学习（二）</span>
            <span class="post-date" title="2020-09-16 22:13:12">2020/09/16</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-15-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（一）">操作系统学习（一）</span>
            <span class="post-date" title="2020-09-15 22:13:12">2020/09/15</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-09-10-07MySQL/mysql_14_%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十四) 经典面试题目">MySql 调优(十四) 经典面试题目</span>
            <span class="post-date" title="2020-09-10 23:13:12">2020/09/10</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_13_JavaSPI%E6%9C%BA%E5%88%B6.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十三) Java SPI 机制详解">MySql 调优(十三) Java SPI 机制详解</span>
            <span class="post-date" title="2020-08-29 23:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_12_%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十二) 经典笔试题">MySql 调优(十二) 经典笔试题</span>
            <span class="post-date" title="2020-08-29 22:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_11_%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十一) 读写分离">MySql 调优(十一) 读写分离</span>
            <span class="post-date" title="2020-08-29 21:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_10_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十)">MySql 调优(十)</span>
            <span class="post-date" title="2020-08-29 20:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-27-07MySQL/mysql_9_%E4%BA%8B%E5%8A%A1.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(九)">MySql 调优(九)</span>
            <span class="post-date" title="2020-08-27 22:13:12">2020/08/27</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-26-07MySQL/mysql_8_%E9%94%81%E6%9C%BA%E5%88%B6.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(八)">MySql 调优(八)</span>
            <span class="post-date" title="2020-08-26 22:13:12">2020/08/26</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-16-07MySQL/mysql_7_%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E5%92%8C%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(七)">MySql 调优(七)</span>
            <span class="post-date" title="2020-08-16 22:13:12">2020/08/16</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-14-07MySQL/mysql_6_%E5%88%86%E5%8C%BA.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(六)">MySql 调优(六)</span>
            <span class="post-date" title="2020-08-14 22:13:12">2020/08/14</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-13-07MySQL/mysql_5_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(五)">MySql 调优(五)</span>
            <span class="post-date" title="2020-08-13 22:13:12">2020/08/13</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-10-07MySQL/mysql_3_%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%9B%91%E6%8E%A7.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(三)">MySql 调优(三)</span>
            <span class="post-date" title="2020-08-10 22:13:12">2020/08/10</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-09-07MySQL/mysql_2_%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%92%8C%E5%85%B3%E9%94%AE%E5%90%8D%E8%AF%8D.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(二)">MySql 调优(二)</span>
            <span class="post-date" title="2020-08-09 22:13:12">2020/08/09</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-05-07MySQL/mysql_1_%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(一)">MySql 调优(一)</span>
            <span class="post-date" title="2020-08-05 22:13:12">2020/08/05</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-04-07MySQL/mysql_0_%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 安装">MySql 安装</span>
            <span class="post-date" title="2020-08-04 22:13:12">2020/08/04</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-24-02JVM/jvm%E5%AD%A6%E4%B9%A011_jvm%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（十一）">JVM 学习（十一）</span>
            <span class="post-date" title="2020-07-24 22:13:12">2020/07/24</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-24-02JVM/jvm%E5%AD%A6%E4%B9%A012_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（十二）">JVM 学习（十二）</span>
            <span class="post-date" title="2020-07-24 22:13:12">2020/07/24</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-23-02JVM/jvm%E5%AD%A6%E4%B9%A0%2010_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（十）">JVM 学习（十）</span>
            <span class="post-date" title="2020-07-23 22:13:12">2020/07/23</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-20-02JVM/jvm%E5%AD%A6%E4%B9%A07_xx.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（七）">JVM 学习（七）</span>
            <span class="post-date" title="2020-07-20 22:13:12">2020/07/20</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-20-02JVM/jvm%E5%AD%A6%E4%B9%A08_%E8%B0%83%E4%BC%982.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（八）">JVM 学习（八）</span>
            <span class="post-date" title="2020-07-20 22:13:12">2020/07/20</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-20-02JVM/jvm%E5%AD%A6%E4%B9%A09_%E8%B0%83%E4%BC%983.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（九）">JVM 学习（九）</span>
            <span class="post-date" title="2020-07-20 22:13:12">2020/07/20</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-19-02JVM/jvm%E5%AD%A6%E4%B9%A05_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（五）">JVM 学习（五）</span>
            <span class="post-date" title="2020-07-19 22:13:12">2020/07/19</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-19-02JVM/jvm%E5%AD%A6%E4%B9%A06_GC.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（六）">JVM 学习（六）</span>
            <span class="post-date" title="2020-07-19 22:13:12">2020/07/19</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-16-02JVM/jvm%E5%AD%A6%E4%B9%A03_4_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（三、四）">JVM 学习（三、四）</span>
            <span class="post-date" title="2020-07-16 22:13:12">2020/07/16</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-06-29-02JVM/jvm%E5%AD%A6%E4%B9%A02_class%E5%8A%A0%E8%BD%BD.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（二）">JVM 学习（二）</span>
            <span class="post-date" title="2020-06-29 22:13:12">2020/06/29</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-06-28-02JVM/jvm%E5%AD%A6%E4%B9%A01_jvm%E5%9F%BA%E7%A1%80_jsf.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（一）">JVM 学习（一）</span>
            <span class="post-date" title="2020-06-28 22:13:12">2020/06/28</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-06-27-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%B0%20AOP.html"
           data-tag="Proxy"
           data-author="" >
            <span class="post-title" title="设计模式之 - 从代理模式到 Spring AOP">设计模式之 - 从代理模式到 Spring AOP</span>
            <span class="post-date" title="2020-06-27 22:13:12">2020/06/27</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-21-05IO/IO%E5%AD%A6%E4%B9%A07.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（七）">IO学习（七）</span>
            <span class="post-date" title="2020-06-21 22:13:12">2020/06/21</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-21-05IO/IO%E5%AD%A6%E4%B9%A08.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（八）">IO学习（八）</span>
            <span class="post-date" title="2020-06-21 22:13:12">2020/06/21</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-16-05IO/IO%E5%AD%A6%E4%B9%A05.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（五）">IO学习（五）</span>
            <span class="post-date" title="2020-06-16 22:13:12">2020/06/16</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-16-05IO/IO%E5%AD%A6%E4%B9%A06.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（六）">IO学习（六）</span>
            <span class="post-date" title="2020-06-16 22:13:12">2020/06/16</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-14-05IO/IO%E5%AD%A6%E4%B9%A03.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（三）">IO学习（三）</span>
            <span class="post-date" title="2020-06-14 22:13:12">2020/06/14</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-06-12-08%E5%88%86%E5%B8%83%E5%BC%8F/Https%E4%B9%8B%E5%AE%9E%E6%88%98.html"
           data-tag="https"
           data-author="" >
            <span class="post-title" title="Https 实战">Https 实战</span>
            <span class="post-date" title="2020-06-12 22:13:12">2020/06/12</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-10-05IO/IO%E5%AD%A6%E4%B9%A02.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（二）">IO学习（二）</span>
            <span class="post-date" title="2020-06-10 22:13:12">2020/06/10</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-08-05IO/IO%E5%AD%A6%E4%B9%A01.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（一）">IO学习（一）</span>
            <span class="post-date" title="2020-06-08 22:13:12">2020/06/08</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-06-06-08%E5%88%86%E5%B8%83%E5%BC%8F/Https%E4%B9%8BSSLTLS%20%E5%8D%8F%E8%AE%AE.html"
           data-tag="https"
           data-author="" >
            <span class="post-title" title="Https 之 SSL/TLS 协议">Https 之 SSL/TLS 协议</span>
            <span class="post-date" title="2020-06-06 22:13:12">2020/06/06</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-06-05IO/IO%E5%AD%A6%E4%B9%A04.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（四）">IO学习（四）</span>
            <span class="post-date" title="2020-06-06 22:13:12">2020/06/06</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-05-25-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80.html"
           data-tag="flex"
           data-author="" >
            <span class="post-title" title="Flex 布局">Flex 布局</span>
            <span class="post-date" title="2020-05-25 22:13:12">2020/05/25</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-05-25-11%E5%89%8D%E7%AB%AF/vue-todo.html"
           data-tag="vue,webpack"
           data-author="" >
            <span class="post-title" title="vue 入门项目">vue 入门项目</span>
            <span class="post-date" title="2020-05-25 22:13:12">2020/05/25</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-04-10-11%E5%89%8D%E7%AB%AF/uniapp.html"
           data-tag="uni-app"
           data-author="" >
            <span class="post-title" title="uni-app">uni-app</span>
            <span class="post-date" title="2020-04-10 22:13:13">2020/04/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-04-10-11%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0(2).html"
           data-tag="vue"
           data-author="" >
            <span class="post-title" title="vue 学习(二)">vue 学习(二)</span>
            <span class="post-date" title="2020-04-10 22:13:12">2020/04/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-04-10-11%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0(1).html"
           data-tag="vue"
           data-author="" >
            <span class="post-title" title="vue 学习(一)">vue 学习(一)</span>
            <span class="post-date" title="2020-04-10 22:13:12">2020/04/10</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-07-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(7).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(七)">多线程高并发学习(七)</span>
            <span class="post-date" title="2020-04-07 22:13:12">2020/04/07</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-06-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(6).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(六)">多线程高并发学习(六)</span>
            <span class="post-date" title="2020-04-06 22:13:12">2020/04/06</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-05-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(5).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(五)">多线程高并发学习(五)</span>
            <span class="post-date" title="2020-04-05 22:13:12">2020/04/05</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-04-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(4).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(四)">多线程高并发学习(四)</span>
            <span class="post-date" title="2020-04-04 22:13:12">2020/04/04</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-03-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(3).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(三)">多线程高并发学习(三)</span>
            <span class="post-date" title="2020-04-03 22:13:12">2020/04/03</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-02-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(2).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(二)">多线程高并发学习(二)</span>
            <span class="post-date" title="2020-04-02 22:13:12">2020/04/02</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-01-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(1).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(一)">多线程高并发学习(一)</span>
            <span class="post-date" title="2020-04-01 22:13:12">2020/04/01</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-03-20-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Observer.html"
           data-tag="Observer"
           data-author="" >
            <span class="post-title" title="设计模式之 - Observer">设计模式之 - Observer</span>
            <span class="post-date" title="2020-03-20 22:13:12">2020/03/20</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-03-20-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-ResponsibilityChain.html"
           data-tag="RSC"
           data-author="" >
            <span class="post-title" title="设计模式之 - Responsibility Chain">设计模式之 - Responsibility Chain</span>
            <span class="post-date" title="2020-03-20 22:13:12">2020/03/20</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-03-20-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-singleton.html"
           data-tag="Singleton"
           data-author="" >
            <span class="post-title" title="设计模式之 - Singleton">设计模式之 - Singleton</span>
            <span class="post-date" title="2020-03-20 22:13:12">2020/03/20</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-05-06%E9%AB%98%E5%B9%B6%E5%8F%91/zookeeper%E5%AD%A6%E4%B9%A0(%E4%B8%89).html"
           data-tag="ZooKeeper"
           data-author="" >
            <span class="post-title" title="ZooKeeper学习(三)">ZooKeeper学习(三)</span>
            <span class="post-date" title="2020-03-05 22:13:12">2020/03/05</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-02-06%E9%AB%98%E5%B9%B6%E5%8F%91/zookeeper%E5%AD%A6%E4%B9%A0(%E4%B8%80).html"
           data-tag="ZooKeeper"
           data-author="" >
            <span class="post-title" title="ZooKeeper学习(一)">ZooKeeper学习(一)</span>
            <span class="post-date" title="2020-03-02 22:13:12">2020/03/02</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-02-06%E9%AB%98%E5%B9%B6%E5%8F%91/zookeeper%E5%AD%A6%E4%B9%A0(%E4%BA%8C).html"
           data-tag="ZooKeeper"
           data-author="" >
            <span class="post-title" title="ZooKeeper学习(二)">ZooKeeper学习(二)</span>
            <span class="post-date" title="2020-03-02 22:13:12">2020/03/02</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-03-02-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98C3_%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86.html"
           data-tag="Eureka"
           data-author="" >
            <span class="post-title" title="第三章 服务治理">第三章 服务治理</span>
            <span class="post-date" title="2020-03-02 22:13:12">2020/03/02</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-01-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%94)-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(五)-面试常见问题">Redis 学习(五)-面试常见问题</span>
            <span class="post-date" title="2020-03-01 22:13:12">2020/03/01</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-02-28-06%E9%AB%98%E5%B9%B6%E5%8F%91/Linux%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%AE%80%E8%A6%81%E6%AD%A5%E9%AA%A4.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux 系统安装简要步骤">Linux 系统安装简要步骤</span>
            <span class="post-date" title="2020-02-28 22:13:12">2020/02/28</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-02-28-06%E9%AB%98%E5%B9%B6%E5%8F%91/Typecho+Tengine%E5%BB%BA%E7%AB%99.html"
           data-tag="Nginx,Blog"
           data-author="" >
            <span class="post-title" title="Typecho+Tengine 搭建个人主页">Typecho+Tengine 搭建个人主页</span>
            <span class="post-date" title="2020-02-28 22:13:12">2020/02/28</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-28-06%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"
           data-tag="LVS,网络"
           data-author="" >
            <span class="post-title" title="高并发负载均衡">高并发负载均衡</span>
            <span class="post-date" title="2020-02-28 22:13:12">2020/02/28</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-02-22-05IO/IO%E5%AD%A6%E4%B9%A09.html"
           data-tag="NIO"
           data-author="" >
            <span class="post-title" title="NIO 原理">NIO 原理</span>
            <span class="post-date" title="2020-02-22 22:13:12">2020/02/22</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-21-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E5%9B%9B)-%E9%9B%86%E7%BE%A4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(四)-主从复制、高可用、集群">Redis 学习(四)-主从复制、高可用、集群</span>
            <span class="post-date" title="2020-02-21 22:13:12">2020/02/21</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-20-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%B8%89)-%E6%8C%81%E4%B9%85%E5%8C%96.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(三)-持久化">Redis 学习(三)-持久化</span>
            <span class="post-date" title="2020-02-20 22:13:12">2020/02/20</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-19-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(二)-管道、发布/订阅、事务、modules、过期">Redis 学习(二)-管道、发布/订阅、事务、modules、过期</span>
            <span class="post-date" title="2020-02-19 22:13:12">2020/02/19</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-18-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(一)-概述、安装、类型、指令">Redis 学习(一)-概述、安装、类型、指令</span>
            <span class="post-date" title="2020-02-18 22:13:12">2020/02/18</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-18-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C18.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 18 章 类加载机制与反射">第 18 章 类加载机制与反射</span>
            <span class="post-date" title="2020-01-18 22:13:12">2020/01/18</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-17-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C17.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 17 章 网络编程">第 17 章 网络编程</span>
            <span class="post-date" title="2020-01-17 23:13:12">2020/01/17</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-16-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C16.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 16 章 多线程">第 16 章 多线程</span>
            <span class="post-date" title="2020-01-16 22:13:12">2020/01/16</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-15-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C15.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 15 章 输入、输出">第 15 章 输入、输出</span>
            <span class="post-date" title="2020-01-15 22:13:12">2020/01/15</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-14-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C14.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 14 章 注解">第 14 章 注解</span>
            <span class="post-date" title="2020-01-14 22:13:12">2020/01/14</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-13-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C13.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 13 章 MySQL 数据库与 JDBC 编程">第 13 章 MySQL 数据库与 JDBC 编程</span>
            <span class="post-date" title="2020-01-13 22:13:12">2020/01/13</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-10-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C10.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 10 章 异常处理">第 10 章 异常处理</span>
            <span class="post-date" title="2020-01-10 22:13:12">2020/01/10</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-09-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C9.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 9 章 泛型">第 9 章 泛型</span>
            <span class="post-date" title="2020-01-09 22:13:12">2020/01/09</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-08-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C8.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 8 章 Java 集合">第 8 章 Java 集合</span>
            <span class="post-date" title="2020-01-08 22:13:12">2020/01/08</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-07-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C7.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 7 章 Java 基础类库">第 7 章 Java 基础类库</span>
            <span class="post-date" title="2020-01-07 22:13:12">2020/01/07</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-06-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C6.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 6 章 面向对象（下）">第 6 章 面向对象（下）</span>
            <span class="post-date" title="2020-01-06 22:13:12">2020/01/06</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-05-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C5.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 5 章 面向对象（上）">第 5 章 面向对象（上）</span>
            <span class="post-date" title="2020-01-05 22:13:12">2020/01/05</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-04-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C4.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 4 章 流程控制与数组">第 4 章 流程控制与数组</span>
            <span class="post-date" title="2020-01-04 22:13:12">2020/01/04</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-03-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C3.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 3 章 数据类型和运算符">第 3 章 数据类型和运算符</span>
            <span class="post-date" title="2020-01-03 22:13:12">2020/01/03</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-02-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C2.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 2 章 理解面向对象">第 2 章 理解面向对象</span>
            <span class="post-date" title="2020-01-02 22:13:12">2020/01/02</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-01-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C1.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 1 章 Java 语言概述与开发环境">第 1 章 Java 语言概述与开发环境</span>
            <span class="post-date" title="2020-01-01 22:13:12">2020/01/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-01疯狂Java讲义/疯狂Java讲义C17" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">第 17 章 网络编程</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java基础">Java基础</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">Java讲义</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2020-11-24 23:15:10'>2020-01-17 23:13</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">17.1 网络编程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-1-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">17.1.1 网络基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E3%80%82"><span class="toc-text">计算机网络分类。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI"><span class="toc-text">OSI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">通信协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-2-IP-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">17.1.2 IP 地址和端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP"><span class="toc-text">IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-text">端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-Java-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%BB%9C%E6%94%AF%E6%8C%81"><span class="toc-text">17.2 Java 的基本网络支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-1-%E4%BD%BF%E7%94%A8-InetAddress"><span class="toc-text">17.2.1 使用 InetAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-2-%E4%BD%BF%E7%94%A8-URLDecoder-%E5%92%8C-URLEncoder"><span class="toc-text">17.2.2 使用 URLDecoder 和 URLEncoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-3-URL-URLConnection%E5%92%8C-URLPermission"><span class="toc-text">17.2.3 URL URLConnection和 URLPermission</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URL"><span class="toc-text">URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLConnection-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">URLConnection 实现多线程下载工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLPermission"><span class="toc-text">URLPermission</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E5%9F%BA%E4%BA%8E-TCP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">17.3 基于 TCP 协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-1-TCP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-text">17.3.1 TCP 协议基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-2-%E4%BD%BF%E7%94%A8-ServerSocket-%E5%88%9B%E5%BB%BA-TCP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">17.3.2 使用 ServerSocket 创建 TCP 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-3-%E4%BD%BF%E7%94%A8-Socket-%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">17.3.3 使用 Socket 进行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6"><span class="toc-text">连接超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-4-%E5%8A%A0%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">17.3.4 加入多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-S-%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%BA%94%E7%94%A8"><span class="toc-text">C&#x2F;S 聊天室应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-5-%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">17.3.5 记录用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E5%AD%97%E7%AC%A6"><span class="toc-text">定义协议字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-map"><span class="toc-text">自定义 map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server"><span class="toc-text">Server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerThread"><span class="toc-text">ServerThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Client"><span class="toc-text">Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ClientThread"><span class="toc-text">ClientThread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-6-%E5%8D%8A%E5%85%B3%E9%97%AD%E7%9A%84-Socket"><span class="toc-text">17.3.6 半关闭的 Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-7-%E4%BD%BF%E7%94%A8-NIO-%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E-Socket-%E9%80%9A%E4%BF%A1"><span class="toc-text">17.3.7 使用 NIO 实现非阻塞 Socket 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector"><span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectableChannel"><span class="toc-text">SelectableChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NIO-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-text">使用 NIO 实现多人聊天室</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-8-%E4%BD%BF%E7%94%A8-Java7-%E7%9A%84-AIO-%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1"><span class="toc-text">17.3.8 使用 Java7 的 AIO 实现非阻塞通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsynchronousServerSocketChannel"><span class="toc-text">AsynchronousServerSocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsynchronousSocketChannel"><span class="toc-text">AsynchronousSocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%B7%A5%E5%85%B7"><span class="toc-text">AIO 多人聊天工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-%E5%9F%BA%E4%BA%8E-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">17.4 基于 UDP 协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-1-UDP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-text">17.4.1 UDP 协议基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-2-%E4%BD%BF%E7%94%A8-DatagramSocket-%E5%8F%91%E9%80%81%E3%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">17.4.2 使用 DatagramSocket 发送、接收数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-3-%E4%BD%BF%E7%94%A8-MulticaseSocket-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%82%B9%E5%B9%BF%E6%92%AD"><span class="toc-text">17.4.3 使用 MulticaseSocket 实现多点广播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-5-%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">17.5 使用代理服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-1-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-Proxy-%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="toc-text">17.5.1 直接使用 Proxy 创建连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-2-%E4%BD%BF%E7%94%A8-ProxySelector-%E8%87%AA%E5%8A%A8%E9%80%89%E6%8B%A9%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">17.5.2 使用 ProxySelector 自动选择代理服务器</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第 17 章 网络编程</p>
<a id="more"></a>

<h2 id="17-1-网络编程的基础知识"><a href="#17-1-网络编程的基础知识" class="headerlink" title="17.1 网络编程的基础知识"></a>17.1 网络编程的基础知识</h2><h3 id="17-1-1-网络基础知识"><a href="#17-1-1-网络基础知识" class="headerlink" title="17.1.1 网络基础知识"></a>17.1.1 网络基础知识</h3><h4 id="计算机网络分类。"><a href="#计算机网络分类。" class="headerlink" title="计算机网络分类。"></a>计算机网络分类。</h4><p>按照规模大小和延申范围：局域网（LAN）、城域网（MAN）、广域网（WAN）。Interenet 可以视为世界上最大的广域网。</p>
<p>按照网络拓扑结构：星型网络、总线型网络、环形网络、树形网络、星型环型网络等。</p>
<p>按照传输介质：双绞线网、同轴电缆网、光纤网和卫星网。</p>
<h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><p>开放系统互连参考模型（OSI），力求将网络简化，并以模块化的方式设计网络。推荐把计算机网络分七层。</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>计算机网络中实现通信必须有一些约定，这些约定被称为通信协议。通信协议负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等制定处理标准。</p>
<p>通信协议通常由三部分组成: 一是<strong>语义</strong>部分，用于决定双方对话的类型; 二是<strong>语法</strong>部分，用于决定双方对话的格式; 三是<strong>变换规则</strong>，用于决定通信双方的应答关系。</p>
<p>IP（Internet Protocol）协议是一个非常重要的协议，是支持网间互联的<strong>数据报协议</strong>。它提供网间连接的完善功能，包括 IP 数据报规定互联网络范围内的地址格式。</p>
<p>TCP(Transmission Control Protocol)协议，规定一种<strong>可靠的数据信息传递服务。</strong></p>
<p>TCP、IP 协议功能上互补，实际使用中常常把这两个协议统称为 TCP/IP 协议，因此 TCP/IP 协议也是 Internet 中最常用的基础协议。TCP/IP 协议将网络分为四层。</p>
<ul>
<li>物理+数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
<h3 id="17-1-2-IP-地址和端口号"><a href="#17-1-2-IP-地址和端口号" class="headerlink" title="17.1.2 IP 地址和端口号"></a>17.1.2 IP 地址和端口号</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>在基于 IP 协议网络中传输的数据包，都必须使用 IP 地址来进行标识。</p>
<p>IP 地址是数字型的，是一个 32 位（32bit）整数，但为了便于记忆，通常把它分为 4 个 8 位的二进制数，每个 8 位可以转换成一个 0~255 的十进制整数，因此日常看到的 IP 地址常常是这种形式：192.168.128.88</p>
<p>NIC(Internet Network Information Center) 统一负责全球 Internet IP 地址的规划、管理，而 Inter NIC、APNIC、RIPE 三大网络信息中心具体负责美国及其他地区的 IP 地址分配。其中 APNIC 负责亚太地区的 IP 管理，总部在日本东京大学。</p>
<p>IP 地址分为 A、B、C、D、E 五类。</p>
<ul>
<li>A类：10.0.0.0~10.255.255.255</li>
<li>B类：172.16.0.0~172.31.255.255</li>
<li>C类：192.168.0.0~192.168.255.255</li>
</ul>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是一个 16 位的整数，用于表示数据交给哪个应用程序处理。端口号可以从 0 到 65535</p>
<ul>
<li>公认端口：0~1023，他们紧密绑定一些特定服务</li>
<li>注册端口：1024~49151，松散绑定一些服务，应用程序通常应该使用这个范围内的端口。</li>
<li>动态和/或私有端口：49152~65535，应用程序使用的动态端口。</li>
</ul>
<h2 id="17-2-Java-的基本网络支持"><a href="#17-2-Java-的基本网络支持" class="headerlink" title="17.2 Java 的基本网络支持"></a>17.2 Java 的基本网络支持</h2><h3 id="17-2-1-使用-InetAddress"><a href="#17-2-1-使用-InetAddress" class="headerlink" title="17.2.1 使用 InetAddress"></a>17.2.1 使用 InetAddress</h3><p>没有提供构造器，提供两个静态方法获取对象：</p>
<ul>
<li>getByName(String host)</li>
<li>getByAddress(byte[] addr)</li>
</ul>
<p>获取实例对应的 IP 地址和主机名:</p>
<ul>
<li>String getCanonicalHostName()：全限定域名</li>
<li>String getHostAddress()</li>
<li>String getHostName()</li>
</ul>
<pre><code class="java">public class InetAddressTest &#123;
    public static void main(String[] args) throws Exception &#123;
        // 根据主机名来获取实例
        InetAddress ip = InetAddress.getByName(&quot;wiki.monkey-kong.cn&quot;);
        // 判断是否可达
        System.out.println(&quot;我的博客是否可达：&quot; + ip.isReachable(2000));
        System.out.println(ip.getCanonicalHostName());
        System.out.println(ip.getHostAddress());
        System.out.println(ip.getHostName());

        // 根据原始 IP 地址来获取对应的实例
        InetAddress ip2 = InetAddress.getByAddress(new byte[]&#123;104, 31, 66, 111&#125;);
        System.out.println(ip2.getHostName());
    &#125;
&#125;</code></pre>
<h3 id="17-2-2-使用-URLDecoder-和-URLEncoder"><a href="#17-2-2-使用-URLDecoder-和-URLEncoder" class="headerlink" title="17.2.2 使用 URLDecoder 和 URLEncoder"></a>17.2.2 使用 URLDecoder 和 URLEncoder</h3><p>URLDecoder 和 URLEncoder 用于完成普通字符串和 application/x-www-form-urlencoded MIME 字符串之间的互相转换。</p>
<pre><code class="java">public class URLDecoderTest &#123;
   public static void main(String[] args) throws Exception &#123;
       String keyWord = URLEncoder.encode(&quot;悟空&quot;, StandardCharsets.UTF_8);
       System.out.println(keyWord);
       String gbk = URLDecoder.decode(keyWord, StandardCharsets.UTF_8);
       System.out.println(gbk);
   &#125;
&#125;</code></pre>
<h3 id="17-2-3-URL-URLConnection和-URLPermission"><a href="#17-2-3-URL-URLConnection和-URLPermission" class="headerlink" title="17.2.3 URL URLConnection和 URLPermission"></a>17.2.3 URL URLConnection和 URLPermission</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL（Uniform Resource Locator）代表统一资源定位器，它是指向互联网资源的指针。资源可以是简单的文件或目录，也可以是对更为复杂对象的引用。</p>
<p>URL 组成：<code>protocol://host:port/resourceName</code></p>
<p>URI（Uniform Resource Identifiers）代表统一资源标识符，不能用于定位任何资源，唯一作用就是解析。</p>
<p>URL 类提供多个构造器用于获取对象，获取对象后就可以访问资源：</p>
<ul>
<li>String getFile()：获取资源名</li>
<li>String getHost()：获取主机名</li>
<li>String getPath()：获取路径</li>
<li>int getPort()</li>
<li>String getProtocol()</li>
<li>URLConnection openConnection()：获取和远程对象的连接</li>
<li>InputStream openStream()：打开连接，并返回一个读取资源的 InputStream</li>
</ul>
<h4 id="URLConnection-实现多线程下载工具类"><a href="#URLConnection-实现多线程下载工具类" class="headerlink" title="URLConnection 实现多线程下载工具类"></a>URLConnection 实现多线程下载工具类</h4><pre><code class="java">public class DownUtil &#123;

    // 定义下载资源的路劲(远程资源)
    private String path;
    // 指定下载文件保存位置(本地保存位置)
    private String targetFile;
    // 下载线程数
    private int threadNum;
    // 定义下载的线程对象
    private DownThread[] threads;
    // 定义下载的文件的总大小
    private int fileSize;

    public DownUtil(String path, String targetFile, int threadNum)&#123;
        this.path = path;
        this.targetFile = targetFile;
        this.threadNum = threadNum;
        threads = new DownThread[threadNum];
    &#125;

    public void download() throws Exception &#123;
        URL url = new URL(path);
        HttpURLConnection conn = (HttpURLConnection)url.openConnection();
        conn.setConnectTimeout(5 * 1000);
        conn.setRequestMethod(&quot;GET&quot;);
        conn.setRequestProperty(&quot;Accept&quot;,&quot;image/gif, image/jepg, image/pjpeg, &quot;
            + &quot;application/x-shockwave-flash, application/xaml+xml&quot;);
        conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;zh-CN&quot;);
        conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);
        conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);
        // 得到文件大小
        fileSize = conn.getContentLength();
        conn.disconnect();
        int currentPartSize = fileSize / threadNum + 1;
        RandomAccessFile file = new RandomAccessFile(targetFile, &quot;rw&quot;);
        // 设置本地文件大小
        file.setLength(fileSize);
        file.close();
        for (int i = 0; i &lt; threadNum; i++) &#123;
            // 计算每个线程下载的开始位置
            int startPos = i * currentPartSize;
            // 每个线程使用一个 RandomAccessFile 进行下载
            RandomAccessFile currentPart = new RandomAccessFile(targetFile, &quot;rw&quot;);
            // 定位该线程的下载位置
            currentPart.seek(startPos);
            // 创建下载线程
            threads[i] = new DownThread(startPos, currentPartSize, currentPart);
            // 启动下载线程
            threads[i].start();
        &#125;
    &#125;

    // 获取下载的完成百分比
    public double getCompleteRate()&#123;
        // 统计多个线程已经下载的总大小
        int sumSize = 0;
        for (int i = 0; i &lt; threadNum; i++) &#123;
            sumSize += threads[i].length;
        &#125;
        // 返回已经完成百分比
        return sumSize * 1.0 /fileSize;
    &#125;

    private class DownThread extends Thread &#123;
        // 当前线程的下载位置
        private int startPos;
        // 当前线程负责下载的文件大小
        private int currentPartSize;
        // 当前线程需要下载的文件块
        private RandomAccessFile currentPart;
        // 当前线程已经下载的字节数
        public int length;
        public DownThread(int startPos, int currentPartSize, RandomAccessFile currentPart)&#123;
            this.startPos = startPos;
            this.currentPartSize = currentPartSize;
            this.currentPart = currentPart;
        &#125;

        @Override
        public void run() &#123;
            try&#123;
                URL url = new URL(path);
                HttpURLConnection conn = (HttpURLConnection)url.openConnection();
                conn.setConnectTimeout(5 * 1000);
                conn.setRequestMethod(&quot;GET&quot;);
                conn.setRequestProperty(&quot;Accept&quot;,&quot;image/gif, image/jepg, image/pjpeg, &quot;
                        + &quot;application/x-shockwave-flash, application/xaml+xml&quot;);
                conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;zh-CN&quot;);
                conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);
                InputStream inStream = conn.getInputStream();
                // 跳过 startPos 个字节，表明该线程只下载自己负责的那部分文件
                inStream.skip(this.startPos);
                byte[] buffer = new byte[1024];
                int hasRead = 0;
                // 读取网络数据，并写入本地文件
                while (length &lt; currentPartSize
                    &amp;&amp; (hasRead = inStream.read(buffer)) != -1)&#123;
                    currentPart.write(buffer, 0, hasRead);
                    // 累计该线程下载的总大小
                    length += hasRead;
                &#125;
                currentPart.close();
                inStream.close();
            &#125; catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="URLPermission"><a href="#URLPermission" class="headerlink" title="URLPermission"></a>URLPermission</h4><p>Java8 新增，用于管理 HttpURLConnection 的权限问题，如果在 HttpURLConnection 安装了安全管理器，通过该对象打开连接时就需要先获得权限。</p>
<p>读取 URL 资源步骤：</p>
<ul>
<li>openConnection() 获取 URLConnection 对象</li>
<li>设置 URLConnection 的参数和普通请求属性</li>
<li>GET 请求直接 connect() 建立和远程资源的实际连接；POST 请求，需要获取 URLConnection 实例对应的输出流来发送请求参数。</li>
<li>远程资源变为可用</li>
</ul>
<p>在建立和远程资源的实际连接之前，可以通过如下方法来设置请求头字段。</p>
<ul>
<li>setAllowUserInteraction()</li>
<li>setDoInput()</li>
<li>setDoOutput()</li>
<li>setIfModifiedSince()</li>
<li>serUseCaches</li>
<li>setRequestProperty(String key, String value)：添加通用头字段</li>
<li>addRequestProperty(String key, String value): 追加，不覆盖</li>
</ul>
<p>远程资源可用后，可以访问头字段和内容</p>
<ul>
<li>Object getContent()</li>
<li>String getHeaderField(String name)</li>
<li>getInputStream()：用于获取 URLConnection 内容</li>
<li>getOutputStream()：用于向 URLConnection 发送请求参数</li>
<li>getHeaderField()</li>
<li>getContentEncoding()</li>
<li>getContentLength()</li>
<li>getContentType()</li>
<li>getDate()</li>
<li>getExpiration()</li>
<li>getLastModified()</li>
</ul>
<pre><code class="java">/**
 * 向指定 URL 发送 GET 方式的请求
 * @param url
 * @param param
 * @return
 */
public static String sendGet(String url, String param) &#123;
    String result = &quot;&quot;;
    String urlName = url + &quot;?&quot; + param;
    try &#123;
        URL realUrl = new URL(urlName);
        // 打开和 URL 之间的连接
        URLConnection conn = realUrl.openConnection();
        // 设置通用的请求属性
        conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);
        conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);
        conn.setRequestProperty(&quot;user-agent&quot;,
                &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;);
        // 建立实际的连接
        conn.connect();
        // 获取所有的响应头字段
        Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();
        for (String key : map.keySet()) &#123;
            System.out.println(key + &quot;----&gt;&quot; + map.get(key));
        &#125;
        try(
                // 定义 BufferedReader 输入流来读取 URL 的响应
                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;utf-8&quot;)))
        &#123;
            String line;
            while ((line = in.readLine()) != null) &#123;
                result += &quot;\n&quot; + line;
            &#125;
        &#125;
    &#125; catch (Exception e) &#123;
        System.out.println(&quot;发送 GET 请求出现异常！&quot; + e);
        e.printStackTrace();
    &#125;
    return result;
&#125;

/**
 * 向指定 URL 发送 POST 方式请求
 * @param url
 * @param param
 * @return
 */
public static String sendPost(String url, String param) &#123;
    String result = &quot;&quot;;
    try &#123;
        URL realUrl = new URL(url);
        // 打开和 URL 之间的连接
        URLConnection conn = realUrl.openConnection();
        // 设置通用的请求属性
        conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);
        conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);
        conn.setRequestProperty(&quot;user-agent&quot;,
                &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;);
        // 发送 POST 请求必须设置如下两行
        conn.setDoInput(true);
        conn.setDoOutput(true);
        try(
            // 获取 URLConnection 对象对应的输出流
            PrintWriter out = new PrintWriter(conn.getOutputStream()))
        &#123;
            // 发送请求参数
            out.print(param);
            // flush 输出流的缓存
            out.flush();
        &#125;
        try(
            // 读取 URL 的响应
            final BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;utf-8&quot;)))
        &#123;
            String line;
            while ((line = in.readLine()) != null) &#123;
                result += &quot;\n&quot; + line;
            &#125;
        &#125;
    &#125; catch (Exception e) &#123;
        System.out.println(&quot;发送 POST 请求出现异常！&quot; + e);
        e.printStackTrace();
    &#125;
    return result;
&#125;</code></pre>
<h2 id="17-3-基于-TCP-协议的网络编程"><a href="#17-3-基于-TCP-协议的网络编程" class="headerlink" title="17.3 基于 TCP 协议的网络编程"></a>17.3 基于 TCP 协议的网络编程</h2><p>TCP/IP 通信协议是一种可靠的网络协议，他在通信的两端各建立一个 Socket 从而在通信的两端之间形成网络虚拟链路。一旦建立了链路，就可以进行通信了。</p>
<h3 id="17-3-1-TCP-协议基础"><a href="#17-3-1-TCP-协议基础" class="headerlink" title="17.3.1 TCP 协议基础"></a>17.3.1 TCP 协议基础</h3><p>通过使用 IP 协议，从而使得 Internet 成为一个允许连接不同类型的计算机和不同操作系统的网络。</p>
<p>要使两台计算机彼此能进行通信，必须使两台计算机使用同一种语言，IP 协议只保证计算机能发送和接收分组数据，但是 IP 协议不能解决数据分组在传输过程中可能出现的问题，因此还需要 TCP 协议。</p>
<p>TCP 协议负责收集这些信息包，并将其按适当的次序放好传送，接收端收到后再将其正确的还原。TCP 协议保证了数据包在传送中准确无误。</p>
<p>凡是要连接到 Internet 的计算机，都必须同时安装和使用这两个协议。</p>
<h3 id="17-3-2-使用-ServerSocket-创建-TCP-服务器端"><a href="#17-3-2-使用-ServerSocket-创建-TCP-服务器端" class="headerlink" title="17.3.2 使用 ServerSocket 创建 TCP 服务器端"></a>17.3.2 使用 ServerSocket 创建 TCP 服务器端</h3><ul>
<li>Socket accept()：如果收到一个客户端 Socket 的连接请求，该方法返回一个与客户端 Socket 对应的Socket；否则该方法将一直处于等待状态，线程也被阻塞。</li>
</ul>
<p>ServerSocket 提供如下几个构造器:</p>
<ul>
<li>ServerSocket(int port)</li>
<li>ServerSocket(int port, int backlog)：增加改变连接队列长度的参数</li>
<li>ServerSocket(int port, int backlog, InetAddress addr)：在机器存在多个 IP 地址的情况下，可以指定 IP</li>
</ul>
<p>通常情况下，ServerSocket 不应该只接收一个客户端请求，所以通常会写个死循环。</p>
<h3 id="17-3-3-使用-Socket-进行通信"><a href="#17-3-3-使用-Socket-进行通信" class="headerlink" title="17.3.3 使用 Socket 进行通信"></a>17.3.3 使用 Socket 进行通信</h3><p>构造器</p>
<ul>
<li>Socket(InetAddress/String remoteAddr, int port)</li>
<li>Socket(InetAddress/String remoteAddr, int port, InetAddr localAddr, int localPort)</li>
</ul>
<p>客户端连接到指定服务端后，不再区分客户端服务端，而是通过两个 socket 进行通讯</p>
<ul>
<li>InputStream getInputStream()：返回给 socket 对象对应的输入流，让程序通过该输入流从 socket 中取出数据</li>
<li>OutputStream getOutputStream()：向 socket 输出数据</li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre><code class="java">public class Server &#123;
    public static void main(String[] args) throws IOException, InterruptedException &#123;
        // 创建一个 ServerSocket，用于监听客户端 Socket 的连接请求
        ServerSocket ss = new ServerSocket(30000);
        // 循环不断地接收来自客户端的请求
        while (true) &#123;
            // 每当接收到客户端 Socket 的请求时，服务端也会对应产生一个 Socket
            Socket s = ss.accept();
            s.setSoTimeout(5000);

            // 将 Socket 对应的输出流包装成 PrintStream
            final PrintStream ps = new PrintStream(s.getOutputStream());
            // 进行普通的 IO 操作
            // Thread.sleep(6000); // 验证 SoTimeout，让 Client 超时
            ps.println(&quot;新年快乐&quot;);

            final BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
            final String line = br.readLine();
            System.out.println(&quot;客户端说：&quot; + line);

            // 关闭输出流，关闭 Socket
            ps.close();
            br.close();
            s.close();
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="java">public class C1ient &#123;
    public static void main(String[] args) throws IOException, InterruptedException &#123;
        final Socket socket = new Socket(&quot;127.0.0.1&quot;, 30000);
        socket.setSoTimeout(5000);

        // 将 Socket 对应的输入流包装成 BufferedReader
        final BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        final String line = br.readLine();
        System.out.println(&quot;服务器说：&quot; + line);

        final PrintStream ps = new PrintStream(socket.getOutputStream());
        // Thread.sleep(6000); // 验证 SoTimeout，让 Client 超时
        ps.print(&quot;我是01号客户端，请求连接。&quot;);

        ps.close();
        br.close();
        socket.close();
    &#125;
&#125;</code></pre>
<h4 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h4><p>Socket 构造器没有超时时间参数。</p>
<pre><code class="java">// 创建一个无连接的 Socket
Socket s = new Socket();
// 通过 connect 方法设置连接超时时间
s.connect(new InetSocketAddress(host, portt), 10000);</code></pre>
<h3 id="17-3-4-加入多线程"><a href="#17-3-4-加入多线程" class="headerlink" title="17.3.4 加入多线程"></a>17.3.4 加入多线程</h3><p>在使用传统的 BufferedReader 的 readLine() 方法读取数据时，在该方法成功返回之前，线程被阻塞，程序无法继续执行。考虑到这个原因，服务器端应该单独启动一个线程，每个线程负责与一个客户端进行通信。</p>
<p>客户端服务服务端数据的线程同样会被阻塞，所以系统应该单独启动一个线程，该线程专门负责服务服务器端数据。</p>
<h4 id="C-S-聊天室应用"><a href="#C-S-聊天室应用" class="headerlink" title="C/S 聊天室应用"></a>C/S 聊天室应用</h4><p>服务器端包含多个线程，每个 Socket 对应一个线程，该线程负责读取 Socket 对应输入流的数据，并将读到的数据向每个 Socket 输出流发送一次（将一个客户端发送的数据广播给其他客户端）。</p>
<pre><code class="java">public class MyServer &#123;
    // 定义保存所有 Socket 的集合
    public static List&lt;Socket&gt; socketList = Collections.synchronizedList(new ArrayList&lt;&gt;());

    public static void main(String[] args) throws IOException &#123;
        final ServerSocket ss = new ServerSocket(30000);
        while (true) &#123;
            // 阻塞，将一直等待别人的连接
            final Socket s = ss.accept();
            socketList.add(s);
            // 每当客户端连接后启动一个 ServerThread 线程为该客户端服务
            new Thread(new ServerThread(s)).start();
        &#125;
    &#125;
&#125;

// 负责处理每个线程通信的线程类
public class ServerThread implements Runnable&#123;
    // 定义当前线程所处理的 socket
    Socket s = null;
    // 该线程所处理的 Socket 对应的输入流
    BufferedReader br = null;
    public ServerThread(Socket s) throws IOException &#123;
        this.s = s;
        // 初始化该 socket 对应的输入流
        br = new BufferedReader(new InputStreamReader(s.getInputStream()));
    &#125;
    @Override
    public void run() &#123;
        try &#123;
            String content = null;
            // 采用循环，不断从 socket 中读取客户端发送的数据
            while ((content = readFromClient()) != null) &#123;
                // 遍历 socketList 中每个 Socket
                // 将读到的内容向每个 Socket 发送一次
                for (Socket s : MyServer.socketList) &#123;
                    final PrintStream ps = new PrintStream(s.getOutputStream());
                    ps.println(content);
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    // 定义读取客户端数据的方法
    private String readFromClient() &#123;
        try &#123;
            return br.readLine();
        &#125; catch (IOException e) &#123;
            // 如果报错，表明该 Socket 对应的客户端已经关闭，移除对应服务端 socket
            MyServer.socketList.remove(s);
        &#125;
        return null;
    &#125;
&#125;</code></pre>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        final Socket s = new Socket(&quot;127.0.0.1&quot;, 30000);
        // 客户端启动 ClientThread 线程不断地读取来自服务器的数据
        new Thread(new ClientThread(s)).start();
        // 获取该 Socket 对应的输出流
        final PrintStream ps = new PrintStream(s.getOutputStream());
        String line = null;
        // 不断地读取键盘输入
        final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        while ((line = br.readLine()) != null) &#123;
            // 将用户的键盘输入内容写入 Socket 对应的输入流
            ps.println(line);
        &#125;
    &#125;
&#125;

public class ClientThread implements Runnable &#123;
    // 该线程负责处理的 Socket
    private Socket s;
    // 该线程所处理的 Socket 对应的输入流
    BufferedReader br = null;
    public ClientThread(Socket s) throws IOException &#123;
        this.s = s;
        br = new BufferedReader(new InputStreamReader(s.getInputStream()));
    &#125;
    @Override
    public void run() &#123;
        try &#123;
            String content = null;
            // 不断地读取 Socket 输入流中的内容，并将这些内容打印输出
            while ((content = br.readLine()) != null) &#123;
                System.out.println(content);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="17-3-5-记录用户信息"><a href="#17-3-5-记录用户信息" class="headerlink" title="17.3.5 记录用户信息"></a>17.3.5 记录用户信息</h3><p>实现私聊功能。</p>
<ul>
<li><p>客户端发送的信息必须有特殊的标识，让服务器可以判断是公聊信息还是私聊信息。</p>
</li>
<li><p>如果是私聊信息，客户端会发送该消息的目标用户。</p>
</li>
</ul>
<h4 id="定义协议字符"><a href="#定义协议字符" class="headerlink" title="定义协议字符"></a>定义协议字符</h4><pre><code class="java">public interface ChatProtocol &#123;
    // 定义协议字符串的长度
    int PROTOCOL_LEN = 1;
    // 下面是一些协议字符串，服务器端和客户端交换信息都应该在前、后添加这种特殊字符
    String MSG_ROUND = &quot;$&quot;;     // 公聊
    String USER_ROUND = &quot;Π&quot;;    // 登录
    String LOGIN_SUCCESS = &quot;1&quot;; // 登录成功
    String NAME_REP = &quot;-1&quot;;     // 登录失败
    String PRIVATE_ROUND = &quot;⭐&quot;;// 私聊
    String SPLIT_SING = &quot;❄&quot;;    // 私聊时分隔符
&#125;</code></pre>
<h4 id="自定义-map"><a href="#自定义-map" class="headerlink" title="自定义 map"></a>自定义 map</h4><pre><code class="java">// 通过组合 HashMap 对象来实现 UserMap，要求 value 也不能重复
public class UserMap&lt;K,V&gt; &#123;
    // 创建一个线程安全的 map
    public Map&lt;K,V&gt; map = Collections.synchronizedMap(new HashMap&lt;K,V&gt;());
    // 根据 value 来删除指定项
    public synchronized void removeByValue(Object value) &#123;
        for (Object key : map.keySet()) &#123;
            if(map.get(key) == value) &#123;
                map.remove(key);
                break;
            &#125;
        &#125;
    &#125;
    // 获取所有 value 组成的 set 集合
    public synchronized Set&lt;V&gt; valueSet() &#123;
        Set&lt;V&gt; result = new HashSet&lt;&gt;();
        // 将 map 中所有 value 添加到 result 中
        map.forEach((key, value) -&gt; result.add(value));
        return result;
    &#125;
    // 根据 value 查找 key
    public synchronized K getKeyByValue(V val) &#123;
        for(K key : map.keySet()) &#123;
            if(map.get(key) == val || map.get(key).equals(val)) &#123;
                return key;
            &#125;
        &#125;
        return null;
    &#125;
    // 实现 put 方法，该方法不允许 value 重复
    public synchronized V put(K key, V value) &#123;
        for(V val : valueSet()) &#123;
            if(val.equals(value) &amp;&amp; val.hashCode() == value.hashCode()) &#123;
                throw new RuntimeException(&quot;UserMap 实例中不允许有重复的 value&quot;);
            &#125;
        &#125;
        return map.put(key, value);
    &#125;
&#125;</code></pre>
<p>严格来说，UserMap 已经不是一个标准的 Map，但程序需要这样一个数据结构。即可以通过用户名找到对应的输出流也可以根据输出流找到对应的用户名。</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><pre><code class="java">public class Server &#123;

    private static final int SERVER_PORT = 30000;
    // 使用 UserMap 来保存每个客户名字和对应输出流之间的映射
    public static UserMap&lt;String, PrintStream&gt; clients = new UserMap&lt;&gt;();
    public void init() &#123;
        try(// 创建一个 ServerSocket，用于监听客户端 Socket 的连接请求
            ServerSocket ss = new ServerSocket(SERVER_PORT))
        &#123;
            while (true) &#123;
                final Socket socket = ss.accept();
                new ServerThread(socket).start();
            &#125;
        &#125; catch (IOException ex) &#123;
            ex.printStackTrace();
            System.out.println(&quot;服务器启动失败。&quot;);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Server server = new Server();
        server.init();
    &#125;
&#125;</code></pre>
<h4 id="ServerThread"><a href="#ServerThread" class="headerlink" title="ServerThread"></a>ServerThread</h4><pre><code class="java">public class ServerThread extends Thread &#123;
    private Socket socket;
    BufferedReader br = null;
    PrintStream ps = null;
    public ServerThread(Socket socket) &#123;
        this.socket = socket;
    &#125;
    public void run() &#123;
        try &#123;
            // 获取该 Socket 对应的输入流
            br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            // 获取该 Socket 对应的输出流
            ps = new PrintStream(socket.getOutputStream());
            String line = null;
            while ((line = br.readLine()) != null) &#123;
                // 以ServerThread开始和结束，则确定读取到的为登录的用户名
                if(line.startsWith(ChatProtocol.USER_ROUND)
                  &amp;&amp; line.endsWith(ChatProtocol.USER_ROUND)) &#123;
                    // 得到真实消息
                    String userName = getRealMsg(line);
                    // 如果用户名重复
                    if(Server.clients.map.containsKey(userName))&#123;
                        System.out.println(&quot;登录失败，用户名重复。&quot;);
                        ps.println(ChatProtocol.NAME_REP);
                    &#125; else &#123;
                        System.out.println(&quot;登录成功。&quot;);
                        ps.println(ChatProtocol.LOGIN_SUCCESS);
                        Server.clients.put(userName, ps);
                    &#125;
                &#125; else if(line.startsWith(ChatProtocol.PRIVATE_ROUND)
                  &amp;&amp; line.startsWith(ChatProtocol.PRIVATE_ROUND))&#123;
                    // 以 PRIVATE_ROUND 开始和结尾，则确定为私聊信息
                    // 得到真实消息
                    String userAndMsg = getRealMsg(line);
                    // 以 SPLIT_SIGN 分割，前半是私聊用户，后半是聊天信息
                    String user = userAndMsg.split(ChatProtocol.SPLIT_SING)[0];
                    String msg = userAndMsg.split(ChatProtocol.SPLIT_SING)[1];
                    // 获取私聊用户对应的输出流，并发送私聊信息
                    Server.clients.map.get(user).println(Server.clients.
                            getKeyByValue(ps) + &quot;悄悄对你说：&quot; + msg);
                &#125; else &#123;
                    // 公聊
                    // 得到真实信息
                    String msg = getRealMsg(line);
                    for(PrintStream clientPs : Server.clients.valueSet()) &#123;
                        clientPs.println(Server.clients.getKeyByValue(ps)
                            + &quot;说&quot; + msg);
                    &#125;
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            Server.clients.removeByValue(ps);
            System.out.println(Server.clients.map.size());
            // 关闭网络、IO资源
            try &#123;
                if(br != null) &#123;
                    br.close();
                &#125;
                if(ps != null) &#123;
                    ps.close();
                &#125;
                if(socket != null) &#123;
                    socket.close();
                &#125;
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
            e.printStackTrace();
        &#125;
    &#125;
    // 将读到的内容去掉前后的协议字符
    private String getRealMsg(String line) &#123;
        return line.substring(ChatProtocol.PROTOCOL_LEN,
                line.length() - ChatProtocol.PROTOCOL_LEN);
    &#125;
&#125;</code></pre>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><pre><code class="java">public class Client &#123;
    private static final int SERVER_PORT = 30000;
    private Socket socket;
    private PrintStream ps;
    private BufferedReader brServer;
    private BufferedReader keyIn;
    public void init() &#123;
        try &#123;
            // 初始化代表键盘的输入流
            keyIn = new BufferedReader(new InputStreamReader(System.in));
            // 连接到服务器
            socket = new Socket(&quot;127.0.0.1&quot;, SERVER_PORT);
            // 获取该 Socket 对应的输入流和输出流
            ps = new PrintStream(socket.getOutputStream());
            brServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String tip = &quot;&quot;;
            while (true) &#123;
                String userName = JOptionPane.showInputDialog(tip
                  + &quot;输入用户名&quot;);
                // 在用户输入用户民前后增加协议字符串后发送给服务器
                ps.println(ChatProtocol.USER_ROUND + userName + ChatProtocol.USER_ROUND);;
                // 读取服务器的响应
                final String result = brServer.readLine();
                // 如果用户名重复，则开始下次循环
                if(result.equals(ChatProtocol.NAME_REP)) &#123;
                    tip = &quot;用户名重复！请重新&quot;;
                    continue;
                &#125;
                // 如果服务器返回成功，则循环结束
                if(result.equals(ChatProtocol.LOGIN_SUCCESS)) &#123;
                    break;
                &#125;
            &#125;
        &#125; catch (UnknownHostException e) &#123;
            System.out.println(&quot;找不到远程服务器，请确定服务器已经启动&quot;);
            closeRs();
            System.exit(1);
        &#125; catch (IOException e) &#123;
            System.out.println(&quot;网络异常！请重新登录&quot;);
            closeRs();
            System.exit(1);
        &#125;
        // 以该 Socket 对应的输入流启动 ClientThread 线程
        new ClientThread(brServer).start();
    &#125;
    // 定义一个读取键盘输出，并向网络发送的方法
    private void readAndSend() &#123;
        try&#123;
            // 不断服务键盘输入
            String line = null;
            while ((line = keyIn.readLine()) != null) &#123;
                // 如果发送的信息中有冒号，且以 // 开头，则认为私聊
                if(line.indexOf(&quot;:&quot;)&gt;0 &amp;&amp; line.startsWith(&quot;//&quot;))&#123;
                    line = line.substring(2);
                    ps.println(ChatProtocol.PRIVATE_ROUND +
                            line.split(&quot;:&quot;)[0] + ChatProtocol.SPLIT_SING +
                            line.split(&quot;:&quot;)[1] + ChatProtocol.PRIVATE_ROUND
                            );
                &#125; else &#123;
                    ps.println(ChatProtocol.MSG_ROUND + line + ChatProtocol.MSG_ROUND);
                &#125;
            &#125;
        &#125; catch (IOException ex) &#123;
            System.out.println(&quot;网络通信异常！请重新登录！&quot;);
            closeRs();
            System.exit(1);
        &#125;
    &#125;
    // 关闭 Socket、输入流、输出流
    private void closeRs() &#123;
        try &#123;
            if (keyIn != null) &#123;
                keyIn.close();
            &#125;
            if (brServer != null) &#123;
                brServer.close();
            &#125;
            if(ps != null) &#123;
                ps.close();
            &#125;
            if(socket != null) &#123;
                socket.close();
            &#125;
        &#125; catch (IOException ex) &#123;
            ex.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Client client = new Client();
        client.init();
        client.readAndSend();
    &#125;
&#125;</code></pre>
<h4 id="ClientThread"><a href="#ClientThread" class="headerlink" title="ClientThread"></a>ClientThread</h4><pre><code class="java">public class ClientThread extends Thread &#123;
    // 该客户端线程负责处理的输入流
    BufferedReader br = null;
    // 使用一个网络输入流来创建客户端线程
    public ClientThread(BufferedReader br) &#123;
        this.br = br;
    &#125;
    @Override
    public void run() &#123;
        try &#123;
            String line = null;
            // 不断从输入流中读取数据，并将这些数据打印
            while ((line = br.readLine()) != null) &#123;
                System.out.println(line);
                /*
                本例仅打印了从服务器端读到的内容。实际上，此处的情况可以更复杂:如
                果希望客户端能看到聊天室的用户列表，则可以让服务器端在每次有用户登
                录、用户退出时，将所有的用户列表信息都向客户端发送一遍。为了区分服
                务器端发送的是聊天信息，还是用户列表，服务器端也应该在要发送的信息
                前、后都添加一定的协议字符串，客户端则根据协议字符串的不同而进行不
                同的处理!
                更复杂的情况:
                如果两端进行游戏，则还有可能发送游戏信息，例如两端进行五子棋游戏，
                则需要发送下棋坐标信息等，服务器端同样在这些下棋坐标信息前、后添加
                协议字符串后再发送，客户端就可以根据该信息知道对手的下棋坐标。
                */
            &#125;
        &#125; catch (IOException ex) &#123;
            ex.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if(br != null) &#123;
                    br.close();
                &#125;
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="17-3-6-半关闭的-Socket"><a href="#17-3-6-半关闭的-Socket" class="headerlink" title="17.3.6 半关闭的 Socket"></a>17.3.6 半关闭的 Socket</h3><p>前面服务总是以行作为通信的最小数据单位。但是在另一些协议里，通信的数据单位可能是多行的。在这种情况下，Socket 的输出流如何表示输出数据已经结束？</p>
<p>在学习 IO 流时，如果要表示输出已经结束，则可以通过关闭输出流来实现，但在网络通信中则不能这样实现，因为一旦关闭输出流，该输出流对应的 Socket 也将随之关闭，这样导致程序无法再从该 Socket 的输入流中读取数据了。</p>
<p>所以 Socket 提供了两个半关闭的方法：</p>
<ul>
<li>shutdownInput()：关闭 socket 输入流，程序还可以通过 socket 的输出流输出数据</li>
<li>shutdownOutput()：与上相反</li>
<li>isInputShutdown()</li>
<li>isOutputShutdown()</li>
</ul>
<h3 id="17-3-7-使用-NIO-实现非阻塞-Socket-通信"><a href="#17-3-7-使用-NIO-实现非阻塞-Socket-通信" class="headerlink" title="17.3.7 使用 NIO 实现非阻塞 Socket 通信"></a>17.3.7 使用 NIO 实现非阻塞 Socket 通信</h3><p>前面介绍的网络通信程序是基于阻塞式 API 的，即当程序执行输入、输出后，在这些操作返回之前会一直阻塞该线程，所以服务器必须为每个客户端都提供一个独立的线程进行处理。</p>
<p>使用 NIO API 则可以让服务器端使用一个或有限的几个线程来同时处理连接到服务器端的所有客户端。</p>
<p>NIO 为非阻塞式 Socket 通信提供了如下几个特殊类：</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><ul>
<li>Selector：它是 SelectaleChannel 对象的多路复用器，所有 Channel 都应该注册到 Selector。通过 open()静态方法创建 Selector 实例。</li>
</ul>
<p>一个 Selector 实例有三个 SelectionKey 集合</p>
<ul>
<li>keys()：所有 SelectionKey 集合，代表注册在该 Selector 上的 Channel。</li>
<li>selectedKeys()：所有可以通过 select() 获取的、需要进行 IO 处理的 Channel</li>
<li>被取消的 SelectionKey 集合：代表所有被取消注册关系的 Channel</li>
</ul>
<p>Selector 还提供了一系列和 select() 相关方法：</p>
<ul>
<li>int select()：监控所有注册的 Channel，当有需要处理的 IO 操作时，该方法返回，并将对应的 SelectionKey 加入被选中 key 集合</li>
<li>int select(long timeout)</li>
<li>int selectNow()：不会阻塞线程</li>
<li>Selector wakeup()：使一个还未返回的 select()方法立即返回</li>
</ul>
<h4 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h4><p>SelectableChannel：代表可以支持非阻塞 IO 操作的 Channel 对象。可以通过 register() 将其注册到指定 Selector 上。</p>
<ul>
<li><p>SelectableChannel configureBlocking(boolean block)：设置是否采用阻塞模式</p>
</li>
<li><p>boolean isBlocking()</p>
</li>
<li><p>int validOps()：表示这个 Channel 所支持的 IO 操作</p>
<ul>
<li>OP_READ(1)</li>
<li>OP_WRITE(4)</li>
<li>OP_CONNECT(8)</li>
<li>OP_ACCEPT(16)</li>
</ul>
</li>
<li><p>boolean isRegistered()</p>
</li>
<li><p>SelectionKey keyFor(Selector sel)</p>
</li>
<li><p>SelectionKey：注册关系</p>
</li>
<li><p>ServerSocketChannel：支持非阻塞操作，对应于 ServerSocket 类，只持支 OP_ACCEPT 操作，也提供了 accept() 方法。</p>
</li>
<li><p>SocketChannel：支持非阻塞操作，对应于 Socket 类，支持 OP_CONNECT、OP_READ 和 OP_WRITE 操作。 该类还实现了 ByteChannel 接口、ScatteringByteChannel 接口和 GatheringByteChannel 接口，所以可以直接读写 ByteBuffer 对象。</p>
</li>
</ul>
<p><img src="../../images/java/c17/NIO.png"></p>
<p>当 Selector 上注册的所有 Channel 都没有需要处理的 IO 操作时，select() 方法将被阻塞。</p>
<h4 id="使用-NIO-实现多人聊天室"><a href="#使用-NIO-实现多人聊天室" class="headerlink" title="使用 NIO 实现多人聊天室"></a>使用 NIO 实现多人聊天室</h4><pre><code class="java">public class NServer &#123;
    // 用于监测所有 Channel 状态的 Selector
    private Selector selector = null;
    static final int PORT = 30000;
    private Charset charset = Charset.forName(&quot;UTF-8&quot;);
    ServerSocketChannel ssc = null;

    public void init() throws IOException &#123;
        // 获取 Selector 对象
        selector = Selector.open();
        // 通过 open 方法来打开一个未绑定的 ServerSocketChannel 实例
        ssc = ServerSocketChannel.open();
        final InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, PORT);
        // 将该 ServerSocketChannel 绑定到指定 IP 地址
        ssc.bind(isa);
        // 设置 ServerSocketChannel 以非阻塞方式工作
        ssc.configureBlocking(false);
        // 将 server 注册到指定的 Selector 对象
        ssc.register(selector, SelectionKey.OP_ACCEPT);

        while (selector.select() &gt; 0) &#123;
            System.out.println(&quot;select()&gt;0&quot;);
            System.out.println(selector.selectedKeys());
            // 处理已选择的 SelectionKey
            for(SelectionKey sk : selector.selectedKeys()) &#123;
                // 从 selector 上已选择的key集合删除当前key
                selector.selectedKeys().remove(sk);
                // 如果 sk 对应的 Channel 包含客户端的连接请求
                if(sk.isAcceptable())&#123;
                    System.out.println(&quot;sk isAcceptable&quot;);
                    // 调用 accept 方法接收连接，产生服务端的 SocketChannel
                    SocketChannel sc = ssc.accept();
                    // 设置采用非阻塞模式
                    sc.configureBlocking(false);
                    // 将该 SocketChannel 也注册到 selector
                    sc.register(selector, SelectionKey.OP_READ);
                    // 将 sk 对应的 Channel 设置成准备接收其他请求
                    sk.interestOps(SelectionKey.OP_ACCEPT);
                &#125;
                // 如果 sk 对应的 Channel 有数据需要读取
                if(sk.isReadable()) &#123;
                    System.out.println(&quot;sk isReadable&quot;);
                    // 读取该 SelectKey 对应的 Channel
                    SocketChannel sc = (SocketChannel) sk.channel();
                    // 定义准备执行读取数据的 ByteBuffer
                    final ByteBuffer buff = ByteBuffer.allocate(1024);
                    String content = &quot;&quot;;
                    // 开始读取数据
                    try &#123;
                        while (sc.read(buff) &gt; 0) &#123;
                            buff.flip();
                            content += charset.decode(buff);
                        &#125;
                        // 打印从该 sk 对应的 Channel 里读取到的数据
                        System.out.println(&quot;读取的数据：&quot; + content);
                        // 将 sk 对应的 Channel 设置成准备下一次读取
                        sk.interestOps(SelectionKey.OP_READ);
                    &#125; catch (IOException ex) &#123;
                        ex.printStackTrace();
                        // 从 Selector 中删除指定的 SelectionKey
                        sk.cancel();
                        if(sk.channel() != null) &#123;
                            sk.channel().close();
                        &#125;
                    &#125;
                    // 如果 content 的长度大于 0，即聊天信息不为空
                    if(content.length()&gt;0) &#123;
                        // 遍历该 selector 里注册的所有 SelectionKey
                        for(SelectionKey key : selector.keys()) &#123;
                            // 获取该key对应的 Channel
                            Channel targetChannel = key.channel();
                            // 如果该 Channel 是 SocketChannel 对象
                            if(targetChannel instanceof SocketChannel)&#123;
                                // 将读到的内容写入还 Channel 中
                                SocketChannel dest = (SocketChannel)targetChannel;
                                dest.write(charset.encode(content));
                            &#125;
                        &#125;
                    &#125;

                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws IOException &#123;
        new NServer().init();
    &#125;
&#125;</code></pre>
<pre><code class="java">public class NClient &#123;
    // 定义监测 SocketChannel 的 Selector 对象
    private Selector selector = null;
    static final int PORT = 30000;
    // 定义处理编码和解码的字符集
    private Charset charset = Charset.forName(&quot;UTF-8&quot;);
    // 客户端 SocketChannel
    private SocketChannel sc = null;

    public void init() throws IOException &#123;
        selector = Selector.open();
        InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, PORT);
        // 调用 open 静态方法创建连接到指定主机的 SocketChannel
        sc = SocketChannel.open(isa);
        // 设置 sc 以非阻塞方式工作
        sc.configureBlocking(false);
        // 将 SocketChannel 对象注册到指定的 Selector
        sc.register(selector, SelectionKey.OP_READ);
        // 启动读取服务器端数据的线程
        new ClientThread().start();
        // 创建键盘输入流
        final Scanner scan = new Scanner(System.in);
        while (scan.hasNextLine()) &#123;
            // 读取键盘输入
            final String line = scan.nextLine();
            // 将键盘输入的内容输出到 SocketChannel 中
            sc.write(charset.encode(line));
        &#125;
    &#125;
    // 定义读取服务器端数据的线程
    private class ClientThread extends Thread &#123;
        @Override
        public void run() &#123;
            try &#123;
                while (selector.select() &gt; 0) &#123;
                    // 遍历每个有而可用 IO 操作的 Channel 对应的 SelectionKey
                    for(SelectionKey sk : selector.selectedKeys())&#123;
                        // 删除正在处理的 SelectionKey
                        selector.selectedKeys().remove(sk);
                        // 如果该 SelectionKey 对应的 Channel 中有可读的数据
                        if(sk.isReadable()) &#123;
                            // 使用 NIO 读取 Channel 中的数据
                            SocketChannel sc = (SocketChannel)sk.channel();
                            ByteBuffer buff = ByteBuffer.allocate(1024);
                            String content = &quot;&quot;;
                            while (sc.read(buff) &gt; 0) &#123;
                                buff.flip();
                                content += charset.decode(buff);
                            &#125;
                            // 打印输出读取的内容
                            System.out.println(&quot;聊天信息：&quot; + content);
                            // 为下一次读取做准备
                            sk.interestOps(SelectionKey.OP_READ);
                        &#125;
                    &#125;
                &#125;
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws IOException &#123;
        new NClient().init();
    &#125;
&#125;</code></pre>
<h3 id="17-3-8-使用-Java7-的-AIO-实现非阻塞通信"><a href="#17-3-8-使用-Java7-的-AIO-实现非阻塞通信" class="headerlink" title="17.3.8 使用 Java7 的 AIO 实现非阻塞通信"></a>17.3.8 使用 Java7 的 AIO 实现非阻塞通信</h3><p>如果按 POSIX 的标准来划分IO ，可以把 IO 分为两类:同步 IO 和异步 IO 。对于 IO 操作可以分成两步:①程序发出 IO 请求;②完成实际的 IO 操作。前面两节所介绍的阻塞 IO、非阻塞 IO 都是针对第一步来划分的。但同步 IO 和异步 IO 区别在第二步，如果实际的 IO 操作<strong>由操作系统完成</strong>，再将结果返回给应用程序， 这就是异步 IO；如果实际的 IO 需要应用程序本身去执行，会阻塞线程，那就是同步 IO 。</p>
<p><img src="../../IMAGES/java/c17/AIO.png"></p>
<p>两个接口，三个实现类。</p>
<h4 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h4><ul>
<li>open() 获取实例</li>
<li>open(AsynchronoutChannelGroup group)</li>
<li>bind() 绑定地址端口</li>
</ul>
<p>创建 AsynchronousServerSocketChannel 实例后，调用 accept() 接收客户端连接。accept() 方法不再阻塞。</p>
<ul>
<li>Future<AsynchronoutSocketChannel> accept()：接收请求，如果需要获取连接成功后返回的 Channel，调用 Future 的 get 方法，但是 get 方法会阻塞。</li>
<li><A> void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super A&gt; handler)：接收请求，成功或失败都会触发 handler 对应的方法。</li>
</ul>
<p>CompletionHandler 是一个接口</p>
<ul>
<li>completed(V result, A attachment)：IO 操作完成时触发。V 为 IO 操作返回的对象；A 为发起 IO 操作时传入的附加参数。</li>
<li>failed(Throwable exc, A attachment)：IO 操作失败时触发</li>
</ul>
<h4 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h4><ul>
<li>open()：获取实例</li>
<li>connect()：连接到指定 ip、端口的服务器</li>
<li>read()、write()：读写</li>
</ul>
<p>read、write 都有两个版本，一个返回 Future一个需要传入 CompletionHandler</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><pre><code class="java">public class SimpleAIOServer &#123;
    static final int PORT = 30000;

    public static void main(String[] args) &#123;
        try(
            // 1. 创建 AsnychronousServerSocketChannel 对象
            AsynchronousServerSocketChannel serverChannel =
                    AsynchronousServerSocketChannel.open())
        &#123;
            // 2. 绑定指定地址、端口
            serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,PORT));
            while (true) &#123;
                // 接收客户端连接
                Future&lt;AsynchronousSocketChannel&gt; future = serverChannel.accept();
                // 获取连接完成后返回的 channel
                AsynchronousSocketChannel socketChannel = future.get();
                // 执行输出
                socketChannel.write(ByteBuffer.wrap(&quot;欢迎来到AIO世界！&quot;
                        .getBytes(&quot;UTF-8&quot;))).get();
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="java">public class SimpleAIOClient &#123;
    static final int PORT = 30000;

    public static void main(String[] args) throws Exception &#123;
        // 用于读取数据的 ByteBuffer
        ByteBuffer buff = ByteBuffer.allocate(1024);
        Charset utf = Charset.forName(&quot;UTF-8&quot;);
        try(
            // 1. 创建 AsynchronousSocketChannel 对象
            AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open())
        &#123;
            // 2. 连接远程服务器
            clientChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT)).get();
            buff.clear();
            // 3. 从 clientChannel 中读取数据
            clientChannel.read(buff).get();
            buff.flip();
            // 将 buff 中的内容转换为字符串
            String content = utf.decode(buff).toString();
            System.out.println(&quot;服务器信息:&quot; + content);
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="AIO-多人聊天工具"><a href="#AIO-多人聊天工具" class="headerlink" title="AIO 多人聊天工具"></a>AIO 多人聊天工具</h4><p>上面程序没有充分利用 Java AIO 的优势，如果要充分挖掘 AIO 优势，应该考虑使用线程池来管理异步 Channel，并使用 ComplettionHandler 来监听异步 IO 操作。</p>
<pre><code class="java">public class AIOServer &#123;
    static final int PORT = 30000;
    final static String UTF_8 = &quot;utf-8&quot;;
    static List&lt;AsynchronousSocketChannel&gt; channelList = new ArrayList&lt;&gt;();
    public void startListen() throws Exception &#123;
        // 创建一个线程池
        final ExecutorService executor = Executors.newFixedThreadPool(20);
        // 以指定线程池来创建一个 AsynchronousChannelGroup
        AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup
                .withThreadPool(executor);
        // 以指定线程池来创建一个 AsynchronoutServerSocketChannel
        AsynchronousServerSocketChannel serverChannel
                = AsynchronousServerSocketChannel.open(channelGroup)
                // 指定监听本机的 PORT 端口
                .bind(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));
        // 使用 CompletionHandler 接收来自客户端的连接请求
        serverChannel.accept(null, new AcceptHandler(serverChannel));
        // Thread.sleep(10000);
    &#125;

    public static void main(String[] args) throws Exception &#123;
        AIOServer server = new AIOServer();
        server.startListen();
        Thread.sleep(10000);
    &#125;
&#125;
// 实现自己的 CompletionHandler 类
class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;&#123;

    private AsynchronousServerSocketChannel serverChannel;
    public AcceptHandler(AsynchronousServerSocketChannel ssc)&#123;
        this.serverChannel = ssc;
    &#125;

    // 定义一个 ByteBuffer 准备读取数据
    ByteBuffer buff = ByteBuffer.allocate(1024);

    // 当实际 IO 操作完成时触发该方法
    @Override
    public void completed(AsynchronousSocketChannel sc, Object attachment) &#123;
        // 记录新连接进来的 Channel
        AIOServer.channelList.add(sc);
        // 准备接收客户端的下一次连接
        serverChannel.accept(null, this);
        sc.read(buff, null, new CompletionHandler&lt;Integer, Object&gt;() &#123;
            @Override
            public void completed(Integer result, Object attachment) &#123;
                buff.flip();
                // 将 buff 中的内容转换为字符串
                String content = StandardCharsets.UTF_8.decode(buff).toString();
                // 遍历每个 Channel,将收到的信息写入各 Channel 中
                for(AsynchronousSocketChannel c : AIOServer.channelList)&#123;
                    try &#123;
                        c.write(ByteBuffer.wrap(content.getBytes(AIOServer.UTF_8)))
                                .get();
                    &#125; catch (Exception ex) &#123;
                        ex.printStackTrace();
                    &#125;
                &#125;
                buff.clear();
                // 读取下一次数据
                sc.read(buff, null, this);
            &#125;
            @Override
            public void failed(Throwable exc, Object attachment) &#123;
                System.out.println(&quot;读取数据失败:&quot; + exc);
                // 从该 Channel 中读取数据失败,就将该 Channel 删除
                AIOServer.channelList.remove(sc);
            &#125;
        &#125;);
    &#125;
    @Override
    public void failed(Throwable exc, Object attachment) &#123;
        System.out.println(&quot;连接失败:&quot; + exc);
    &#125;
&#125;</code></pre>
<pre><code class="java">public class AIOClient &#123;
    final static String UTF_8 = &quot;utf-8&quot;;
    final static int PORT = 30000;
    // 与服务器端通信的异步 Channel
    AsynchronousSocketChannel clientChannel;
    JFrame mainWin = new JFrame(&quot;多人聊天&quot;);
    JTextArea jta = new JTextArea(16, 48);
    JTextField jtf = new JTextField(40);
    JButton sendBn = new JButton(&quot;发送&quot;);
    public void init() &#123;
        mainWin.setLayout(new BorderLayout());
        jta.setEditable(false);
        mainWin.add(new JScrollPane(jta), BorderLayout.CENTER);
        JPanel jp = new JPanel();
        jp.add(jtf);
        jp.add(sendBn);
        // 发送消息的 Action,Action 是 ActionListener 的子接口
        Action sendAction = new AbstractAction() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                String content = jtf.getText();
                if (content.trim().length() &gt; 0) &#123;
                    try &#123;
                        // 将 content 内容写入 Channel 中
                        clientChannel.write(ByteBuffer.wrap(content.trim().getBytes(UTF_8))).get();
                    &#125; catch (Exception ex) &#123;
                        ex.printStackTrace();
                    &#125;
                &#125;
                // 清空输入框
                jtf.setText(&quot;&quot;);
            &#125;
        &#125;;
        sendBn.addActionListener(sendAction);
        // 将 Ctrl + Enter 键和 send 关联
        jtf.getInputMap().put(KeyStroke.getKeyStroke(&#39;\n&#39;,
                InputEvent.CTRL_DOWN_MASK), &quot;send&quot;);
        // 将 send 和 sendAction 关联
        jtf.getActionMap().put(&quot;send&quot;, sendAction);
        mainWin.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        mainWin.add(jp, BorderLayout.SOUTH);
        mainWin.pack();
        mainWin.setVisible(true);
    &#125;
    public void connect() throws Exception &#123;
        // 定义一个 ByteBuffer 准备读取数据
        final ByteBuffer buff = ByteBuffer.allocate(1024);
        // 创建一个线程池
        ExecutorService executor = Executors.newFixedThreadPool(80);
        // 以指定线程池来创建一个 AsynchronousChannelGroup
        AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withThreadPool(executor);
        // 以 channelGroup 作为组管理器来创建 AsynchronousSocketChannel
        clientChannel = AsynchronousSocketChannel.open(channelGroup);
        // 让 AsynchronousSocketChannel 连接到指定 IP 端口
        clientChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT)).get();
        jta.append(&quot;---与服务器连接成功---\n&quot;);
        buff.clear();
        clientChannel.read(buff, null,
                new CompletionHandler&lt;Integer, Object&gt;() &#123;
            @Override
            public void completed(Integer result, Object attachment) &#123;
                buff.flip();
                String content = StandardCharsets.UTF_8.decode(buff).toString();
                // 显示从服务器端读取的数据
                jta.append(&quot;某人说:&quot; + content + &quot;\n&quot;);
                buff.clear();
                clientChannel.read(buff, null, this);
            &#125;
            @Override
            public void failed(Throwable exc, Object attachment) &#123;
                System.out.println(&quot;读取数据失败: &quot; + exc);
            &#125;
        &#125;);
    &#125;

    public static void main(String[] args) throws Exception &#123;
        AIOClient client = new AIOClient();
        client.init();
        client.connect();
    &#125;
&#125;</code></pre>
<h2 id="17-4-基于-UDP-协议的网络编程"><a href="#17-4-基于-UDP-协议的网络编程" class="headerlink" title="17.4 基于 UDP 协议的网络编程"></a>17.4 基于 UDP 协议的网络编程</h2><p>UDP 协议是一种不可靠的网络协议，它在通信实例的两端各建立一个 Socket，但这两个 Socket 之间并没有虚拟链路，这两个 Socket 只是发送、接收数据报的对象。</p>
<p>Java 提供了 DatagramSocket 对象作为 UDP 协议的 Socket，使用 DatagramPacket 代表 DatagramSocket 发送、接收的数据报。</p>
<h3 id="17-4-1-UDP-协议基础"><a href="#17-4-1-UDP-协议基础" class="headerlink" title="17.4.1 UDP 协议基础"></a>17.4.1 UDP 协议基础</h3><p>UDP(User Datagram Protocol)即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络连接。</p>
<p>UDP 协议是一种面向非连接的协议，在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP 协议无法控制。</p>
<p>UDP 协议适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<p>因为 UDP 协议是面向非连接的协议，没有建立连接的过程，因此通信效率很高。</p>
<ul>
<li>TCP：可靠，传输大小无限制，但是需要连接建立时间，差错控制开销大</li>
<li>UDP：不可靠，差错控制开销较小，传输大小限制在 64KB 以下，不需要建立连接。</li>
</ul>
<h3 id="17-4-2-使用-DatagramSocket-发送、接收数据"><a href="#17-4-2-使用-DatagramSocket-发送、接收数据" class="headerlink" title="17.4.2 使用 DatagramSocket 发送、接收数据"></a>17.4.2 使用 DatagramSocket 发送、接收数据</h3><p>DatagramSocket 构造器</p>
<ul>
<li>DatagramSocket()</li>
<li>DatagramSocket(int port)</li>
<li>DatagramSocket(int port, InetAddress addr)</li>
</ul>
<p>DatagramSocket 接收、发送数据</p>
<ul>
<li>receive(DatagramPacket p)</li>
<li>send(DatagramPcket p)</li>
</ul>
<p>DatagramPacket  构造器</p>
<ul>
<li>DatagramPacket(byte[] buf, int length)：以空数组创建 DatagramPacket，作用是接收 DatagramSocket 中的数据</li>
<li>DatagramPacket(byte[] buf, int length, InetAddress addr, int port)：以包含数据的数组来创建 DatagramPacket 对象</li>
<li>DatagramPacket(byte[] buf, int offset, int length)：以空数组创建 DatagramPacket，并指定接收到的数据放入 buf，从 offset 开始，最多放 length</li>
<li>DatagramPacket(byte[] buf, int offset, int length, int prot)</li>
</ul>
<p>接收数据应该用第一个和第三个；发送数据应该用第二个和第四个。</p>
<p>获取发送者信息：</p>
<ul>
<li>InetAddress getAddress()</li>
<li>int getPort()</li>
<li>SocketAddress getSocketAddress()</li>
</ul>
<pre><code class="java">public class UdpServer &#123;
    public static final int PORT = 30000;
    // 定义每个数据包的大小最大为 4kb
    private static final int DATA_LEN = 4096;
    // 定义接收网络数据的子接数组
    byte[] inBuff = new byte[DATA_LEN];
    // 以指定子接数组创建准备接收数据的 DatagramPacket 对象
    private DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);
    // 定义一个用于发送的 DatagramPacket 对象
    private DatagramPacket outPacket;
    // 定义一个字符串数组,服务端发送该数组的元素
    String[] books = new String[] &#123;
            &quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;
    &#125;;
    public void init() throws IOException &#123;
        try(
            // 创建 DatagramSocket 对象
            DatagramSocket socket = new DatagramSocket(PORT))
        &#123;
            // 采用循环接收数据
            for (int i = 0; i &lt; 1000; i++) &#123;
                // 读取 Socket 中的数据,读到的数据放入 inPacket 封装的数组里
                socket.receive(inPacket);
                // 判断 inPacket.getData() 和 inBuff 是否是同一个数组
                System.out.println(inBuff == inPacket.getData());
                // 将接收到的内容转换成字符串后输出
                System.out.println(new String(inBuff, 0, inPacket.getLength()));
                // 从字符串数组中取出一个元素作为发送的数据
                byte[] sendData = books[i % 3].getBytes();
                outPacket = new DatagramPacket(sendData, sendData.length, inPacket.getSocketAddress());
                // 发送数据
                socket.send(outPacket);
            &#125;
        &#125;
    &#125;
    public static void main(String[] args) throws IOException &#123;
        new UdpServer().init();
    &#125;
&#125;</code></pre>
<pre><code class="java">public class UdpClient &#123;
    // 定义发送数据报的目的地
    public static final int DEST_PORT = 30000;
    public static final String DEST_IP = &quot;127.0.0.1&quot;;
    // 定义每个数据报的大小最大为 4kb
    private static final int DATA_LEN = 4096;
    // 定义接收网络数据的字节数组
    byte[] inBuff = new byte[DATA_LEN];
    // 以指定的字节数组创建准备接收数据的 DatagramPacket 对象
    private DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);
    // 定义一个用于发送的 DatagramSocket 对象
    private DatagramPacket outPacket = null;
    public void init() throws IOException &#123;
        try(
            // 创建一个客户端 DatagramSockett,使用随机端口
            DatagramSocket socket = new DatagramSocket())
        &#123;
            // 初始化发送用的 DatagramSocket
            outPacket = new DatagramPacket(new byte[0],
                    0, InetAddress.getByName(DEST_IP), DEST_PORT);
            // 创建键盘输入流
            Scanner scan = new Scanner(System.in);
            // 不断地读取键盘输入
            while (scan.hasNextLine()) &#123;
                byte[] buff = scan.nextLine().getBytes();
                outPacket.setData(buff);
                // 发送数据
                socket.send(outPacket);
                // 读取 socket 中的数据
                socket.receive(inPacket);
                System.out.println(new String(inBuff, 0, inPacket.getLength()));;
            &#125;
        &#125;
    &#125;
    public static void main(String[] args) throws IOException &#123;
        new UdpClient().init();
    &#125;
&#125;</code></pre>
<h3 id="17-4-3-使用-MulticaseSocket-实现多点广播"><a href="#17-4-3-使用-MulticaseSocket-实现多点广播" class="headerlink" title="17.4.3 使用 MulticaseSocket 实现多点广播"></a>17.4.3 使用 MulticaseSocket 实现多点广播</h3><p>DatagramSocket 只允许数据报发送给指定的目标地址，而 MulticastSocket 可以将数据报以广播方式发送到多个客户端。</p>
<p>其思想是设置一组特殊网络地址作为多点广播地址，每一个多点广播地址都被看做一个组，当客户端需要发送、接收广播信息时，加入到该组即可。</p>
<p>IP 协议为多点广播提供了这批特殊的 IP 地址，这些 IP 地址的范围是 :224.O.0.0 至 239.255.255.255</p>
<p><img src="D:/02_blog/blog/source/images/java/c17/多点广播.png"></p>
<p>当 MulticastSocket 把一个 DatagramP acket 发送到多点广播E 地址时， 该数据报将被自动广播到加入该地址的所有Multicast Socket。MulticastSocket 既可以将数据报发送到多点广播地址，也可以接收其他主机的广播信息。</p>
<p>构造器</p>
<ul>
<li>public MulticastSocket()</li>
<li>public MulticastSocket(int port)</li>
<li>public MulticastSocket(SocketAddress addr)</li>
</ul>
<p>如果创建仅用于发送数据报的 MulticastSocket 对象，则使用默认地址、随机端口即可。但如果创建接收用的MulticastSocket 对象，则该MulticastSocket 对象必须具有指定端口。</p>
<p>MulticastSocket 加入到指定的多点广播地址</p>
<ul>
<li>joinGroup(InetAddress multicastAddr)</li>
<li>leaveGroup(InetAddress multicastAddr)</li>
</ul>
<p>TimeToLive</p>
<ul>
<li><p>setTimeToLive(int ttl)：设置数据报最多可以跨国多少个网络</p>
<ul>
<li>0：数据报应停留在本机</li>
<li>1：局域网（默认）</li>
<li>32：本站点</li>
<li>64：本地区</li>
<li>128：本大洲</li>
<li>255：所有地方</li>
</ul>
</li>
</ul>
<h2 id="17-5-使用代理服务器"><a href="#17-5-使用代理服务器" class="headerlink" title="17.5 使用代理服务器"></a>17.5 使用代理服务器</h2><p>Java5 开始，提供 Proxy 和 ProxySelector。Rroxy 代表一个代理服务器，可以在打开 URLConnection 连接时指定 Proxy，创建 Socket 连接时也可以指定 Proxy。</p>
<p>代理服务器功能：</p>
<ul>
<li>突破自身 IP 限制，对外隐藏自身 IP 地址，访问国外受限站点，访问国内特定单位、团体的内部资源。</li>
<li>提高访问速度，代理服务器提供的缓冲功能可以避免每个用户直接访问呢远程主机，从而提高客户端访问速度。</li>
</ul>
<h3 id="17-5-1-直接使用-Proxy-创建连接"><a href="#17-5-1-直接使用-Proxy-创建连接" class="headerlink" title="17.5.1 直接使用 Proxy 创建连接"></a>17.5.1 直接使用 Proxy 创建连接</h3><p>构造器：</p>
<ul>
<li>Proxy(Proxy.Type type, SocketAddress sa)<ul>
<li>Proxy.Type.DIRECT：直接连接，不使用代理</li>
<li>Proxy.Type.HTTP：支持高级协议代理，如 HTTP、FTP</li>
<li>Proxy.Type.SOCKS：表示 SOCKS(v4或V5)代理</li>
</ul>
</li>
</ul>
<pre><code class="java">public class ProxyTest &#123;
    // 代理服务器的地址
    final String PROXY_ADDR = &quot;129.82.12.188&quot;;
    final int PROXY_PORT = 3124;
    // 定义需要访问的网站地址
    String urlStr = &quot;http://www.baidu.com&quot;;
    public void init() throws Exception&#123;
        URL url = new URL(urlStr);
        // 创建一个代理服务器对象
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                new InetSocketAddress(PROXY_ADDR, PROXY_PORT));
        // 使用指定的代理服务器打开连接
        URLConnection conn = url.openConnection(proxy);
        // 设置超时时长
        conn.setConnectTimeout(3000);
        try(
            // 通过代理服务器读取数据的 Scanner
            Scanner scan = new Scanner(conn.getInputStream());
            PrintStream ps = new PrintStream(&quot;index.html&quot;))
        &#123;
            while (scan.hasNextLine()) &#123;
                String line = scan.nextLine();
                System.out.println(line);
                // 将网页资源内容输出到指定输出流
                ps.println(line);
            &#125;
        &#125;
    &#125;
    public static void main(String[] args) throws Exception &#123;
        new ProxyTest().init();
    &#125;
&#125;</code></pre>
<h3 id="17-5-2-使用-ProxySelector-自动选择代理服务器"><a href="#17-5-2-使用-ProxySelector-自动选择代理服务器" class="headerlink" title="17.5.2 使用 ProxySelector 自动选择代理服务器"></a>17.5.2 使用 ProxySelector 自动选择代理服务器</h3><p>上面的方式每次打开 http 或 socket 连接时都要显示的设置代理服务器，比较麻烦。ProxySelector 可以实现默认代理服务器。</p>
<ul>
<li>List<Proxy> select(URI uri)：根据业务需要返回代理服务器列表，如果只有一个 Porxy，将会作为默认代理服务器。</li>
<li>connectFailed(URI uri, SOcketAddress sa, IOException ioe)</li>
</ul>
<pre><code class="java">public class ProxySelectorTest &#123;
    // 代理服务器的地址
    final String PROXY_ADDR = &quot;129.82.12.188&quot;;
    final int PROXY_PORT = 3124;
    // 定义需要访问的网站地址
    String urlStr = &quot;http://www.baidu.com&quot;;
    public void init() throws Exception&#123;
        // 注册默认的代理选择器
        ProxySelector.setDefault(new ProxySelector() &#123;
            @Override
            public List&lt;Proxy&gt; select(URI uri) &#123;
                System.out.println(&quot;select&quot;);
                // 本程序总是返回某个固定的代理服务器
                List&lt;Proxy&gt; result = new ArrayList&lt;&gt;();
                result.add(new Proxy(Proxy.Type.HTTP,
                        new InetSocketAddress(PROXY_ADDR, PROXY_PORT)));
                return result;
            &#125;
            // 根据业务需要返回特定的对应的代理服务器
            @Override
            public void connectFailed(URI uri, SocketAddress sa, IOException ioe) &#123;
                System.out.println(&quot;无法连接道指定的代理服务器.&quot;);
            &#125;
        &#125;);
         URL url = new URL(urlStr);
        // 没有指定代理服务器,直接打开连接
        final URLConnection conn = url.openConnection();
        System.out.println(conn);
    &#125;

    public static void main(String[] args) throws Exception &#123;
        new ProxySelectorTest().init();
    &#125;
&#125;</code></pre>
<p>Java 为 ProxySelector 提供了一个实现类 DefaultProxySelector，但是没有公开 API，应该尽量避免直接使用该 API，系统已经将 DefaultProxySelector 注册为默认的代理选择器。可以通过改变系统属性来动态选择代理选择器。</p>
<pre><code class="java">public class DefaultProxySelectorTest &#123;
    // 定义需要访问的网站地址
    static String urlStr = &quot;http://www.baidu.com&quot;;

    public static void main(String[] args) throws URISyntaxException, IOException &#123;
        // 获取系统的默认属性
        final Properties props = System.getProperties();
        // 通过设置系统属性设置 HTTP 访问所有的代理服务器的主机地址、端口
        props.setProperty(&quot;http.proxyHost&quot;, &quot;192.168.10.96&quot;);
        props.setProperty(&quot;http.proxyPort&quot;, &quot;8080&quot;);
        // 设置不使用代理的主机
        props.setProperty(&quot;http.nonProxyHosts&quot;, &quot;localhost|192.168.10.*&quot;);
        // https
        props.setProperty(&quot;https.proxyHost&quot;, &quot;192.168.10.96&quot;);
        props.setProperty(&quot;https.proxyPort&quot;, &quot;443&quot;);
        // ftp
        props.setProperty(&quot;ftp.proxyHost&quot;, &quot;192.168.10.96&quot;);
        props.setProperty(&quot;ftp.proxyPort&quot;, &quot;2121&quot;);
        props.setProperty(&quot;ftp.nonProxyHosts&quot;, &quot;localhost|192.168.10.*&quot;);
        // socket
        props.setProperty(&quot;socket.proxyHost&quot;, &quot;192.168.10.96&quot;);
        props.setProperty(&quot;socket.proxyPort&quot;, &quot;2121&quot;);
        // 获取系统默认的代理选择器
        final ProxySelector selector = ProxySelector.getDefault();
        System.out.println(&quot;系统默认的代理选择器：&quot; + selector);
        // 根据 URI 动态决定所使用的代理服务器
        System.out.println(&quot;系统为 ftp://www.crazyit.org 选择的代理服务器为：&quot; +
                ProxySelector.getDefault().select(new URI(&quot;ftp://www.crazyit.org&quot;)));

        URL url = new URL(urlStr);
        final URLConnection conn = url.openConnection();
        conn.setConnectTimeout(3000);
        try(
            Scanner scan = new Scanner(conn.getInputStream(), &quot;utf-8&quot;))
        &#123;
            // 读取远程主机的内容
            while (scan.hasNextLine()) &#123;
                System.out.println(scan.nextLine());
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 lixianfu1@outlook.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '8b4bf9e725fa9e5652a9',
            clientSecret: 'bfc996b7a7d84a81599a9af4ca153637bd05b9f3',
            repo: 'gitalk',
            owner: 'Monkey-kong',
            admin: ['Monkey-kong'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2020 悟空
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 562px;
    }
    .nav.fullscreen {
        margin-left: -562px;
    }
    .nav-left {
        width: 140px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>






</html>
