<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 5 章 面向对象（上） | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 5 章 面向对象（上）</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 5 章 面向对象（上）</h1><div class="post-meta">Jan 5, 2020<span> | </span><span class="category"><a href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-类和对象"><span class="toc-text">5.1 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-定义类"><span class="toc-text">5.1.1 定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义类"><span class="toc-text">定义类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义成员变量"><span class="toc-text">定义成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义方法"><span class="toc-text">定义方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义构造器"><span class="toc-text">定义构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-对象的产生和使用"><span class="toc-text">5.1.2 对象的产生和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-对象、引用和指针"><span class="toc-text">5.1.3 对象、引用和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-对象的this引用"><span class="toc-text">5.1.4 对象的this引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-方法详解"><span class="toc-text">5.2 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-方法的所属性"><span class="toc-text">5.2.1 方法的所属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-方法的参数传递机制"><span class="toc-text">5.2.2 方法的参数传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本类型参数传递"><span class="toc-text">基本类型参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用类型参数传递"><span class="toc-text">引用类型参数传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-形参个数可变的方法"><span class="toc-text">5.2.3 形参个数可变的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归方法"><span class="toc-text">递归方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-方法重载"><span class="toc-text">5.2.5 方法重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-成员变量和局部变量"><span class="toc-text">5.3 成员变量和局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类变量和实例变量"><span class="toc-text">类变量和实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#局部变量"><span class="toc-text">局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-成员变量的初始化和内存中的运行机制"><span class="toc-text">5.3.2 成员变量的初始化和内存中的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-局部变量的初始化和内存中的运行机制"><span class="toc-text">5.3.3 局部变量的初始化和内存中的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-变量的使用规则"><span class="toc-text">5.3.4 变量的使用规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-隐藏和封装"><span class="toc-text">5.4 隐藏和封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-理解封装"><span class="toc-text">5.4.1 理解封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-使用访问控制符"><span class="toc-text">5.4.2 使用访问控制符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-package、import和import-static"><span class="toc-text">5.4.3 package、import和import static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-Java-的常用包"><span class="toc-text">5.4.4 Java 的常用包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-深入构造器"><span class="toc-text">5.5 深入构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-使用构造器执行初始化"><span class="toc-text">5.5.1 使用构造器执行初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-构造器重载"><span class="toc-text">5.5.2 构造器重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-类的继承"><span class="toc-text">5.6 类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-继承的特点"><span class="toc-text">5.6.1 继承的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-重写父类的方法"><span class="toc-text">5.6.2 重写父类的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-super-限定"><span class="toc-text">5.6.3 super 限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-调用父类构造器"><span class="toc-text">5.6.4 调用父类构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-多态"><span class="toc-text">5.7 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-多态性"><span class="toc-text">5.7.1 多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-引用变量的强制类型转换"><span class="toc-text">5.7.2 引用变量的强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-3-instanceof-运算符"><span class="toc-text">5.7.3 instanceof 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-继承与组合"><span class="toc-text">5.8 继承与组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-使用继承的注意点"><span class="toc-text">5.8.1 使用继承的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-利用组合实现复用"><span class="toc-text">5.8.2 利用组合实现复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-初始化块"><span class="toc-text">5.9 初始化块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-1-使用初始化块"><span class="toc-text">5.9.1 使用初始化块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-2-初始化块和构造器"><span class="toc-text">5.9.2 初始化块和构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-3-静态初始化块"><span class="toc-text">5.9.3 静态初始化块</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 5 章 面向对象（上）</p>
<a id="more"></a>
<h2 id="5-1-类和对象"><a href="#5-1-类和对象" class="headerlink" title="5.1 类和对象"></a>5.1 类和对象</h2><p>可以把类当成一种自定义类型，可以使用类来定义变量，这种类型的变量就称为引用变量。也就是说，所有类是引用类型。</p>
<p>类是某一批对象的抽象，可以把类理解成某种概念；对象才是一个具体存在的实体。</p>
<h3 id="5-1-1-定义类"><a href="#5-1-1-定义类" class="headerlink" title="5.1.1 定义类"></a>5.1.1 定义类</h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    零到多个构造器定义...</div><div class="line">    零到多个成员变量...</div><div class="line">    零到多个方法...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修饰符可以是public、final、abstract，或者完全省略这三个修饰符。</p>
<p>static 修饰的成员不能访问没有 static 修饰的成员。</p>
<p>构造器是一个类创建对象的根本途径，如果一个类没有构造器，这个类通常无法创建实例。因此，Java语言提供了一个功能：如果程序员没有为一个类编写构造器，则系统会为该类提供一个默认的构造器。一定程序员为类提供了构造器，系统将不在为该类提供构造器。</p>
<h4 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[修饰符]类型 成员变量名 [= 默认值]</div></pre></td></tr></table></figure>
<p>修饰符：public、protected、private、static、final。前边三个最多只能出现一次。</p>
<p>类型：可以是Java语言允许的任何数据类型，包括基本类型和引用类型。</p>
<h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[修饰符]方法返回值类型 方法名(形参列表)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 由零条到多条可执行性语句组成的方法体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修饰符：public、protected、private、static、final、abstract。前面三个最多只能出现其中之一；final和abstract最多只能出现其中之一。</p>
<p>返回类型：Java语言允许的任何数据类型。</p>
<h4 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[修饰符]构造器名(形参列表)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 由零条到多条可执行性语句组成的构造器执行体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修饰符：public、protected、private其中之一。可以省略</p>
<p>构造器名：必须和类名相同</p>
<p>构造器既不能定义返回值类型，也不能用void标识。如果加了返回值类型，编译不会出错，但Java会把这个所谓的构造器来当成一个方法来处理，不再是一个构造器。</p>
<h3 id="5-1-2-对象的产生和使用"><a href="#5-1-2-对象的产生和使用" class="headerlink" title="5.1.2 对象的产生和使用"></a>5.1.2 对象的产生和使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义P变量的同时并为p变量赋值</span></div><div class="line">Person p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>static 修饰的方法和成员变量，既可通过类来调用，也可以通过实例来调用；没有使用static修饰的普通方法和成员变量，只可通过实例来调用。</p>
<h3 id="5-1-3-对象、引用和指针"><a href="#5-1-3-对象、引用和指针" class="headerlink" title="5.1.3 对象、引用和指针"></a>5.1.3 对象、引用和指针</h3><p>从Person类定义来看，Person对象应该包含两个实例变量，而变量是需要内存来存储的。</p>
<p><img src="../../images/java/c5/对象内存存储示意图.png" alt="对象内存存储示意图"></p>
<p>从上图看出，Person对象由多块内存组成。</p>
<p>当把这个Person对象赋值给一个引用变量时，Java让引用变量指向这个对象。</p>
<p>与前面介绍的数组类型类似，类也是一种引用数据类型，因此程序中定义的Person类型的变量实际上时一个引用，它被存放再栈内存中，指向实际的Person对象；而真正的Person对象则存放再堆内存中。下面是将Person对象赋值给一个引用变量示意图：</p>
<p><img src="../../images/java/c5/对象赋值给引用变量.png" alt=""></p>
<p>如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，这个对象就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占用的内存区。</p>
<p>因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可，也就是把这些引用变量赋值为null</p>
<h3 id="5-1-4-对象的this引用"><a href="#5-1-4-对象的this引用" class="headerlink" title="5.1.4 对象的this引用"></a>5.1.4 对象的this引用</h3><p>this关键字总是指向调用该方法的对象。</p>
<ul>
<li>构造器中引用该构造器正在初始化的对象</li>
<li>在方法中引用调用该方法的对象</li>
</ul>
<p>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或者实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"正在执行jump方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不用this</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        Dog d = <span class="keyword">new</span> Dog();</div><div class="line">        d.jump();</div><div class="line">        System.out.println(<span class="string">"正在执行run方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 使用this</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jump();</div><div class="line">        System.out.println(<span class="string">"正在执行run方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// this可以省略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        jump();</div><div class="line">        System.out.println(<span class="string">"正在执行run方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于static修饰发方法而言，如果在方法中使用this关键字，则这个关键字就无法指向合适的对象。所以，static修饰的方法中不能使用this。所以static修饰的方法不能访问不使用static修饰的普通成员。</p>
<p>如果确实需要在静态方法中访问另一个普通方法，则只能重新创建一个对象。</p>
<p>在构造器中，this标识正在初始化的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThislnConstructor</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> foo;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThislnConstructor</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> foo = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.foo = <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> ThislnConstructor().foo);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-2-方法详解"><a href="#5-2-方法详解" class="headerlink" title="5.2 方法详解"></a>5.2 方法详解</h2><h3 id="5-2-1-方法的所属性"><a href="#5-2-1-方法的所属性" class="headerlink" title="5.2.1 方法的所属性"></a>5.2.1 方法的所属性</h3><ul>
<li>方法不能独立定义，方法只能在类体里定义</li>
<li>方法要么属于该类本身，要么属于该类的一个对象</li>
<li>永远不能独立执行方法，执行方法必须使用类或对象作为调用者</li>
</ul>
<p>看上去，static修饰的方法既可以用类来调用也可以使用对象来调用，但是实际上底层依然是使用该对象所属的类来作为调用者。</p>
<h3 id="5-2-2-方法的参数传递机制"><a href="#5-2-2-方法的参数传递机制" class="headerlink" title="5.2.2 方法的参数传递机制"></a>5.2.2 方法的参数传递机制</h3><p>Java里方法的参数传递方式只有一种：值传递。就是将实际参数值的副本传入方法内，而参数本身不会受到任何影响。</p>
<h4 id="基本类型参数传递"><a href="#基本类型参数传递" class="headerlink" title="基本类型参数传递"></a>基本类型参数传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveTransferTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> tmp = a;</div><div class="line">        a = b;</div><div class="line">        b = tmp;</div><div class="line">        System.out.println(<span class="string">"swap方法里，a="</span>+a+<span class="string">";b="</span>+b);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">6</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">9</span>;</div><div class="line">        swap(a, b);</div><div class="line">        System.out.println(<span class="string">"交换后，a="</span>+a+<span class="string">";b="</span>+b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="../../images/java/c5/参数传递1.png" alt=""></p>
<p><img src="../../images/java/c5/传输传递2.png" alt=""></p>
<h4 id="引用类型参数传递"><a href="#引用类型参数传递" class="headerlink" title="引用类型参数传递"></a>引用类型参数传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataWrap</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTransferTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(DataWrap dw)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> tmp = dw.a;</div><div class="line">        dw.a = dw.b;</div><div class="line">        dw.b = tmp;</div><div class="line">        System.out.println(<span class="string">"swap 方法里，a="</span>+ dw.a + <span class="string">";b="</span>+ dw.b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DataWrap dw = <span class="keyword">new</span> DataWrap();</div><div class="line">        dw.a = <span class="number">6</span>;</div><div class="line">        dw.b = <span class="number">9</span>;</div><div class="line">        swap(dw);</div><div class="line">        System.out.println(<span class="string">"交换结束后，a="</span>+ dw.a + <span class="string">";b="</span>+ dw.b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这很容易造成一种错觉:调用swap()方法时，传入swap()方法的就是dw 对象本身，而不是它的复制品。但这只是一种错觉，下面还是结合示意图来说明程序的执行过程。</p>
<p><img src="../../images/java/c5/引用参数传递1.png" alt=""></p>
<p><img src="../../images/java/c5/引用参数传递2.png" alt=""></p>
<h3 id="5-2-3-形参个数可变的方法"><a href="#5-2-3-形参个数可变的方法" class="headerlink" title="5.2.3 形参个数可变的方法"></a>5.2.3 形参个数可变的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, String... books)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String tmp : books)</div><div class="line">        &#123;</div><div class="line">            System.out.println(tmp);</div><div class="line">        &#125;</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        test(<span class="number">5</span>, <span class="string">"疯狂Java讲义"</span>,<span class="string">"轻量级Java EE企业应用实战"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>个数可变的形参只能处于形参列表的最后，也就是说，一个方法中最多只能有一个个数可变的形参。</p>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursive</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">4</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span> * fn(n-<span class="number">1</span>) + fn(n-<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(fn(<span class="number">10</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仔细看上面递归的过程，当一个方法不断地调用它本身时，必须在某个时刻方法的返回值是确定的，即不再调用它本身， 否则这种递归就变成了无穷递归， 类似于死循环。因此定义递归方法时有一条最重要的规定:递归一定要向己知方向递归。</p>
<h3 id="5-2-5-方法重载"><a href="#5-2-5-方法重载" class="headerlink" title="5.2.5 方法重载"></a>5.2.5 方法重载</h3><p>一个类中包含两个或两个以上方法的方法名相同，但形参列表不同，则被称为方法重载。</p>
<p>方法重载要求：两同一不同。同一个类中方法名相同，新参列表不同。和返回值类型、修饰符等没有关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"无参数"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"重载的test方法 "</span> + msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Overload ol = <span class="keyword">new</span> Overload();</div><div class="line">        ol.test();</div><div class="line">        ol.test(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用方法时可以忽略方法的返回值，所以返回值类型不能用于区分重载方法。</p>
<h2 id="5-3-成员变量和局部变量"><a href="#5-3-成员变量和局部变量" class="headerlink" title="5.3 成员变量和局部变量"></a>5.3 成员变量和局部变量</h2><p><img src="../../images/java/c5/变量分类图.png" alt=""></p>
<p>类变量的作用域与这个类的生存范围相同；而实例变量则与对应实例的生存范围相同。</p>
<h4 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 实例变量</span></div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">    <span class="comment">// 类变量</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> eyeNum;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Person的eyeNum类变量值："</span> + Person.eyeNum);</div><div class="line">        <span class="comment">// 创建Person对象</span></div><div class="line">        Person p = <span class="keyword">new</span> Person();</div><div class="line">        System.out.println(<span class="string">"p变量的name:"</span> + p.name + <span class="string">"; p变量eyeNun:"</span> + p.eyeNum);</div><div class="line">        p.name = <span class="string">"孙悟空"</span>;</div><div class="line">        p.eyeNum = <span class="number">2</span>;</div><div class="line">        System.out.println(<span class="string">"p变量的name:"</span> + p.name + <span class="string">"; p变量eyeNun:"</span> + p.eyeNum);</div><div class="line">        System.out.println(<span class="string">"Person的eyeNum类变量值："</span> + Person.eyeNum);</div><div class="line">        Person p2 = <span class="keyword">new</span> Person();</div><div class="line">        <span class="comment">// 2</span></div><div class="line">        System.out.println(<span class="string">"p2对象的eyeNum类变量值："</span> + p2.eyeNum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面程序来看，成员变量无须显式初始化，只要为一个类定义了类变量或实例变量，系统就会在这个类的准备阶段或创建该类的实例时进行默认初始化，成员变量默认初始化时的赋值规则与数组动态初始化时数组元素的赋值规则完全相同。</p>
<p>实例也可访问类变量，同一个类的所有实例访问类变量时，实际上访问的是该类本身的同一个变量， 也就是说，访问了同一片内存区。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>除了形参外，都必须显示初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockVarTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> a;</div><div class="line">            <span class="comment">// 下面代码将出现错误，a还未初始化</span></div><div class="line">            <span class="comment">// System.out.println("代码块局部变量a的值：" + a);</span></div><div class="line">            a = <span class="number">5</span>;</div><div class="line">            System.out.println(<span class="string">"代码块局部变量a的值："</span> + a);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// a已经不存在</span></div><div class="line">        <span class="comment">// System.out.println("代码块局部变量a的值：" + a);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodLoaclVarTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a;</div><div class="line">        <span class="comment">// a还未初始化</span></div><div class="line">        <span class="comment">// System.out.println("方法局部变量a的值：" + a);</span></div><div class="line">        a = <span class="number">5</span>;</div><div class="line">        System.out.println(<span class="string">"方法局部变量a的值："</span> + a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个类里不能定义两个同名的成员变量，即使一个是类变量， 一个是实例变量也不行;</p>
<p>J ava 允许局部变量和成员变量同名，如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可使用th is (对于实例变量)或类名(对于类变量)作为调用者来限定访问成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableOverrideTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"李刚"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> price = <span class="number">78.0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> price = <span class="number">65</span>;</div><div class="line">        System.out.println(price);</div><div class="line">        System.out.println(VariableOverrideTest.price);</div><div class="line">        <span class="keyword">new</span> VariableOverrideTest().info();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        String name = <span class="string">"孙悟空"</span>;</div><div class="line">        System.out.println(name);</div><div class="line">        System.out.println(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-3-2-成员变量的初始化和内存中的运行机制"><a href="#5-3-2-成员变量的初始化和内存中的运行机制" class="headerlink" title="5.3.2 成员变量的初始化和内存中的运行机制"></a>5.3.2 成员变量的初始化和内存中的运行机制</h3><p>当系统加载类或创建该类的实例时， 系统自动为成员变量分配内存空间，并在分配内存空间后， 自动为成员变量指定初始值。</p>
<p><img src="../../images/java/c5/初始化类.png" alt=""></p>
<p><img src="../../images/java/c5/创建对象.png" alt=""></p>
<p><img src="../../images/java/c5/实例变量赋值.png" alt=""></p>
<p><img src="../../images/java/c5/类变量赋值.png" alt=""></p>
<h3 id="5-3-3-局部变量的初始化和内存中的运行机制"><a href="#5-3-3-局部变量的初始化和内存中的运行机制" class="headerlink" title="5.3.3 局部变量的初始化和内存中的运行机制"></a>5.3.3 局部变量的初始化和内存中的运行机制</h3><p>局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间， 直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存， 并将初始值保存到这块内存中。</p>
<p>与成员变量不同， 局部变量不属于任何类或实例， 因此它总是保存在其所在方法的枝内存中。如果局部变量是基本类型的变量，则直接把这个变量的值保存在该变量对应的内存中; 如果局部变量是一个引用类型的变量，则这个变量里存放的是地址，通过该地址引用到该变量实际引用的对象或数组。</p>
<p>桔内存中的变量无须系统垃坡回收，往往随方法或代码块的运行结束而结束。因此，局部变量的作用域是从初始化该变量开始，直到该方法或该代码块运行完成而结束。因为局部变量只保存基本类型的值或者对象的引用， 因此局部变量所占的内存区通常比较小。</p>
<h3 id="5-3-4-变量的使用规则"><a href="#5-3-4-变量的使用规则" class="headerlink" title="5.3.4 变量的使用规则"></a>5.3.4 变量的使用规则</h3><p>能用代码块局部变量的地方，就坚决不要使用方法局部变量。</p>
<p>考虑用成员变量的几种情形：</p>
<ul>
<li>用于描述某个类或某个对象的固有信息，例如人的身高、体重等信息。</li>
<li>保存该类或者实例运行时的状态信息，例如上面五子棋程序中的棋盘数组。</li>
<li>某个信息需要在某个类的多个方法之间进行共享。</li>
</ul>
<h2 id="5-4-隐藏和封装"><a href="#5-4-隐藏和封装" class="headerlink" title="5.4 隐藏和封装"></a>5.4 隐藏和封装</h2><h3 id="5-4-1-理解封装"><a href="#5-4-1-理解封装" class="headerlink" title="5.4.1 理解封装"></a>5.4.1 理解封装</h3><p>封装( Encapsulation) 是面向对象的三大特征之一(另外两个是继承和多态) ，它指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。</p>
<p>封装实际上有两个方面的含义:把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java 提供的访问控制符来实现。</p>
<h3 id="5-4-2-使用访问控制符"><a href="#5-4-2-使用访问控制符" class="headerlink" title="5.4.2 使用访问控制符"></a>5.4.2 使用访问控制符</h3><p>访问控制级别：private、default、protected、public</p>
<p>private：当前类访问权限</p>
<p>default：包访问权限</p>
<p>protected：子类访问权限</p>
<p>public：公告访问权限</p>
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类中</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>同一个包中</td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>子类中</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>全局范围内</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>访问控制符用于控制一个类的成员是否可以被其他类访问，对于局部变量而言，其作用域就是它所在的方法，不可能被其他类访问，因此不能使用访问控制符来修饰。</p>
<h3 id="5-4-3-package、import和import-static"><a href="#5-4-3-package、import和import-static" class="headerlink" title="5.4.3 package、import和import static"></a>5.4.3 package、import和import static</h3><p>package：指定类所在的包。同一个包下的类可以自由访问</p>
<p>import：导入指定的类或者包下的所有类。注意不包含子包下的类。java默认为所有源文件导入java.lang包下的所有类</p>
<p>import static：静态导入。导入静态成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> unit5_oo1;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticImportTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// out 是java.lang.System类的静态成员变量，代表标准输出</span></div><div class="line">        <span class="comment">// PI是 java.lang.Math 类的静态成员变量</span></div><div class="line">        out.println(PI);</div><div class="line">        <span class="comment">// 直接调用Math类的sqrt静态方法</span></div><div class="line">        out.println(sqrt(<span class="number">256</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-4-4-Java-的常用包"><a href="#5-4-4-Java-的常用包" class="headerlink" title="5.4.4 Java 的常用包"></a>5.4.4 Java 的常用包</h3><p>Java 的核心类都放在Java 包以及其子包下， Java 扩展的许多类都放在Javax 包以及其子包下。</p>
<ul>
<li>java.lang：Java语言的核心类，如String、Math、System和Thread等系统自动导入。</li>
<li>java.util：工具类/接口和集合框架类/接口，如Arrays和List、Set等。</li>
<li>java.net：Java网络编程相关类/接口。</li>
<li>java.io：Java输入/输出编程相关的类/接口。</li>
<li>java.text：Java格式化相关的类。</li>
<li>java.sql：Java进行JDBC数据库编程相关的类/接口。</li>
<li>java.awt：抽象窗口工具集的相关类/接口。主要用于构建图形用户接口（GUI）程序。</li>
<li>java.swing：Swing图形用户界面编程的相关类/接口，用于构建平台无关的GUI程序。</li>
</ul>
<h2 id="5-5-深入构造器"><a href="#5-5-深入构造器" class="headerlink" title="5.5 深入构造器"></a>5.5 深入构造器</h2><p>构造器用于构建实例时执行初始化。构造器是创建对象的重要途经（即使使用工厂模式、反射等方式创建对象，其实质依然是依赖于构造器），因此，Java 类必须包含一个或一个以上的构造器。</p>
<h3 id="5-5-1-使用构造器执行初始化"><a href="#5-5-1-使用构造器执行初始化" class="headerlink" title="5.5.1 使用构造器执行初始化"></a>5.5.1 使用构造器执行初始化</h3><p>当创建一个对象时，系统会为这个对象的实例变量进行默认初始化，所有基本类型的实例变量设为0或false，把所有引用类型的实例变量设置为null。如果想改变这种默认的初始化，就可以通过构造器来实现。</p>
<h3 id="5-5-2-构造器重载"><a href="#5-5-2-构造器重载" class="headerlink" title="5.5.2 构造器重载"></a>5.5.2 构造器重载</h3><p>同一个类里具有多个构造器， 多个构造器的形参列表不同，即被称为构造器重载。</p>
<p>构造器重载和方法重载基本相似：名字相同（肯定相同，都是类名）；形参不同</p>
<p>如果一个构造器的执行体里完全包含另一个构造器的执行体，可以使用this关键字来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">    <span class="keyword">public</span> String color;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> weight;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String name, String color)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String name, String color, <span class="keyword">double</span> weight)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 调用两个参数的构造器</span></div><div class="line">        <span class="keyword">this</span>(name, color);</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-6-类的继承"><a href="#5-6-类的继承" class="headerlink" title="5.6 类的继承"></a>5.6 类的继承</h2><p>Java的继承具有单继承的特点，每个子类只有一个直接父类。</p>
<h3 id="5-6-1-继承的特点"><a href="#5-6-1-继承的特点" class="headerlink" title="5.6.1 继承的特点"></a>5.6.1 继承的特点</h3><p>父类和子类的关系，是一种一般和特殊的关系。例如水果和苹果的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Balana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Balana b = <span class="keyword">new</span> Balana();</div><div class="line">        <span class="comment">// Balana对象本身没有 weight 成员变量</span></div><div class="line">        b.weight = <span class="number">56</span>;</div><div class="line">        b.info();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 类只有一个<strong>直接</strong>父类。如果没有显示指定这个类的直接父类，则这个类默认扩展java.lang.Object类。因此，java.lang.Object类是所有类的父类，要么是其直接父类，要么是其间接父类。因此，所有的java对象都可以调用java.lang.Object类所定义的实例方法。</p>
<h3 id="5-6-2-重写父类的方法"><a href="#5-6-2-重写父类的方法" class="headerlink" title="5.6.2 重写父类的方法"></a>5.6.2 重写父类的方法</h3><p>子类扩展了父类，子类是一个特殊的父类。大部分时候，子类总是以父类为基础， 额外增加新的成员变量和方法。但有一种情况例外: 子类需要重写父类的方法。例如鸟类都包含了飞翔方法， 其中驼鸟是一种特殊的鸟类，因此驼乌应该是鸟的子类，因此它也将从乌类获得飞翔方法，但这个飞翔方法明显不适合驼鸟，为此，驼鸟需要重写鸟类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我在天空里自由自在地飞翔..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</div><div class="line">    <span class="comment">// 重写 Bird 类的 fly() 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我只能在地上奔跑..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Ostrich os = <span class="keyword">new</span> Ostrich();</div><div class="line">        os.fly();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种子类包含与父类同名方法的现象被称为方法重写( Override ) ， 也被称为方法覆盖。可以说子类重写了父类的方法， 也可以说子类覆盖了父类的方法。</p>
<p>方法的重写要遵循” 两同两小一大”规则，” 两同”即方法名相同、形参列表相同;” 两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等， 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等;” 一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。尤其需要指出的是，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法。</p>
<p>如果父类方法具有private 访问权限，则该方法对其子类是隐藏的，因此其子类无法访问该方法，也就是无法重写该方法。</p>
<p>当子类覆盖父类方法后，子类的对象将无法访问父类中被覆盖的方法，但可以在子类方法中调用父类中被覆盖的方法，通过 super或者类名作为调用者实现。</p>
<p>方法重载（overload）：主要发生在同一个类的多个同名方法之间。</p>
<p>方法重写（override）：主要发生在子类和父类同名方法之间。</p>
<p>当然，父类方法和子类方法之间也可能发生重载。</p>
<h3 id="5-6-3-super-限定"><a href="#5-6-3-super-限定" class="headerlink" title="5.6.3 super 限定"></a>5.6.3 super 限定</h3><p>如果需要在子类方法中调用父类被覆盖的实例方法，则可使用super 限定来调用父类被覆盖的实例方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callOverrideMethod</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 在子类方法中通过super显示调用父类被覆盖的实例方法</span></div><div class="line">    <span class="keyword">super</span>.fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>super 是Java 提供的一个关键字， super 用于限定该对象调用它从父类继承得到的实例变量或方法。正如this 不能出现在statlc 修饰的方法中一样， super 也不能出现在static 修饰的方法中。static 修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象，因而super 限定也就失去了意义。</p>
<p>如果子类定义了和父类相同的实例变量，则在子类中用super访问父类的实例变量。</p>
<p>方法中访问名为a的成员变量，但是没有显示指定调用者，查找顺序为：</p>
<ol>
<li>查找局部变量</li>
<li>查找当前类的成员变量</li>
<li>查找直接父类、间接父类的成员变量。如果找到Object还没有找到则编译报错</li>
</ol>
<p>当创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为他从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> String tag = <span class="string">"疯狂 Java 讲义"</span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Parent</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 定义一个私有的tag实例变量来隐藏父类的tag实例变量</span></div><div class="line">    <span class="keyword">private</span> String tag = <span class="string">"轻量级 Java EE 企业应用实战"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HideTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Derived d = <span class="keyword">new</span> Derived();</div><div class="line">        <span class="comment">// 程序不可访问d的私有变量tag，编译报错</span></div><div class="line">        <span class="comment">// System.out.println(d.tag);</span></div><div class="line">        System.out.println(((Parent)d).tag);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-6-4-调用父类构造器"><a href="#5-6-4-调用父类构造器" class="headerlink" title="5.6.4 调用父类构造器"></a>5.6.4 调用父类构造器</h3><p>子类不会获得父类的构造器，但子类构造器里可以调用父类构造器的初始化代码，类似于前面所介绍的一个构造器调用另一个重载的构造器。</p>
<p>在一个构造器中调用另一个重载的构造器使用this 调用来完成， 在子类构造器中调用父类构造器使用super 调用来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> size;</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">double</span> size, String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.size = size;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> String color;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">(<span class="keyword">double</span> size, String name, String color)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 通过super调用父类构造器的初始化过程</span></div><div class="line">        <span class="keyword">super</span>(size, name);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Sub s = <span class="keyword">new</span> Sub(<span class="number">5.6</span>, <span class="string">"测试对象"</span>, <span class="string">"红色"</span>);</div><div class="line">        System.out.println(s.size + <span class="string">"--"</span> + s.name + <span class="string">"--"</span> + s.color);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>super 调用的是其父类的构造器， 而this 调用的是同一个类中重载的构造器。</p>
<p>使用super、this调用构造器时都必须出现在构造器执行体的第一行，所以this和super调用不会同时出现。</p>
<p>不管是否使用super 调用来执行父类构造器的初始化代码， 子类构造器总会调用父类构造器一次。子类构造器调用父类构造器情况：</p>
<ol>
<li>子类构造器第一行使用super显示调用</li>
<li>子类构造器第一行使用this显示调用本类中重载的构造器，执行本类对应的构造器时即会掉哟个父类构造器</li>
<li>既没有用super也没有用this，系统在执行子类构造器之前，隐式调用父类无参构造器</li>
</ol>
<p>因此，创建任何 Java 对象，最先执行的总是 java.lang.Object 类的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Creature 无参的构造器"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Creature</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Animal 带一个参数的构造器，"</span> +</div><div class="line">                <span class="string">"该动物的name为"</span> + name);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 使用this调用重载构造器</span></div><div class="line">        <span class="keyword">this</span>(name);</div><div class="line">        System.out.println(<span class="string">"Animal 带两个参数的构造器，"</span> +</div><div class="line">                <span class="string">"其age为"</span> + age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wolf</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 显示调用父类有两个参数的构造器</span></div><div class="line">        <span class="keyword">super</span>(<span class="string">"花太郎"</span>, <span class="number">3</span>);</div><div class="line">        System.out.println(<span class="string">"Wolf无参数的构造器"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Wolf();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-7-多态"><a href="#5-7-多态" class="headerlink" title="5.7 多态"></a>5.7 多态</h2><p>Java 引用变量有两个类型: 一个是编译时类型， 一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的多态(Polymorphism) 。</p>
<h3 id="5-7-1-多态性"><a href="#5-7-1-多态性" class="headerlink" title="5.7.1 多态性"></a>5.7.1 多态性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> book = <span class="number">6</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">base</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"父类的普通方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"父类的被覆盖的方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span>&#123;</div><div class="line">    <span class="comment">// 重新定义一个book实例变量隐藏父类的book实例变量</span></div><div class="line">    <span class="keyword">public</span> String book = <span class="string">"轻量级 Java EE企业应用实战"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子类的普通方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子类的覆盖父类的方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 编译时类型和运行时类型完全一样，不存在多态</span></div><div class="line">        BaseClass bc = <span class="keyword">new</span> BaseClass();</div><div class="line">        <span class="comment">// 6</span></div><div class="line">        System.out.println(bc.book);</div><div class="line">        bc.base();</div><div class="line">        bc.test();</div><div class="line">        <span class="comment">// 编译时类型和运行时类型完全一样，不存在多态</span></div><div class="line">        SubClass sc = <span class="keyword">new</span> SubClass();</div><div class="line">        System.out.println(sc.book);</div><div class="line">        sc.base(); <span class="comment">// 执行从父类继承的方法</span></div><div class="line">        sc.test(); <span class="comment">// 执行当前类方法</span></div><div class="line">        <span class="comment">// 编译时类型和运行时类型不一样，存在多态</span></div><div class="line">        BaseClass ploymophicBc = <span class="keyword">new</span> SubClass();</div><div class="line">        <span class="comment">// 6，表明对象的实例变量则不具备多态性</span></div><div class="line">        System.out.println(ploymophicBc.book);</div><div class="line">        ploymophicBc.base(); <span class="comment">// 执行从父类继承的方法</span></div><div class="line">        ploymophicBc.test(); <span class="comment">// 执行当前类方法</span></div><div class="line">        <span class="comment">// 因为 ploymophicBC 的编译时类型是BaseClass</span></div><div class="line">        <span class="comment">// ploymophicBc.sub();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>变量ploymophicBc 则比较特殊， 它的编译时类型是BaseClass ，而运行时类型是SubClass ，当调用该引用变量的testO方法( BaseClass 类中定义了该方法， 子类SubClass 覆盖了父类的该方法)时， 实际执行的是SubClass 类中覆盖后的test()方法，这就可能出现多态了。</p>
<p>因为子类其实是一种特殊的父类， 因此Java 允许把一个子类对象直接赋给一个父类引用变量， 无须任何类型转换， 或者被称为向上转型( upcasting) ，向上转型由系统自动完成。</p>
<p>通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，而不是它运行时类型所定义的成员交量。</p>
<h3 id="5-7-2-引用变量的强制类型转换"><a href="#5-7-2-引用变量的强制类型转换" class="headerlink" title="5.7.2 引用变量的强制类型转换"></a>5.7.2 引用变量的强制类型转换</h3><p>强制类型转换需要注意：</p>
<ol>
<li>基本类型之间的转换只能在数值类型之间进行，这里所说的数值类型包括整数型、字符型和浮点型。但数值类型和布尔类型之间不能进行类型转换。</li>
<li>引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时就会出现错误。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> d = <span class="number">13.4</span>;</div><div class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)d;</div><div class="line">        System.out.println(l);</div><div class="line">        <span class="keyword">int</span> in = <span class="number">5</span>;</div><div class="line">        <span class="comment">// 编译报错，数值类型变量不可转换为boolean类型</span></div><div class="line">        <span class="comment">// boolean b = (boolean)in;</span></div><div class="line">        Object obj = <span class="string">"Hello"</span>;</div><div class="line">        String objStr = (String)obj;</div><div class="line">        System.out.println(objStr);</div><div class="line"></div><div class="line">        <span class="comment">// 编译类型为Object，实际类型为Integer</span></div><div class="line">        Object objPri = Integer.valueOf(<span class="number">5</span>);</div><div class="line">        <span class="comment">// 引发ClassCastException 异常</span></div><div class="line">        String str = (String)objPri;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进行强制类型转换之前，先用instanceof 运算符判断是否可以成功转换，从而避免出现<br>ClassCastException 异常，这样可以保证程序更加健壮。</p>
<p>向上转型总是成功，向下转型可能出现 ClassCastException 异常，使用 instanceof 判断。</p>
<h3 id="5-7-3-instanceof-运算符"><a href="#5-7-3-instanceof-运算符" class="headerlink" title="5.7.3 instanceof 运算符"></a>5.7.3 instanceof 运算符</h3><p>instanceof 运算符前面通常是一个引用类型的变量，后一个操作数通常是一个类（也可以是接口），它用于判断前面的对象是否是后面的类、子类、接口实现类的实例。</p>
<p>instanceof 前面操作数要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceofTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 编译类型是Object，实际类型是String</span></div><div class="line">        Object hello = <span class="string">"hello"</span>;</div><div class="line">        System.out.println(<span class="string">"String是否是Object类的实例："</span></div><div class="line">                + (hello <span class="keyword">instanceof</span> Object) );</div><div class="line">        System.out.println(<span class="string">"String是否是String类的实例："</span></div><div class="line">                + (hello <span class="keyword">instanceof</span> String));</div><div class="line">        System.out.println(<span class="string">"String是否是Math类的实例:"</span></div><div class="line">                + (hello <span class="keyword">instanceof</span> Math));</div><div class="line">        <span class="comment">// String实现了Comparable接口</span></div><div class="line">        System.out.println(<span class="string">"String是否是Comparable接口的实例："</span></div><div class="line">                + (hello <span class="keyword">instanceof</span> Comparable));</div><div class="line">        String a = <span class="string">"hello"</span>;</div><div class="line">        <span class="comment">// String类与Math类没有继承关系，编译报错</span></div><div class="line"><span class="comment">//        System.out.println("String是否是Math类的实例："</span></div><div class="line"><span class="comment">//                + (a instanceof Math));</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-8-继承与组合"><a href="#5-8-继承与组合" class="headerlink" title="5.8 继承与组合"></a>5.8 继承与组合</h2><h3 id="5-8-1-使用继承的注意点"><a href="#5-8-1-使用继承的注意点" class="headerlink" title="5.8.1 使用继承的注意点"></a>5.8.1 使用继承的注意点</h3><p>继承带来了高度复用的同时，也破坏了了父类的封装性。子类可以通过重写来改变父类的方法实现，从而导致子类可以恶意篡改父类的方法。</p>
<p>为了保证父类有良好的封装性，不会被子类随意改变，设计父类通常应该遵循如下规则。</p>
<ul>
<li>尽量隐藏父类的内部数据，尽量把父类所有成员变量设置为private</li>
<li>不让子类随意访问、修改父类方法。父类中辅助和工具方法应该用private。如果父类方法需要被外部调用，但又不希望子类重写该方法，可以使用final修饰；如果希望父类某个方法被子类重写，但不希望被其他类自由访问，可使用protected修饰</li>
<li>尽量不要在父类构造器中调用将要被子类重写的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"将被子类重写的方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子类重写父类方法，"</span> +</div><div class="line">                <span class="string">"其name长度为"</span> + name.length());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 引发空指针异常</span></div><div class="line">        Sub s = <span class="keyword">new</span> Sub();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建 Sub 对象时，回先执行其父类构造器，如果父类构造器调用了其子类重写的方法，则变成调用被子类重写后的方法。</p>
<p>何时需要从父类派生新的子类：</p>
<ul>
<li>子类需要增加额外属性，而不仅仅是属性值的改变。例如从Person类派生出Student子类，Person类里没有提供grade属性。</li>
<li>子类需要增加自己独有的行为方式（包括增加新的方法或重写父类的方法）。</li>
</ul>
<h3 id="5-8-2-利用组合实现复用"><a href="#5-8-2-利用组合实现复用" class="headerlink" title="5.8.2 利用组合实现复用"></a>5.8.2 利用组合实现复用</h3><p>如果需要复用一个类，除把这个类当成基类来继承之外，还可以把该类当成另一个类的组合成分，从而允许新类直接复用该类的public方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal1</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"心脏跳动..."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        beat();</div><div class="line">        System.out.println(<span class="string">"吸气，吐气，呼吸中..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird1</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">// 将原来的父类组合到原来的子类中，作为子类的一个组合成分</span></div><div class="line">    <span class="keyword">private</span> Animal1 a;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird1</span><span class="params">(Animal1 a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = a;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        a.breath();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我在天空自在的飞翔..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wolf1</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">private</span> Animal1 a;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wolf1</span><span class="params">(Animal1 a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = a;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        a.breath();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我在地上快速的奔跑..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Animal1 a1 = <span class="keyword">new</span> Animal1();</div><div class="line">        Bird1 b = <span class="keyword">new</span> Bird1(a1);</div><div class="line">        b.breath();</div><div class="line">        b.fly();</div><div class="line">        Animal1 a2 = <span class="keyword">new</span> Animal1();</div><div class="line">        Wolf1 w = <span class="keyword">new</span> Wolf1(a2);</div><div class="line">        w.breath();</div><div class="line">        w.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承要表达的是一种”是( is-a) “的关系，而组合表达的是”有( has-a ) “的关系。</p>
<p><strong>问题</strong>：使用组合关系来实现复用时，需要创建两个 Animal 对象，是不是意味着使用组合关系时系统开销更大？</p>
<h2 id="5-9-初始化块"><a href="#5-9-初始化块" class="headerlink" title="5.9 初始化块"></a>5.9 初始化块</h2><h3 id="5-9-1-使用初始化块"><a href="#5-9-1-使用初始化块" class="headerlink" title="5.9.1 使用初始化块"></a>5.9.1 使用初始化块</h3><p>初始化块是Java 类里可出现的第4 种成员(前面依次有成员变量、方法和构造器)， 一个类里可以有多个初始化块，相同类型的初始化块之间有顺序: 前面定义的初始化块先执行，后面定义的初始化块后执行。初始化块的修饰符只有 static</p>
<p>初始化块只在创建Java 对象时隐式执行，而且在执行构造器之前执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">6</span>;</div><div class="line">        <span class="keyword">if</span> (a &gt; <span class="number">4</span>)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"Person 初始化块，a 大于4"</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Person的初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Person的第二个初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Person类的无参构造器"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Person();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>普通初始化块、声明实例变量指定的默认值都可认为是对象的初始化代码，它们的执行顺序与源程序中的排列顺序相同。</p>
<h3 id="5-9-2-初始化块和构造器"><a href="#5-9-2-初始化块和构造器" class="headerlink" title="5.9.2 初始化块和构造器"></a>5.9.2 初始化块和构造器</h3><p>如果两个构造器中有相同的初始化代码，且这些初始化代码无须接收参数，就可以把它们放在初始化块中定义。通过把多个构造器中的相同代码提取到初始化块中定义，能更好地提高初始化代码的复用，提高整个应用的可维护性。</p>
<p>实际上初始化块是一个假象，使用Javac 命令编译Java 类后，该Java 类中的初始化块会消失，初始化块中代码会被”还原”到每个构造器中，且位于构造器所有代码的前面。</p>
<h3 id="5-9-3-静态初始化块"><a href="#5-9-3-静态初始化块" class="headerlink" title="5.9.3 静态初始化块"></a>5.9.3 静态初始化块</h3><p>普通初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化</p>
<p>静态初始化块总是比普通初始化块先执行。</p>
<p>静态初始化块是类相关的，用于对整个类进行初始化处理，通常用于对类变量执行初始化处理。静态初始化块不能对实例变量进行初始化处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"Root 的静态初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Root 的普通初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Root 的无参构造器"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"Mid 的静态初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Mid 的普通初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Mid 的无参构造器"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        System.out.println(<span class="string">"Mid 的带参数构造器，参数值："</span> + msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"Leaf 的静态初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Leaf 的普通初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"疯狂 Java 讲义"</span>);</div><div class="line">        System.out.println(<span class="string">"执行 Leaf 的构造器"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Leaf();</div><div class="line">        System.out.println(<span class="string">"============================"</span>);</div><div class="line">        <span class="keyword">new</span> Leaf();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类初始化阶段：执行静态初始化块</p>
<p>对象初始化阶段：执行普通初始化块和构造器</p>
<p>一旦Leaf 类初始化成功后， Leaf 类在该虚拟机里将一直存在，因此当第二次创建Leaf 实例时无须再次对Leaf 类进行初始化。</p>
<p>静态初始化块和声明静态成员变量时所指定的初始值都是该类的初始化代码，它们的执行顺序与源程序中的排列顺序相同。</p>
</div><div class="tags"><a href="/tags/疯狂-Java-讲义/">疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-01-06-疯狂Java讲义/疯狂Java讲义C6.html">第 6 章 面向对象（下）</a><a class="next" href="/2020-01-04-疯狂Java讲义/疯狂Java讲义C4.html">第 4 章 流程控制与数组</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加解密技术/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/吉他/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/吉他/" style="font-size: 15px;">吉他</a> <a href="/tags/疯狂-Java-讲义/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>