<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 18 章 类加载机制与反射 | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 18 章 类加载机制与反射</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 18 章 类加载机制与反射</h1><div class="post-meta">Jan 18, 2020<span> | </span><span class="category"><a href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-类的加载、连接和初始化"><span class="toc-text">18.1 类的加载、连接和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-1-JVM-和类"><span class="toc-text">18.1.1 JVM 和类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-2-类的加载"><span class="toc-text">18.1.2 类的加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-3-类的连接"><span class="toc-text">18.1.3 类的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-4-类的初始化"><span class="toc-text">18.1.4 类的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-5-类初始化的时机"><span class="toc-text">18.1.5 类初始化的时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-类加载器"><span class="toc-text">18.2 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-1-类加载机制"><span class="toc-text">18.2.1 类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类加载器层次"><span class="toc-text">类加载器层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类加载器负责规则"><span class="toc-text">类加载器负责规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类加载器加载步骤"><span class="toc-text">类加载器加载步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-2-创建并使用自定义的类加载器"><span class="toc-text">18.2.2 创建并使用自定义的类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-3-URLClassLoader-类"><span class="toc-text">18.2.3 URLClassLoader 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-通过反射查看类信息"><span class="toc-text">18.3 通过反射查看类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-1-获得-Class-对象"><span class="toc-text">18.3.1 获得 Class 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-2-从-Class-中获取信息"><span class="toc-text">18.3.2 从 Class 中获取信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取-Class-对应类所包含的构造器"><span class="toc-text">获取 Class 对应类所包含的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取方法"><span class="toc-text">获取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取成员变量"><span class="toc-text">获取成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取-Annotation"><span class="toc-text">获取 Annotation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取内部类、外部类、接口、父类"><span class="toc-text">获取内部类、外部类、接口、父类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修饰符、所在包、类名"><span class="toc-text">修饰符、所在包、类名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相关判断方法"><span class="toc-text">相关判断方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-3-Java-8-新增的方法参数反射"><span class="toc-text">18.3.3 Java 8 新增的方法参数反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-使用反射生成并操作对象"><span class="toc-text">18.4 使用反射生成并操作对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-1-创建对象"><span class="toc-text">18.4.1 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-2-调用方法"><span class="toc-text">18.4.2 调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-3-访问成员变量值"><span class="toc-text">18.4.3 访问成员变量值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-4-操作数组"><span class="toc-text">18.4.4 操作数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-使用反射生成-JDK-动态代理"><span class="toc-text">18.5 使用反射生成 JDK 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-使用-Proxy-和-InvocationHandler-创建动态代理"><span class="toc-text">18.5.1 使用 Proxy 和 InvocationHandler 创建动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-2-动态代理和-AOP"><span class="toc-text">18.5.2 动态代理和 AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6-反射和泛型"><span class="toc-text">18.6 反射和泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-1-泛型和-Class-类"><span class="toc-text">18.6.1 泛型和 Class 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-2-使用反射来获取泛型信息"><span class="toc-text">18.6.2 使用反射来获取泛型信息</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 18 章 类加载机制与反射</p>
<a id="more"></a>
<h2 id="18-1-类的加载、连接和初始化"><a href="#18-1-类的加载、连接和初始化" class="headerlink" title="18.1 类的加载、连接和初始化"></a>18.1 类的加载、连接和初始化</h2><h3 id="18-1-1-JVM-和类"><a href="#18-1-1-JVM-和类" class="headerlink" title="18.1.1 JVM 和类"></a>18.1.1 JVM 和类</h3><p>同一个 JVM 的所有线程、所有变量都处于同一个进程里，他们都使用该 JVM进程的内存区。</p>
<p>JVM 进程终止情况：</p>
<ul>
<li>程序正常结束</li>
<li>System.exit() 或 Runtime.getRuntime().exit()</li>
<li>遇到未捕获的异常或错误</li>
<li>程序所在平台强制结束 JVM 进程</li>
</ul>
<h3 id="18-1-2-类的加载"><a href="#18-1-2-类的加载" class="headerlink" title="18.1.2 类的加载"></a>18.1.2 类的加载</h3><p>类加载指的是将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象。</p>
<p>其实类也是一种对象，都是 java.lang.Class 的实例。</p>
<p>使用不同的类加载器，可以从不同的来源加载类的二进制数据：</p>
<ul>
<li>本地文件系统加载 class 文件</li>
<li>从 JAR 包加载</li>
<li>通过网络加载 class 文件</li>
<li>把一个 Java 源文件动态编译，并执行加载</li>
</ul>
<p>加载类通常无需等到首次使用才加载，JVM 规范允许系统预先加载某些类。</p>
<h3 id="18-1-3-类的连接"><a href="#18-1-3-类的连接" class="headerlink" title="18.1.3 类的连接"></a>18.1.3 类的连接</h3><p>生成 Class 对象后，接着将会进入到连接阶段，连接阶段负责把类的二进制数据合并到 JRE 中。</p>
<p>类的连接分三个阶段：</p>
<ul>
<li>验证：验证被加载的类是否有正确的内部结构，并和其他类协调一致。</li>
<li>准备：为类的类变量分配内存，并设置默认初始值</li>
<li>解析：将类的二进制数据中的符号引用替换成直接引用</li>
</ul>
<h3 id="18-1-4-类的初始化"><a href="#18-1-4-类的初始化" class="headerlink" title="18.1.4 类的初始化"></a>18.1.4 类的初始化</h3><p>主要是对类变量进行初始化。</p>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态初始化块为类变量指定初始值</li>
</ul>
<p>初始化类步骤：</p>
<ol>
<li>如果该类还没有被加载和连接，则程序先加载并连接该类</li>
<li>如果该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>如果该类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<p>所以 JVM 最先初始化的总是 Object 类。</p>
<h3 id="18-1-5-类初始化的时机"><a href="#18-1-5-类初始化的时机" class="headerlink" title="18.1.5 类初始化的时机"></a>18.1.5 类初始化的时机</h3><ul>
<li>创建类的实例。new、反射创建实例、反序列化创建实例</li>
<li>调用某个类的类方法（静态方法）</li>
<li>访问某个类或接口的类变量</li>
<li>使用反射方式来强制创建某个类或接口的 Class 对象。<code>Class.forName(&quot;Person&quot;)</code></li>
<li>初始化某个类的子类</li>
<li>直接使用 java.exe 命令来运行某个主类</li>
</ul>
<p>需要注意的是，如果编译时就就能确定值的 final 变量，相当于宏变量，编译时就已经替换，因此即使程序使用该静态变量，也不会导致类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"静态初始化块..."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 使用一个字符串直接量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String compileConstant = <span class="string">"疯狂Java讲义"</span>;</div><div class="line">    <span class="keyword">static</span> String a = <span class="string">"a"</span>;</div><div class="line">    <span class="keyword">static</span> String b = <span class="string">"b"</span>;</div><div class="line">    <span class="keyword">static</span> String c = a + b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileConstantTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 访问类变量，不会触发初始化。因为是宏变量</span></div><div class="line">        System.out.println(MyTest.compileConstant);</div><div class="line">        <span class="comment">// 会触发初始化</span></div><div class="line">        System.out.println(MyTest.c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用 ClassLoader 类的 loadClass() 方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化。Class.forName()才会触发初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"Tester 类的静态初始化块..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</div><div class="line">        <span class="comment">// 下面语句仅仅是加载 Tester 类</span></div><div class="line">        cl.loadClass(<span class="string">"unit18_classload.c1.Tester"</span>);</div><div class="line">        System.out.println(<span class="string">"========="</span>);</div><div class="line">        Class.forName(<span class="string">"unit18_classload.c1.Tester"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-2-类加载器"><a href="#18-2-类加载器" class="headerlink" title="18.2 类加载器"></a>18.2 类加载器</h2><h3 id="18-2-1-类加载机制"><a href="#18-2-1-类加载机制" class="headerlink" title="18.2.1 类加载机制"></a>18.2.1 类加载机制</h3><p>类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个 java.lang.Class 实例。一旦一个类被载入 JVM 中，同一个类就不会被再次载入了。</p>
<h4 id="类加载器层次"><a href="#类加载器层次" class="headerlink" title="类加载器层次"></a>类加载器层次</h4><p>JVM 启动时，会形成由三个类加载器组成的初始类加载器层次结构。</p>
<ul>
<li>Bootstrap ClassLoader：跟类加载器</li>
<li>Extension ClassLoader：扩展类加载器</li>
<li>System ClassLoader：系统类加载器</li>
</ul>
<h4 id="类加载器负责规则"><a href="#类加载器负责规则" class="headerlink" title="类加载器负责规则"></a>类加载器负责规则</h4><p>JVM 类加载机制有如下三种：</p>
<ul>
<li>全盘负责：当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 C拉萨市、 也将由该类加载器负责载入。</li>
<li>父类委托：尝试让父类加载器试图加载该 Class，父类无法加载时才尝试从自己的类路径中加载该类。</li>
<li>缓存机制：保证所有加载过的 Class 都会被缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderPropTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 获取系统类加载器</span></div><div class="line">        ClassLoader systemLoader = ClassLoader.getSystemClassLoader();</div><div class="line">        System.out.println(<span class="string">"系统类加载器："</span> + systemLoader);</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">        * 获取系统类加载器的加载路径--通常由 CLASSPATH 环境变量指定</span></div><div class="line"><span class="comment">        * 如果操作系统没有指定 CLASSPATH 环境变量，则默认以当前路径作为</span></div><div class="line"><span class="comment">        * 系统类加载器的加载路径</span></div><div class="line"><span class="comment">        * */</span></div><div class="line">        Enumeration&lt;URL&gt; eml = systemLoader.getResources(<span class="string">""</span>);</div><div class="line">        <span class="keyword">while</span> (eml.hasMoreElements())&#123;</div><div class="line">            System.out.println(eml.nextElement());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取系统类加载器的父类加载器，得到扩展类加载器</span></div><div class="line">        <span class="keyword">final</span> ClassLoader extensionLoader = systemLoader.getParent();</div><div class="line">        System.out.println(<span class="string">"扩展类加载器："</span> + extensionLoader);</div><div class="line">        System.out.println(<span class="string">"扩展类加载器的加载路径："</span> +</div><div class="line">                System.getProperty(<span class="string">"java.ext.dirs"</span>));</div><div class="line">        System.out.println(<span class="string">"扩展类加载器的 parent："</span> +</div><div class="line">                extensionLoader.getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果</span></div><div class="line">系统类加载器：jdk.internal.loader.ClassLoaders$AppClassLoader@<span class="number">3f</span>ee733d</div><div class="line">file:/D:/<span class="number">01</span>_code/<span class="number">01</span>_javasebasic/waojava/bin/</div><div class="line">扩展类加载器：jdk.internal.loader.ClassLoaders$PlatformClassLoader@<span class="number">30</span>dae81</div><div class="line">扩展类加载器的加载路径：<span class="keyword">null</span></div><div class="line">扩展类加载器的 parent：<span class="keyword">null</span></div></pre></td></tr></table></figure>
<p>扩展类加载器的 parent 是 null，并不是根类加载器，这是因为根类加载器并没有继承 ClassLoadeer 抽象类。但实际上，扩展类加载器的父类加载器是根类加载器，只是根类加载器并不是 Java 实现的。</p>
<h4 id="类加载器加载步骤"><a href="#类加载器加载步骤" class="headerlink" title="类加载器加载步骤"></a>类加载器加载步骤</h4><ol>
<li>监测此 Class 是否载入过（即在缓存区中是否有此 Class），否则直接第八步</li>
<li>父类加载器不存在（parent 为根类加载器，或者本身就是根类加载器），则跳到第四步；如果父类加载器存在，执行第三步。</li>
<li>请求使用父类加载器去载入目标类，成功则第八步，否则第五步</li>
<li>请求使用根类加载器去载入目标类，成功则第八步，否则第七步</li>
<li>当前类加载器寻找 Class 文件，成功则第六步，否则第七步</li>
<li>从文件中载入 Class，成功则第八步</li>
<li>抛出 ClassNotFoundException 异常</li>
<li>返回对应的 java.lang.Class 对象</li>
</ol>
<p>第5、6步允许重写 ClassLoader 的 findClass() 方法来实现自己的载入策略，甚至重写 loadClass() 来实现自己的载入过程。</p>
<h3 id="18-2-2-创建并使用自定义的类加载器"><a href="#18-2-2-创建并使用自定义的类加载器" class="headerlink" title="18.2.2 创建并使用自定义的类加载器"></a>18.2.2 创建并使用自定义的类加载器</h3><p>NM 中除根类加载器之外的所有类加载器都是 ClassLoader 子类的实例， 开发者可以通过扩展 ClassLoader 的子类，重写其方法来自定义类加载器。</p>
<p>ClassLoader:</p>
<ul>
<li>loadClass(String name, boolean resolve)<ul>
<li>findLoadedClass(String)检查是否已经加载</li>
<li>父类加载器 loadClass()，如果父类加载器为null，则用根类加载器</li>
<li>findClass(String)</li>
</ul>
</li>
<li>findClass(String name)</li>
<li>Class defineClass(String name, byte[] b, int off, int len)：将指定类发字节码文件读入字节数组 byte[] b，并把它转换为 Class 对象。final 方法，禁止重写。</li>
<li>findSystemClass(String name)：从本地文件系统装入文件。如文件存在则使用 defineClass() 生成 Class 对象那。</li>
<li>static getSystemClassLoader()：返回系统类加载器</li>
<li>getParent()：获取该类加载器的父类加载器</li>
<li>resolveClass(Class&lt;?&gt; c)：链接指定的类</li>
<li>findLoadedClass(String name)：类加载机制缓存机制的体现。</li>
</ul>
<p>所以重写 findClass() 方法可以避免覆盖默认类加载器的<strong>父类委托、缓冲机制</strong>两种策略; 如果重写 loadClass() 方法，则实现逻辑更为复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</div><div class="line">    <span class="comment">// 读取一个文件的内容</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getBytes(String filename) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        File file  = <span class="keyword">new</span> File(filename);</div><div class="line">        <span class="keyword">long</span> len = file.length();</div><div class="line">        <span class="keyword">byte</span>[] raw = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)len];</div><div class="line">        <span class="keyword">try</span>(FileInputStream fin = <span class="keyword">new</span> FileInputStream(file))&#123;</div><div class="line">            <span class="comment">// 一次拂去 Class 文件的全部二进制数据</span></div><div class="line">            <span class="keyword">int</span> r = fin.read(raw);</div><div class="line">            <span class="keyword">if</span>(r != len)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"无法读取全部文件："</span> +</div><div class="line">                        r + <span class="string">" != "</span> + len);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>  raw;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义编译指定 Java 文件的方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compile</span><span class="params">(String javaFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"CompileClassLoader:正在编译 "</span> +</div><div class="line">                javaFile + <span class="string">"..."</span>);</div><div class="line">        <span class="comment">// 调用系统的 javac 命令</span></div><div class="line">        Process p = Runtime.getRuntime().exec(<span class="string">"javac "</span> + javaFile);</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">// 其他线程都等待这个线程完成</span></div><div class="line">            p.waitFor();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">            System.out.println(ie);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取 javac 线程的退出值</span></div><div class="line">        <span class="keyword">int</span> ret = p.exitValue();</div><div class="line">        <span class="comment">// 返回编译是否成功</span></div><div class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重写 ClassLoader 的 findClass 方法</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        Class clazz = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 将包路径中的点(.)替换成斜线</span></div><div class="line">        String fileStub = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</div><div class="line">        String javaFilename = fileStub + <span class="string">".java"</span>;</div><div class="line">        String classFilename = fileStub + <span class="string">".class"</span>;</div><div class="line">        File javaFile = <span class="keyword">new</span> File(javaFilename);</div><div class="line">        File classFile = <span class="keyword">new</span> File(classFilename);</div><div class="line">        <span class="comment">// 当指定 Java 源文件存在，且 class 文件不存在，或者 Java 源文件</span></div><div class="line">        <span class="comment">// 的修改时间比 Class 文件的修改时间晚，重新编译</span></div><div class="line">        <span class="keyword">if</span>(javaFile.exists() &amp;&amp; (!classFile.exists() ||</div><div class="line">                javaFile.lastModified() &gt; classFile.lastModified()))&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                <span class="comment">// 如果编译失败，或者该 class 文件不存在</span></div><div class="line">                <span class="keyword">if</span>(!compile(javaFilename) || !classFile.exists())&#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"ClassNotFoundException:"</span> +</div><div class="line">                            javaFilename);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                ex.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果 class 文件存在，系统负责将该文件转换成 class 对象</span></div><div class="line">        <span class="keyword">if</span>(classFile.exists()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 将 class 文件的二进制数据读入数组</span></div><div class="line">                <span class="keyword">byte</span>[] raw = getBytes(classFilename);</div><div class="line">                <span class="comment">// 调用 classLoader 的 defineClass 方法将二进制数据转换成 class 对象</span></div><div class="line">                clazz = defineClass(name, raw, <span class="number">0</span>, raw.length);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ie) &#123;</div><div class="line">                ie.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果 clazz 为 null，表明加载失败，则抛出异常</span></div><div class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> clazz;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个主方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 如果运行该程序时没有参数，即没有目标类</span></div><div class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"缺少目标类，请按如下格式运行 Java 源文件："</span>);</div><div class="line">            System.out.println(<span class="string">"java CompileClassLoader ClassName"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 第一个参数是需要运行的类</span></div><div class="line">        String progClass = args[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 剩下的参数将作为运行目标类的参数</span></div><div class="line">        <span class="comment">// 将这些参数复制到一个新数组中</span></div><div class="line">        String[] progArgs = <span class="keyword">new</span> String[args.length -<span class="number">1</span>];</div><div class="line">        System.arraycopy(args, <span class="number">1</span>, progArgs, <span class="number">0</span>, progArgs.length);</div><div class="line">        CompileClassLoader ccl = <span class="keyword">new</span> CompileClassLoader();</div><div class="line">        <span class="comment">// 加载需要运行的类</span></div><div class="line">        Class&lt;?&gt; clazz = ccl.loadClass(progClass);</div><div class="line">        <span class="comment">// 获取需要运行的类的主方法</span></div><div class="line">        Method main = clazz.getMethod(<span class="string">"main"</span>, (<span class="keyword">new</span> String[<span class="number">0</span>]).getClass());</div><div class="line">        Object argsArray[] = &#123;progArgs&#125;;</div><div class="line">        main.invoke(<span class="keyword">null</span>, argsArray);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(String arg : args) &#123;</div><div class="line">            System.out.println(<span class="string">"运行 Hello 的参数："</span> + arg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>java CompileClassLoader Hello aaa</code> 就可以不编译直接运行 Hello 了。</p>
<p>自定义类加载器常见作用：</p>
<ul>
<li>执行代码前自动验证数字签名</li>
<li>根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译*.class文件。</li>
<li>根据用户需求来动态加载类</li>
<li>根据应用需求把其他数据以字节码的形式加载到应用中</li>
</ul>
<h3 id="18-2-3-URLClassLoader-类"><a href="#18-2-3-URLClassLoader-类" class="headerlink" title="18.2.3 URLClassLoader 类"></a>18.2.3 URLClassLoader 类</h3><p>ClassLoader 提供了一个实现类 URLClassLoader ，该类也是系统类加载器和扩展类加载器的父类。</p>
<p>它既可以从本地文件系统获取二进制文件来加载类，也可以从远程主机获取二进制文件夹来加载类。</p>
<ul>
<li>URLClassLoader(URL[] urls)</li>
<li>URLClassLoader(URL[] urls, ClassLoader parent)</li>
</ul>
<p>下面程序示范了如何直接从文件系统中加载 MySQL 驱动，这样可以无需将 MySQL 驱动添加到 CLASSPATH 环境变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLClassLoaderTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn;</div><div class="line">    <span class="comment">// 定义一个获取数据库连接的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">(String url, String user,</span></span></div><div class="line"><span class="function"><span class="params">        String pass)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">if</span>(conn == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 创建一个 URL 数组</span></div><div class="line">            URL[] urls = &#123;<span class="keyword">new</span> URL(<span class="string">"file:mysql-connection-java-5.1.30-bin.jar"</span>)&#125;;</div><div class="line">            <span class="comment">// 以默认的 ClassLoader 作为父 ClassLoader，创建 URLClassLoader</span></div><div class="line">            URLClassLoader myClassLoader = <span class="keyword">new</span> URLClassLoader(urls);</div><div class="line">            <span class="comment">// 加载 MySQL 的 JDBC 驱动，并创建默认实例</span></div><div class="line">            Driver driver = (Driver)myClassLoader</div><div class="line">                    .loadClass(<span class="string">"com.mysql.cj.jdbc.Driver"</span>)</div><div class="line">                    .getConstructor().newInstance();</div><div class="line">            <span class="comment">// 创建一个设置 JDBC 连接属性的 Properties 对象</span></div><div class="line">            Properties props = <span class="keyword">new</span> Properties();</div><div class="line">            <span class="comment">// 至少需要为该对象传入 user 和 password 两个属性</span></div><div class="line">            props.setProperty(<span class="string">"user"</span>, user);</div><div class="line">            props.setProperty(<span class="string">"password"</span>, pass);</div><div class="line">            <span class="comment">// 调用 Driver 对象的 connect 方法来取得数据库连接</span></div><div class="line">            conn = driver.connect(url, props);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> conn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(getConn(<span class="string">"jdbc:mysql://localhost:3306/mysql"</span>,</div><div class="line">                <span class="string">"root"</span>, <span class="string">"root"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-3-通过反射查看类信息"><a href="#18-3-通过反射查看类信息" class="headerlink" title="18.3 通过反射查看类信息"></a>18.3 通过反射查看类信息</h2><p>很多对象在运行时都会出现两种类型：编译时类型和运行时类型。</p>
<h3 id="18-3-1-获得-Class-对象"><a href="#18-3-1-获得-Class-对象" class="headerlink" title="18.3.1 获得 Class 对象"></a>18.3.1 获得 Class 对象</h3><p>获得 Class 对象的三种方式：</p>
<ul>
<li>Class.forName(String clazzNamem)</li>
<li>调用某个类的 class 属性：Person.class</li>
<li>调用某个对象的 getClass() 方法</li>
</ul>
<h3 id="18-3-2-从-Class-中获取信息"><a href="#18-3-2-从-Class-中获取信息" class="headerlink" title="18.3.2 从 Class 中获取信息"></a>18.3.2 从 Class 中获取信息</h3><h4 id="获取-Class-对应类所包含的构造器"><a href="#获取-Class-对应类所包含的构造器" class="headerlink" title="获取 Class 对应类所包含的构造器"></a>获取 Class 对应类所包含的构造器</h4><ul>
<li>Connstructor<t> getConstructor(Class&lt;?&gt;…parameterTypes)：返回 Class 对象对应类的、带指定形参列表的 public 构造器。</t></li>
<li>Constructor&lt;?&gt;[] getConstructors()：返回所有 public 构造器</li>
<li>Constructor<t> getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</t></li>
<li>Consructor&lt;?&gt;[] getDeclaredConstructors()</li>
</ul>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><ul>
<li>Method getMethod(String name, Clss&lt;?&gt;…parameterTypes)</li>
<li>Method[] getMethods()</li>
<li>Method getDeclaredMethod(String name, Clss&lt;?&gt;…parameterTypes)</li>
<li>Method[] getDeclaredMethods()</li>
</ul>
<h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><ul>
<li>Field getField(String name)</li>
<li>Field[] getFields()</li>
<li>Field getDeclaredField(String name)</li>
<li>Field[] getDeclaredFields()</li>
</ul>
<h4 id="获取-Annotation"><a href="#获取-Annotation" class="headerlink" title="获取 Annotation"></a>获取 Annotation</h4><ul>
<li><a extends="" annotation=""> A getAnnotation(Class<a> annotationClass)</a></a></li>
<li>Annotation[] getAnnotations()</li>
<li><a extends="" annotation=""> A getDeclaredAnnotation(Class<a> annotationClass)</a></a></li>
<li>Annotation[] getDeclaredAnnotations()</li>
<li><a extends="" annotation=""> A[] getAnnotationsByType(Class<a> annotationClass)</a></a></li>
<li><a extends="" annotation=""> A[] getDeclaredAnnotationsByType(Class<a> annotationClass)</a></a></li>
</ul>
<h4 id="获取内部类、外部类、接口、父类"><a href="#获取内部类、外部类、接口、父类" class="headerlink" title="获取内部类、外部类、接口、父类"></a>获取内部类、外部类、接口、父类</h4><ul>
<li>Class&lt;?&gt;[] getDeclaredClasses() ：内部类</li>
<li>Class&lt;?&gt; getDeclaringClass()：外部类</li>
<li>Class&lt;?&gt; getInterfaces()：实现的接口</li>
<li>Class&lt;? super T&gt; getSuperclass()：父类</li>
</ul>
<h4 id="修饰符、所在包、类名"><a href="#修饰符、所在包、类名" class="headerlink" title="修饰符、所在包、类名"></a>修饰符、所在包、类名</h4><ul>
<li>int getModifiers()</li>
<li>Package getPackage()</li>
<li>String getName()</li>
<li>String getSimpleName()</li>
</ul>
<h4 id="相关判断方法"><a href="#相关判断方法" class="headerlink" title="相关判断方法"></a>相关判断方法</h4><ul>
<li>boolean iaAnnotation()</li>
<li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</li>
<li>boolean isAnonymousClass()</li>
<li>boolean isArray()</li>
<li>boolean isEnum()</li>
<li>boolean isInterface()</li>
<li>boolean isInstance(Object obj)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义可重复注解</span></div><div class="line"><span class="meta">@Repeatable</span>(Annos.class)</div><div class="line"><span class="meta">@interface</span> Anno&#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@interface</span> Annos &#123;</div><div class="line">    Anno[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用 4 个注解修饰该类</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(value = <span class="string">"unchacked"</span>)</div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="meta">@Anno</span></div><div class="line"><span class="meta">@Anno</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</div><div class="line">    <span class="comment">// 私有构造器</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassTest</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">// 有参构造器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTest</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行有参构造器"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 无参方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"无参 info..."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 有参方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String str)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"有参 info...:"</span> + str);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 内部类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="comment">// 获取 Class 对象</span></div><div class="line">        <span class="keyword">final</span> Class&lt;ClassTest&gt; clazz = ClassTest.class;</div><div class="line">        <span class="comment">// 获取构造器</span></div><div class="line">        <span class="keyword">final</span> Constructor&lt;?&gt;[] ctors = clazz.getDeclaredConstructors();</div><div class="line">        System.out.println(<span class="string">"ClassTest 的全部构造器如下："</span>);</div><div class="line">        <span class="keyword">for</span>(Constructor c : ctors)&#123;</div><div class="line">            System.out.println(c);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取该 Class 对象所对应类的全部 public 方法</span></div><div class="line">        <span class="keyword">final</span> Method[] mtds = clazz.getMethods();</div><div class="line">        System.out.println(<span class="string">"ClassTest 的全部 public 方法如下："</span>);</div><div class="line">        <span class="keyword">for</span>(Method md : mtds)&#123;</div><div class="line">            System.out.println(md);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取该 class 对象所对应类的指定方法</span></div><div class="line">        System.out.println(<span class="string">"带一个参数的 info 方法为："</span> +</div><div class="line">                clazz.getMethod(<span class="string">"info"</span>, String.class));</div><div class="line">        <span class="comment">// 获取全部注解</span></div><div class="line">        <span class="keyword">final</span> Annotation[] anns = clazz.getAnnotations();</div><div class="line">        System.out.println(<span class="string">"全部注解如下："</span>);</div><div class="line">        <span class="keyword">for</span>(Annotation an : anns) &#123;</div><div class="line">            System.out.println(an);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"@SuppressWarnings 注解为："</span> +</div><div class="line">                Arrays.toString(clazz.getAnnotationsByType(SuppressWarnings.class)));</div><div class="line">        System.out.println(<span class="string">"@Anno 注解为："</span> +</div><div class="line">                Arrays.toString(clazz.getAnnotationsByType(Anno.class)));</div><div class="line"></div><div class="line">        <span class="comment">// 获取内部类</span></div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] inners = clazz.getDeclaredClasses();</div><div class="line">        System.out.println(<span class="string">"全部内部类如下："</span>);</div><div class="line">        <span class="keyword">for</span>(Class c : inners)&#123;</div><div class="line">            System.out.println(c);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 加载内部类</span></div><div class="line">        Class inClazz = Class.forName(<span class="string">"unit18_classload.c3.ClassTest$Inner"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 获取外部类</span></div><div class="line">        System.out.println(<span class="string">"inClazz 对应类的外部类为："</span> +</div><div class="line">                inClazz.getDeclaredClasses());</div><div class="line">        System.out.println(<span class="string">"包："</span> + clazz.getPackage());</div><div class="line">        System.out.println(<span class="string">"父类："</span> + clazz.getSuperclass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="18-3-3-Java-8-新增的方法参数反射"><a href="#18-3-3-Java-8-新增的方法参数反射" class="headerlink" title="18.3.3 Java 8 新增的方法参数反射"></a>18.3.3 Java 8 新增的方法参数反射</h3><p>Java 8 新增了一个抽象基类：Executable，代表可执行的类成员，派生了 Constructor、Method 两个子类。</p>
<ul>
<li>int getParameterCount()</li>
<li>Parameter[] getParameters()</li>
</ul>
<p>Parameter 提供了大量方法获取声明该参数的信息：</p>
<ul>
<li>geetModifiers()：修饰该形参的修饰符</li>
<li>String getName</li>
<li>Type getParameterizedType()</li>
<li>Class&lt;?&gt; getType()</li>
<li>boolean isNamePresent()</li>
<li>boolean isVarArgs()：是否为个数可变的形参</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replace</span><span class="params">(String str, List&lt;String&gt; list)</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParameterTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">        <span class="comment">// 获取 String 的类</span></div><div class="line">        <span class="keyword">final</span> Class&lt;Test&gt; clazz = Test.class;</div><div class="line">        <span class="comment">// 获取 Test 类带有两个参数的 replace 方法</span></div><div class="line">        <span class="keyword">final</span> Method replace = clazz.getMethod(<span class="string">"replace"</span>, String.class, List.class);</div><div class="line">        <span class="comment">// 获取指定方法的参数个数</span></div><div class="line">        System.out.println(<span class="string">"参数个数："</span> + replace.getParameterCount());</div><div class="line">        <span class="comment">// 获取所有参数信息</span></div><div class="line">        <span class="keyword">final</span> Parameter[] parameters = replace.getParameters();</div><div class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(Parameter p : parameters) &#123;</div><div class="line">            System.out.println(<span class="string">"----第"</span> + index++ + <span class="string">"个参数信息----"</span>);</div><div class="line">            System.out.println(<span class="string">"参数名："</span> + p.getName());</div><div class="line">            System.out.println(<span class="string">"形参类型："</span> + p.getType());</div><div class="line">            System.out.println(<span class="string">"泛型类型："</span> + p.getParameterizedType());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-4-使用反射生成并操作对象"><a href="#18-4-使用反射生成并操作对象" class="headerlink" title="18.4 使用反射生成并操作对象"></a>18.4 使用反射生成并操作对象</h2><h3 id="18-4-1-创建对象"><a href="#18-4-1-创建对象" class="headerlink" title="18.4.1 创建对象"></a>18.4.1 创建对象</h3><p>很多框架都需要根据配置文件信息来创建 Java 对象。这就必须要用到反射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPoolFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个对象池，前面的对象名，后面是实际对象</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; objectPool = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="comment">// 定义一个创建对象的方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createObject</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span></span></div><div class="line"><span class="function">            ClassNotFoundException, NoSuchMethodException,</span></div><div class="line"><span class="function">            IllegalAccessException, InvocationTargetException,</span></div><div class="line"><span class="function">            InstantiationException </span>&#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt; clazz = Class.forName(clazzName);</div><div class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 该方法根据指定文件来初始化对象池</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName))&#123;</div><div class="line">            <span class="keyword">final</span> Properties props = <span class="keyword">new</span> Properties();</div><div class="line">            props.load(fis);</div><div class="line">            <span class="keyword">for</span>(String name : props.stringPropertyNames())&#123;</div><div class="line">                objectPool.put(name, createObject(props.getProperty(name)));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            System.out.println(<span class="string">"读取"</span> + fileName + <span class="string">"异常"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> objectPool.get(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ObjectPoolFactory pf = <span class="keyword">new</span> ObjectPoolFactory();</div><div class="line">        pf.initPool(<span class="string">"a.txt"</span>);</div><div class="line">        System.out.println(pf.getObject(<span class="string">"a"</span>));</div><div class="line">        System.out.println(pf.getObject(<span class="string">"b"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想用指定的构造器创建对象：</p>
<ul>
<li>获取该类的 Class 对象</li>
<li>利用 Class 对象的 getConstructor() 方法来获取指定的构造器</li>
<li>newInstance()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJFrame</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 获取 JFrame 对象的 Class 对象</span></div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt; jframeClazz = Class.forName(<span class="string">"javax.swing.JFrame"</span>);</div><div class="line">        <span class="comment">// 获取 JFrame 中带一个字符串参数的构造器</span></div><div class="line">        Constructor ctor = jframeClazz.getConstructor(String.class);</div><div class="line">        <span class="keyword">final</span> Object obj = ctor.newInstance(<span class="string">"测试窗口"</span>);</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有当程序需要动态创建某个类的对象时才会考虑使用反射，通常在开发通用性比较广的框架、基础平台时可能会大量使用反射。</p>
<h3 id="18-4-2-调用方法"><a href="#18-4-2-调用方法" class="headerlink" title="18.4.2 调用方法"></a>18.4.2 调用方法</h3><ul>
<li>Object invoke(Object obj, Object…args)</li>
</ul>
<p>加强对象池工厂，允许在配置文件中配置对象的成员变量的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedObjectPoolFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个对象池</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; objectPool = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> Properties config = <span class="keyword">new</span> Properties();</div><div class="line">    <span class="comment">// 从指定属性文件中初始化 Properties 对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName))&#123;</div><div class="line">            config.load(fis);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">            System.out.println(<span class="string">"读取"</span> + fileName + <span class="string">"异常"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个创建对象的方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createObject</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(clazzName);</div><div class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据指定文件来初始化对象池</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">for</span>(String name : config.stringPropertyNames()) &#123;</div><div class="line">            <span class="keyword">if</span>(!name.contains(<span class="string">"%"</span>))&#123;</div><div class="line">                objectPool.put(name, createObject(config.getProperty(name)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 根据属性文件调用指定对象的 setter 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initProperty</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String name : config.stringPropertyNames())&#123;</div><div class="line">            <span class="keyword">if</span>(name.contains(<span class="string">"%"</span>))&#123;</div><div class="line">                <span class="comment">// 将配置文件中的 key 按 % 分隔</span></div><div class="line">                String[] objAndProp = name.split(<span class="string">"%"</span>);</div><div class="line">                <span class="comment">// 获取调用 setter 方法的参数值</span></div><div class="line">                Object target = getObject(objAndProp[<span class="number">0</span>]);</div><div class="line">                <span class="comment">// 获取 setter 方法名：set+"首字母大写"+剩下部分</span></div><div class="line">                String mtdName = <span class="string">"set"</span> +</div><div class="line">                        objAndProp[<span class="number">1</span>].substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()</div><div class="line">                        + objAndProp[<span class="number">1</span>].substring(<span class="number">1</span>);</div><div class="line">                <span class="comment">// 获取 Class 对象</span></div><div class="line">                <span class="keyword">final</span> Class&lt;?&gt; targetClass = target.getClass();</div><div class="line">                <span class="comment">// 获取希望调用的 setter 方法</span></div><div class="line">                <span class="keyword">final</span> Method mtd = targetClass.getMethod(mtdName, String.class);</div><div class="line">                <span class="comment">// 调用方法</span></div><div class="line">                mtd.invoke(target, config.getProperty(name));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> objectPool.get(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">final</span> ExtendedObjectPoolFactory epf = <span class="keyword">new</span> ExtendedObjectPoolFactory();</div><div class="line">        epf.init(<span class="string">"a.txt"</span>);</div><div class="line">        epf.initPool();</div><div class="line">        epf.initProperty();</div><div class="line">        System.out.println(epf.getObject(<span class="string">"a"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring IOC 的原理就是如此。</p>
<p>如果希望调用 private 方法：</p>
<ul>
<li>setAccessible(boolean flag)：将 Method 的 accessible 设置为 true表示不检查访问权限。</li>
</ul>
<h3 id="18-4-3-访问成员变量值"><a href="#18-4-3-访问成员变量值" class="headerlink" title="18.4.3 访问成员变量值"></a>18.4.3 访问成员变量值</h3><ul>
<li>getXxx(Object obj)：获取 obj 对象该成员变量的值，Xxx 对应 8 种基本类型。如果引用类型取消 Xxx</li>
<li>setXxx(Object obj, Xxx val)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Person[name:"</span> + name + <span class="string">", age:"</span> + age + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 创建一个 Person 对象</span></div><div class="line">        Person p = <span class="keyword">new</span> Person();</div><div class="line">        <span class="comment">// 获取对应 Class 对象</span></div><div class="line">        Class&lt;Person&gt; personClazz = Person.class;</div><div class="line">        <span class="comment">// 获取 Person 的名为 name 的成员变量</span></div><div class="line">        <span class="keyword">final</span> Field nameField = personClazz.getDeclaredField(<span class="string">"name"</span>);</div><div class="line">        <span class="comment">// 设置取消访问权限检查</span></div><div class="line">        nameField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 调用 set() 方法为 p 对象的 name 赋值</span></div><div class="line">        nameField.set(p, <span class="string">"Alvin"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Field ageField = personClazz.getDeclaredField(<span class="string">"age"</span>);</div><div class="line">        ageField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        ageField.setInt(p, <span class="number">26</span>);</div><div class="line">        System.out.println(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="18-4-4-操作数组"><a href="#18-4-4-操作数组" class="headerlink" title="18.4.4 操作数组"></a>18.4.4 操作数组</h3><p>java.lang.reflect 包下还提供一个 Array 类，代表数组，可以动态创建、操作数组。</p>
<ul>
<li>static Object newInstance(Class&lt;?&gt; componentType, int…length)</li>
<li><p>static xxx getXxx(Object array, int index)</p>
</li>
<li><p>static void setXxx(Object array, int index, xxx val)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建一个三位数组</span></div><div class="line">        <span class="keyword">final</span> Object arr = Array.newInstance(String.class, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</div><div class="line">        <span class="comment">// 获取 arr 种 index 为 2 的元素，该元素应该是一个二维数组</span></div><div class="line">        <span class="keyword">final</span> Object arrObj = Array.get(arr, <span class="number">2</span>);</div><div class="line">        <span class="comment">// 使用 Array 为二维数组的元素赋值。</span></div><div class="line">        Array.set(arrObj, <span class="number">2</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"aaa"</span>,<span class="string">"bbb"</span>&#125;);</div><div class="line"></div><div class="line">        <span class="comment">// 获取 arrObj 数组中 index 为 3 的元素，该元素是一维数组</span></div><div class="line">        <span class="keyword">final</span> Object anArr = Array.get(arrObj, <span class="number">3</span>);</div><div class="line">        Array.set(anArr, <span class="number">8</span>, <span class="string">"888"</span>);</div><div class="line">        <span class="comment">// 将 arr 强制转换为三维数组</span></div><div class="line">        String[][][] cast = (String[][][])arr;</div><div class="line">        System.out.println(cast[<span class="number">2</span>][<span class="number">2</span>][<span class="number">0</span>]);</div><div class="line">        System.out.println(cast[<span class="number">2</span>][<span class="number">2</span>][<span class="number">1</span>]);</div><div class="line"></div><div class="line">        System.out.println(cast[<span class="number">2</span>][<span class="number">3</span>][<span class="number">8</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-5-使用反射生成-JDK-动态代理"><a href="#18-5-使用反射生成-JDK-动态代理" class="headerlink" title="18.5 使用反射生成 JDK 动态代理"></a>18.5 使用反射生成 JDK 动态代理</h2><h3 id="18-5-1-使用-Proxy-和-InvocationHandler-创建动态代理"><a href="#18-5-1-使用-Proxy-和-InvocationHandler-创建动态代理" class="headerlink" title="18.5.1 使用 Proxy 和 InvocationHandler 创建动态代理"></a>18.5.1 使用 Proxy 和 InvocationHandler 创建动态代理</h3><p>如果在程序中为一个或多个接口动态生成实现类，就可以使用 Proxy 来创建动态代理类；如果需要为一个或多个接口动态创建实例，也可以使用 Proxy 来创建动态代理实例。</p>
<ul>
<li>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;…interfaces)：创建一个动态代理类所对应的Class 对象，该代理类将实现 interfaces 所指定的多个接口</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
</ul>
<p>即使采用第一种方式生成动态代理类后，如果需要通过该代理类创建对象，依然需要传入一个 InvocationHandler 对象。也就是说系统生成的每个代理对象都有一个与之关联的 InvocationHandler 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行动态代理对象的所有方法时，都会被替换成执行如下的 invoke 方法</span></div><div class="line"><span class="comment">     * proxy：动态代理对象</span></div><div class="line"><span class="comment">     * method：正在执行的方法</span></div><div class="line"><span class="comment">     * args：方法实参</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"======&gt;正在执行的方法："</span> + method);</div><div class="line">        <span class="keyword">if</span>(args != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"传入的实参："</span>);</div><div class="line">            <span class="keyword">for</span> (Object val : args) &#123;</div><div class="line">                System.out.println(val);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"没有实参"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建一个 InvocationHandler 对象</span></div><div class="line">        <span class="keyword">final</span> MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</div><div class="line">        <span class="comment">// 使用指定的 InvocationHandler 来生成一个动态代理对象</span></div><div class="line">        Person p = (Person) Proxy.newProxyInstance(</div><div class="line">                Person.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Person.class&#125;, handler);</div><div class="line">        <span class="comment">// 调用动态代理对象的 walk 和 sayHello 方法</span></div><div class="line">        p.walk();</div><div class="line">        p.sayHello(<span class="string">"alvin"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="18-5-2-动态代理和-AOP"><a href="#18-5-2-动态代理和-AOP" class="headerlink" title="18.5.2 动态代理和 AOP"></a>18.5.2 动态代理和 AOP</h3><p>各个模块可以执行公共代码，但是又无需在程序中以硬编码方式直接调用公共部分代码。这时就可以通过动态代理来达到这种效果。</p>
<p>JDK 动态代理只能为接口创建动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GunDog</span> <span class="keyword">implements</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只猎狗"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我奔跑迅速"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogUtil</span> </span>&#123;</div><div class="line">    <span class="comment">// 第一个拦截器方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"====模拟第一个通用方法===="</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 第二个拦截器方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"====模拟第二个通用方法===="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="comment">// 需要被代理的对象</span></div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 执行动态代理对象的所有方法时，都会被替换成执行该方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">final</span> DogUtil du = <span class="keyword">new</span> DogUtil();</div><div class="line">        <span class="comment">// 执行 DogUtil 对象中的 method1 方法</span></div><div class="line">        du.method1();</div><div class="line">        <span class="comment">// 以 target 作为主调来执行 method 方法</span></div><div class="line">        <span class="keyword">final</span> Object result = method.invoke(target, args);</div><div class="line">        <span class="comment">// 执行 DogUtil 对象中的 method2 方法</span></div><div class="line">        du.method2();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyFactot</span>γ </span>&#123;</div><div class="line">    <span class="comment">// 为指定的 target 生成动态代理对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</div><div class="line">        <span class="comment">// 创建一个 MyInvocationHandler 对象</span></div><div class="line">        <span class="keyword">final</span> MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</div><div class="line">        <span class="comment">// 为 handler 设置 target 对象</span></div><div class="line">        handler.setTarget(target);</div><div class="line">        <span class="comment">// 创建并返回一个动态代理</span></div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</div><div class="line">                target.getClass().getInterfaces(), handler);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建一个原始的 GunDog 对象，作为 target</span></div><div class="line">        <span class="keyword">final</span> Dog target = <span class="keyword">new</span> GunDog();</div><div class="line">        <span class="comment">// dog 实际上是动态代理对象，只是该动态代理对象也实现了 Dog 接口</span></div><div class="line">        Dog dog = (Dog)MyProxyFactotγ.getProxy(target);</div><div class="line">        dog.info();</div><div class="line">        dog.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="18-6-反射和泛型"><a href="#18-6-反射和泛型" class="headerlink" title="18.6 反射和泛型"></a>18.6 反射和泛型</h2><h3 id="18-6-1-泛型和-Class-类"><a href="#18-6-1-泛型和-Class-类" class="headerlink" title="18.6.1 泛型和 Class 类"></a>18.6.1 泛型和 Class 类</h3><p>使用 Class<t> 泛型可以避免强制类型转换。</t></p>
<p>使用泛型前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrazyitObjectFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">// 创建指定类对应的 Class 对象</span></div><div class="line">            Class cls = Class.forName(name);</div><div class="line">            <span class="keyword">return</span> cls.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Date d = (Date)CrazyitObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</div><div class="line"><span class="comment">// 将导致编译正常，但是运行时报错，而且需要强转</span></div><div class="line">JFrame f = (JFrame)CrazyitObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</div></pre></td></tr></table></figure>
<p>使用泛型后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrazyitObjectFactory2</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; cls)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">return</span> cls.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取实例后无需类型转换</span></div><div class="line">        <span class="keyword">final</span> Date d = CrazyitObjectFactory2.getInstance(Date.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="18-6-2-使用反射来获取泛型信息"><a href="#18-6-2-使用反射来获取泛型信息" class="headerlink" title="18.6.2 使用反射来获取泛型信息"></a>18.6.2 使用反射来获取泛型信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; score;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Class&lt;GenericTest&gt; clazz = GenericTest.class;</div><div class="line">        <span class="keyword">final</span> Field f = clazz.getDeclaredField(<span class="string">"score"</span>);</div><div class="line">        <span class="comment">// 直接使用 getType() 取出类型只对普通类型的成员变量有效</span></div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt; a = f.getType();</div><div class="line">        <span class="comment">// 仅仅输出 java.util.Map</span></div><div class="line">        System.out.println(<span class="string">"score的类型是："</span> + a);</div><div class="line">        <span class="comment">// 获得成员变量 f 的泛型类型</span></div><div class="line">        <span class="keyword">final</span> Type gType = f.getGenericType();</div><div class="line">        <span class="comment">// 如果 gType 是 ParameterizedType 对象</span></div><div class="line">        <span class="keyword">if</span>(gType <span class="keyword">instanceof</span> ParameterizedType) &#123;</div><div class="line">            ParameterizedType pType = (ParameterizedType)gType;</div><div class="line">            <span class="comment">// 获取原始类型</span></div><div class="line">            <span class="keyword">final</span> Type rType = pType.getRawType();</div><div class="line">            System.out.println(<span class="string">"原始类型是："</span> + rType);</div><div class="line">            <span class="comment">// 取得泛型类型的泛型参数</span></div><div class="line">            <span class="keyword">final</span> Type[] tArgs = pType.getActualTypeArguments();</div><div class="line">            System.out.println(<span class="string">"泛型信息是："</span> );</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tArgs.length; i++) &#123;</div><div class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"个泛型类型是:"</span> + tArgs[i]);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"获取泛型类型出错！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/疯狂-Java-讲义/">疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-02-18-202002/Redis 学习(一)-基本指令.html">Redis 学习(一)-概述、安装、类型、指令</a><a class="next" href="/2020-01-17-疯狂Java讲义/疯狂Java讲义C17.html">第 17 章 网络编程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加解密技术/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/吉他/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/无关技术/">无关技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/吉他/" style="font-size: 15px;">吉他</a> <a href="/tags/疯狂-Java-讲义/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/无关技术/" style="font-size: 15px;">无关技术</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>