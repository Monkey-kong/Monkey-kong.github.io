<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 18 章 类加载机制与反射 | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 18 章 类加载机制与反射</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 18 章 类加载机制与反射</h1><div class="post-meta">2020-01-18<span> | </span><span class="category"><a href="/categories/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">18.1 类的加载、连接和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-1-JVM-%E5%92%8C%E7%B1%BB"><span class="toc-text">18.1.1 JVM 和类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">18.1.2 类的加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-3-%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-text">18.1.3 类的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-4-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">18.1.4 类的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-5-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">18.1.5 类初始化的时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">18.2 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">18.2.1 类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1"><span class="toc-text">类加载器层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%B4%9F%E8%B4%A3%E8%A7%84%E5%88%99"><span class="toc-text">类加载器负责规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E6%AD%A5%E9%AA%A4"><span class="toc-text">类加载器加载步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-2-%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">18.2.2 创建并使用自定义的类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-3-URLClassLoader-%E7%B1%BB"><span class="toc-text">18.2.3 URLClassLoader 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-text">18.3 通过反射查看类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-1-%E8%8E%B7%E5%BE%97-Class-%E5%AF%B9%E8%B1%A1"><span class="toc-text">18.3.1 获得 Class 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-2-%E4%BB%8E-Class-%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF"><span class="toc-text">18.3.2 从 Class 中获取信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E5%BA%94%E7%B1%BB%E6%89%80%E5%8C%85%E5%90%AB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">获取 Class 对应类所包含的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-text">获取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">获取成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Annotation"><span class="toc-text">获取 Annotation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%A4%96%E9%83%A8%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E7%88%B6%E7%B1%BB"><span class="toc-text">获取内部类、外部类、接口、父类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E6%89%80%E5%9C%A8%E5%8C%85%E3%80%81%E7%B1%BB%E5%90%8D"><span class="toc-text">修饰符、所在包、类名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-text">相关判断方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-3-Java-8-%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%8F%8D%E5%B0%84"><span class="toc-text">18.3.3 Java 8 新增的方法参数反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90%E5%B9%B6%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1"><span class="toc-text">18.4 使用反射生成并操作对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">18.4.1 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-2-%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">18.4.2 调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-3-%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%80%BC"><span class="toc-text">18.4.3 访问成员变量值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-4-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84"><span class="toc-text">18.4.4 操作数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">18.5 使用反射生成 JDK 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-%E4%BD%BF%E7%94%A8-Proxy-%E5%92%8C-InvocationHandler-%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">18.5.1 使用 Proxy 和 InvocationHandler 创建动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-AOP"><span class="toc-text">18.5.2 动态代理和 AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6-%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="toc-text">18.6 反射和泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-1-%E6%B3%9B%E5%9E%8B%E5%92%8C-Class-%E7%B1%BB"><span class="toc-text">18.6.1 泛型和 Class 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-2-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">18.6.2 使用反射来获取泛型信息</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 18 章 类加载机制与反射</p>
<a id="more"></a>

<h2 id="18-1-类的加载、连接和初始化"><a href="#18-1-类的加载、连接和初始化" class="headerlink" title="18.1 类的加载、连接和初始化"></a>18.1 类的加载、连接和初始化</h2><h3 id="18-1-1-JVM-和类"><a href="#18-1-1-JVM-和类" class="headerlink" title="18.1.1 JVM 和类"></a>18.1.1 JVM 和类</h3><p>同一个 JVM 的所有线程、所有变量都处于同一个进程里，他们都使用该 JVM进程的内存区。</p>
<p>JVM 进程终止情况：</p>
<ul>
<li>程序正常结束</li>
<li>System.exit() 或 Runtime.getRuntime().exit()</li>
<li>遇到未捕获的异常或错误</li>
<li>程序所在平台强制结束 JVM 进程</li>
</ul>
<h3 id="18-1-2-类的加载"><a href="#18-1-2-类的加载" class="headerlink" title="18.1.2 类的加载"></a>18.1.2 类的加载</h3><p>类加载指的是将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象。</p>
<p>其实类也是一种对象，都是 java.lang.Class 的实例。</p>
<p>使用不同的类加载器，可以从不同的来源加载类的二进制数据：</p>
<ul>
<li>本地文件系统加载 class 文件</li>
<li>从 JAR 包加载</li>
<li>通过网络加载 class 文件</li>
<li>把一个 Java 源文件动态编译，并执行加载</li>
</ul>
<p>加载类通常无需等到首次使用才加载，JVM 规范允许系统预先加载某些类。</p>
<h3 id="18-1-3-类的连接"><a href="#18-1-3-类的连接" class="headerlink" title="18.1.3 类的连接"></a>18.1.3 类的连接</h3><p>生成 Class 对象后，接着将会进入到连接阶段，连接阶段负责把类的二进制数据合并到 JRE 中。</p>
<p>类的连接分三个阶段：</p>
<ul>
<li>验证：验证被加载的类是否有正确的内部结构，并和其他类协调一致。</li>
<li>准备：为类的类变量分配内存，并设置默认初始值</li>
<li>解析：将类的二进制数据中的符号引用替换成直接引用</li>
</ul>
<h3 id="18-1-4-类的初始化"><a href="#18-1-4-类的初始化" class="headerlink" title="18.1.4 类的初始化"></a>18.1.4 类的初始化</h3><p>主要是对类变量进行初始化。</p>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态初始化块为类变量指定初始值</li>
</ul>
<p>初始化类步骤：</p>
<ol>
<li>如果该类还没有被加载和连接，则程序先加载并连接该类</li>
<li>如果该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>如果该类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<p>所以 JVM 最先初始化的总是 Object 类。</p>
<h3 id="18-1-5-类初始化的时机"><a href="#18-1-5-类初始化的时机" class="headerlink" title="18.1.5 类初始化的时机"></a>18.1.5 类初始化的时机</h3><ul>
<li>创建类的实例。new、反射创建实例、反序列化创建实例</li>
<li>调用某个类的类方法（静态方法）</li>
<li>访问某个类或接口的类变量</li>
<li>使用反射方式来强制创建某个类或接口的 Class 对象。<code>Class.forName(&quot;Person&quot;)</code></li>
<li>初始化某个类的子类</li>
<li>直接使用 java.exe 命令来运行某个主类</li>
</ul>
<p>需要注意的是，如果编译时就就能确定值的 final 变量，相当于宏变量，编译时就已经替换，因此即使程序使用该静态变量，也不会导致类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化块...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个字符串直接量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String compileConstant = <span class="string">&quot;疯狂Java讲义&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> String c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileConstantTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问类变量，不会触发初始化。因为是宏变量</span></span><br><span class="line">        System.out.println(MyTest.compileConstant);</span><br><span class="line">        <span class="comment">// 会触发初始化</span></span><br><span class="line">        System.out.println(MyTest.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 ClassLoader 类的 loadClass() 方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化。Class.forName()才会触发初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tester 类的静态初始化块...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="comment">// 下面语句仅仅是加载 Tester 类</span></span><br><span class="line">        cl.loadClass(<span class="string">&quot;unit18_classload.c1.Tester&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        Class.forName(<span class="string">&quot;unit18_classload.c1.Tester&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-2-类加载器"><a href="#18-2-类加载器" class="headerlink" title="18.2 类加载器"></a>18.2 类加载器</h2><h3 id="18-2-1-类加载机制"><a href="#18-2-1-类加载机制" class="headerlink" title="18.2.1 类加载机制"></a>18.2.1 类加载机制</h3><p>类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个 java.lang.Class 实例。一旦一个类被载入 JVM 中，同一个类就不会被再次载入了。</p>
<h4 id="类加载器层次"><a href="#类加载器层次" class="headerlink" title="类加载器层次"></a>类加载器层次</h4><p>JVM 启动时，会形成由三个类加载器组成的初始类加载器层次结构。</p>
<ul>
<li>Bootstrap ClassLoader：跟类加载器</li>
<li>Extension ClassLoader：扩展类加载器</li>
<li>System ClassLoader：系统类加载器</li>
</ul>
<h4 id="类加载器负责规则"><a href="#类加载器负责规则" class="headerlink" title="类加载器负责规则"></a>类加载器负责规则</h4><p>JVM 类加载机制有如下三种：</p>
<ul>
<li>全盘负责：当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 C拉萨市、 也将由该类加载器负责载入。</li>
<li>父类委托：尝试让父类加载器试图加载该 Class，父类无法加载时才尝试从自己的类路径中加载该类。</li>
<li>缓存机制：保证所有加载过的 Class 都会被缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderPropTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;系统类加载器：&quot;</span> + systemLoader);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 获取系统类加载器的加载路径--通常由 CLASSPATH 环境变量指定</span></span><br><span class="line"><span class="comment">        * 如果操作系统没有指定 CLASSPATH 环境变量，则默认以当前路径作为</span></span><br><span class="line"><span class="comment">        * 系统类加载器的加载路径</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Enumeration&lt;URL&gt; eml = systemLoader.getResources(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (eml.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(eml.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取系统类加载器的父类加载器，得到扩展类加载器</span></span><br><span class="line">        <span class="keyword">final</span> ClassLoader extensionLoader = systemLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器：&quot;</span> + extensionLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器的加载路径：&quot;</span> +</span><br><span class="line">                System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器的 parent：&quot;</span> +</span><br><span class="line">                extensionLoader.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">系统类加载器：jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d</span><br><span class="line">file:/D:/01_code/01_javasebasic/waojava/bin/</span><br><span class="line">扩展类加载器：jdk.internal.loader.ClassLoaders$PlatformClassLoader@30dae81</span><br><span class="line">扩展类加载器的加载路径：<span class="keyword">null</span></span><br><span class="line">扩展类加载器的 parent：<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>扩展类加载器的 parent 是 null，并不是根类加载器，这是因为根类加载器并没有继承 ClassLoadeer 抽象类。但实际上，扩展类加载器的父类加载器是根类加载器，只是根类加载器并不是 Java 实现的。</p>
<h4 id="类加载器加载步骤"><a href="#类加载器加载步骤" class="headerlink" title="类加载器加载步骤"></a>类加载器加载步骤</h4><ol>
<li>监测此 Class 是否载入过（即在缓存区中是否有此 Class），否则直接第八步</li>
<li>父类加载器不存在（parent 为根类加载器，或者本身就是根类加载器），则跳到第四步；如果父类加载器存在，执行第三步。</li>
<li>请求使用父类加载器去载入目标类，成功则第八步，否则第五步</li>
<li>请求使用根类加载器去载入目标类，成功则第八步，否则第七步</li>
<li>当前类加载器寻找 Class 文件，成功则第六步，否则第七步</li>
<li>从文件中载入 Class，成功则第八步</li>
<li>抛出 ClassNotFoundException 异常</li>
<li>返回对应的 java.lang.Class 对象</li>
</ol>
<p>第5、6步允许重写 ClassLoader 的 findClass() 方法来实现自己的载入策略，甚至重写 loadClass() 来实现自己的载入过程。</p>
<h3 id="18-2-2-创建并使用自定义的类加载器"><a href="#18-2-2-创建并使用自定义的类加载器" class="headerlink" title="18.2.2 创建并使用自定义的类加载器"></a>18.2.2 创建并使用自定义的类加载器</h3><p>NM 中除根类加载器之外的所有类加载器都是 ClassLoader 子类的实例， 开发者可以通过扩展 ClassLoader 的子类，重写其方法来自定义类加载器。</p>
<p>ClassLoader:</p>
<ul>
<li>loadClass(String name, boolean resolve)<ul>
<li>findLoadedClass(String)检查是否已经加载</li>
<li>父类加载器 loadClass()，如果父类加载器为null，则用根类加载器</li>
<li>findClass(String)</li>
</ul>
</li>
<li>findClass(String name)</li>
<li>Class defineClass(String name, byte[] b, int off, int len)：将指定类发字节码文件读入字节数组 byte[] b，并把它转换为 Class 对象。final 方法，禁止重写。</li>
<li>findSystemClass(String name)：从本地文件系统装入文件。如文件存在则使用 defineClass() 生成 Class 对象那。</li>
<li>static getSystemClassLoader()：返回系统类加载器</li>
<li>getParent()：获取该类加载器的父类加载器</li>
<li>resolveClass(Class&lt;?&gt; c)：链接指定的类</li>
<li>findLoadedClass(String name)：类加载机制缓存机制的体现。</li>
</ul>
<p>所以重写 findClass() 方法可以避免覆盖默认类加载器的<strong>父类委托、缓冲机制</strong>两种策略; 如果重写 loadClass() 方法，则实现逻辑更为复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">// 读取一个文件的内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getBytes(String filename) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File file  = <span class="keyword">new</span> File(filename);</span><br><span class="line">        <span class="keyword">long</span> len = file.length();</span><br><span class="line">        <span class="keyword">byte</span>[] raw = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)len];</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fin = <span class="keyword">new</span> FileInputStream(file))&#123;</span><br><span class="line">            <span class="comment">// 一次拂去 Class 文件的全部二进制数据</span></span><br><span class="line">            <span class="keyword">int</span> r = fin.read(raw);</span><br><span class="line">            <span class="keyword">if</span>(r != len)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;无法读取全部文件：&quot;</span> +</span><br><span class="line">                        r + <span class="string">&quot; != &quot;</span> + len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  raw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义编译指定 Java 文件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compile</span><span class="params">(String javaFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompileClassLoader:正在编译 &quot;</span> +</span><br><span class="line">                javaFile + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用系统的 javac 命令</span></span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="string">&quot;javac &quot;</span> + javaFile);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 其他线程都等待这个线程完成</span></span><br><span class="line">            p.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            System.out.println(ie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 javac 线程的退出值</span></span><br><span class="line">        <span class="keyword">int</span> ret = p.exitValue();</span><br><span class="line">        <span class="comment">// 返回编译是否成功</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写 ClassLoader 的 findClass 方法</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将包路径中的点(.)替换成斜线</span></span><br><span class="line">        String fileStub = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String javaFilename = fileStub + <span class="string">&quot;.java&quot;</span>;</span><br><span class="line">        String classFilename = fileStub + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        File javaFile = <span class="keyword">new</span> File(javaFilename);</span><br><span class="line">        File classFile = <span class="keyword">new</span> File(classFilename);</span><br><span class="line">        <span class="comment">// 当指定 Java 源文件存在，且 class 文件不存在，或者 Java 源文件</span></span><br><span class="line">        <span class="comment">// 的修改时间比 Class 文件的修改时间晚，重新编译</span></span><br><span class="line">        <span class="keyword">if</span>(javaFile.exists() &amp;&amp; (!classFile.exists() ||</span><br><span class="line">                javaFile.lastModified() &gt; classFile.lastModified()))&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 如果编译失败，或者该 class 文件不存在</span></span><br><span class="line">                <span class="keyword">if</span>(!compile(javaFilename) || !classFile.exists())&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;ClassNotFoundException:&quot;</span> +</span><br><span class="line">                            javaFilename);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 class 文件存在，系统负责将该文件转换成 class 对象</span></span><br><span class="line">        <span class="keyword">if</span>(classFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将 class 文件的二进制数据读入数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] raw = getBytes(classFilename);</span><br><span class="line">                <span class="comment">// 调用 classLoader 的 defineClass 方法将二进制数据转换成 class 对象</span></span><br><span class="line">                clazz = defineClass(name, raw, <span class="number">0</span>, raw.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 clazz 为 null，表明加载失败，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 如果运行该程序时没有参数，即没有目标类</span></span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;缺少目标类，请按如下格式运行 Java 源文件：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;java CompileClassLoader ClassName&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个参数是需要运行的类</span></span><br><span class="line">        String progClass = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 剩下的参数将作为运行目标类的参数</span></span><br><span class="line">        <span class="comment">// 将这些参数复制到一个新数组中</span></span><br><span class="line">        String[] progArgs = <span class="keyword">new</span> String[args.length -<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(args, <span class="number">1</span>, progArgs, <span class="number">0</span>, progArgs.length);</span><br><span class="line">        CompileClassLoader ccl = <span class="keyword">new</span> CompileClassLoader();</span><br><span class="line">        <span class="comment">// 加载需要运行的类</span></span><br><span class="line">        Class&lt;?&gt; clazz = ccl.loadClass(progClass);</span><br><span class="line">        <span class="comment">// 获取需要运行的类的主方法</span></span><br><span class="line">        Method main = clazz.getMethod(<span class="string">&quot;main&quot;</span>, (<span class="keyword">new</span> String[<span class="number">0</span>]).getClass());</span><br><span class="line">        Object argsArray[] = &#123;progArgs&#125;;</span><br><span class="line">        main.invoke(<span class="keyword">null</span>, argsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行 Hello 的参数：&quot;</span> + arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java CompileClassLoader Hello aaa</code> 就可以不编译直接运行 Hello 了。</p>
<p>自定义类加载器常见作用：</p>
<ul>
<li>执行代码前自动验证数字签名</li>
<li>根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译*.class文件。</li>
<li>根据用户需求来动态加载类</li>
<li>根据应用需求把其他数据以字节码的形式加载到应用中</li>
</ul>
<h3 id="18-2-3-URLClassLoader-类"><a href="#18-2-3-URLClassLoader-类" class="headerlink" title="18.2.3 URLClassLoader 类"></a>18.2.3 URLClassLoader 类</h3><p>ClassLoader 提供了一个实现类 URLClassLoader ，该类也是系统类加载器和扩展类加载器的父类。</p>
<p>它既可以从本地文件系统获取二进制文件来加载类，也可以从远程主机获取二进制文件夹来加载类。</p>
<ul>
<li>URLClassLoader(URL[] urls)</li>
<li>URLClassLoader(URL[] urls, ClassLoader parent)</li>
</ul>
<p>下面程序示范了如何直接从文件系统中加载 MySQL 驱动，这样可以无需将 MySQL 驱动添加到 CLASSPATH 环境变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn;</span><br><span class="line">    <span class="comment">// 定义一个获取数据库连接的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">(String url, String user,</span></span></span><br><span class="line"><span class="function"><span class="params">        String pass)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个 URL 数组</span></span><br><span class="line">            URL[] urls = &#123;<span class="keyword">new</span> URL(<span class="string">&quot;file:mysql-connection-java-5.1.30-bin.jar&quot;</span>)&#125;;</span><br><span class="line">            <span class="comment">// 以默认的 ClassLoader 作为父 ClassLoader，创建 URLClassLoader</span></span><br><span class="line">            URLClassLoader myClassLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">            <span class="comment">// 加载 MySQL 的 JDBC 驱动，并创建默认实例</span></span><br><span class="line">            Driver driver = (Driver)myClassLoader</span><br><span class="line">                    .loadClass(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br><span class="line">                    .getConstructor().newInstance();</span><br><span class="line">            <span class="comment">// 创建一个设置 JDBC 连接属性的 Properties 对象</span></span><br><span class="line">            Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 至少需要为该对象传入 user 和 password 两个属性</span></span><br><span class="line">            props.setProperty(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">            props.setProperty(<span class="string">&quot;password&quot;</span>, pass);</span><br><span class="line">            <span class="comment">// 调用 Driver 对象的 connect 方法来取得数据库连接</span></span><br><span class="line">            conn = driver.connect(url, props);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(getConn(<span class="string">&quot;jdbc:mysql://localhost:3306/mysql&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-3-通过反射查看类信息"><a href="#18-3-通过反射查看类信息" class="headerlink" title="18.3 通过反射查看类信息"></a>18.3 通过反射查看类信息</h2><p>很多对象在运行时都会出现两种类型：编译时类型和运行时类型。</p>
<h3 id="18-3-1-获得-Class-对象"><a href="#18-3-1-获得-Class-对象" class="headerlink" title="18.3.1 获得 Class 对象"></a>18.3.1 获得 Class 对象</h3><p>获得 Class 对象的三种方式：</p>
<ul>
<li>Class.forName(String clazzNamem)</li>
<li>调用某个类的 class 属性：Person.class</li>
<li>调用某个对象的 getClass() 方法</li>
</ul>
<h3 id="18-3-2-从-Class-中获取信息"><a href="#18-3-2-从-Class-中获取信息" class="headerlink" title="18.3.2 从 Class 中获取信息"></a>18.3.2 从 Class 中获取信息</h3><h4 id="获取-Class-对应类所包含的构造器"><a href="#获取-Class-对应类所包含的构造器" class="headerlink" title="获取 Class 对应类所包含的构造器"></a>获取 Class 对应类所包含的构造器</h4><ul>
<li>Connstructor<T> getConstructor(Class&lt;?&gt;…parameterTypes)：返回 Class 对象对应类的、带指定形参列表的 public 构造器。</li>
<li>Constructor&lt;?&gt;[] getConstructors()：返回所有 public 构造器</li>
<li>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</li>
<li>Consructor&lt;?&gt;[] getDeclaredConstructors()</li>
</ul>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><ul>
<li>Method getMethod(String name, Clss&lt;?&gt;…parameterTypes)</li>
<li>Method[] getMethods()</li>
<li>Method getDeclaredMethod(String name, Clss&lt;?&gt;…parameterTypes)</li>
<li>Method[] getDeclaredMethods()</li>
</ul>
<h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><ul>
<li>Field getField(String name)</li>
<li>Field[] getFields()</li>
<li>Field getDeclaredField(String name)</li>
<li>Field[] getDeclaredFields()</li>
</ul>
<h4 id="获取-Annotation"><a href="#获取-Annotation" class="headerlink" title="获取 Annotation"></a>获取 Annotation</h4><ul>
<li><A extends Annotation> A getAnnotation(Class<A> annotationClass)</li>
<li>Annotation[] getAnnotations()</li>
<li><A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)</li>
<li>Annotation[] getDeclaredAnnotations()</li>
<li><A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass)</li>
<li><A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass)</li>
</ul>
<h4 id="获取内部类、外部类、接口、父类"><a href="#获取内部类、外部类、接口、父类" class="headerlink" title="获取内部类、外部类、接口、父类"></a>获取内部类、外部类、接口、父类</h4><ul>
<li>Class&lt;?&gt;[] getDeclaredClasses() ：内部类</li>
<li>Class&lt;?&gt; getDeclaringClass()：外部类</li>
<li>Class&lt;?&gt; getInterfaces()：实现的接口</li>
<li>Class&lt;? super T&gt; getSuperclass()：父类</li>
</ul>
<h4 id="修饰符、所在包、类名"><a href="#修饰符、所在包、类名" class="headerlink" title="修饰符、所在包、类名"></a>修饰符、所在包、类名</h4><ul>
<li>int getModifiers()</li>
<li>Package getPackage()</li>
<li>String getName()</li>
<li>String getSimpleName()</li>
</ul>
<h4 id="相关判断方法"><a href="#相关判断方法" class="headerlink" title="相关判断方法"></a>相关判断方法</h4><ul>
<li>boolean iaAnnotation()</li>
<li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</li>
<li>boolean isAnonymousClass()</li>
<li>boolean isArray()</li>
<li>boolean isEnum()</li>
<li>boolean isInterface()</li>
<li>boolean isInstance(Object obj)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义可重复注解</span></span><br><span class="line"><span class="meta">@Repeatable(Annos.class)</span></span><br><span class="line"><span class="meta">@interface</span> Anno&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Annos &#123;</span><br><span class="line">    Anno[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 4 个注解修饰该类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &quot;unchacked&quot;)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Anno</span></span><br><span class="line"><span class="meta">@Anno</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无参方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参 info...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参 info...:&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取 Class 对象</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;ClassTest&gt; clazz = ClassTest.class;</span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt;[] ctors = clazz.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassTest 的全部构造器如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : ctors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该 Class 对象所对应类的全部 public 方法</span></span><br><span class="line">        <span class="keyword">final</span> Method[] mtds = clazz.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassTest 的全部 public 方法如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Method md : mtds)&#123;</span><br><span class="line">            System.out.println(md);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该 class 对象所对应类的指定方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;带一个参数的 info 方法为：&quot;</span> +</span><br><span class="line">                clazz.getMethod(<span class="string">&quot;info&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取全部注解</span></span><br><span class="line">        <span class="keyword">final</span> Annotation[] anns = clazz.getAnnotations();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部注解如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Annotation an : anns) &#123;</span><br><span class="line">            System.out.println(an);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;@SuppressWarnings 注解为：&quot;</span> +</span><br><span class="line">                Arrays.toString(clazz.getAnnotationsByType(SuppressWarnings.class)));</span><br><span class="line">        System.out.println(<span class="string">&quot;@Anno 注解为：&quot;</span> +</span><br><span class="line">                Arrays.toString(clazz.getAnnotationsByType(Anno.class)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取内部类</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] inners = clazz.getDeclaredClasses();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部内部类如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Class c : inners)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载内部类</span></span><br><span class="line">        Class inClazz = Class.forName(<span class="string">&quot;unit18_classload.c3.ClassTest$Inner&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取外部类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;inClazz 对应类的外部类为：&quot;</span> +</span><br><span class="line">                inClazz.getDeclaredClasses());</span><br><span class="line">        System.out.println(<span class="string">&quot;包：&quot;</span> + clazz.getPackage());</span><br><span class="line">        System.out.println(<span class="string">&quot;父类：&quot;</span> + clazz.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3-3-Java-8-新增的方法参数反射"><a href="#18-3-3-Java-8-新增的方法参数反射" class="headerlink" title="18.3.3 Java 8 新增的方法参数反射"></a>18.3.3 Java 8 新增的方法参数反射</h3><p>Java 8 新增了一个抽象基类：Executable，代表可执行的类成员，派生了 Constructor、Method 两个子类。</p>
<ul>
<li>int getParameterCount()</li>
<li>Parameter[] getParameters()</li>
</ul>
<p>Parameter 提供了大量方法获取声明该参数的信息：</p>
<ul>
<li>geetModifiers()：修饰该形参的修饰符</li>
<li>String getName</li>
<li>Type getParameterizedType()</li>
<li>Class&lt;?&gt; getType()</li>
<li>boolean isNamePresent()</li>
<li>boolean isVarArgs()：是否为个数可变的形参</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replace</span><span class="params">(String str, List&lt;String&gt; list)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParameterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 String 的类</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;Test&gt; clazz = Test.class;</span><br><span class="line">        <span class="comment">// 获取 Test 类带有两个参数的 replace 方法</span></span><br><span class="line">        <span class="keyword">final</span> Method replace = clazz.getMethod(<span class="string">&quot;replace&quot;</span>, String.class, List.class);</span><br><span class="line">        <span class="comment">// 获取指定方法的参数个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;参数个数：&quot;</span> + replace.getParameterCount());</span><br><span class="line">        <span class="comment">// 获取所有参数信息</span></span><br><span class="line">        <span class="keyword">final</span> Parameter[] parameters = replace.getParameters();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Parameter p : parameters) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----第&quot;</span> + index++ + <span class="string">&quot;个参数信息----&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;参数名：&quot;</span> + p.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;形参类型：&quot;</span> + p.getType());</span><br><span class="line">            System.out.println(<span class="string">&quot;泛型类型：&quot;</span> + p.getParameterizedType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-4-使用反射生成并操作对象"><a href="#18-4-使用反射生成并操作对象" class="headerlink" title="18.4 使用反射生成并操作对象"></a>18.4 使用反射生成并操作对象</h2><h3 id="18-4-1-创建对象"><a href="#18-4-1-创建对象" class="headerlink" title="18.4.1 创建对象"></a>18.4.1 创建对象</h3><p>很多框架都需要根据配置文件信息来创建 Java 对象。这就必须要用到反射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个对象池，前面的对象名，后面是实际对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; objectPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义一个创建对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createObject</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">            IllegalAccessException, InvocationTargetException,</span></span><br><span class="line"><span class="function">            InstantiationException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; clazz = Class.forName(clazzName);</span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法根据指定文件来初始化对象池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName))&#123;</span><br><span class="line">            <span class="keyword">final</span> Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">            props.load(fis);</span><br><span class="line">            <span class="keyword">for</span>(String name : props.stringPropertyNames())&#123;</span><br><span class="line">                objectPool.put(name, createObject(props.getProperty(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取&quot;</span> + fileName + <span class="string">&quot;异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectPool.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ObjectPoolFactory pf = <span class="keyword">new</span> ObjectPoolFactory();</span><br><span class="line">        pf.initPool(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        System.out.println(pf.getObject(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(pf.getObject(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想用指定的构造器创建对象：</p>
<ul>
<li>获取该类的 Class 对象</li>
<li>利用 Class 对象的 getConstructor() 方法来获取指定的构造器</li>
<li>newInstance()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateJFrame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 JFrame 对象的 Class 对象</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; jframeClazz = Class.forName(<span class="string">&quot;javax.swing.JFrame&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 JFrame 中带一个字符串参数的构造器</span></span><br><span class="line">        Constructor ctor = jframeClazz.getConstructor(String.class);</span><br><span class="line">        <span class="keyword">final</span> Object obj = ctor.newInstance(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当程序需要动态创建某个类的对象时才会考虑使用反射，通常在开发通用性比较广的框架、基础平台时可能会大量使用反射。</p>
<h3 id="18-4-2-调用方法"><a href="#18-4-2-调用方法" class="headerlink" title="18.4.2 调用方法"></a>18.4.2 调用方法</h3><ul>
<li>Object invoke(Object obj, Object…args)</li>
</ul>
<p>加强对象池工厂，允许在配置文件中配置对象的成员变量的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedObjectPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个对象池</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; objectPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Properties config = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 从指定属性文件中初始化 Properties 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName))&#123;</span><br><span class="line">            config.load(fis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取&quot;</span> + fileName + <span class="string">&quot;异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个创建对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createObject</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(clazzName);</span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据指定文件来初始化对象池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String name : config.stringPropertyNames()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!name.contains(<span class="string">&quot;%&quot;</span>))&#123;</span><br><span class="line">                objectPool.put(name, createObject(config.getProperty(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据属性文件调用指定对象的 setter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initProperty</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : config.stringPropertyNames())&#123;</span><br><span class="line">            <span class="keyword">if</span>(name.contains(<span class="string">&quot;%&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// 将配置文件中的 key 按 % 分隔</span></span><br><span class="line">                String[] objAndProp = name.split(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取调用 setter 方法的参数值</span></span><br><span class="line">                Object target = getObject(objAndProp[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">// 获取 setter 方法名：set+&quot;首字母大写&quot;+剩下部分</span></span><br><span class="line">                String mtdName = <span class="string">&quot;set&quot;</span> +</span><br><span class="line">                        objAndProp[<span class="number">1</span>].substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()</span><br><span class="line">                        + objAndProp[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 获取 Class 对象</span></span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">                <span class="comment">// 获取希望调用的 setter 方法</span></span><br><span class="line">                <span class="keyword">final</span> Method mtd = targetClass.getMethod(mtdName, String.class);</span><br><span class="line">                <span class="comment">// 调用方法</span></span><br><span class="line">                mtd.invoke(target, config.getProperty(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectPool.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExtendedObjectPoolFactory epf = <span class="keyword">new</span> ExtendedObjectPoolFactory();</span><br><span class="line">        epf.init(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        epf.initPool();</span><br><span class="line">        epf.initProperty();</span><br><span class="line">        System.out.println(epf.getObject(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring IOC 的原理就是如此。</p>
<p>如果希望调用 private 方法：</p>
<ul>
<li>setAccessible(boolean flag)：将 Method 的 accessible 设置为 true表示不检查访问权限。</li>
</ul>
<h3 id="18-4-3-访问成员变量值"><a href="#18-4-3-访问成员变量值" class="headerlink" title="18.4.3 访问成员变量值"></a>18.4.3 访问成员变量值</h3><ul>
<li>getXxx(Object obj)：获取 obj 对象该成员变量的值，Xxx 对应 8 种基本类型。如果引用类型取消 Xxx</li>
<li>setXxx(Object obj, Xxx val)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person[name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取对应 Class 对象</span></span><br><span class="line">        Class&lt;Person&gt; personClazz = Person.class;</span><br><span class="line">        <span class="comment">// 获取 Person 的名为 name 的成员变量</span></span><br><span class="line">        <span class="keyword">final</span> Field nameField = personClazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置取消访问权限检查</span></span><br><span class="line">        nameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 调用 set() 方法为 p 对象的 name 赋值</span></span><br><span class="line">        nameField.set(p, <span class="string">&quot;Alvin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Field ageField = personClazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ageField.setInt(p, <span class="number">26</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4-4-操作数组"><a href="#18-4-4-操作数组" class="headerlink" title="18.4.4 操作数组"></a>18.4.4 操作数组</h3><p>java.lang.reflect 包下还提供一个 Array 类，代表数组，可以动态创建、操作数组。</p>
<ul>
<li><p>static Object newInstance(Class&lt;?&gt; componentType, int…length)</p>
</li>
<li><p>static xxx getXxx(Object array, int index)</p>
</li>
<li><p>static void setXxx(Object array, int index, xxx val)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个三位数组</span></span><br><span class="line">        <span class="keyword">final</span> Object arr = Array.newInstance(String.class, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 获取 arr 种 index 为 2 的元素，该元素应该是一个二维数组</span></span><br><span class="line">        <span class="keyword">final</span> Object arrObj = Array.get(arr, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 使用 Array 为二维数组的元素赋值。</span></span><br><span class="line">        Array.set(arrObj, <span class="number">2</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 arrObj 数组中 index 为 3 的元素，该元素是一维数组</span></span><br><span class="line">        <span class="keyword">final</span> Object anArr = Array.get(arrObj, <span class="number">3</span>);</span><br><span class="line">        Array.set(anArr, <span class="number">8</span>, <span class="string">&quot;888&quot;</span>);</span><br><span class="line">        <span class="comment">// 将 arr 强制转换为三维数组</span></span><br><span class="line">        String[][][] cast = (String[][][])arr;</span><br><span class="line">        System.out.println(cast[<span class="number">2</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        System.out.println(cast[<span class="number">2</span>][<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        System.out.println(cast[<span class="number">2</span>][<span class="number">3</span>][<span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-5-使用反射生成-JDK-动态代理"><a href="#18-5-使用反射生成-JDK-动态代理" class="headerlink" title="18.5 使用反射生成 JDK 动态代理"></a>18.5 使用反射生成 JDK 动态代理</h2><h3 id="18-5-1-使用-Proxy-和-InvocationHandler-创建动态代理"><a href="#18-5-1-使用-Proxy-和-InvocationHandler-创建动态代理" class="headerlink" title="18.5.1 使用 Proxy 和 InvocationHandler 创建动态代理"></a>18.5.1 使用 Proxy 和 InvocationHandler 创建动态代理</h3><p>如果在程序中为一个或多个接口动态生成实现类，就可以使用 Proxy 来创建动态代理类；如果需要为一个或多个接口动态创建实例，也可以使用 Proxy 来创建动态代理实例。</p>
<ul>
<li>static Class<?> getProxyClass(ClassLoader loader, Class<?>…interfaces)：创建一个动态代理类所对应的Class 对象，该代理类将实现 interfaces 所指定的多个接口</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
</ul>
<p>即使采用第一种方式生成动态代理类后，如果需要通过该代理类创建对象，依然需要传入一个 InvocationHandler 对象。也就是说系统生成的每个代理对象都有一个与之关联的 InvocationHandler 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行动态代理对象的所有方法时，都会被替换成执行如下的 invoke 方法</span></span><br><span class="line"><span class="comment">     * proxy：动态代理对象</span></span><br><span class="line"><span class="comment">     * method：正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：方法实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======&gt;正在执行的方法：&quot;</span> + method);</span><br><span class="line">        <span class="keyword">if</span>(args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传入的实参：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Object val : args) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有实参&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 InvocationHandler 对象</span></span><br><span class="line">        <span class="keyword">final</span> MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        <span class="comment">// 使用指定的 InvocationHandler 来生成一个动态代理对象</span></span><br><span class="line">        Person p = (Person) Proxy.newProxyInstance(</span><br><span class="line">                Person.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Person.class&#125;, handler);</span><br><span class="line">        <span class="comment">// 调用动态代理对象的 walk 和 sayHello 方法</span></span><br><span class="line">        p.walk();</span><br><span class="line">        p.sayHello(<span class="string">&quot;alvin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-5-2-动态代理和-AOP"><a href="#18-5-2-动态代理和-AOP" class="headerlink" title="18.5.2 动态代理和 AOP"></a>18.5.2 动态代理和 AOP</h3><p>各个模块可以执行公共代码，但是又无需在程序中以硬编码方式直接调用公共部分代码。这时就可以通过动态代理来达到这种效果。</p>
<p>JDK 动态代理只能为接口创建动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GunDog</span> <span class="keyword">implements</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只猎狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我奔跑迅速&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个拦截器方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====模拟第一个通用方法====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二个拦截器方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====模拟第二个通用方法====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行动态代理对象的所有方法时，都会被替换成执行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DogUtil du = <span class="keyword">new</span> DogUtil();</span><br><span class="line">        <span class="comment">// 执行 DogUtil 对象中的 method1 方法</span></span><br><span class="line">        du.method1();</span><br><span class="line">        <span class="comment">// 以 target 作为主调来执行 method 方法</span></span><br><span class="line">        <span class="keyword">final</span> Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 执行 DogUtil 对象中的 method2 方法</span></span><br><span class="line">        du.method2();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyFactot</span>γ </span>&#123;</span><br><span class="line">    <span class="comment">// 为指定的 target 生成动态代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 MyInvocationHandler 对象</span></span><br><span class="line">        <span class="keyword">final</span> MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        <span class="comment">// 为 handler 设置 target 对象</span></span><br><span class="line">        handler.setTarget(target);</span><br><span class="line">        <span class="comment">// 创建并返回一个动态代理</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原始的 GunDog 对象，作为 target</span></span><br><span class="line">        <span class="keyword">final</span> Dog target = <span class="keyword">new</span> GunDog();</span><br><span class="line">        <span class="comment">// dog 实际上是动态代理对象，只是该动态代理对象也实现了 Dog 接口</span></span><br><span class="line">        Dog dog = (Dog)MyProxyFactotγ.getProxy(target);</span><br><span class="line">        dog.info();</span><br><span class="line">        dog.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-6-反射和泛型"><a href="#18-6-反射和泛型" class="headerlink" title="18.6 反射和泛型"></a>18.6 反射和泛型</h2><h3 id="18-6-1-泛型和-Class-类"><a href="#18-6-1-泛型和-Class-类" class="headerlink" title="18.6.1 泛型和 Class 类"></a>18.6.1 泛型和 Class 类</h3><p>使用 Class<T> 泛型可以避免强制类型转换。</p>
<p>使用泛型前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrazyitObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建指定类对应的 Class 对象</span></span><br><span class="line">            Class cls = Class.forName(name);</span><br><span class="line">            <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date d = (Date)CrazyitObjectFactory.getInstance(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line"><span class="comment">// 将导致编译正常，但是运行时报错，而且需要强转</span></span><br><span class="line">JFrame f = (JFrame)CrazyitObjectFactory.getInstance(<span class="string">&quot;java.util.Date&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用泛型后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrazyitObjectFactory2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取实例后无需类型转换</span></span><br><span class="line">        <span class="keyword">final</span> Date d = CrazyitObjectFactory2.getInstance(Date.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-6-2-使用反射来获取泛型信息"><a href="#18-6-2-使用反射来获取泛型信息" class="headerlink" title="18.6.2 使用反射来获取泛型信息"></a>18.6.2 使用反射来获取泛型信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;GenericTest&gt; clazz = GenericTest.class;</span><br><span class="line">        <span class="keyword">final</span> Field f = clazz.getDeclaredField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">        <span class="comment">// 直接使用 getType() 取出类型只对普通类型的成员变量有效</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; a = f.getType();</span><br><span class="line">        <span class="comment">// 仅仅输出 java.util.Map</span></span><br><span class="line">        System.out.println(<span class="string">&quot;score的类型是：&quot;</span> + a);</span><br><span class="line">        <span class="comment">// 获得成员变量 f 的泛型类型</span></span><br><span class="line">        <span class="keyword">final</span> Type gType = f.getGenericType();</span><br><span class="line">        <span class="comment">// 如果 gType 是 ParameterizedType 对象</span></span><br><span class="line">        <span class="keyword">if</span>(gType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pType = (ParameterizedType)gType;</span><br><span class="line">            <span class="comment">// 获取原始类型</span></span><br><span class="line">            <span class="keyword">final</span> Type rType = pType.getRawType();</span><br><span class="line">            System.out.println(<span class="string">&quot;原始类型是：&quot;</span> + rType);</span><br><span class="line">            <span class="comment">// 取得泛型类型的泛型参数</span></span><br><span class="line">            <span class="keyword">final</span> Type[] tArgs = pType.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">&quot;泛型信息是：&quot;</span> );</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tArgs.length; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个泛型类型是:&quot;</span> + tArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取泛型类型出错！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/"><i class="fa fa-tag"></i>疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-02-18-202002/Redis%20%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html">Redis 学习(一)-概述、安装、类型、指令</a><a class="next" href="/2020-01-17-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C17.html">第 17 章 网络编程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%89%E4%BB%96/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/">无关技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 15px;">心情</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/%E5%90%89%E4%BB%96/" style="font-size: 15px;">吉他</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">无关技术</a> <a href="/tags/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>