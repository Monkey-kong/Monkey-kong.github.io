<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>SpringCloud学习(九) | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SpringCloud学习(九)</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SpringCloud学习(九)</h1><div class="post-meta">Oct 10, 2020<span> | </span><span class="category"><a href="/categories/SpringCloud/">SpringCloud</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、我们真的需要锁么？"><span class="toc-text">1、我们真的需要锁么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、分布式锁解决方案"><span class="toc-text">2、分布式锁解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-无锁情况"><span class="toc-text">2.1 无锁情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-JVM-锁"><span class="toc-text">2.1 JVM 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-基于-MySQL-实现分布式锁"><span class="toc-text">2.2 基于 MySQL 实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-基于-Redis-实现分布式锁"><span class="toc-text">2.3 基于 Redis 实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单节点"><span class="toc-text">单节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedLock（多master）"><span class="toc-text">RedLock（多master）</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><ul>
<li>分布式锁</li>
</ul>
<a id="more"></a>
<h2 id="1、我们真的需要锁么？"><a href="#1、我们真的需要锁么？" class="headerlink" title="1、我们真的需要锁么？"></a>1、我们真的需要锁么？</h2><p>需要锁的条件：</p>
<ol>
<li>多任务环境下。（进程，线程）</li>
<li>任务都对同一共享资源进行写操作。</li>
<li>对资源的访问是互斥的。</li>
</ol>
<p>操作周期：</p>
<ol>
<li>竞争锁。获取锁后才能对资源进行操作。</li>
<li>占有锁。操作中。</li>
<li>其他竞争者，任务阻塞。</li>
<li>占有锁者，释放锁。继续从 1 开始。</li>
</ol>
<p>分布式锁应用场景：</p>
<p>​    服务集群，比如 N 个订单服务，接受到大量司机的发送的对一个订单的抢单请求。如果是单个服务，可以用 jvm 锁控制，但是服务集群，jvm 就不行了。因为不在一个 jvm 中。jvm 锁解决不了分布式环境中的加锁问题。</p>
<h2 id="2、分布式锁解决方案"><a href="#2、分布式锁解决方案" class="headerlink" title="2、分布式锁解决方案"></a>2、分布式锁解决方案</h2><p>服务启动：</p>
<p><img src="../../images/springcloud/7/启动的服务.png" alt=""></p>
<p>jmeter 测试：10个司机同时抢一张订单。</p>
<p><img src="../../images/springcloud/7/jmeter测试1.png" alt=""></p>
<p><img src="../../images/springcloud/7/jmeter测试2.png" alt=""></p>
<p><img src="../../images/springcloud/7/jmeter测试3.png" alt=""></p>
<h3 id="2-1-无锁情况"><a href="#2-1-无锁情况" class="headerlink" title="2.1 无锁情况"></a>2.1 无锁情况</h3><p>测试结果：全部枪单成了。。。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Qualifier("grabNoLockService")</div><div class="line"></div><div class="line">司机:5 执行抢单逻辑</div><div class="line">司机:7 执行抢单逻辑</div><div class="line">司机:1 执行抢单逻辑</div><div class="line">司机:2 执行抢单逻辑</div><div class="line">司机:9 执行抢单逻辑</div><div class="line">司机:5 抢单成功</div><div class="line">司机:7 抢单成功</div><div class="line">司机:1 抢单成功</div><div class="line">司机:2 抢单成功</div><div class="line">司机:9 抢单成功</div><div class="line"></div><div class="line">司机:10 执行抢单逻辑</div><div class="line">司机:4 执行抢单逻辑</div><div class="line">司机:6 执行抢单逻辑</div><div class="line">司机:8 执行抢单逻辑</div><div class="line">司机:3 执行抢单逻辑</div><div class="line">司机:10 抢单成功</div><div class="line">司机:8 抢单成功</div><div class="line">司机:6 抢单成功</div><div class="line">司机:4 抢单成功</div><div class="line">司机:3 抢单成功</div></pre></td></tr></table></figure>
<p>结论：没锁肯定不行的。本来只有一张订单，现在你分出去十张订单了。</p>
<h3 id="2-1-JVM-锁"><a href="#2-1-JVM-锁" class="headerlink" title="2.1 JVM 锁"></a>2.1 JVM 锁</h3><p>测试结果：有两个司机枪单成功了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Qualifier("grabJvmLockService")</div><div class="line"></div><div class="line">司机:4 执行抢单逻辑</div><div class="line">司机:4 抢单成功</div><div class="line">司机:3 执行抢单逻辑</div><div class="line">司机:3 抢单失败</div><div class="line">司机:5 执行抢单逻辑</div><div class="line">司机:5 抢单失败</div><div class="line">司机:7 执行抢单逻辑</div><div class="line">司机:7 抢单失败</div><div class="line">司机:6 执行抢单逻辑</div><div class="line">司机:6 抢单失败</div><div class="line"></div><div class="line">司机:1 执行抢单逻辑</div><div class="line">司机:1 抢单成功</div><div class="line">司机:8 执行抢单逻辑</div><div class="line">司机:8 抢单失败</div><div class="line">司机:9 执行抢单逻辑</div><div class="line">司机:9 抢单失败</div><div class="line">司机:10 执行抢单逻辑</div><div class="line">司机:10 抢单失败</div><div class="line">司机:2 执行抢单逻辑</div><div class="line">司机:2 抢单失败</div></pre></td></tr></table></figure>
<p>结论：JVM 锁无法解决分布式，集群环境的问题。因为 JVM 锁只能控制单个 JVM 内部同步。所以需要分布式锁。</p>
<h3 id="2-2-基于-MySQL-实现分布式锁"><a href="#2-2-基于-MySQL-实现分布式锁" class="headerlink" title="2.2 基于 MySQL 实现分布式锁"></a>2.2 基于 MySQL 实现分布式锁</h3><p>测试结果：只有一个司机抢单成功，OK 的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=2)</div><div class="line">司机:2 执行抢单逻辑</div><div class="line">司机:2 抢单成功</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=2)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=4)</div><div class="line">司机:4 执行抢单逻辑</div><div class="line">司机:4 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=4)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=10)</div><div class="line">司机:10 执行抢单逻辑</div><div class="line">司机:10 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=10)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=9)</div><div class="line">司机:9 执行抢单逻辑</div><div class="line">司机:9 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=9)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=1)</div><div class="line">司机:1 执行抢单逻辑</div><div class="line">司机:1 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=1)</div><div class="line"></div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=8)</div><div class="line">司机:8 执行抢单逻辑</div><div class="line">司机:8 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=8)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=5)</div><div class="line">司机:5 执行抢单逻辑</div><div class="line">司机:5 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=5)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=7)</div><div class="line">司机:7 执行抢单逻辑</div><div class="line">司机:7 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=7)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=3)</div><div class="line">司机:3 执行抢单逻辑</div><div class="line">司机:3 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=3)</div><div class="line">加锁对象:OrderLock(orderId=1001, driverId=6)</div><div class="line">司机:6 执行抢单逻辑</div><div class="line">司机:6 抢单失败</div><div class="line">解锁对象:OrderLock(orderId=1001, driverId=6)</div></pre></td></tr></table></figure>
<p>结论：基于 MySQL 可以实现分布式锁。</p>
<p>存在的问题：</p>
<ul>
<li><p>如果中间出现异常了，如何释放锁？比如加锁后服务器断电了，finally 都来不及跑。</p>
<ul>
<li>用存储过程可以解决？具体怎么解决？加锁-操作订单-释放锁 放在一个 sp 中？</li>
</ul>
</li>
<li><p>MySQL 的并发是有限制的，不适合高并发场景。<strong>具体并发数要看机器的配置而定。</strong></p>
<ul>
<li><p>压测结果：<a href="https://help.aliyun.com/document_detail/150351.html?spm=a2c4g.11186623.6.1463.1e732d02nCMBBa" target="_blank" rel="external">https://help.aliyun.com/document_detail/150351.html?spm=a2c4g.11186623.6.1463.1e732d02nCMBBa</a></p>
<p>4核 16GB ：最大连接数 4000，QPS  39766.67  四万左右，TPS  1988.33  两千左右</p>
<p>8核 16GB ：最大连接数 4000，QPS   64750.34 六万左右，TPS   3237.52 三千左右</p>
</li>
<li><p>牛逼点的：<a href="https://help.aliyun.com/document_detail/101100.html?spm=5176.11065259.1996646101.searchclickresult.5a6316bcjenDJn" target="_blank" rel="external">https://help.aliyun.com/document_detail/101100.html?spm=5176.11065259.1996646101.searchclickresult.5a6316bcjenDJn</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-基于-Redis-实现分布式锁"><a href="#2-3-基于-Redis-实现分布式锁" class="headerlink" title="2.3 基于 Redis 实现分布式锁"></a>2.3 基于 Redis 实现分布式锁</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stringRedisTemplate 用法</div><div class="line">https://blog.csdn.net/zzz127333092/article/details/88742088</div></pre></td></tr></table></figure>
<p>redis：内存存储的数据结构服务器，内存数据库。redis 是单进程单线程的。</p>
<p>可用于：数据库，高速缓存，消息队列。采用单线程模型，并发能力强大。10 万并发没问题。</p>
<p>测试结果：只有一个司机抢单成功，OK 的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">司机:2 执行抢单逻辑</div><div class="line">司机:2 抢单成功</div><div class="line">司机:5 执行抢单逻辑</div><div class="line">司机:5 抢单失败</div><div class="line">司机:4 执行抢单逻辑</div><div class="line">司机:4 抢单失败</div><div class="line">司机:9 执行抢单逻辑</div><div class="line">司机:9 抢单失败</div><div class="line">司机:3 执行抢单逻辑</div><div class="line">司机:3 抢单失败</div><div class="line"></div><div class="line">司机:8 执行抢单逻辑</div><div class="line">司机:8 抢单失败</div><div class="line">司机:10 执行抢单逻辑</div><div class="line">司机:10 抢单失败</div><div class="line">司机:7 执行抢单逻辑</div><div class="line">司机:7 抢单失败</div><div class="line">司机:6 执行抢单逻辑</div><div class="line">司机:6 抢单失败</div><div class="line">司机:1 执行抢单逻辑</div><div class="line">司机:1 抢单失败</div></pre></td></tr></table></figure>
<p>结论：如果 redis 是单节点是 OK 的。但是如果是多节点，由于 Redis 的主从复制（replication）是异步的，这可能导致丧失锁的安全性。</p>
<blockquote>
<p>《Redis 分布锁》</p>
</blockquote>
<h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><p><strong><em>加锁</em></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SET orderId driverId NX PX 30000</div><div class="line">set order_1001 driver_001 nx px 30000</div></pre></td></tr></table></figure>
<p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p>
<p><strong><em>释放锁</em></strong></p>
<p>关键，判断是不是自己加的锁。</p>
<p><strong><em>关注点</em></strong>：</p>
<ol>
<li><p>orderId，是我们的 key，要锁的目标。一个单只能分配给一个司机，所以以 orderId 作为 key。</p>
</li>
<li><p>driverId 是我们的司机ID，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。即一个订单被一个司机抢。</p>
</li>
<li><p>NX 表示只有当 orderId 不存在的时候才能 SET 成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</p>
</li>
<li><p>PX 30000表示这个锁有一个 30 秒的自动过期时间。当然，这里 30 秒只是一个例子，客户端可以选择合适的过期时间。</p>
</li>
<li><p><strong>这个锁必须要设置一个过期时间。</strong>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分区，导致它再也无法和 Redis 节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。antirez在后面的分析中也特别强调了这一点，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p>
</li>
<li><p>此操作不能分割。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SETNX orderId driverId</div><div class="line">EXPIRE orderId 30</div><div class="line">虽然这两个命令和前面算法描述中的一个 SET 命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX 后崩溃了，那么就没有机会执行 EXPIRE 了，导致它一直持有这个锁。造成死锁。</div></pre></td></tr></table></figure>
</li>
<li><p>必须给 key 设置一个 value，并且保证每个线程不一样，用于释放锁时判断是否是自己的锁。如果 value 在每个线程间一样。会发生 <strong>误解锁</strong>的问题。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.客户端1获取锁成功。</div><div class="line">2.客户端1在某个操作上阻塞了很长时间。</div><div class="line">3.过期时间到了，锁自动释放了。</div><div class="line">4.客户端2获取到了对应同一个资源的锁。</div><div class="line">5.客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</div><div class="line">之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</div></pre></td></tr></table></figure>
</li>
<li><p>释放锁的操作，得释放自己加的锁。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.客户端1获取锁成功。</div><div class="line">2.客户端1访问共享资源。</div><div class="line">3.客户端1为了释放锁，先执行<span class="string">'GET'</span>操作获取随机字符串的值。</div><div class="line">4.客户端1判断随机字符串的值，与预期的值相等。</div><div class="line">5.客户端1由于某个原因阻塞住了很长时间。</div><div class="line">6.过期时间到了，锁自动释放了。</div><div class="line">7.客户端2获取到了对应同一个资源的锁。</div><div class="line">8.客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</div></pre></td></tr></table></figure>
</li>
<li><p>redis故障问题。</p>
<p>如果 redis 故障了，所有客户端无法获取锁，服务变得不可用。为了提高可用性，我们给 redis 配置主从，当master不可用时，系统切换到 slave，但是由于 Redis 的主从复制（replication）是异步的，这可能导致丧失锁的安全性。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.客户端1从 Master 获取了锁。</div><div class="line">2.Master 宕机了，存储锁的 key 还没有来得及同步到Slave上。</div><div class="line">3.Slave 升级为 Master。</div><div class="line">4.客户端2从新的Master获取到了对应同一个资源的锁。</div></pre></td></tr></table></figure>
<p>客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p>
</li>
<li><p>这个算法中出现的锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。应该设置稍微短一些，如果线程持有锁，开启线程自动延长有效期（<strong>自动续租锁</strong>）。</p>
</li>
</ol>
<p><strong><em>还有一点，如果在过期时间内，程序没有执行完，是不能让key过期的，所以要延时。</em></strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">断点打在：rlock.lock();</div><div class="line">执行完，之后，等着，去redis查看，看过期时间，是不是一直在变，</div><div class="line">答案：一直在变。到20时，自动加到30.</div></pre></td></tr></table></figure>
<p>为了解决 9、10 问题。antirez 设计了 Redlock 算法</p>
<p>Redis 的作者 antirez 给出了一个更好的实现，称为 Redlock，算是 Redis 官方对于实现分布式锁的指导规范。Redlock 的算法描述就放在 Redis 的官网上：</p>
<p><a href="https://redis.io/topics/distlock" target="_blank" rel="external">https://redis.io/topics/distlock</a></p>
<h4 id="RedLock（多master）"><a href="#RedLock（多master）" class="headerlink" title="RedLock（多master）"></a>RedLock（多master）</h4><p>debug</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">断点达到：rLock.lock()</div><div class="line">执行完后，看结果，发现如果是 3 个 redis 节点，则有 2 个节点中 设置了值。</div></pre></td></tr></table></figure>
<p>目的：对共享资源做互斥访问。   </p>
<p>因此 antirez 提出了新的分布式锁的算法 Redlock，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p>
<p>运行 Redlock 算法的客户端依次执行下面各个步骤，来完成 获取锁 的操作：</p>
<ol>
<li>获取当前时间（毫秒数）。</li>
<li>按顺序依次向 N 个 Redis 节点执行 <strong>获取锁</strong> 的操作。这个获取操作跟前面基于单 Redis 节点的 <strong>获取锁</strong> 的过程相同，包含 value driverId ，也包含<strong>过期时间</strong>(比如 <code>PX 30000</code> ，<strong>即锁的有效时间</strong>)。为了保证在某个Redis 节点不可用的时候算法能够继续运行，这个 <strong>获取锁</strong> 的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用，或者该 Redis 节点上的锁已经被其它客户端持有（注：Redlock 原文中这里只提到了 Redis 节点不可用的情况，但也应该包含其它的失败情况）。</li>
<li>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</li>
<li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。</li>
<li>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起 <strong>释放锁</strong> 的操作（即前面介绍的Redis Lua脚本）。</li>
</ol>
<p>当然，上面描述的只是 获取锁 的过程，而 释放锁 的过程比较简单：客户端向所有Redis节点发起 释放锁 的操作，不管这些节点当时在获取锁的时候成功与否。</p>
<blockquote>
<p>问题：Redis 节点崩溃重启，是否会对分布式锁造成影响？</p>
<p>答案：影响肯定是有的。即使持久化方式设置为每次修改都刷盘，也是会收到操作系统刷盘的影响的。antirez 提出延迟重启，让所有锁过期的方案。</p>
</blockquote>
<p>由于 N 个 Redis 节点中的大多数能正常工作就能保证 Redlock 正常工作，因此理论上它的可用性更高。我们前面讨论的单 Redis 节点的分布式锁在 failover 的时候锁失效的问题，在 Redlock 中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟 Redis 对数据的持久化程度有关。</p>
<p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p>
<ol>
<li>客户端1成功锁住了A, B, C， <strong>获取锁</strong> 成功（但D和E没有锁住）。</li>
<li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li>
<li>节点C重启后，客户端2锁住了C, D, E， <strong>获取锁</strong> 成功。</li>
</ol>
<p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p>
<p>在默认情况下，Redis 的 AOF 持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis 允许设置成每次修改数据都进行 fsync，但这会降低性能。当然，即使执行了 fsync 也仍然有可能丢失数据（这取决于系统而不是 Redis 的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez 又提出了<strong>延迟重启</strong> (delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p>
<blockquote>
<p>问题：为啥释放锁时要向所有 Redis 节点发送释放消息？</p>
<p>答案：因为异步通信模型中可能存在客户端向服务器是正常的，但是反方向却有问题。</p>
</blockquote>
<p>关于 Redlock 还有一点细节值得拿出来分析一下：在最后 释放锁 的时候，antirez 在算法描述中特别强调，客户端应该向所有 Redis 节点发起<strong>释放锁</strong>的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？设想这样一种情况，客户端发给某个 Redis 节点的 获取锁 的请求成功到达了该Redis节点，这个节点也成功执行了 <code>SET</code> 操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在 Redis 这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些 Redis 节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p>
</div><div class="tags"><a href="/tags/SpringCloud/">SpringCloud</a></div><div class="post-nav"><a class="pre" href="/2020-10-11-Spring Cloud/SpringCloud(8)-分布式事务.html">SpringCloud学习(十)</a><a class="next" href="/2020-10-08-常见问题/服务器磁盘满了.html"></a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加解密技术/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/吉他/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/无关技术/">无关技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/吉他/" style="font-size: 15px;">吉他</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/无关技术/" style="font-size: 15px;">无关技术</a> <a href="/tags/疯狂-Java-讲义/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>