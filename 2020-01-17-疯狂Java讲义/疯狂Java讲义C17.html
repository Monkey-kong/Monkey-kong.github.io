<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 17 章 网络编程 | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 17 章 网络编程</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 17 章 网络编程</h1><div class="post-meta">2020-01-17<span> | </span><span class="category"><a href="/categories/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">17.1 网络编程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-1-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">17.1.1 网络基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E3%80%82"><span class="toc-text">计算机网络分类。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI"><span class="toc-text">OSI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">通信协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-2-IP-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">17.1.2 IP 地址和端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP"><span class="toc-text">IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-text">端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-Java-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%BB%9C%E6%94%AF%E6%8C%81"><span class="toc-text">17.2 Java 的基本网络支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-1-%E4%BD%BF%E7%94%A8-InetAddress"><span class="toc-text">17.2.1 使用 InetAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-2-%E4%BD%BF%E7%94%A8-URLDecoder-%E5%92%8C-URLEncoder"><span class="toc-text">17.2.2 使用 URLDecoder 和 URLEncoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-3-URL-URLConnection%E5%92%8C-URLPermission"><span class="toc-text">17.2.3 URL URLConnection和 URLPermission</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URL"><span class="toc-text">URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLConnection-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">URLConnection 实现多线程下载工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLPermission"><span class="toc-text">URLPermission</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E5%9F%BA%E4%BA%8E-TCP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">17.3 基于 TCP 协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-1-TCP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-text">17.3.1 TCP 协议基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-2-%E4%BD%BF%E7%94%A8-ServerSocket-%E5%88%9B%E5%BB%BA-TCP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">17.3.2 使用 ServerSocket 创建 TCP 服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-3-%E4%BD%BF%E7%94%A8-Socket-%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">17.3.3 使用 Socket 进行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6"><span class="toc-text">连接超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-4-%E5%8A%A0%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">17.3.4 加入多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-S-%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%BA%94%E7%94%A8"><span class="toc-text">C&#x2F;S 聊天室应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-5-%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">17.3.5 记录用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E5%AD%97%E7%AC%A6"><span class="toc-text">定义协议字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-map"><span class="toc-text">自定义 map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server"><span class="toc-text">Server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerThread"><span class="toc-text">ServerThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Client"><span class="toc-text">Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ClientThread"><span class="toc-text">ClientThread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-6-%E5%8D%8A%E5%85%B3%E9%97%AD%E7%9A%84-Socket"><span class="toc-text">17.3.6 半关闭的 Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-7-%E4%BD%BF%E7%94%A8-NIO-%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E-Socket-%E9%80%9A%E4%BF%A1"><span class="toc-text">17.3.7 使用 NIO 实现非阻塞 Socket 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector"><span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectableChannel"><span class="toc-text">SelectableChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NIO-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-text">使用 NIO 实现多人聊天室</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-8-%E4%BD%BF%E7%94%A8-Java7-%E7%9A%84-AIO-%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1"><span class="toc-text">17.3.8 使用 Java7 的 AIO 实现非阻塞通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AsynchronousServerSocketChannel"><span class="toc-text">AsynchronousServerSocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsynchronousSocketChannel"><span class="toc-text">AsynchronousSocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%B7%A5%E5%85%B7"><span class="toc-text">AIO 多人聊天工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-%E5%9F%BA%E4%BA%8E-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">17.4 基于 UDP 协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-1-UDP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-text">17.4.1 UDP 协议基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-2-%E4%BD%BF%E7%94%A8-DatagramSocket-%E5%8F%91%E9%80%81%E3%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">17.4.2 使用 DatagramSocket 发送、接收数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-3-%E4%BD%BF%E7%94%A8-MulticaseSocket-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%82%B9%E5%B9%BF%E6%92%AD"><span class="toc-text">17.4.3 使用 MulticaseSocket 实现多点广播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-5-%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">17.5 使用代理服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-1-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-Proxy-%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="toc-text">17.5.1 直接使用 Proxy 创建连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-2-%E4%BD%BF%E7%94%A8-ProxySelector-%E8%87%AA%E5%8A%A8%E9%80%89%E6%8B%A9%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">17.5.2 使用 ProxySelector 自动选择代理服务器</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 17 章 网络编程</p>
<a id="more"></a>

<h2 id="17-1-网络编程的基础知识"><a href="#17-1-网络编程的基础知识" class="headerlink" title="17.1 网络编程的基础知识"></a>17.1 网络编程的基础知识</h2><h3 id="17-1-1-网络基础知识"><a href="#17-1-1-网络基础知识" class="headerlink" title="17.1.1 网络基础知识"></a>17.1.1 网络基础知识</h3><h4 id="计算机网络分类。"><a href="#计算机网络分类。" class="headerlink" title="计算机网络分类。"></a>计算机网络分类。</h4><p>按照规模大小和延申范围：局域网（LAN）、城域网（MAN）、广域网（WAN）。Interenet 可以视为世界上最大的广域网。</p>
<p>按照网络拓扑结构：星型网络、总线型网络、环形网络、树形网络、星型环型网络等。</p>
<p>按照传输介质：双绞线网、同轴电缆网、光纤网和卫星网。</p>
<h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><p>开放系统互连参考模型（OSI），力求将网络简化，并以模块化的方式设计网络。推荐把计算机网络分七层。</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>计算机网络中实现通信必须有一些约定，这些约定被称为通信协议。通信协议负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等制定处理标准。</p>
<p>通信协议通常由三部分组成: 一是<strong>语义</strong>部分，用于决定双方对话的类型; 二是<strong>语法</strong>部分，用于决定双方对话的格式; 三是<strong>变换规则</strong>，用于决定通信双方的应答关系。</p>
<p>IP（Internet Protocol）协议是一个非常重要的协议，是支持网间互联的<strong>数据报协议</strong>。它提供网间连接的完善功能，包括 IP 数据报规定互联网络范围内的地址格式。</p>
<p>TCP(Transmission Control Protocol)协议，规定一种<strong>可靠的数据信息传递服务。</strong></p>
<p>TCP、IP 协议功能上互补，实际使用中常常把这两个协议统称为 TCP/IP 协议，因此 TCP/IP 协议也是 Internet 中最常用的基础协议。TCP/IP 协议将网络分为四层。</p>
<ul>
<li>物理+数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
<h3 id="17-1-2-IP-地址和端口号"><a href="#17-1-2-IP-地址和端口号" class="headerlink" title="17.1.2 IP 地址和端口号"></a>17.1.2 IP 地址和端口号</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>在基于 IP 协议网络中传输的数据包，都必须使用 IP 地址来进行标识。</p>
<p>IP 地址是数字型的，是一个 32 位（32bit）整数，但为了便于记忆，通常把它分为 4 个 8 位的二进制数，每个 8 位可以转换成一个 0~255 的十进制整数，因此日常看到的 IP 地址常常是这种形式：192.168.128.88</p>
<p>NIC(Internet Network Information Center) 统一负责全球 Internet IP 地址的规划、管理，而 Inter NIC、APNIC、RIPE 三大网络信息中心具体负责美国及其他地区的 IP 地址分配。其中 APNIC 负责亚太地区的 IP 管理，总部在日本东京大学。</p>
<p>IP 地址分为 A、B、C、D、E 五类。</p>
<ul>
<li>A类：10.0.0.0~10.255.255.255</li>
<li>B类：172.16.0.0~172.31.255.255</li>
<li>C类：192.168.0.0~192.168.255.255</li>
</ul>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是一个 16 位的整数，用于表示数据交给哪个应用程序处理。端口号可以从 0 到 65535</p>
<ul>
<li>公认端口：0~1023，他们紧密绑定一些特定服务</li>
<li>注册端口：1024~49151，松散绑定一些服务，应用程序通常应该使用这个范围内的端口。</li>
<li>动态和/或私有端口：49152~65535，应用程序使用的动态端口。</li>
</ul>
<h2 id="17-2-Java-的基本网络支持"><a href="#17-2-Java-的基本网络支持" class="headerlink" title="17.2 Java 的基本网络支持"></a>17.2 Java 的基本网络支持</h2><h3 id="17-2-1-使用-InetAddress"><a href="#17-2-1-使用-InetAddress" class="headerlink" title="17.2.1 使用 InetAddress"></a>17.2.1 使用 InetAddress</h3><p>没有提供构造器，提供两个静态方法获取对象：</p>
<ul>
<li>getByName(String host)</li>
<li>getByAddress(byte[] addr)</li>
</ul>
<p>获取实例对应的 IP 地址和主机名:</p>
<ul>
<li>String getCanonicalHostName()：全限定域名</li>
<li>String getHostAddress()</li>
<li>String getHostName()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据主机名来获取实例</span></span><br><span class="line">        InetAddress ip = InetAddress.getByName(<span class="string">&quot;wiki.monkey-kong.cn&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否可达</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我的博客是否可达：&quot;</span> + ip.isReachable(<span class="number">2000</span>));</span><br><span class="line">        System.out.println(ip.getCanonicalHostName());</span><br><span class="line">        System.out.println(ip.getHostAddress());</span><br><span class="line">        System.out.println(ip.getHostName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据原始 IP 地址来获取对应的实例</span></span><br><span class="line">        InetAddress ip2 = InetAddress.getByAddress(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">104</span>, <span class="number">31</span>, <span class="number">66</span>, <span class="number">111</span>&#125;);</span><br><span class="line">        System.out.println(ip2.getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-2-2-使用-URLDecoder-和-URLEncoder"><a href="#17-2-2-使用-URLDecoder-和-URLEncoder" class="headerlink" title="17.2.2 使用 URLDecoder 和 URLEncoder"></a>17.2.2 使用 URLDecoder 和 URLEncoder</h3><p>URLDecoder 和 URLEncoder 用于完成普通字符串和 application/x-www-form-urlencoded MIME 字符串之间的互相转换。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDecoderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String keyWord = URLEncoder.encode(<span class="string">&quot;悟空&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(keyWord);</span><br><span class="line">        String gbk = URLDecoder.decode(keyWord, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(gbk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-2-3-URL-URLConnection和-URLPermission"><a href="#17-2-3-URL-URLConnection和-URLPermission" class="headerlink" title="17.2.3 URL URLConnection和 URLPermission"></a>17.2.3 URL URLConnection和 URLPermission</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL（Uniform Resource Locator）代表统一资源定位器，它是指向互联网资源的指针。资源可以是简单的文件或目录，也可以是对更为复杂对象的引用。</p>
<p>URL 组成：<code>protocol://host:port/resourceName</code></p>
<p>URI（Uniform Resource Identifiers）代表统一资源标识符，不能用于定位任何资源，唯一作用就是解析。</p>
<p>URL 类提供多个构造器用于获取对象，获取对象后就可以访问资源：</p>
<ul>
<li>String getFile()：获取资源名</li>
<li>String getHost()：获取主机名</li>
<li>String getPath()：获取路径</li>
<li>int getPort()</li>
<li>String getProtocol()</li>
<li>URLConnection openConnection()：获取和远程对象的连接</li>
<li>InputStream openStream()：打开连接，并返回一个读取资源的 InputStream</li>
</ul>
<h4 id="URLConnection-实现多线程下载工具类"><a href="#URLConnection-实现多线程下载工具类" class="headerlink" title="URLConnection 实现多线程下载工具类"></a>URLConnection 实现多线程下载工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义下载资源的路劲(远程资源)</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">// 指定下载文件保存位置(本地保存位置)</span></span><br><span class="line">    <span class="keyword">private</span> String targetFile;</span><br><span class="line">    <span class="comment">// 下载线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="comment">// 定义下载的线程对象</span></span><br><span class="line">    <span class="keyword">private</span> DownThread[] threads;</span><br><span class="line">    <span class="comment">// 定义下载的文件的总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fileSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownUtil</span><span class="params">(String path, String targetFile, <span class="keyword">int</span> threadNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.targetFile = targetFile;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">        threads = <span class="keyword">new</span> DownThread[threadNum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        conn.setConnectTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>,<span class="string">&quot;image/gif, image/jepg, image/pjpeg, &quot;</span></span><br><span class="line">            + <span class="string">&quot;application/x-shockwave-flash, application/xaml+xml&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到文件大小</span></span><br><span class="line">        fileSize = conn.getContentLength();</span><br><span class="line">        conn.disconnect();</span><br><span class="line">        <span class="keyword">int</span> currentPartSize = fileSize / threadNum + <span class="number">1</span>;</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置本地文件大小</span></span><br><span class="line">        file.setLength(fileSize);</span><br><span class="line">        file.close();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算每个线程下载的开始位置</span></span><br><span class="line">            <span class="keyword">int</span> startPos = i * currentPartSize;</span><br><span class="line">            <span class="comment">// 每个线程使用一个 RandomAccessFile 进行下载</span></span><br><span class="line">            RandomAccessFile currentPart = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">// 定位该线程的下载位置</span></span><br><span class="line">            currentPart.seek(startPos);</span><br><span class="line">            <span class="comment">// 创建下载线程</span></span><br><span class="line">            threads[i] = <span class="keyword">new</span> DownThread(startPos, currentPartSize, currentPart);</span><br><span class="line">            <span class="comment">// 启动下载线程</span></span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下载的完成百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCompleteRate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 统计多个线程已经下载的总大小</span></span><br><span class="line">        <span class="keyword">int</span> sumSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            sumSize += threads[i].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回已经完成百分比</span></span><br><span class="line">        <span class="keyword">return</span> sumSize * <span class="number">1.0</span> /fileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程的下载位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> startPos;</span><br><span class="line">        <span class="comment">// 当前线程负责下载的文件大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentPartSize;</span><br><span class="line">        <span class="comment">// 当前线程需要下载的文件块</span></span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile currentPart;</span><br><span class="line">        <span class="comment">// 当前线程已经下载的字节数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownThread</span><span class="params">(<span class="keyword">int</span> startPos, <span class="keyword">int</span> currentPartSize, RandomAccessFile currentPart)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.currentPartSize = currentPartSize;</span><br><span class="line">            <span class="keyword">this</span>.currentPart = currentPart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">                HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">                conn.setConnectTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>,<span class="string">&quot;image/gif, image/jepg, image/pjpeg, &quot;</span></span><br><span class="line">                        + <span class="string">&quot;application/x-shockwave-flash, application/xaml+xml&quot;</span>);</span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN&quot;</span>);</span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                InputStream inStream = conn.getInputStream();</span><br><span class="line">                <span class="comment">// 跳过 startPos 个字节，表明该线程只下载自己负责的那部分文件</span></span><br><span class="line">                inStream.skip(<span class="keyword">this</span>.startPos);</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 读取网络数据，并写入本地文件</span></span><br><span class="line">                <span class="keyword">while</span> (length &lt; currentPartSize</span><br><span class="line">                    &amp;&amp; (hasRead = inStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    currentPart.write(buffer, <span class="number">0</span>, hasRead);</span><br><span class="line">                    <span class="comment">// 累计该线程下载的总大小</span></span><br><span class="line">                    length += hasRead;</span><br><span class="line">                &#125;</span><br><span class="line">                currentPart.close();</span><br><span class="line">                inStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="URLPermission"><a href="#URLPermission" class="headerlink" title="URLPermission"></a>URLPermission</h4><p>Java8 新增，用于管理 HttpURLConnection 的权限问题，如果在 HttpURLConnection 安装了安全管理器，通过该对象打开连接时就需要先获得权限。</p>
<p>读取 URL 资源步骤：</p>
<ul>
<li>openConnection() 获取 URLConnection 对象</li>
<li>设置 URLConnection 的参数和普通请求属性</li>
<li>GET 请求直接 connect() 建立和远程资源的实际连接；POST 请求，需要获取 URLConnection 实例对应的输出流来发送请求参数。</li>
<li>远程资源变为可用</li>
</ul>
<p>在建立和远程资源的实际连接之前，可以通过如下方法来设置请求头字段。</p>
<ul>
<li>setAllowUserInteraction()</li>
<li>setDoInput()</li>
<li>setDoOutput()</li>
<li>setIfModifiedSince()</li>
<li>serUseCaches</li>
<li>setRequestProperty(String key, String value)：添加通用头字段</li>
<li>addRequestProperty(String key, String value): 追加，不覆盖</li>
</ul>
<p>远程资源可用后，可以访问头字段和内容</p>
<ul>
<li>Object getContent()</li>
<li>String getHeaderField(String name)</li>
<li>getInputStream()：用于获取 URLConnection 内容</li>
<li>getOutputStream()：用于向 URLConnection 发送请求参数</li>
<li>getHeaderField()</li>
<li>getContentEncoding()</li>
<li>getContentLength()</li>
<li>getContentType()</li>
<li>getDate()</li>
<li>getExpiration()</li>
<li>getLastModified()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向指定 URL 发送 GET 方式的请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendGet</span><span class="params">(String url, String param)</span> </span>&#123;</span><br><span class="line">	String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	String urlName = url + <span class="string">&quot;?&quot;</span> + param;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		URL realUrl = <span class="keyword">new</span> URL(urlName);</span><br><span class="line">		<span class="comment">// 打开和 URL 之间的连接</span></span><br><span class="line">		URLConnection conn = realUrl.openConnection();</span><br><span class="line">		<span class="comment">// 设置通用的请求属性</span></span><br><span class="line">		conn.setRequestProperty(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>);</span><br><span class="line">		conn.setRequestProperty(<span class="string">&quot;connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">		conn.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;</span>);</span><br><span class="line">		<span class="comment">// 建立实际的连接</span></span><br><span class="line">		conn.connect();</span><br><span class="line">		<span class="comment">// 获取所有的响应头字段</span></span><br><span class="line">		Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();</span><br><span class="line">		<span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">			System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">				<span class="comment">// 定义 BufferedReader 输入流来读取 URL 的响应</span></span><br><span class="line">				BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream(), <span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			String line;</span><br><span class="line">			<span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				result += <span class="string">&quot;\n&quot;</span> + line;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;发送 GET 请求出现异常！&quot;</span> + e);</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向指定 URL 发送 POST 方式请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendPost</span><span class="params">(String url, String param)</span> </span>&#123;</span><br><span class="line">	String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		URL realUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">		<span class="comment">// 打开和 URL 之间的连接</span></span><br><span class="line">		URLConnection conn = realUrl.openConnection();</span><br><span class="line">		<span class="comment">// 设置通用的请求属性</span></span><br><span class="line">		conn.setRequestProperty(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>);</span><br><span class="line">		conn.setRequestProperty(<span class="string">&quot;connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">		conn.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;</span>);</span><br><span class="line">		<span class="comment">// 发送 POST 请求必须设置如下两行</span></span><br><span class="line">		conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">		conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// 获取 URLConnection 对象对应的输出流</span></span><br><span class="line">			PrintWriter out = <span class="keyword">new</span> PrintWriter(conn.getOutputStream()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 发送请求参数</span></span><br><span class="line">			out.print(param);</span><br><span class="line">			<span class="comment">// flush 输出流的缓存</span></span><br><span class="line">			out.flush();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// 读取 URL 的响应</span></span><br><span class="line">			<span class="keyword">final</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream(), <span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			String line;</span><br><span class="line">			<span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				result += <span class="string">&quot;\n&quot;</span> + line;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;发送 POST 请求出现异常！&quot;</span> + e);</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-3-基于-TCP-协议的网络编程"><a href="#17-3-基于-TCP-协议的网络编程" class="headerlink" title="17.3 基于 TCP 协议的网络编程"></a>17.3 基于 TCP 协议的网络编程</h2><p>TCP/IP 通信协议是一种可靠的网络协议，他在通信的两端各建立一个 Socket 从而在通信的两端之间形成网络虚拟链路。一旦建立了链路，就可以进行通信了。</p>
<h3 id="17-3-1-TCP-协议基础"><a href="#17-3-1-TCP-协议基础" class="headerlink" title="17.3.1 TCP 协议基础"></a>17.3.1 TCP 协议基础</h3><p>通过使用 IP 协议，从而使得 Internet 成为一个允许连接不同类型的计算机和不同操作系统的网络。</p>
<p>要使两台计算机彼此能进行通信，必须使两台计算机使用同一种语言，IP 协议只保证计算机能发送和接收分组数据，但是 IP 协议不能解决数据分组在传输过程中可能出现的问题，因此还需要 TCP 协议。</p>
<p>TCP 协议负责收集这些信息包，并将其按适当的次序放好传送，接收端收到后再将其正确的还原。TCP 协议保证了数据包在传送中准确无误。</p>
<p>凡是要连接到 Internet 的计算机，都必须同时安装和使用这两个协议。</p>
<h3 id="17-3-2-使用-ServerSocket-创建-TCP-服务器端"><a href="#17-3-2-使用-ServerSocket-创建-TCP-服务器端" class="headerlink" title="17.3.2 使用 ServerSocket 创建 TCP 服务器端"></a>17.3.2 使用 ServerSocket 创建 TCP 服务器端</h3><ul>
<li>Socket accept()：如果收到一个客户端 Socket 的连接请求，该方法返回一个与客户端 Socket 对应的Socket；否则该方法将一直处于等待状态，线程也被阻塞。</li>
</ul>
<p>ServerSocket 提供如下几个构造器:</p>
<ul>
<li>ServerSocket(int port)</li>
<li>ServerSocket(int port, int backlog)：增加改变连接队列长度的参数</li>
<li>ServerSocket(int port, int backlog, InetAddress addr)：在机器存在多个 IP 地址的情况下，可以指定 IP</li>
</ul>
<p>通常情况下，ServerSocket 不应该只接收一个客户端请求，所以通常会写个死循环。</p>
<h3 id="17-3-3-使用-Socket-进行通信"><a href="#17-3-3-使用-Socket-进行通信" class="headerlink" title="17.3.3 使用 Socket 进行通信"></a>17.3.3 使用 Socket 进行通信</h3><p>构造器</p>
<ul>
<li>Socket(InetAddress/String remoteAddr, int port)</li>
<li>Socket(InetAddress/String remoteAddr, int port, InetAddr localAddr, int localPort)</li>
</ul>
<p>客户端连接到指定服务端后，不再区分客户端服务端，而是通过两个 socket 进行通讯</p>
<ul>
<li>InputStream getInputStream()：返回给 socket 对象对应的输入流，让程序通过该输入流从 socket 中取出数据</li>
<li>OutputStream getOutputStream()：向 socket 输出数据</li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 ServerSocket，用于监听客户端 Socket 的连接请求</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">// 循环不断地接收来自客户端的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每当接收到客户端 Socket 的请求时，服务端也会对应产生一个 Socket</span></span><br><span class="line">            Socket s = ss.accept();</span><br><span class="line">            s.setSoTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 Socket 对应的输出流包装成 PrintStream</span></span><br><span class="line">            <span class="keyword">final</span> PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">            <span class="comment">// 进行普通的 IO 操作</span></span><br><span class="line">            <span class="comment">// Thread.sleep(6000); // 验证 SoTimeout，让 Client 超时</span></span><br><span class="line">            ps.println(<span class="string">&quot;新年快乐&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            <span class="keyword">final</span> String line = br.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端说：&quot;</span> + line);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭输出流，关闭 Socket</span></span><br><span class="line">            ps.close();</span><br><span class="line">            br.close();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C1ient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">        socket.setSoTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Socket 对应的输入流包装成 BufferedReader</span></span><br><span class="line">        <span class="keyword">final</span> BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        <span class="keyword">final</span> String line = br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器说：&quot;</span> + line);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">        <span class="comment">// Thread.sleep(6000); // 验证 SoTimeout，让 Client 超时</span></span><br><span class="line">        ps.print(<span class="string">&quot;我是01号客户端，请求连接。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ps.close();</span><br><span class="line">        br.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h4><p>Socket 构造器没有超时时间参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个无连接的 Socket</span></span><br><span class="line">Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line"><span class="comment">// 通过 connect 方法设置连接超时时间</span></span><br><span class="line">s.connect(<span class="keyword">new</span> InetSocketAddress(host, portt), <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="17-3-4-加入多线程"><a href="#17-3-4-加入多线程" class="headerlink" title="17.3.4 加入多线程"></a>17.3.4 加入多线程</h3><p>在使用传统的 BufferedReader 的 readLine() 方法读取数据时，在该方法成功返回之前，线程被阻塞，程序无法继续执行。考虑到这个原因，服务器端应该单独启动一个线程，每个线程负责与一个客户端进行通信。</p>
<p>客户端服务服务端数据的线程同样会被阻塞，所以系统应该单独启动一个线程，该线程专门负责服务服务器端数据。</p>
<h4 id="C-S-聊天室应用"><a href="#C-S-聊天室应用" class="headerlink" title="C/S 聊天室应用"></a>C/S 聊天室应用</h4><p>服务器端包含多个线程，每个 Socket 对应一个线程，该线程负责读取 Socket 对应输入流的数据，并将读到的数据向每个 Socket 输出流发送一次（将一个客户端发送的数据广播给其他客户端）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义保存所有 Socket 的集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Socket&gt; socketList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">30000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞，将一直等待别人的连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket s = ss.accept();</span><br><span class="line">            socketList.add(s);</span><br><span class="line">            <span class="comment">// 每当客户端连接后启动一个 ServerThread 线程为该客户端服务</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(s)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责处理每个线程通信的线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义当前线程所处理的 socket</span></span><br><span class="line">    Socket s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 该线程所处理的 Socket 对应的输入流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="comment">// 初始化该 socket 对应的输入流</span></span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String content = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 采用循环，不断从 socket 中读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> ((content = readFromClient()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历 socketList 中每个 Socket</span></span><br><span class="line">                <span class="comment">// 将读到的内容向每个 Socket 发送一次</span></span><br><span class="line">                <span class="keyword">for</span> (Socket s : MyServer.socketList) &#123;</span><br><span class="line">                    <span class="keyword">final</span> PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">                    ps.println(content);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义读取客户端数据的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">readFromClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果报错，表明该 Socket 对应的客户端已经关闭，移除对应服务端 socket</span></span><br><span class="line">            MyServer.socketList.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">        <span class="comment">// 客户端启动 ClientThread 线程不断地读取来自服务器的数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientThread(s)).start();</span><br><span class="line">        <span class="comment">// 获取该 Socket 对应的输出流</span></span><br><span class="line">        <span class="keyword">final</span> PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 不断地读取键盘输入</span></span><br><span class="line">        <span class="keyword">final</span> BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将用户的键盘输入内容写入 Socket 对应的输入流</span></span><br><span class="line">            ps.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该线程负责处理的 Socket</span></span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line">    <span class="comment">// 该线程所处理的 Socket 对应的输入流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String content = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 不断地读取 Socket 输入流中的内容，并将这些内容打印输出</span></span><br><span class="line">            <span class="keyword">while</span> ((content = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3-5-记录用户信息"><a href="#17-3-5-记录用户信息" class="headerlink" title="17.3.5 记录用户信息"></a>17.3.5 记录用户信息</h3><p>实现私聊功能。</p>
<ul>
<li><p>客户端发送的信息必须有特殊的标识，让服务器可以判断是公聊信息还是私聊信息。</p>
</li>
<li><p>如果是私聊信息，客户端会发送该消息的目标用户。</p>
</li>
</ul>
<h4 id="定义协议字符"><a href="#定义协议字符" class="headerlink" title="定义协议字符"></a>定义协议字符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChatProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义协议字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> PROTOCOL_LEN = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下面是一些协议字符串，服务器端和客户端交换信息都应该在前、后添加这种特殊字符</span></span><br><span class="line">    String MSG_ROUND = <span class="string">&quot;$&quot;</span>;     <span class="comment">// 公聊</span></span><br><span class="line">    String USER_ROUND = <span class="string">&quot;Π&quot;</span>;    <span class="comment">// 登录</span></span><br><span class="line">    String LOGIN_SUCCESS = <span class="string">&quot;1&quot;</span>; <span class="comment">// 登录成功</span></span><br><span class="line">    String NAME_REP = <span class="string">&quot;-1&quot;</span>;     <span class="comment">// 登录失败</span></span><br><span class="line">    String PRIVATE_ROUND = <span class="string">&quot;⭐&quot;</span>;<span class="comment">// 私聊</span></span><br><span class="line">    String SPLIT_SING = <span class="string">&quot;❄&quot;</span>;    <span class="comment">// 私聊时分隔符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-map"><a href="#自定义-map" class="headerlink" title="自定义 map"></a>自定义 map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过组合 HashMap 对象来实现 UserMap，要求 value 也不能重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程安全的 map</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;K,V&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K,V&gt;());</span><br><span class="line">    <span class="comment">// 根据 value 来删除指定项</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeByValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == value) &#123;</span><br><span class="line">                map.remove(key);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取所有 value 组成的 set 集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;V&gt; <span class="title">valueSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;V&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将 map 中所有 value 添加到 result 中</span></span><br><span class="line">        map.forEach((key, value) -&gt; result.add(value));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 value 查找 key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> K <span class="title">getKeyByValue</span><span class="params">(V val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(K key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == val || map.get(key).equals(val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现 put 方法，该方法不允许 value 重复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(V val : valueSet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val.equals(value) &amp;&amp; val.hashCode() == value.hashCode()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;UserMap 实例中不允许有重复的 value&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格来说，UserMap 已经不是一个标准的 Map，但程序需要这样一个数据结构。即可以通过用户名找到对应的输出流也可以根据输出流找到对应的用户名。</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">// 使用 UserMap 来保存每个客户名字和对应输出流之间的映射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserMap&lt;String, PrintStream&gt; clients = <span class="keyword">new</span> UserMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="comment">// 创建一个 ServerSocket，用于监听客户端 Socket 的连接请求</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(SERVER_PORT))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket socket = ss.accept();</span><br><span class="line">                <span class="keyword">new</span> ServerThread(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器启动失败。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        server.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServerThread"><a href="#ServerThread" class="headerlink" title="ServerThread"></a>ServerThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取该 Socket 对应的输入流</span></span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            <span class="comment">// 获取该 Socket 对应的输出流</span></span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 以ServerThread开始和结束，则确定读取到的为登录的用户名</span></span><br><span class="line">                <span class="keyword">if</span>(line.startsWith(ChatProtocol.USER_ROUND)</span><br><span class="line">                  &amp;&amp; line.endsWith(ChatProtocol.USER_ROUND)) &#123;</span><br><span class="line">                    <span class="comment">// 得到真实消息</span></span><br><span class="line">                    String userName = getRealMsg(line);</span><br><span class="line">                    <span class="comment">// 如果用户名重复</span></span><br><span class="line">                    <span class="keyword">if</span>(Server.clients.map.containsKey(userName))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;登录失败，用户名重复。&quot;</span>);</span><br><span class="line">                        ps.println(ChatProtocol.NAME_REP);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;登录成功。&quot;</span>);</span><br><span class="line">                        ps.println(ChatProtocol.LOGIN_SUCCESS);</span><br><span class="line">                        Server.clients.put(userName, ps);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(line.startsWith(ChatProtocol.PRIVATE_ROUND)</span><br><span class="line">                  &amp;&amp; line.startsWith(ChatProtocol.PRIVATE_ROUND))&#123;</span><br><span class="line">                    <span class="comment">// 以 PRIVATE_ROUND 开始和结尾，则确定为私聊信息</span></span><br><span class="line">                    <span class="comment">// 得到真实消息</span></span><br><span class="line">                    String userAndMsg = getRealMsg(line);</span><br><span class="line">                    <span class="comment">// 以 SPLIT_SIGN 分割，前半是私聊用户，后半是聊天信息</span></span><br><span class="line">                    String user = userAndMsg.split(ChatProtocol.SPLIT_SING)[<span class="number">0</span>];</span><br><span class="line">                    String msg = userAndMsg.split(ChatProtocol.SPLIT_SING)[<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 获取私聊用户对应的输出流，并发送私聊信息</span></span><br><span class="line">                    Server.clients.map.get(user).println(Server.clients.</span><br><span class="line">                            getKeyByValue(ps) + <span class="string">&quot;悄悄对你说：&quot;</span> + msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 公聊</span></span><br><span class="line">                    <span class="comment">// 得到真实信息</span></span><br><span class="line">                    String msg = getRealMsg(line);</span><br><span class="line">                    <span class="keyword">for</span>(PrintStream clientPs : Server.clients.valueSet()) &#123;</span><br><span class="line">                        clientPs.println(Server.clients.getKeyByValue(ps)</span><br><span class="line">                            + <span class="string">&quot;说&quot;</span> + msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Server.clients.removeByValue(ps);</span><br><span class="line">            System.out.println(Server.clients.map.size());</span><br><span class="line">            <span class="comment">// 关闭网络、IO资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将读到的内容去掉前后的协议字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRealMsg</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> line.substring(ChatProtocol.PROTOCOL_LEN,</span><br><span class="line">                line.length() - ChatProtocol.PROTOCOL_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> PrintStream ps;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader brServer;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader keyIn;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化代表键盘的输入流</span></span><br><span class="line">            keyIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="comment">// 连接到服务器</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, SERVER_PORT);</span><br><span class="line">            <span class="comment">// 获取该 Socket 对应的输入流和输出流</span></span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">            brServer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String tip = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String userName = JOptionPane.showInputDialog(tip</span><br><span class="line">                  + <span class="string">&quot;输入用户名&quot;</span>);</span><br><span class="line">                <span class="comment">// 在用户输入用户民前后增加协议字符串后发送给服务器</span></span><br><span class="line">                ps.println(ChatProtocol.USER_ROUND + userName + ChatProtocol.USER_ROUND);;</span><br><span class="line">                <span class="comment">// 读取服务器的响应</span></span><br><span class="line">                <span class="keyword">final</span> String result = brServer.readLine();</span><br><span class="line">                <span class="comment">// 如果用户名重复，则开始下次循环</span></span><br><span class="line">                <span class="keyword">if</span>(result.equals(ChatProtocol.NAME_REP)) &#123;</span><br><span class="line">                    tip = <span class="string">&quot;用户名重复！请重新&quot;</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果服务器返回成功，则循环结束</span></span><br><span class="line">                <span class="keyword">if</span>(result.equals(ChatProtocol.LOGIN_SUCCESS)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到远程服务器，请确定服务器已经启动&quot;</span>);</span><br><span class="line">            closeRs();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;网络异常！请重新登录&quot;</span>);</span><br><span class="line">            closeRs();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以该 Socket 对应的输入流启动 ClientThread 线程</span></span><br><span class="line">        <span class="keyword">new</span> ClientThread(brServer).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个读取键盘输出，并向网络发送的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readAndSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 不断服务键盘输入</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = keyIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果发送的信息中有冒号，且以 // 开头，则认为私聊</span></span><br><span class="line">                <span class="keyword">if</span>(line.indexOf(<span class="string">&quot;:&quot;</span>)&gt;<span class="number">0</span> &amp;&amp; line.startsWith(<span class="string">&quot;//&quot;</span>))&#123;</span><br><span class="line">                    line = line.substring(<span class="number">2</span>);</span><br><span class="line">                    ps.println(ChatProtocol.PRIVATE_ROUND +</span><br><span class="line">                            line.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>] + ChatProtocol.SPLIT_SING +</span><br><span class="line">                            line.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>] + ChatProtocol.PRIVATE_ROUND</span><br><span class="line">                            );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ps.println(ChatProtocol.MSG_ROUND + line + ChatProtocol.MSG_ROUND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;网络通信异常！请重新登录！&quot;</span>);</span><br><span class="line">            closeRs();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭 Socket、输入流、输出流</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeRs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (keyIn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                keyIn.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (brServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                brServer.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.init();</span><br><span class="line">        client.readAndSend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClientThread"><a href="#ClientThread" class="headerlink" title="ClientThread"></a>ClientThread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该客户端线程负责处理的输入流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 使用一个网络输入流来创建客户端线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(BufferedReader br)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.br = br;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 不断从输入流中读取数据，并将这些数据打印</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                本例仅打印了从服务器端读到的内容。实际上，此处的情况可以更复杂:如</span></span><br><span class="line"><span class="comment">                果希望客户端能看到聊天室的用户列表，则可以让服务器端在每次有用户登</span></span><br><span class="line"><span class="comment">                录、用户退出时，将所有的用户列表信息都向客户端发送一遍。为了区分服</span></span><br><span class="line"><span class="comment">                务器端发送的是聊天信息，还是用户列表，服务器端也应该在要发送的信息</span></span><br><span class="line"><span class="comment">                前、后都添加一定的协议字符串，客户端则根据协议字符串的不同而进行不</span></span><br><span class="line"><span class="comment">                同的处理!</span></span><br><span class="line"><span class="comment">                更复杂的情况:</span></span><br><span class="line"><span class="comment">                如果两端进行游戏，则还有可能发送游戏信息，例如两端进行五子棋游戏，</span></span><br><span class="line"><span class="comment">                则需要发送下棋坐标信息等，服务器端同样在这些下棋坐标信息前、后添加</span></span><br><span class="line"><span class="comment">                协议字符串后再发送，客户端就可以根据该信息知道对手的下棋坐标。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3-6-半关闭的-Socket"><a href="#17-3-6-半关闭的-Socket" class="headerlink" title="17.3.6 半关闭的 Socket"></a>17.3.6 半关闭的 Socket</h3><p>前面服务总是以行作为通信的最小数据单位。但是在另一些协议里，通信的数据单位可能是多行的。在这种情况下，Socket 的输出流如何表示输出数据已经结束？</p>
<p>在学习 IO 流时，如果要表示输出已经结束，则可以通过关闭输出流来实现，但在网络通信中则不能这样实现，因为一旦关闭输出流，该输出流对应的 Socket 也将随之关闭，这样导致程序无法再从该 Socket 的输入流中读取数据了。</p>
<p>所以 Socket 提供了两个半关闭的方法：</p>
<ul>
<li>shutdownInput()：关闭 socket 输入流，程序还可以通过 socket 的输出流输出数据</li>
<li>shutdownOutput()：与上相反</li>
<li>isInputShutdown()</li>
<li>isOutputShutdown()</li>
</ul>
<h3 id="17-3-7-使用-NIO-实现非阻塞-Socket-通信"><a href="#17-3-7-使用-NIO-实现非阻塞-Socket-通信" class="headerlink" title="17.3.7 使用 NIO 实现非阻塞 Socket 通信"></a>17.3.7 使用 NIO 实现非阻塞 Socket 通信</h3><p>前面介绍的网络通信程序是基于阻塞式 API 的，即当程序执行输入、输出后，在这些操作返回之前会一直阻塞该线程，所以服务器必须为每个客户端都提供一个独立的线程进行处理。</p>
<p>使用 NIO API 则可以让服务器端使用一个或有限的几个线程来同时处理连接到服务器端的所有客户端。</p>
<p>NIO 为非阻塞式 Socket 通信提供了如下几个特殊类：</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><ul>
<li>Selector：它是 SelectaleChannel 对象的多路复用器，所有 Channel 都应该注册到 Selector。通过 open()静态方法创建 Selector 实例。</li>
</ul>
<p>一个 Selector 实例有三个 SelectionKey 集合</p>
<ul>
<li>keys()：所有 SelectionKey 集合，代表注册在该 Selector 上的 Channel。</li>
<li>selectedKeys()：所有可以通过 select() 获取的、需要进行 IO 处理的 Channel</li>
<li>被取消的 SelectionKey 集合：代表所有被取消注册关系的 Channel</li>
</ul>
<p>Selector 还提供了一系列和 select() 相关方法：</p>
<ul>
<li>int select()：监控所有注册的 Channel，当有需要处理的 IO 操作时，该方法返回，并将对应的 SelectionKey 加入被选中 key 集合</li>
<li>int select(long timeout)</li>
<li>int selectNow()：不会阻塞线程</li>
<li>Selector wakeup()：使一个还未返回的 select()方法立即返回</li>
</ul>
<h4 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h4><p>SelectableChannel：代表可以支持非阻塞 IO 操作的 Channel 对象。可以通过 register() 将其注册到指定 Selector 上。</p>
<ul>
<li><p>SelectableChannel configureBlocking(boolean block)：设置是否采用阻塞模式</p>
</li>
<li><p>boolean isBlocking()</p>
</li>
<li><p>int validOps()：表示这个 Channel 所支持的 IO 操作</p>
<ul>
<li>OP_READ(1)</li>
<li>OP_WRITE(4)</li>
<li>OP_CONNECT(8)</li>
<li>OP_ACCEPT(16)</li>
</ul>
</li>
<li><p>boolean isRegistered()</p>
</li>
<li><p>SelectionKey keyFor(Selector sel)</p>
</li>
<li><p>SelectionKey：注册关系</p>
</li>
<li><p>ServerSocketChannel：支持非阻塞操作，对应于 ServerSocket 类，只持支 OP_ACCEPT 操作，也提供了 accept() 方法。</p>
</li>
<li><p>SocketChannel：支持非阻塞操作，对应于 Socket 类，支持 OP_CONNECT、OP_READ 和 OP_WRITE 操作。 该类还实现了 ByteChannel 接口、ScatteringByteChannel 接口和 GatheringByteChannel 接口，所以可以直接读写 ByteBuffer 对象。</p>
</li>
</ul>
<p><img src="../../images/java/c17/NIO.png"></p>
<p>当 Selector 上注册的所有 Channel 都没有需要处理的 IO 操作时，select() 方法将被阻塞。</p>
<h4 id="使用-NIO-实现多人聊天室"><a href="#使用-NIO-实现多人聊天室" class="headerlink" title="使用 NIO 实现多人聊天室"></a>使用 NIO 实现多人聊天室</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于监测所有 Channel 状态的 Selector</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 Selector 对象</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">// 通过 open 方法来打开一个未绑定的 ServerSocketChannel 实例</span></span><br><span class="line">        ssc = ServerSocketChannel.open();</span><br><span class="line">        <span class="keyword">final</span> InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT);</span><br><span class="line">        <span class="comment">// 将该 ServerSocketChannel 绑定到指定 IP 地址</span></span><br><span class="line">        ssc.bind(isa);</span><br><span class="line">        <span class="comment">// 设置 ServerSocketChannel 以非阻塞方式工作</span></span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将 server 注册到指定的 Selector 对象</span></span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;select()&gt;0&quot;</span>);</span><br><span class="line">            System.out.println(selector.selectedKeys());</span><br><span class="line">            <span class="comment">// 处理已选择的 SelectionKey</span></span><br><span class="line">            <span class="keyword">for</span>(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">                <span class="comment">// 从 selector 上已选择的key集合删除当前key</span></span><br><span class="line">                selector.selectedKeys().remove(sk);</span><br><span class="line">                <span class="comment">// 如果 sk 对应的 Channel 包含客户端的连接请求</span></span><br><span class="line">                <span class="keyword">if</span>(sk.isAcceptable())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;sk isAcceptable&quot;</span>);</span><br><span class="line">                    <span class="comment">// 调用 accept 方法接收连接，产生服务端的 SocketChannel</span></span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    <span class="comment">// 设置采用非阻塞模式</span></span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 将该 SocketChannel 也注册到 selector</span></span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 将 sk 对应的 Channel 设置成准备接收其他请求</span></span><br><span class="line">                    sk.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 sk 对应的 Channel 有数据需要读取</span></span><br><span class="line">                <span class="keyword">if</span>(sk.isReadable()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;sk isReadable&quot;</span>);</span><br><span class="line">                    <span class="comment">// 读取该 SelectKey 对应的 Channel</span></span><br><span class="line">                    SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">                    <span class="comment">// 定义准备执行读取数据的 ByteBuffer</span></span><br><span class="line">                    <span class="keyword">final</span> ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="comment">// 开始读取数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (sc.read(buff) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            buff.flip();</span><br><span class="line">                            content += charset.decode(buff);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 打印从该 sk 对应的 Channel 里读取到的数据</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;读取的数据：&quot;</span> + content);</span><br><span class="line">                        <span class="comment">// 将 sk 对应的 Channel 设置成准备下一次读取</span></span><br><span class="line">                        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                        <span class="comment">// 从 Selector 中删除指定的 SelectionKey</span></span><br><span class="line">                        sk.cancel();</span><br><span class="line">                        <span class="keyword">if</span>(sk.channel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            sk.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果 content 的长度大于 0，即聊天信息不为空</span></span><br><span class="line">                    <span class="keyword">if</span>(content.length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历该 selector 里注册的所有 SelectionKey</span></span><br><span class="line">                        <span class="keyword">for</span>(SelectionKey key : selector.keys()) &#123;</span><br><span class="line">                            <span class="comment">// 获取该key对应的 Channel</span></span><br><span class="line">                            Channel targetChannel = key.channel();</span><br><span class="line">                            <span class="comment">// 如果该 Channel 是 SocketChannel 对象</span></span><br><span class="line">                            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span> SocketChannel)&#123;</span><br><span class="line">                                <span class="comment">// 将读到的内容写入还 Channel 中</span></span><br><span class="line">                                SocketChannel dest = (SocketChannel)targetChannel;</span><br><span class="line">                                dest.write(charset.encode(content));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NServer().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义监测 SocketChannel 的 Selector 对象</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">// 定义处理编码和解码的字符集</span></span><br><span class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 客户端 SocketChannel</span></span><br><span class="line">    <span class="keyword">private</span> SocketChannel sc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT);</span><br><span class="line">        <span class="comment">// 调用 open 静态方法创建连接到指定主机的 SocketChannel</span></span><br><span class="line">        sc = SocketChannel.open(isa);</span><br><span class="line">        <span class="comment">// 设置 sc 以非阻塞方式工作</span></span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将 SocketChannel 对象注册到指定的 Selector</span></span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">// 启动读取服务器端数据的线程</span></span><br><span class="line">        <span class="keyword">new</span> ClientThread().start();</span><br><span class="line">        <span class="comment">// 创建键盘输入流</span></span><br><span class="line">        <span class="keyword">final</span> Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            <span class="comment">// 读取键盘输入</span></span><br><span class="line">            <span class="keyword">final</span> String line = scan.nextLine();</span><br><span class="line">            <span class="comment">// 将键盘输入的内容输出到 SocketChannel 中</span></span><br><span class="line">            sc.write(charset.encode(line));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义读取服务器端数据的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遍历每个有而可用 IO 操作的 Channel 对应的 SelectionKey</span></span><br><span class="line">                    <span class="keyword">for</span>(SelectionKey sk : selector.selectedKeys())&#123;</span><br><span class="line">                        <span class="comment">// 删除正在处理的 SelectionKey</span></span><br><span class="line">                        selector.selectedKeys().remove(sk);</span><br><span class="line">                        <span class="comment">// 如果该 SelectionKey 对应的 Channel 中有可读的数据</span></span><br><span class="line">                        <span class="keyword">if</span>(sk.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 使用 NIO 读取 Channel 中的数据</span></span><br><span class="line">                            SocketChannel sc = (SocketChannel)sk.channel();</span><br><span class="line">                            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            <span class="keyword">while</span> (sc.read(buff) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                buff.flip();</span><br><span class="line">                                content += charset.decode(buff);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 打印输出读取的内容</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;聊天信息：&quot;</span> + content);</span><br><span class="line">                            <span class="comment">// 为下一次读取做准备</span></span><br><span class="line">                            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NClient().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3-8-使用-Java7-的-AIO-实现非阻塞通信"><a href="#17-3-8-使用-Java7-的-AIO-实现非阻塞通信" class="headerlink" title="17.3.8 使用 Java7 的 AIO 实现非阻塞通信"></a>17.3.8 使用 Java7 的 AIO 实现非阻塞通信</h3><p>如果按 POSIX 的标准来划分IO ，可以把 IO 分为两类:同步 IO 和异步 IO 。对于 IO 操作可以分成两步:①程序发出 IO 请求;②完成实际的 IO 操作。前面两节所介绍的阻塞 IO、非阻塞 IO 都是针对第一步来划分的。但同步 IO 和异步 IO 区别在第二步，如果实际的 IO 操作<strong>由操作系统完成</strong>，再将结果返回给应用程序， 这就是异步 IO；如果实际的 IO 需要应用程序本身去执行，会阻塞线程，那就是同步 IO 。</p>
<p><img src="../../IMAGES/java/c17/AIO.png"></p>
<p>两个接口，三个实现类。</p>
<h4 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h4><ul>
<li>open() 获取实例</li>
<li>open(AsynchronoutChannelGroup group)</li>
<li>bind() 绑定地址端口</li>
</ul>
<p>创建 AsynchronousServerSocketChannel 实例后，调用 accept() 接收客户端连接。accept() 方法不再阻塞。</p>
<ul>
<li>Future<AsynchronoutSocketChannel> accept()：接收请求，如果需要获取连接成功后返回的 Channel，调用 Future 的 get 方法，但是 get 方法会阻塞。</li>
<li><A> void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super A&gt; handler)：接收请求，成功或失败都会触发 handler 对应的方法。</li>
</ul>
<p>CompletionHandler 是一个接口</p>
<ul>
<li>completed(V result, A attachment)：IO 操作完成时触发。V 为 IO 操作返回的对象；A 为发起 IO 操作时传入的附加参数。</li>
<li>failed(Throwable exc, A attachment)：IO 操作失败时触发</li>
</ul>
<h4 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h4><ul>
<li>open()：获取实例</li>
<li>connect()：连接到指定 ip、端口的服务器</li>
<li>read()、write()：读写</li>
</ul>
<p>read、write 都有两个版本，一个返回 Future一个需要传入 CompletionHandler</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 1. 创建 AsnychronousServerSocketChannel 对象</span></span><br><span class="line">            AsynchronousServerSocketChannel serverChannel =</span><br><span class="line">                    AsynchronousServerSocketChannel.open())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 绑定指定地址、端口</span></span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,PORT));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收客户端连接</span></span><br><span class="line">                Future&lt;AsynchronousSocketChannel&gt; future = serverChannel.accept();</span><br><span class="line">                <span class="comment">// 获取连接完成后返回的 channel</span></span><br><span class="line">                AsynchronousSocketChannel socketChannel = future.get();</span><br><span class="line">                <span class="comment">// 执行输出</span></span><br><span class="line">                socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;欢迎来到AIO世界！&quot;</span></span><br><span class="line">                        .getBytes(<span class="string">&quot;UTF-8&quot;</span>))).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAIOClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 用于读取数据的 ByteBuffer</span></span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        Charset utf = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 1. 创建 AsynchronousSocketChannel 对象</span></span><br><span class="line">            AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 连接远程服务器</span></span><br><span class="line">            clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT)).get();</span><br><span class="line">            buff.clear();</span><br><span class="line">            <span class="comment">// 3. 从 clientChannel 中读取数据</span></span><br><span class="line">            clientChannel.read(buff).get();</span><br><span class="line">            buff.flip();</span><br><span class="line">            <span class="comment">// 将 buff 中的内容转换为字符串</span></span><br><span class="line">            String content = utf.decode(buff).toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器信息:&quot;</span> + content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AIO-多人聊天工具"><a href="#AIO-多人聊天工具" class="headerlink" title="AIO 多人聊天工具"></a>AIO 多人聊天工具</h4><p>上面程序没有充分利用 Java AIO 的优势，如果要充分挖掘 AIO 优势，应该考虑使用线程池来管理异步 Channel，并使用 ComplettionHandler 来监听异步 IO 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String UTF_8 = <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> List&lt;AsynchronousSocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startListen</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 以指定线程池来创建一个 AsynchronousChannelGroup</span></span><br><span class="line">        AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup</span><br><span class="line">                .withThreadPool(executor);</span><br><span class="line">        <span class="comment">// 以指定线程池来创建一个 AsynchronoutServerSocketChannel</span></span><br><span class="line">        AsynchronousServerSocketChannel serverChannel</span><br><span class="line">                = AsynchronousServerSocketChannel.open(channelGroup)</span><br><span class="line">                <span class="comment">// 指定监听本机的 PORT 端口</span></span><br><span class="line">                .bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">// 使用 CompletionHandler 接收来自客户端的连接请求</span></span><br><span class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler(serverChannel));</span><br><span class="line">        <span class="comment">// Thread.sleep(10000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AIOServer server = <span class="keyword">new</span> AIOServer();</span><br><span class="line">        server.startListen();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现自己的 CompletionHandler 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverChannel = ssc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 ByteBuffer 准备读取数据</span></span><br><span class="line">    ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当实际 IO 操作完成时触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录新连接进来的 Channel</span></span><br><span class="line">        AIOServer.channelList.add(sc);</span><br><span class="line">        <span class="comment">// 准备接收客户端的下一次连接</span></span><br><span class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        sc.read(buff, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">                buff.flip();</span><br><span class="line">                <span class="comment">// 将 buff 中的内容转换为字符串</span></span><br><span class="line">                String content = StandardCharsets.UTF_8.decode(buff).toString();</span><br><span class="line">                <span class="comment">// 遍历每个 Channel,将收到的信息写入各 Channel 中</span></span><br><span class="line">                <span class="keyword">for</span>(AsynchronousSocketChannel c : AIOServer.channelList)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        c.write(ByteBuffer.wrap(content.getBytes(AIOServer.UTF_8)))</span><br><span class="line">                                .get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                buff.clear();</span><br><span class="line">                <span class="comment">// 读取下一次数据</span></span><br><span class="line">                sc.read(buff, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;读取数据失败:&quot;</span> + exc);</span><br><span class="line">                <span class="comment">// 从该 Channel 中读取数据失败,就将该 Channel 删除</span></span><br><span class="line">                AIOServer.channelList.remove(sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接失败:&quot;</span> + exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String UTF_8 = <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">// 与服务器端通信的异步 Channel</span></span><br><span class="line">    AsynchronousSocketChannel clientChannel;</span><br><span class="line">    JFrame mainWin = <span class="keyword">new</span> JFrame(<span class="string">&quot;多人聊天&quot;</span>);</span><br><span class="line">    JTextArea jta = <span class="keyword">new</span> JTextArea(<span class="number">16</span>, <span class="number">48</span>);</span><br><span class="line">    JTextField jtf = <span class="keyword">new</span> JTextField(<span class="number">40</span>);</span><br><span class="line">    JButton sendBn = <span class="keyword">new</span> JButton(<span class="string">&quot;发送&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainWin.setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">        jta.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        mainWin.add(<span class="keyword">new</span> JScrollPane(jta), BorderLayout.CENTER);</span><br><span class="line">        JPanel jp = <span class="keyword">new</span> JPanel();</span><br><span class="line">        jp.add(jtf);</span><br><span class="line">        jp.add(sendBn);</span><br><span class="line">        <span class="comment">// 发送消息的 Action,Action 是 ActionListener 的子接口</span></span><br><span class="line">        Action sendAction = <span class="keyword">new</span> AbstractAction() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                String content = jtf.getText();</span><br><span class="line">                <span class="keyword">if</span> (content.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 将 content 内容写入 Channel 中</span></span><br><span class="line">                        clientChannel.write(ByteBuffer.wrap(content.trim().getBytes(UTF_8))).get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清空输入框</span></span><br><span class="line">                jtf.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        sendBn.addActionListener(sendAction);</span><br><span class="line">        <span class="comment">// 将 Ctrl + Enter 键和 send 关联</span></span><br><span class="line">        jtf.getInputMap().put(KeyStroke.getKeyStroke(<span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">                InputEvent.CTRL_DOWN_MASK), <span class="string">&quot;send&quot;</span>);</span><br><span class="line">        <span class="comment">// 将 send 和 sendAction 关联</span></span><br><span class="line">        jtf.getActionMap().put(<span class="string">&quot;send&quot;</span>, sendAction);</span><br><span class="line">        mainWin.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        mainWin.add(jp, BorderLayout.SOUTH);</span><br><span class="line">        mainWin.pack();</span><br><span class="line">        mainWin.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个 ByteBuffer 准备读取数据</span></span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">// 以指定线程池来创建一个 AsynchronousChannelGroup</span></span><br><span class="line">        AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withThreadPool(executor);</span><br><span class="line">        <span class="comment">// 以 channelGroup 作为组管理器来创建 AsynchronousSocketChannel</span></span><br><span class="line">        clientChannel = AsynchronousSocketChannel.open(channelGroup);</span><br><span class="line">        <span class="comment">// 让 AsynchronousSocketChannel 连接到指定 IP 端口</span></span><br><span class="line">        clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT)).get();</span><br><span class="line">        jta.append(<span class="string">&quot;---与服务器连接成功---\n&quot;</span>);</span><br><span class="line">        buff.clear();</span><br><span class="line">        clientChannel.read(buff, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">                buff.flip();</span><br><span class="line">                String content = StandardCharsets.UTF_8.decode(buff).toString();</span><br><span class="line">                <span class="comment">// 显示从服务器端读取的数据</span></span><br><span class="line">                jta.append(<span class="string">&quot;某人说:&quot;</span> + content + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                buff.clear();</span><br><span class="line">                clientChannel.read(buff, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;读取数据失败: &quot;</span> + exc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AIOClient client = <span class="keyword">new</span> AIOClient();</span><br><span class="line">        client.init();</span><br><span class="line">        client.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-4-基于-UDP-协议的网络编程"><a href="#17-4-基于-UDP-协议的网络编程" class="headerlink" title="17.4 基于 UDP 协议的网络编程"></a>17.4 基于 UDP 协议的网络编程</h2><p>UDP 协议是一种不可靠的网络协议，它在通信实例的两端各建立一个 Socket，但这两个 Socket 之间并没有虚拟链路，这两个 Socket 只是发送、接收数据报的对象。</p>
<p>Java 提供了 DatagramSocket 对象作为 UDP 协议的 Socket，使用 DatagramPacket 代表 DatagramSocket 发送、接收的数据报。</p>
<h3 id="17-4-1-UDP-协议基础"><a href="#17-4-1-UDP-协议基础" class="headerlink" title="17.4.1 UDP 协议基础"></a>17.4.1 UDP 协议基础</h3><p>UDP(User Datagram Protocol)即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络连接。</p>
<p>UDP 协议是一种面向非连接的协议，在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP 协议无法控制。</p>
<p>UDP 协议适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<p>因为 UDP 协议是面向非连接的协议，没有建立连接的过程，因此通信效率很高。</p>
<ul>
<li>TCP：可靠，传输大小无限制，但是需要连接建立时间，差错控制开销大</li>
<li>UDP：不可靠，差错控制开销较小，传输大小限制在 64KB 以下，不需要建立连接。</li>
</ul>
<h3 id="17-4-2-使用-DatagramSocket-发送、接收数据"><a href="#17-4-2-使用-DatagramSocket-发送、接收数据" class="headerlink" title="17.4.2 使用 DatagramSocket 发送、接收数据"></a>17.4.2 使用 DatagramSocket 发送、接收数据</h3><p>DatagramSocket 构造器</p>
<ul>
<li>DatagramSocket()</li>
<li>DatagramSocket(int port)</li>
<li>DatagramSocket(int port, InetAddress addr)</li>
</ul>
<p>DatagramSocket 接收、发送数据</p>
<ul>
<li>receive(DatagramPacket p)</li>
<li>send(DatagramPcket p)</li>
</ul>
<p>DatagramPacket  构造器</p>
<ul>
<li>DatagramPacket(byte[] buf, int length)：以空数组创建 DatagramPacket，作用是接收 DatagramSocket 中的数据</li>
<li>DatagramPacket(byte[] buf, int length, InetAddress addr, int port)：以包含数据的数组来创建 DatagramPacket 对象</li>
<li>DatagramPacket(byte[] buf, int offset, int length)：以空数组创建 DatagramPacket，并指定接收到的数据放入 buf，从 offset 开始，最多放 length</li>
<li>DatagramPacket(byte[] buf, int offset, int length, int prot)</li>
</ul>
<p>接收数据应该用第一个和第三个；发送数据应该用第二个和第四个。</p>
<p>获取发送者信息：</p>
<ul>
<li>InetAddress getAddress()</li>
<li>int getPort()</li>
<li>SocketAddress getSocketAddress()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">// 定义每个数据包的大小最大为 4kb</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_LEN = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 定义接收网络数据的子接数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] inBuff = <span class="keyword">new</span> <span class="keyword">byte</span>[DATA_LEN];</span><br><span class="line">    <span class="comment">// 以指定子接数组创建准备接收数据的 DatagramPacket 对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket inPacket = <span class="keyword">new</span> DatagramPacket(inBuff, inBuff.length);</span><br><span class="line">    <span class="comment">// 定义一个用于发送的 DatagramPacket 对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket outPacket;</span><br><span class="line">    <span class="comment">// 定义一个字符串数组,服务端发送该数组的元素</span></span><br><span class="line">    String[] books = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">            <span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建 DatagramSocket 对象</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(PORT))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 采用循环接收数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 读取 Socket 中的数据,读到的数据放入 inPacket 封装的数组里</span></span><br><span class="line">                socket.receive(inPacket);</span><br><span class="line">                <span class="comment">// 判断 inPacket.getData() 和 inBuff 是否是同一个数组</span></span><br><span class="line">                System.out.println(inBuff == inPacket.getData());</span><br><span class="line">                <span class="comment">// 将接收到的内容转换成字符串后输出</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(inBuff, <span class="number">0</span>, inPacket.getLength()));</span><br><span class="line">                <span class="comment">// 从字符串数组中取出一个元素作为发送的数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] sendData = books[i % <span class="number">3</span>].getBytes();</span><br><span class="line">                outPacket = <span class="keyword">new</span> DatagramPacket(sendData, sendData.length, inPacket.getSocketAddress());</span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                socket.send(outPacket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> UdpServer().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义发送数据报的目的地</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEST_PORT = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST_IP = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义每个数据报的大小最大为 4kb</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_LEN = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 定义接收网络数据的字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] inBuff = <span class="keyword">new</span> <span class="keyword">byte</span>[DATA_LEN];</span><br><span class="line">    <span class="comment">// 以指定的字节数组创建准备接收数据的 DatagramPacket 对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket inPacket = <span class="keyword">new</span> DatagramPacket(inBuff, inBuff.length);</span><br><span class="line">    <span class="comment">// 定义一个用于发送的 DatagramSocket 对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket outPacket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建一个客户端 DatagramSockett,使用随机端口</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化发送用的 DatagramSocket</span></span><br><span class="line">            outPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>],</span><br><span class="line">                    <span class="number">0</span>, InetAddress.getByName(DEST_IP), DEST_PORT);</span><br><span class="line">            <span class="comment">// 创建键盘输入流</span></span><br><span class="line">            Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="comment">// 不断地读取键盘输入</span></span><br><span class="line">            <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buff = scan.nextLine().getBytes();</span><br><span class="line">                outPacket.setData(buff);</span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                socket.send(outPacket);</span><br><span class="line">                <span class="comment">// 读取 socket 中的数据</span></span><br><span class="line">                socket.receive(inPacket);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(inBuff, <span class="number">0</span>, inPacket.getLength()));;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> UdpClient().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-4-3-使用-MulticaseSocket-实现多点广播"><a href="#17-4-3-使用-MulticaseSocket-实现多点广播" class="headerlink" title="17.4.3 使用 MulticaseSocket 实现多点广播"></a>17.4.3 使用 MulticaseSocket 实现多点广播</h3><p>DatagramSocket 只允许数据报发送给指定的目标地址，而 MulticastSocket 可以将数据报以广播方式发送到多个客户端。</p>
<p>其思想是设置一组特殊网络地址作为多点广播地址，每一个多点广播地址都被看做一个组，当客户端需要发送、接收广播信息时，加入到该组即可。</p>
<p>IP 协议为多点广播提供了这批特殊的 IP 地址，这些 IP 地址的范围是 :224.O.0.0 至 239.255.255.255</p>
<p><img src="D:/02_blog/blog/source/images/java/c17/多点广播.png"></p>
<p>当 MulticastSocket 把一个 DatagramP acket 发送到多点广播E 地址时， 该数据报将被自动广播到加入该地址的所有Multicast Socket。MulticastSocket 既可以将数据报发送到多点广播地址，也可以接收其他主机的广播信息。</p>
<p>构造器</p>
<ul>
<li>public MulticastSocket()</li>
<li>public MulticastSocket(int port)</li>
<li>public MulticastSocket(SocketAddress addr)</li>
</ul>
<p>如果创建仅用于发送数据报的 MulticastSocket 对象，则使用默认地址、随机端口即可。但如果创建接收用的MulticastSocket 对象，则该MulticastSocket 对象必须具有指定端口。</p>
<p>MulticastSocket 加入到指定的多点广播地址</p>
<ul>
<li>joinGroup(InetAddress multicastAddr)</li>
<li>leaveGroup(InetAddress multicastAddr)</li>
</ul>
<p>TimeToLive</p>
<ul>
<li><p>setTimeToLive(int ttl)：设置数据报最多可以跨国多少个网络</p>
<ul>
<li>0：数据报应停留在本机</li>
<li>1：局域网（默认）</li>
<li>32：本站点</li>
<li>64：本地区</li>
<li>128：本大洲</li>
<li>255：所有地方</li>
</ul>
</li>
</ul>
<h2 id="17-5-使用代理服务器"><a href="#17-5-使用代理服务器" class="headerlink" title="17.5 使用代理服务器"></a>17.5 使用代理服务器</h2><p>Java5 开始，提供 Proxy 和 ProxySelector。Rroxy 代表一个代理服务器，可以在打开 URLConnection 连接时指定 Proxy，创建 Socket 连接时也可以指定 Proxy。</p>
<p>代理服务器功能：</p>
<ul>
<li>突破自身 IP 限制，对外隐藏自身 IP 地址，访问国外受限站点，访问国内特定单位、团体的内部资源。</li>
<li>提高访问速度，代理服务器提供的缓冲功能可以避免每个用户直接访问呢远程主机，从而提高客户端访问速度。</li>
</ul>
<h3 id="17-5-1-直接使用-Proxy-创建连接"><a href="#17-5-1-直接使用-Proxy-创建连接" class="headerlink" title="17.5.1 直接使用 Proxy 创建连接"></a>17.5.1 直接使用 Proxy 创建连接</h3><p>构造器：</p>
<ul>
<li>Proxy(Proxy.Type type, SocketAddress sa)<ul>
<li>Proxy.Type.DIRECT：直接连接，不使用代理</li>
<li>Proxy.Type.HTTP：支持高级协议代理，如 HTTP、FTP</li>
<li>Proxy.Type.SOCKS：表示 SOCKS(v4或V5)代理</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理服务器的地址</span></span><br><span class="line">    <span class="keyword">final</span> String PROXY_ADDR = <span class="string">&quot;129.82.12.188&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PROXY_PORT = <span class="number">3124</span>;</span><br><span class="line">    <span class="comment">// 定义需要访问的网站地址</span></span><br><span class="line">    String urlStr = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">        <span class="comment">// 创建一个代理服务器对象</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(PROXY_ADDR, PROXY_PORT));</span><br><span class="line">        <span class="comment">// 使用指定的代理服务器打开连接</span></span><br><span class="line">        URLConnection conn = url.openConnection(proxy);</span><br><span class="line">        <span class="comment">// 设置超时时长</span></span><br><span class="line">        conn.setConnectTimeout(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 通过代理服务器读取数据的 Scanner</span></span><br><span class="line">            Scanner scan = <span class="keyword">new</span> Scanner(conn.getInputStream());</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;index.html&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">                String line = scan.nextLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                <span class="comment">// 将网页资源内容输出到指定输出流</span></span><br><span class="line">                ps.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProxyTest().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-5-2-使用-ProxySelector-自动选择代理服务器"><a href="#17-5-2-使用-ProxySelector-自动选择代理服务器" class="headerlink" title="17.5.2 使用 ProxySelector 自动选择代理服务器"></a>17.5.2 使用 ProxySelector 自动选择代理服务器</h3><p>上面的方式每次打开 http 或 socket 连接时都要显示的设置代理服务器，比较麻烦。ProxySelector 可以实现默认代理服务器。</p>
<ul>
<li>List<Proxy> select(URI uri)：根据业务需要返回代理服务器列表，如果只有一个 Porxy，将会作为默认代理服务器。</li>
<li>connectFailed(URI uri, SOcketAddress sa, IOException ioe)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySelectorTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理服务器的地址</span></span><br><span class="line">    <span class="keyword">final</span> String PROXY_ADDR = <span class="string">&quot;129.82.12.188&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PROXY_PORT = <span class="number">3124</span>;</span><br><span class="line">    <span class="comment">// 定义需要访问的网站地址</span></span><br><span class="line">    String urlStr = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 注册默认的代理选择器</span></span><br><span class="line">        ProxySelector.setDefault(<span class="keyword">new</span> ProxySelector() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Proxy&gt; <span class="title">select</span><span class="params">(URI uri)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">                <span class="comment">// 本程序总是返回某个固定的代理服务器</span></span><br><span class="line">                List&lt;Proxy&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                result.add(<span class="keyword">new</span> Proxy(Proxy.Type.HTTP,</span><br><span class="line">                        <span class="keyword">new</span> InetSocketAddress(PROXY_ADDR, PROXY_PORT)));</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据业务需要返回特定的对应的代理服务器</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri, SocketAddress sa, IOException ioe)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;无法连接道指定的代理服务器.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">        <span class="comment">// 没有指定代理服务器,直接打开连接</span></span><br><span class="line">        <span class="keyword">final</span> URLConnection conn = url.openConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProxySelectorTest().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 为 ProxySelector 提供了一个实现类 DefaultProxySelector，但是没有公开 API，应该尽量避免直接使用该 API，系统已经将 DefaultProxySelector 注册为默认的代理选择器。可以通过改变系统属性来动态选择代理选择器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultProxySelectorTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义需要访问的网站地址</span></span><br><span class="line">    <span class="keyword">static</span> String urlStr = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统的默认属性</span></span><br><span class="line">        <span class="keyword">final</span> Properties props = System.getProperties();</span><br><span class="line">        <span class="comment">// 通过设置系统属性设置 HTTP 访问所有的代理服务器的主机地址、端口</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;http.proxyHost&quot;</span>, <span class="string">&quot;192.168.10.96&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;http.proxyPort&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置不使用代理的主机</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;http.nonProxyHosts&quot;</span>, <span class="string">&quot;localhost|192.168.10.*&quot;</span>);</span><br><span class="line">        <span class="comment">// https</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;https.proxyHost&quot;</span>, <span class="string">&quot;192.168.10.96&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;https.proxyPort&quot;</span>, <span class="string">&quot;443&quot;</span>);</span><br><span class="line">        <span class="comment">// ftp</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;ftp.proxyHost&quot;</span>, <span class="string">&quot;192.168.10.96&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;ftp.proxyPort&quot;</span>, <span class="string">&quot;2121&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;ftp.nonProxyHosts&quot;</span>, <span class="string">&quot;localhost|192.168.10.*&quot;</span>);</span><br><span class="line">        <span class="comment">// socket</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;socket.proxyHost&quot;</span>, <span class="string">&quot;192.168.10.96&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;socket.proxyPort&quot;</span>, <span class="string">&quot;2121&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取系统默认的代理选择器</span></span><br><span class="line">        <span class="keyword">final</span> ProxySelector selector = ProxySelector.getDefault();</span><br><span class="line">        System.out.println(<span class="string">&quot;系统默认的代理选择器：&quot;</span> + selector);</span><br><span class="line">        <span class="comment">// 根据 URI 动态决定所使用的代理服务器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;系统为 ftp://www.crazyit.org 选择的代理服务器为：&quot;</span> +</span><br><span class="line">                ProxySelector.getDefault().select(<span class="keyword">new</span> URI(<span class="string">&quot;ftp://www.crazyit.org&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">        <span class="keyword">final</span> URLConnection conn = url.openConnection();</span><br><span class="line">        conn.setConnectTimeout(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            Scanner scan = <span class="keyword">new</span> Scanner(conn.getInputStream(), <span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取远程主机的内容</span></span><br><span class="line">            <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">                System.out.println(scan.nextLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div><div class="tags"><a href="/tags/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/"><i class="fa fa-tag"></i>疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-01-18-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C18.html">第 18 章 类加载机制与反射</a><a class="next" href="/2020-01-16-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C16.html">第 16 章 多线程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%89%E4%BB%96/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/">无关技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 15px;">心情</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/%E5%90%89%E4%BB%96/" style="font-size: 15px;">吉他</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">无关技术</a> <a href="/tags/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>