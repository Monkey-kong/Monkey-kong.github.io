<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 16 章 多线程 | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 16 章 多线程</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 16 章 多线程</h1><div class="post-meta">Jan 16, 2020<span> | </span><span class="category"><a href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-线程概述"><span class="toc-text">16.1 线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-线程和进程"><span class="toc-text">16.1.1 线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-多线程的优势"><span class="toc-text">16.1.2 多线程的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-线程的创建和启动"><span class="toc-text">16.2 线程的创建和启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-1-继承-Thread-类创建线程类"><span class="toc-text">16.2.1 继承 Thread 类创建线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-2-实现Runnable-接口创建线程类"><span class="toc-text">16.2.2 实现Runnable 接口创建线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-3-使用-Callable-和-Future-创建线程"><span class="toc-text">16.2.3 使用 Callable 和 Future 创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-4-创建线程的三种方式对比"><span class="toc-text">16.2.4 创建线程的三种方式对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-线程的生命周期"><span class="toc-text">16.3 线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4-控制线程"><span class="toc-text">16.4 控制线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-1-join-线程"><span class="toc-text">16.4.1 join 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-2-后台线程（Daemon-Thread）"><span class="toc-text">16.4.2 后台线程（Daemon Thread）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-3-线程睡眠（sleep）"><span class="toc-text">16.4.3 线程睡眠（sleep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-4-改变线程优先级"><span class="toc-text">16.4.4 改变线程优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-5-线程同步"><span class="toc-text">16.5 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-1-线程安全问题"><span class="toc-text">16.5.1 线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-4-释放同步监视器的锁定"><span class="toc-text">16.5.4 释放同步监视器的锁定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-5-死锁"><span class="toc-text">16.5.5 死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-6-线程通信"><span class="toc-text">16.6 线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-1-传统的线程通信"><span class="toc-text">16.6.1 传统的线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-2-使用Condition-控制线程通信"><span class="toc-text">16.6.2 使用Condition 控制线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-3-使用阻塞队列-BlockingQueue-控制线程通信"><span class="toc-text">16.6.3 使用阻塞队列(BlockingQueue) 控制线程通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-7-线程组和未处理的异常"><span class="toc-text">16.7 线程组和未处理的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-8-线程池"><span class="toc-text">16.8 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-8-1-Java8-改进的线程池"><span class="toc-text">16.8.1 Java8 改进的线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-8-2-Java8-增强的-ForkJoinPool"><span class="toc-text">16.8.2 Java8 增强的 ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-9-线程相关类"><span class="toc-text">16.9 线程相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-9-1-ThreadLocal-类"><span class="toc-text">16.9.1 ThreadLocal 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-9-2-包装线程不安全的集合"><span class="toc-text">16.9.2 包装线程不安全的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-9-3-线程安全的集合类"><span class="toc-text">16.9.3 线程安全的集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-9-4-Java-9-新增的发布-订阅框架"><span class="toc-text">16.9.4 Java 9 新增的发布-订阅框架</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 16 章 多线程</p>
<a id="more"></a>
<h2 id="16-1-线程概述"><a href="#16-1-线程概述" class="headerlink" title="16.1 线程概述"></a>16.1 线程概述</h2><h3 id="16-1-1-线程和进程"><a href="#16-1-1-线程和进程" class="headerlink" title="16.1.1 线程和进程"></a>16.1.1 线程和进程</h3><p><strong>理解进程：</strong></p>
<p>进程是处于<strong>运行过程中的程序</strong>，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位。</p>
<ul>
<li><strong>独立性</strong>：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下， 一个用户进程<strong>不可以</strong>直接访问其他进程的地址空间。</li>
<li><strong>动态性</strong>：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，这些概念在程序中都是不具备的。</li>
<li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行（<strong>注意不是并行</strong>），多个进程之间不会互相影响。</li>
</ul>
<p><strong>理解并发和并行：</strong></p>
<p>并发性(concurrency )和并行性( paral1el) 是两个概念，并行指在同一时刻，有多条指令在多个处理器上同时执行; 并发指在同一时刻只能有一条指令执行， 但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。<strong>简单的说，一个处理器肯定只能并发处理任务；两个处理器最多只能并行处理两个任务。</strong></p>
<p><strong>理解线程：</strong></p>
<ul>
<li>线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。</li>
<li>线程可以拥有自己的<strong>堆栈</strong>、自己的<strong>程序计数器</strong>和自己的<strong>局部变量</strong>，<strong>但不拥有系统资源</strong>，它与父进程的其他线程共享该进程所拥有的全部资源。</li>
<li><p>因为多个线程共享父进程的全资源，因此编程更加方便；但必须更加小心，因为需要确保线程不会妨碍同一进程里的其他线程。</p>
</li>
<li><p>线程是独立运行的，它并不知道进程中是否还有其他线程存在。</p>
</li>
<li>线程的执行是<strong>抢占式</strong>的，也就是说，当前运行的线程在<strong>任何时候</strong>都可能被挂起，以便另外一个线程可以运行。</li>
</ul>
<p>操作系统可以同时执行多个任务，每个任务就是进程；进程可以同时执行多个任务，每个任务就是线程。</p>
<h3 id="16-1-2-多线程的优势"><a href="#16-1-2-多线程的优势" class="headerlink" title="16.1.2 多线程的优势"></a>16.1.2 多线程的优势</h3><ul>
<li>内存易共享：进程之间不能共享内存，但线程之间共享内存非常容易。</li>
<li>创建代价小：系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。</li>
<li>开发方便：Java 语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了 Java 的多线程编程。</li>
</ul>
<h2 id="16-2-线程的创建和启动"><a href="#16-2-线程的创建和启动" class="headerlink" title="16.2 线程的创建和启动"></a>16.2 线程的创建和启动</h2><h3 id="16-2-1-继承-Thread-类创建线程类"><a href="#16-2-1-继承-Thread-类创建线程类" class="headerlink" title="16.2.1 继承 Thread 类创建线程类"></a>16.2.1 继承 Thread 类创建线程类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">// 重写 run() 方法。方法体就是线程执行体</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> ( ; i &lt; <span class="number">100</span>; i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(<span class="string">"当前线程："</span> + getName() + <span class="string">" "</span> + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">			<span class="keyword">if</span> (i == <span class="number">20</span>)</div><div class="line">			&#123;</div><div class="line">				FirstThread thread1 = <span class="keyword">new</span> FirstThread(); <span class="comment">// 创建并启动第一个线程</span></div><div class="line">				thread1.setName(<span class="string">"自定义Thread1"</span>);</div><div class="line">				thread1.start();</div><div class="line">				<span class="keyword">new</span> FirstThread().start(); <span class="comment">// 创建并启动第二个线程</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序每次创建线程对象时都需要创建一个 FirstThread 对象，所以Thread-0 和Thread-1 不能共享该实例变量。</p>
<h3 id="16-2-2-实现Runnable-接口创建线程类"><a href="#16-2-2-实现Runnable-接口创建线程类" class="headerlink" title="16.2.2 实现Runnable 接口创建线程类"></a>16.2.2 实现Runnable 接口创建线程类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">	<span class="comment">// 重写 run() 方法。方法体就是线程执行体</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> ( ; i &lt; <span class="number">100</span>; i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" ---- "</span> + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">			<span class="keyword">if</span> (i == <span class="number">20</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="comment">// 创建并启动第一个线程</span></div><div class="line">				SecondThread thread = <span class="keyword">new</span> SecondThread();</div><div class="line">				<span class="keyword">new</span> Thread(thread, <span class="string">"新线程 1"</span>).start();</div><div class="line">				<span class="keyword">new</span> Thread(thread, <span class="string">"新线程 2"</span>).start();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-2-3-使用-Callable-和-Future-创建线程"><a href="#16-2-3-使用-Callable-和-Future-创建线程" class="headerlink" title="16.2.3 使用 Callable 和 Future 创建线程"></a>16.2.3 使用 Callable 和 Future 创建线程</h3><p>Callable 接口提供了一个 call() 方法可以作为线程执行体，但 call() 方法比 run() 方法功能更强大。call() 方法可以有返回值。call() 方法可以声明抛出异常。</p>
<p>但是 Callable 接口没有实现 Runnable 接口。所以 Callable 对象不能直接作为 Thread 的 target。Java 5 提供了Future 接口来代表 Callable 接口里call()方法的返回值。并为Future 接口提供了一个 FutureTask 实现类，该实现类实现了 Future 接口，并实现了 Runnable 接口可以作为 Thread 类的 target 。</p>
<p>在 Future 接口里定义了如下几个公共方法来控制它关联的 Callable 任务。</p>
<ul>
<li>boolean cancel(boolean mayInterruptlfRunning):试图取消该 Future 里关联的Callable 任务。</li>
<li>V get(): 返回 Callable 任务里 call()方法的返回值。调用该方法将导致程序<strong>阻塞</strong>，必须等到子线程结束后才会得到返回值。</li>
<li>V get(long timeout， TimeUnit unit): 返回 Callable 任务里 call()方法的返回值。该方法让程序最多阻塞 timeout 和 unit 指定的时间，如果经过指定时间后 Callable 任务依然没有返回值，将会抛出 TimeoutException 异常。</li>
<li>boolean isCancelled(): 如果在 Callable 任务正常完成前被取消，则返回 true 。</li>
<li>boolean isDone(): 如果 Callable 任务己完成，则返回 true 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdThread</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)() -&gt; &#123;</div><div class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++)</div><div class="line">			&#123;</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" 循环变量i的值："</span> + i);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Thread.sleep(2000);</span></div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;);</div><div class="line">		<span class="comment">// task.cancel(true);</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" 的循环变量 i 的值："</span> + i);</div><div class="line">			<span class="keyword">if</span> (i == <span class="number">20</span>)</div><div class="line">			&#123;</div><div class="line">				System.out.println(task.isCancelled()); <span class="comment">// false</span></div><div class="line">				System.out.println(task.isDone());		<span class="comment">// false</span></div><div class="line">				<span class="keyword">new</span> Thread(task, <span class="string">"有返回值的线程1"</span>).start();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			System.out.println(task.isCancelled()); <span class="comment">// false</span></div><div class="line">			System.out.println(task.isDone());		<span class="comment">// false</span></div><div class="line">			System.out.println(<span class="string">"子线程的返回值："</span> + task.get(<span class="number">1000</span>, TimeUnit.MILLISECONDS));</div><div class="line">			System.out.println(task.isCancelled()); <span class="comment">// false</span></div><div class="line">			System.out.println(task.isDone());		<span class="comment">// true</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception ex)</div><div class="line">		&#123;</div><div class="line">			ex.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-2-4-创建线程的三种方式对比"><a href="#16-2-4-创建线程的三种方式对比" class="headerlink" title="16.2.4 创建线程的三种方式对比"></a>16.2.4 创建线程的三种方式对比</h3><p>采用实现Runnable 、Callable 接口的方式创建多线程的优缺点:</p>
<ul>
<li>线程类只是实现了 Runnable 接口或 Callable 接口， 还可以继承其他类。</li>
<li>在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使 Thread.currentThread()方法。</li>
</ul>
<p>采用继承 Thread 类的方式创建多线程的优缺点:</p>
<ul>
<li>劣势是，因为线程类己经继承了Thread 类，所以不能再继承其他父类。</li>
<li>优势是，编写简单，如果需要访问当前线程，则无须使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<h2 id="16-3-线程的生命周期"><a href="#16-3-线程的生命周期" class="headerlink" title="16.3 线程的生命周期"></a>16.3 线程的生命周期</h2><p>在线程的生命周期中，它要经过新建（New) 、就绪（Runnable) 、运行（Running) 、阻塞（Blocked) 和死亡（Dead) 5 种状态</p>
<p><img src="../../images/java/c16/线程的生命周期.png" alt=""></p>
<p>新建：new 关键宇创建了一个线程之后，该线程就处于新建状态</p>
<p>就绪：当线程对象调用了start() 方法之后，该线程处于就绪状态， Java 虚拟机会为其创建<strong>方法调用栈</strong>和<strong>程序计数器</strong>，处于这个状态中的线程并没有开始运行， 只是表示该线程可以运行了。至于该线程何时开始运行， 取决于 JVM 里线程调度器的调度。</p>
<p>调用了线程的 run() 方法之后， 该线程己经不再处于新建状态，不要再次调用线程对象的start()方法。因为只能对处于新建状态的线程调用start()方法，否则将引发 IllegalThreadStateException 异常。</p>
<p>当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。</p>
<p>线程对象的 isAlive() 方法， 当线程处于就绪、运行、阻塞三种状态时，该方法将返回 true; 当线程处于新建、死亡两种状态时，该方法将返回 false 。</p>
<p>若试图在线程己死亡的情况下再次调用start()方法来启动该线程，将引发 IllegalThreadStateException 异常，这表明处于死亡状态的线程无法再次运行了。</p>
<p>总结：</p>
<ul>
<li>new 后就是新建；start 后就就绪；就绪得到 jvm 调度就运行；运行完成就死亡。</li>
<li>运行变阻塞：sleep、等待同步控制器、调用阻塞方法、<strong>等待通知</strong>、<strong>suspend</strong></li>
<li>阻塞变就绪：sleep完、等到同步控制器、得到IO资源、收到通知、<strong>resume</strong></li>
<li>运行变死亡：执行完了、抛未处理异常了、<strong>stop</strong></li>
<li>运行边就绪：失去 处理器资源、<strong>yield</strong></li>
</ul>
<h2 id="16-4-控制线程"><a href="#16-4-控制线程" class="headerlink" title="16.4 控制线程"></a>16.4 控制线程</h2><h3 id="16-4-1-join-线程"><a href="#16-4-1-join-线程" class="headerlink" title="16.4.1 join 线程"></a>16.4.1 join 线程</h3><p>Thread 提供了让一个线程等待另一个线程完成的方法一 join() 方法。当在某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞， 直到被 join()方法加入的 join 线程执行完为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(String name)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 重写 run 方法，定义线程执行</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </div><div class="line">		&#123;</div><div class="line">			System.out.println(getName() + <span class="string">" "</span> + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="comment">// 启动子线程</span></div><div class="line">		<span class="keyword">new</span> JoinThread(<span class="string">"新线程"</span>).start();;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (i == <span class="number">20</span>)</div><div class="line">			&#123;</div><div class="line">				JoinThread jt = <span class="keyword">new</span> JoinThread( <span class="string">"被 Join 的线程"</span> ) ;</div><div class="line">				jt.start();</div><div class="line">				<span class="comment">// main 线程调用了 jt 线程的 join()方法</span></div><div class="line">				<span class="comment">// 所以 main 线程必须等 jt 执行结束才会向下执行</span></div><div class="line">				jt.join();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主线程执行到 i == 20 时，程序启动并 Join 了名为”被 Join 的线程”的线程，所以主线程将一直处于阻塞状态，直到名为”被Join 的线程”的线程执行完成。</p>
<p>总结：xx.join() 表示当前线程阻塞，等待 xx 执行完。</p>
<h3 id="16-4-2-后台线程（Daemon-Thread）"><a href="#16-4-2-后台线程（Daemon-Thread）" class="headerlink" title="16.4.2 后台线程（Daemon Thread）"></a>16.4.2 后台线程（Daemon Thread）</h3><p>JVM 的垃圾回收线程就是典型的后台线程</p>
<p>特征：</p>
<ul>
<li>如果所有的前台线程都死亡，后台线程也会自动死亡</li>
<li>前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </div><div class="line">		&#123;</div><div class="line">			System.out.println(getName() + <span class="string">" "</span> + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		DaemonThread t = <span class="keyword">new</span> DaemonThread();</div><div class="line">		System.out.println(t.isDaemon());</div><div class="line">		<span class="comment">// 设置位后台线程，必须在 start 之前设置，否则会报错</span></div><div class="line">		t.setDaemon(<span class="keyword">true</span>);</div><div class="line">		System.out.println(t.isDaemon());</div><div class="line">		t.start();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() +<span class="string">" "</span>+ i) ;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 一一程序执行到此处，前台线程(main 线程)结束一一</span></div><div class="line">		<span class="comment">// 后台线程也应该随之结束</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-4-3-线程睡眠（sleep）"><a href="#16-4-3-线程睡眠（sleep）" class="headerlink" title="16.4.3 线程睡眠（sleep）"></a>16.4.3 线程睡眠（sleep）</h3><p>Thread.sleep(1000);：进入阻塞状态；抛出 InterruptedException 异常</p>
<p>Thread.yield(); :进入就绪状态，让出执行机会</p>
<p>sleep() 方法暂停当前线程后， 会给其他线程执行机会，不会理会其他线程的优先级；但yield() 方法只会给优先级相同，或优先级更高的线程执行机会。</p>
<p><strong>总结</strong>：yield 只是让出一下处理器，自己也会立马抢，有可能自己又抢到了，继续执行自己。</p>
<h3 id="16-4-4-改变线程优先级"><a href="#16-4-4-改变线程优先级" class="headerlink" title="16.4.4 改变线程优先级"></a>16.4.4 改变线程优先级</h3><p>每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。</p>
<p>每个线程默认的优先级都与创建它的父线程的优先级相同， 在默认情况下， main 线程具有普通优先级，由main 线程创建的子线程也具有普通优先级。</p>
<p>Thread.setPriority(int priority)</p>
<p>Thread.getPriority()</p>
<p>MAX_PRIORITY: 其值是10 。</p>
<p>MIN_PRIORITY: 其值是1 。</p>
<p>NORM_PRIORITY: 其值是5 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PriorityTest</span><span class="params">(String name)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) </div><div class="line">		&#123;</div><div class="line">			System.out.println(getName() + <span class="string">",其优先级是："</span> + getPriority() </div><div class="line">					+ <span class="string">",循环变量："</span> + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="comment">// 改变主线程优先级</span></div><div class="line">		Thread.currentThread().setPriority(<span class="number">6</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) </div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(i == <span class="number">10</span>)</div><div class="line">			&#123;</div><div class="line">				PriorityTest low = <span class="keyword">new</span> PriorityTest(<span class="string">"低级"</span>);</div><div class="line">				System.out.println(<span class="string">"创建之初的优先级："</span> + low.getPriority());</div><div class="line">				low.setPriority(Thread.MIN_PRIORITY);</div><div class="line">				low.start();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>)</div><div class="line">			&#123;</div><div class="line">				PriorityTest high = <span class="keyword">new</span> PriorityTest(<span class="string">"高级"</span>);</div><div class="line">				System.out.println(<span class="string">"创建之初的优先级："</span> + high.getPriority());</div><div class="line">				high.setPriority(Thread.MAX_PRIORITY);</div><div class="line">				high.start();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="16-5-线程同步"><a href="#16-5-线程同步" class="headerlink" title="16.5 线程同步"></a>16.5 线程同步</h2><h3 id="16-5-1-线程安全问题"><a href="#16-5-1-线程安全问题" class="headerlink" title="16.5.1 线程安全问题"></a>16.5.1 线程安全问题</h3><ol>
<li>用户输入账户、密码</li>
<li>用户输入取款金额</li>
<li>系统判断余额是否足够</li>
<li>足够则取款成功，否则取款失败</li>
</ol>
<p>同步代码块、同步锁（Lock）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="comment">// 定义锁对象</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">	<span class="keyword">private</span> String accountNo;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;&#125;;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">this</span>.accountNo = accountNo;</div><div class="line">		<span class="keyword">this</span>.balance = balance;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 因为账户余额不允许随便修改，所以只为balance 提供 getter 方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">return</span> balance;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">if</span>(balance &gt;= drawAmount)</div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"取钱成功！吐出钞票："</span> + drawAmount);</div><div class="line">			<span class="keyword">try</span> </div><div class="line">			&#123;</div><div class="line">				Thread.sleep(<span class="number">1</span>); <span class="comment">// 睡眠，相当于强制让线程切换</span></div><div class="line">			&#125; </div><div class="line">			<span class="keyword">catch</span> (InterruptedException e) </div><div class="line">			&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 修改余额</span></div><div class="line">			balance -= drawAmount;</div><div class="line">			System.out.println(<span class="string">"\t余额为："</span> + balance);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> </div><div class="line">		&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"取钱失败！余额不足！"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw2</span><span class="params">(<span class="keyword">double</span> drawAmount)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="comment">// 加锁</span></div><div class="line">		lock.lock();</div><div class="line">		<span class="keyword">try</span> </div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(balance &gt;= drawAmount)</div><div class="line">			&#123;</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"取钱成功！吐出钞票："</span> + drawAmount);</div><div class="line">				<span class="keyword">try</span> </div><div class="line">				&#123;</div><div class="line">					Thread.sleep(<span class="number">1</span>); <span class="comment">// 睡眠，相当于强制让线程切换</span></div><div class="line">				&#125; </div><div class="line">				<span class="keyword">catch</span> (InterruptedException e) </div><div class="line">				&#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// 修改余额</span></div><div class="line">				balance -= drawAmount;</div><div class="line">				System.out.println(<span class="string">"\t余额为："</span> + balance);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			&#123;</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"取钱失败！余额不足！"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">finally</span> </div><div class="line">		&#123;</div><div class="line">			<span class="comment">// 修改完成，释放锁</span></div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">return</span> accountNo.hashCode();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (obj !=<span class="keyword">null</span> &amp;&amp; obj.getClass() == Account.class)</div><div class="line">		&#123;</div><div class="line">			Account target = (Account)obj ;</div><div class="line">			<span class="keyword">return</span> target.getAccountNo( ).equals (accountNo);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">return</span> accountNo;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountNo</span><span class="params">(String accountNo)</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">this</span>.accountNo = accountNo;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="keyword">private</span> Account account;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.account = account;</div><div class="line">		<span class="keyword">this</span>.drawAmount = drawAmount;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 当多个线程修改同一个共享数据时，将涉及数据安全问题</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		account.draw(drawAmount);</div><div class="line">		<span class="comment">// account.draw2(drawAmount);</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		Account account = <span class="keyword">new</span> Account(<span class="string">"1234567"</span>, <span class="number">1000</span>);</div><div class="line">		<span class="comment">// 模拟两个线程对同一个账户取钱</span></div><div class="line">		<span class="keyword">new</span> DrawThread(<span class="string">"甲"</span>, account, <span class="number">800</span>).start();;</div><div class="line">		<span class="keyword">new</span> DrawThread(<span class="string">"乙"</span>, account, <span class="number">800</span>).start();;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-5-4-释放同步监视器的锁定"><a href="#16-5-4-释放同步监视器的锁定" class="headerlink" title="16.5.4 释放同步监视器的锁定"></a>16.5.4 释放同步监视器的锁定</h3><p>何时会释放对同步监视器的锁定呢?</p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步方法、同步代码块中出现了未处理的 Error 或 Exception，导致该方法、代码块异常结束</li>
<li>当前线程在同步方法、同步代码块中执行了同步监视器对象的 wait 方法</li>
</ul>
<p>注意：线程执行同步代码块或同步方法时，程序调用 Thread .sleep() 、Thread.yield() 方法来暂停当前线程的执行，当前线程不会释放同步监视器。</p>
<p>其他线程调用了该线程的 suspend()方法将该线程挂起， 该线程不会释放同步监视器。当然， 程序应该尽量避免使用 suspend()和 resume()方法来控制线程。</p>
<h3 id="16-5-5-死锁"><a href="#16-5-5-死锁" class="headerlink" title="16.5.5 死锁"></a>16.5.5 死锁</h3><p>当两个线程相互等待对方释放同步监视器时就会发生死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		System.out.println(<span class="string">"当前线程名："</span> + Thread.currentThread().getName()</div><div class="line">				+ <span class="string">"进入了A实例的foo()方法"</span>);</div><div class="line">		<span class="keyword">try</span> </div><div class="line">		&#123;</div><div class="line">			Thread.sleep(<span class="number">200</span>);</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">catch</span> (InterruptedException e) </div><div class="line">		&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"当前线程名："</span> + Thread.currentThread().getName()</div><div class="line">				+ <span class="string">"企图调用B实例的last()方法"</span>);</div><div class="line">		b.last();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		System.out.println(<span class="string">"进入了A类的last()方法内部。"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(A a)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		System.out.println(<span class="string">"当前线程名："</span> + Thread.currentThread().getName()</div><div class="line">				+ <span class="string">"进入了B实例的bar()方法"</span>);</div><div class="line">		<span class="keyword">try</span> </div><div class="line">		&#123;</div><div class="line">			Thread.sleep(<span class="number">200</span>);</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">catch</span> (InterruptedException e) </div><div class="line">		&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"当前线程名："</span> + Thread.currentThread().getName()</div><div class="line">				+ <span class="string">"企图调用A实例的last()方法"</span>);</div><div class="line">		a.last();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		System.out.println(<span class="string">"进入了B类的last()方法内部。"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	A a = <span class="keyword">new</span> A();</div><div class="line">	B b = <span class="keyword">new</span> B();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		Thread.currentThread().setName(<span class="string">"主线程"</span>);</div><div class="line">		a.foo(b);</div><div class="line">		System.out.println(<span class="string">"进入了主线程后"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		Thread.currentThread().setName(<span class="string">"副线程"</span>);</div><div class="line">		b.bar(a);</div><div class="line">		System.out.println(<span class="string">"进入入了副线程后"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		DeadLock dl = <span class="keyword">new</span> DeadLock();</div><div class="line">		<span class="keyword">new</span> Thread(dl).start();</div><div class="line">		dl.init();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="16-6-线程通信"><a href="#16-6-线程通信" class="headerlink" title="16.6 线程通信"></a>16.6 线程通信</h2><h3 id="16-6-1-传统的线程通信"><a href="#16-6-1-传统的线程通信" class="headerlink" title="16.6.1 传统的线程通信"></a>16.6.1 传统的线程通信</h3><p>问题：有一个取钱线程和一个存钱线程。要求每当存钱线程存前后，取钱线程立即取出该笔钱。要求不允许连续存和连续取。</p>
<p><strong>wait()</strong>: 导致当前线程等待， 直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。调用wait()方法的当前线程会<strong>释放对该同步监视器的锁定</strong>。</p>
<p><strong>notify()</strong>: 唤醒在此同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会<strong>选择唤醒其中一个线程</strong>。选择是任意性的。<strong>只有当前线程放弃对该同步监视器的锁定后(使用wait()方法) ，才可以执行被唤醒的线程。</strong></p>
<p><strong>notifyAll()</strong>:唤醒在此同步监视器上等待的所有线程。</p>
<p><strong>这三个方法必须由同步监视器对象来调用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount, <span class="keyword">int</span> i)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">try</span> </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!flag) <span class="comment">// 没有存款，阻塞取钱方法</span></div><div class="line">        &#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 执行取钱操作</span></div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 取钱("</span>+i+<span class="string">")："</span> + drawAmount);</div><div class="line">            balance -= drawAmount;</div><div class="line">            System.out.println(<span class="string">"账户余额为："</span> + balance);</div><div class="line">            <span class="comment">// 标识为没有存款</span></div><div class="line">            flag = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 唤醒其他线程</span></div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">catch</span> (Exception e) </div><div class="line">    &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>阻塞并不是死锁，对于这种情况，取钱者线程已经执行结束，而存款者线程只是在等待其他线程来取钱而己，并不是等待其他线程释放同步监视器。不要把死锁和程序阻塞等同起来!</p>
<h3 id="16-6-2-使用Condition-控制线程通信"><a href="#16-6-2-使用Condition-控制线程通信" class="headerlink" title="16.6.2 使用Condition 控制线程通信"></a>16.6.2 使用Condition 控制线程通信</h3><p>如果程序不使用 synchronized 关键字来保证同步，而是直接使用 Lock 对象来保证同步，则系统中不存在隐式的同步监视器， 也就不能使用 wait() 、notify() 、notifyAll()方法进行线程通信了。</p>
<p>Condition 实例被绑定在一个Lock 对象上。要获得特定Lock 实例的Condition 实例，调用Lock 对象的 newCondition() 方法即可。Condition 类提供了如下三个方法。</p>
<p>await() : 类似于隐式同步监视器上的wait()方法，导致当前线程等待， 直到其他线程调用该Condition</p>
<p>的signal()方法或signalAll()方法来唤醒该线程。</p>
<p>signal(): 唤醒在此Lock 对象上等待的单个线程。</p>
<p>signalAll(): 唤醒在此Lock 对象上等待的所有线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 显示定义 Lock 对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="comment">// 获得指定 Lock 对象对应的 Condition</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition cond = lock.newCondition();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount, <span class="keyword">int</span> i)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    lock.lock(); <span class="comment">// 加锁</span></div><div class="line">    <span class="keyword">try</span> </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!flag) <span class="comment">// 没有存款，阻塞取钱方法</span></div><div class="line">        &#123;</div><div class="line">            cond.await();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 执行取钱操作</span></div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 取钱("</span>+i+<span class="string">")："</span> + drawAmount);</div><div class="line">            balance -= drawAmount;</div><div class="line">            System.out.println(<span class="string">"账户余额为："</span> + balance);</div><div class="line">            <span class="comment">// 标识为没有存款</span></div><div class="line">            flag = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 唤醒其他线程</span></div><div class="line">            cond.signalAll();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">catch</span> (Exception e) </div><div class="line">    &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> </div><div class="line">    &#123;</div><div class="line">        lock.unlock(); <span class="comment">// 释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-6-3-使用阻塞队列-BlockingQueue-控制线程通信"><a href="#16-6-3-使用阻塞队列-BlockingQueue-控制线程通信" class="headerlink" title="16.6.3 使用阻塞队列(BlockingQueue) 控制线程通信"></a>16.6.3 使用阻塞队列(BlockingQueue) 控制线程通信</h3><p>除了Queue的通用方法。BlockingQueue 提供如下两个支持阻塞的方法。</p>
<p>put(E e): 尝试把E 元素放入BlockingQueue 中，如果该队列的元素己满，则阻塞该线程。</p>
<p>take(): 尝试从BlockingQueue 的头部取出元素，如果该队列的元素己空， 则阻塞该线程。</p>
<p><img src="../../images/java/c16/BlockQueen.png" alt=""></p>
<p><img src="../../images/java/c16/BlockQueen实现类.png" alt=""></p>
<p>BlockingQueue 实现类：</p>
<ul>
<li>ArrayBlockingQueue：基于数组实现的阻塞队列</li>
<li>LinkedBlockingQueue：基于链表实现的阻塞队列</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue：同步队列。存、取操作必须交替进行</li>
<li>DelayQueue：延时队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="keyword">private</span> BlockingQueue&lt;String&gt; bq;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; bq)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">this</span>.bq = bq;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		String[] strArr = <span class="keyword">new</span> String[]</div><div class="line">		&#123;</div><div class="line">			<span class="string">"Java"</span>,<span class="string">"Struts"</span>,<span class="string">"Spring"</span>	</div><div class="line">		&#125;;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </div><div class="line">		&#123;</div><div class="line">			System.out.println(getName() + <span class="string">"生产者准备生产集合元素！"</span>);</div><div class="line">			<span class="keyword">try</span> </div><div class="line">			&#123;</div><div class="line">				Thread.sleep(<span class="number">200</span>);</div><div class="line">				<span class="comment">// 尝试放入元素， 如果队列己满，则线程被阻塞</span></div><div class="line">				bq.put(strArr[i % <span class="number">3</span>]);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</div><div class="line">			System.out.println(getName() + <span class="string">"生产完成："</span> + bq);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="keyword">private</span> BlockingQueue&lt;String&gt; bq;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; bq)</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">this</span>.bq = bq;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) </div><div class="line">		&#123;</div><div class="line">			System.out.println(getName() + <span class="string">"消费者准备消费集合元素！"</span>);</div><div class="line">			<span class="keyword">try</span> </div><div class="line">			&#123;</div><div class="line">				Thread.sleep(<span class="number">200</span>);</div><div class="line">				<span class="comment">//尝试取出元素，如果队列己空，则线程被阻塞</span></div><div class="line">				bq.take();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123; e.printStackTrace(); &#125;</div><div class="line">			System.out.println(getName() + <span class="string">"消费完成："</span> + bq);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest2</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span></div><div class="line"><span class="function">	</span>&#123;</div><div class="line">		BlockingQueue&lt;String&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</div><div class="line">		<span class="comment">// 启动3个生产者线程</span></div><div class="line">		<span class="keyword">new</span> Producer(bq).start();</div><div class="line">		<span class="keyword">new</span> Producer(bq).start();</div><div class="line">		<span class="keyword">new</span> Producer(bq).start();</div><div class="line">		<span class="comment">// 启动一个消费者线程</span></div><div class="line">		<span class="keyword">new</span> Consumer(bq).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="16-7-线程组和未处理的异常"><a href="#16-7-线程组和未处理的异常" class="headerlink" title="16.7 线程组和未处理的异常"></a>16.7 线程组和未处理的异常</h2><p>对线程组的控制相当于同时控制这批线程。</p>
<p>在默认情况下，子线程和创建它的父线程处于同一个线程组内。</p>
<p>一旦某个线程加入了指定线程组之后，该线程将一直属于该线程组，直到该线程死亡，线程运行中途不能改变它所属的线程组。</p>
<p>指定线程的线程组：</p>
<ul>
<li>Thread(ThreadGroup group, Runnable target)</li>
<li>Thread(ThreadGroup group, Runnable target, String name)</li>
<li>Thread(ThreadGroup group, String name)</li>
</ul>
<p>创建线程组：</p>
<ul>
<li>ThreadGroup(String name)</li>
<li>ThreadGroup(ThreadGroup parent, String name)</li>
</ul>
<p>操作线程组：</p>
<ul>
<li>int activeCount()</li>
<li>interrupt()</li>
<li>isDaemon()</li>
<li>setDaemon(boolean daemon)</li>
<li>setMaxPriority(int pri)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(ThreadGroup group, String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(group, name);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</div><div class="line">            System.out.println(getName() + <span class="string">" 线程 i 变量"</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取主线程所在的线程组，这是所有线程默认的线程组</span></div><div class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</div><div class="line">        System.out.println(<span class="string">"主线程组的名字："</span> + mainGroup.getName());</div><div class="line">        System.out.println(<span class="string">"主线程组是否是后台线程："</span> + mainGroup.isDaemon());</div><div class="line">        <span class="keyword">new</span> MyThread(<span class="string">"主线程组的线程"</span>).start();</div><div class="line">        ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"新线程组"</span>);</div><div class="line">        tg.setDaemon(<span class="keyword">true</span>);</div><div class="line">        System.out.println(<span class="string">"tg 线程组是否是后台线程组："</span> + tg.isDaemon());</div><div class="line">        <span class="keyword">new</span> MyThread(tg, <span class="string">"tg 组的线程甲"</span>).start();</div><div class="line">        <span class="keyword">new</span> MyThread(tg, <span class="string">"tg 组的线程乙"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>未处理异常：</p>
<p>如果线程执行过程中抛出了一个未处理异常，JVM 在结束该线程之前，会自动检查是否有对应的 Thread。UncaughtExceptionHandler 对象，如果有则会调用该对象的 uncaughtException(Thread t, Throwalbe e) 方法来处理该异常。</p>
<p>设置异常处理器：</p>
<ul>
<li><p>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为所有线程设置默认处理器</p>
</li>
<li><p>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定线程设置处理器</p>
</li>
</ul>
<p>ThreadGroup 类实现了 Thread.UncaughtExceptionHandler 接口，所以每个线程所属的线程组将会作为默认的异常处理器。</p>
<p>线程组处理异常默认流程：</p>
<ol>
<li>有父线程组，调用父线程组的 uncaughtException()</li>
<li>线程实例有默认的异常处理器，调用该处理器</li>
<li>如果异常对象是 ThreadDeath 对象，则不做任何处理；否则，将异常信息打印到 System.err 错误输出流，并结束该线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(t + <span class="string">" 线程出现了异常："</span> + e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread.currentThread().setUncaughtExceptionHandler(<span class="keyword">new</span> MyExHandler());</div><div class="line">        <span class="keyword">int</span> a = <span class="number">5</span>/<span class="number">0</span>;</div><div class="line">        <span class="comment">// 与 catch 不同，程序不会正常结束</span></div><div class="line">        System.out.println(<span class="string">"程序正常结束！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>catch 捕获异常时，异常不会向上传播；但使用异常处理器处理后，异常依然会传播给上一级调用者。</p>
<h2 id="16-8-线程池"><a href="#16-8-线程池" class="headerlink" title="16.8 线程池"></a>16.8 线程池</h2><p>系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p>
<p>线程池在系统启动时即创建大量空闲的线程，程序将一个 Runnable 对象或 Callable 对象传给线程池，线程池就会启动一个空闲的线程来执行他们的 run() 或 call() 方法，当 run() 或 call() 方法执行结束后，该线程不会死亡，而是再次返回线程池成为空闲状态。</p>
<p>除此之外，线程池可以有效的控制系统中并发线程的数量。</p>
<h3 id="16-8-1-Java8-改进的线程池"><a href="#16-8-1-Java8-改进的线程池" class="headerlink" title="16.8.1 Java8 改进的线程池"></a>16.8.1 Java8 改进的线程池</h3><p>使用 Executors 工厂类产生线程池：</p>
<ul>
<li>newCachedThreadPool()：根据系统需要创建线程，线程会被缓存在线程池中</li>
<li>newFixedThreadPool(int n)：可重用、固定线程数的线程池</li>
<li>newSingleThreadExecutor()：一个线程</li>
<li>newScheduledThreadPool(int n)：指定线程数的线程池，可以在指定延迟后执行线程任务</li>
<li>newSingleThreadScheduledExecutor()：一个线程</li>
<li>ExecutorService newWorkStealingPool(int n)：</li>
<li>ExecutorService newWorkStealingPool()：根据 CPU 个数设置个数</li>
</ul>
<p>work stealing 池，都相当于后台线程池。</p>
<p>ExecutorService：</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)：提交 run 给线程池，Future 为返回值，但 run 没有返回值，会返回 null，但可以调用 Future 的 isDone()、isCancelled() 来获取对象执行状态</li>
<li><t>Future<t> submit(Runnable task, T result)：指定返回值</t></t></li>
<li><t>Future<t> submit(Callable<t> task)：提交 call</t></t></t></li>
</ul>
<p>ScheduledExecutorService：</p>
<ul>
<li>ScheduledFuture<v> schedule(Callable<v> task, long delay, TimeUnit unit)</v></v></li>
<li>ScheduledFuture&lt;?&gt; schedule(Runnable task, long delay, TimeUnit unit)</li>
<li>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable task, long delay, long period, TimeUnit unit)</li>
<li>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable task, long delay, long delay, TimeUnit unit)</li>
</ul>
<p>关闭线程池：</p>
<p>用完线程池后应该调用 shutdown() 方法关闭线程池，不再接收新的任务，但会将以前所有已提交的任务执行完成。</p>
<p>shutdownNow()：试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadpoolTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. 创建线程池</span></div><div class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);</div><div class="line">        <span class="comment">// 2. 创建 target</span></div><div class="line">        Runnable target = () -&gt;&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                + <span class="string">"的 i 值为："</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 3. target 放入线程池</span></div><div class="line">        pool.submit(target);</div><div class="line">        pool.submit(target);</div><div class="line">        <span class="comment">// 4. 关闭线程池</span></div><div class="line">        pool.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-8-2-Java8-增强的-ForkJoinPool"><a href="#16-8-2-Java8-增强的-ForkJoinPool" class="headerlink" title="16.8.2 Java8 增强的 ForkJoinPool"></a>16.8.2 Java8 增强的 ForkJoinPool</h3><p>ForkJoinP ool 来支持将一个任务拆分成多个”小任务”并行计算，再把多个”小任务”的结果合并成总的计算结果。ForkJoinPool 是 ExecutorSerrvice 的实现类，因此是一种特殊的线程池。</p>
<ul>
<li>ForkJoinPool(int n)</li>
<li><p>ForkJoinPool()：以 Runtime.availableProcessors() 作为线程数</p>
</li>
<li><p>ForkJoinPool commonPool()：通用池的运行状态不受 shutdown()的影响</p>
</li>
<li>int getCommonPoolParallelism()：返回通用池并行级别</li>
</ul>
<p><img src="../../images/java/c16/线程池工具类.png" alt=""></p>
<ul>
<li>submit(ForkJoinTask task)</li>
<li>invoke(ForkJoinTask task)</li>
</ul>
<p>ForkJoinTask：可以并行、合并的任务</p>
<p>RecursiveAction：无返回值的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 继承 RecursiveAction 来实现可分解的任务</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span></span>&#123;</div><div class="line">    <span class="comment">// 每个小任务最多打印50个数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">50</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.start = start;</div><div class="line">        <span class="keyword">this</span>.end = end;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(end - start &lt; THRESHOLD)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                + <span class="string">"的 i 值："</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</div><div class="line">            PrintTask left = <span class="keyword">new</span> PrintTask(start, middle);</div><div class="line">            PrintTask right = <span class="keyword">new</span> PrintTask(middle, end);</div><div class="line">            <span class="comment">// 并行执行两个 小任务</span></div><div class="line">            left.fork();</div><div class="line">            right.fork();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPooITest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">        pool.submit(<span class="keyword">new</span> PrintTask(<span class="number">0</span>, <span class="number">300</span>));</div><div class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">        pool.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RecursiveTask：有返回值的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 继承 RecursiveTask 来实现可分解的任务</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 每个小任务最多累加 20 个数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arr[];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalTask</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.arr = arr;</div><div class="line">        <span class="keyword">this</span>.start = start;</div><div class="line">        <span class="keyword">this</span>.end = end;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 差小于 THRESHOLD 时，开始累加</span></div><div class="line">        <span class="keyword">if</span>(end - start &lt; THRESHOLD)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</div><div class="line">                sum += arr[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> sum;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</div><div class="line">            CalTask left = <span class="keyword">new</span> CalTask(arr, start, middle);</div><div class="line">            CalTask right = <span class="keyword">new</span> CalTask(arr, middle, end);</div><div class="line">            <span class="comment">// 并行执行两个 小任务</span></div><div class="line">            left.fork();</div><div class="line">            right.fork();</div><div class="line">            <span class="comment">// 把两个小任务累加的结果合并起来</span></div><div class="line">            <span class="keyword">return</span> left.join() + right.join();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPooITest2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</div><div class="line">        Random rand = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">int</span> tmp = rand.nextInt(<span class="number">20</span>);</div><div class="line">            total += (arr[i] = tmp);</div><div class="line">        &#125;</div><div class="line">        System.out.println(total);</div><div class="line">        <span class="comment">// 1. 创建一个通用池</span></div><div class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</div><div class="line">        <span class="comment">// 2. 提交任务</span></div><div class="line">        ForkJoinTask&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> CalTask(arr, <span class="number">0</span>, arr.length));</div><div class="line">        System.out.println(future.get());</div><div class="line">        <span class="comment">// 3. 关闭线程池</span></div><div class="line">        pool.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="16-9-线程相关类"><a href="#16-9-线程相关类" class="headerlink" title="16.9 线程相关类"></a>16.9 线程相关类</h2><h3 id="16-9-1-ThreadLocal-类"><a href="#16-9-1-ThreadLocal-类" class="headerlink" title="16.9.1 ThreadLocal 类"></a>16.9.1 ThreadLocal 类</h3><p>ThreadLocal  即 Thread Local Variable，为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立的改变自己的副本。可以很简洁的隔离多线程程序的资源竞争。</p>
<ul>
<li>T get()：返回此线程局部变量中当前线程副本中的值</li>
<li>void remove()：删除此线程局部变量中当前线程副本中的值</li>
<li>void set(T value)：设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</div><div class="line">    <span class="comment">// 定义 ThreadLocal</span></div><div class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String str)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name.set(str);</div><div class="line">        <span class="comment">// 访问当前线程的 name 副本的值</span></div><div class="line">        System.out.println(<span class="string">"---"</span> + <span class="keyword">this</span>.name.get());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name.get();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String str)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name.set(str);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Account account;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span><span class="params">(Account account, String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        <span class="keyword">this</span>.account = account;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">6</span>)&#123;</div><div class="line">                account.setName(getName());</div><div class="line">            &#125;</div><div class="line">            System.out.println(account.getName()</div><div class="line">                    + <span class="string">" 账户的 i 值："</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocaITest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 启动两个线程，共享同一个 Account</span></div><div class="line">        <span class="comment">// 初始名 是主线程的副本</span></div><div class="line">        Account at = <span class="keyword">new</span> Account(<span class="string">"初始名"</span>);</div><div class="line">        <span class="comment">// 6 之后，两个子线程也有 name 的副本了</span></div><div class="line">        <span class="keyword">new</span> MyTest(at, <span class="string">"线程甲"</span>).start();</div><div class="line">        <span class="keyword">new</span> MyTest(at, <span class="string">"线程乙"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常建议: 如果多个线程之间需要共享资源，以达到线程之间的通信功能，就使用同步机制; 如果仅仅需要隔离多个线程之间的共享冲突，则可以使用 ThreadLocal 。</p>
<h3 id="16-9-2-包装线程不安全的集合"><a href="#16-9-2-包装线程不安全的集合" class="headerlink" title="16.9.2 包装线程不安全的集合"></a>16.9.2 包装线程不安全的集合</h3><p>Collections 工具类</p>
<ul>
<li>synchronizedCollection</li>
<li>synchronizedList</li>
<li>synchronizedMap</li>
<li>synchronizedSet</li>
<li>synchronizedSortedMap</li>
<li>synchronizedSortedSet</li>
</ul>
<p>应该在创建之后立即包装。</p>
<h3 id="16-9-3-线程安全的集合类"><a href="#16-9-3-线程安全的集合类" class="headerlink" title="16.9.3 线程安全的集合类"></a>16.9.3 线程安全的集合类</h3><p>Java.util.concurrent 包下提供了大量支持高效并发访问的集合接口和实现类。</p>
<p><img src="../../images/java/c16/线程安全的集合类.png" alt=""></p>
<p>大致分为两类：</p>
<ul>
<li>以 Concurrent 开头的集合类，如 ConcurrentHashMap 、ConcurrentSkipListMap 、ConcurrentSkip ListSet、ConcurrentLinkedQueue 和 ConcurrentLinkedDeque 。<ul>
<li>并发写入线程安全，但读取操作不必锁定。不会锁住整个集合，因此在并发写入时有较好的性能。</li>
</ul>
</li>
<li>以 CopyOnWrite 开头的集合类，如 CopyOnWriteArrayList 、CopyOn WriteArraySet 。<ul>
<li>采用复制底层数组的方式来实现写操作。执行读取操作时，直接读取本身，无需加锁和阻塞。执行写入操作时，会复制一份新的数组，对新数组进行写入。频繁写入性能较差，适合读多写少的场景，例如缓存。</li>
</ul>
</li>
</ul>
<h3 id="16-9-4-Java-9-新增的发布-订阅框架"><a href="#16-9-4-Java-9-新增的发布-订阅框架" class="headerlink" title="16.9.4 Java 9 新增的发布-订阅框架"></a>16.9.4 Java 9 新增的发布-订阅框架</h3><p>可以非常方便地处理异步线程之间的流数据交换，而且不需要使用数据中心来缓存数据，同时具有非常高效的性能。</p>
<ul>
<li>Flow.Publisher：数据发布者、生产者<ul>
<li>void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)：注册订阅者，会触发订阅者 onSubscribe() 或 onError() 方法</li>
</ul>
</li>
<li>Flow.Subscriber：数据订阅者、消费者<ul>
<li>void onSubscribe(Flow.Subscription s)</li>
<li>void onComplete()</li>
<li>void onError(Throwable t)</li>
<li>void onNext(T item)：从发布者获取数据项时触发该方法</li>
</ul>
</li>
<li>Flow.Subscription：发布者和订阅者之间的连接纽带。订阅者通过 request() 方法来获取数据，也可以通过 cancel() 方法来取消订阅</li>
<li>Flow.Processor：数据处理器，可同时作为发布者和订阅者使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PubSubTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 创建发布者(ForkJoinPool.commonPool())</span></div><div class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</div><div class="line">        <span class="comment">// 创建订阅者</span></div><div class="line">        MySubscriber&lt;String&gt; subscriber = <span class="keyword">new</span> MySubscriber&lt;&gt;();</div><div class="line">        <span class="comment">// 注册订阅者</span></div><div class="line">        publisher.subscribe(subscriber);</div><div class="line">        <span class="comment">// 发布几个数据</span></div><div class="line">        System.out.println(<span class="string">"开始发布数据"</span>);</div><div class="line">        List.of(<span class="string">"Java"</span>, <span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"Lua"</span>)</div><div class="line">            .forEach(i -&gt; &#123;</div><div class="line">                publisher.submit(i);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">500</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        <span class="comment">// 发布结束</span></div><div class="line">        publisher.close();</div><div class="line">        <span class="comment">// 发布结束后，为了让发布者线程不死亡，暂停线程</span></div><div class="line">        <span class="keyword">synchronized</span> (<span class="string">"fkjava"</span>)&#123;</div><div class="line">            <span class="string">"fkjava"</span>.wait();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义订阅者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Flow</span>.<span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 发布者、订阅者之间的纽带</span></div><div class="line">    <span class="keyword">private</span> Flow.Subscription subscription;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Flow.Subscription subscription)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscription = subscription;</div><div class="line">        <span class="comment">// 开始请求数据</span></div><div class="line">        subscription.request(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 接收到数据时触发</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T item)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"获取到数据："</span> + item);</div><div class="line">        <span class="comment">// 请求下一条数据</span></div><div class="line">        subscription.request(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        throwable.printStackTrace();</div><div class="line">        <span class="keyword">synchronized</span> (<span class="string">"fkjava"</span>)&#123;</div><div class="line">            <span class="string">"fkjava"</span>.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"订阅结束"</span>);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="string">"fkjava"</span>)&#123;</div><div class="line">            <span class="string">"fkjava"</span>.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/疯狂-Java-讲义/">疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-01-17-疯狂Java讲义/疯狂Java讲义C17.html"></a><a class="next" href="/2020-01-15-疯狂Java讲义/疯狂Java讲义C15.html">第 15 章 输入、输出</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加解密技术/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/吉他/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/疯狂-Java-讲义/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/吉他/" style="font-size: 15px;">吉他</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>