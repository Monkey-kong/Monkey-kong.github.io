<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>JVM 学习（三、四） | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM 学习（三、四）</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM 学习（三、四）</h1><div class="post-meta">Jul 16, 2020<span> | </span><span class="category"><a href="/categories/JVM/">JVM</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CPU-内存模型"><span class="toc-text">1. CPU 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-存储器的层次结构"><span class="toc-text">1.1 存储器的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-缓存一致性-Cache-Coherence-问题"><span class="toc-text">1.2 缓存一致性(Cache Coherence)问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-CPU-乱序执行"><span class="toc-text">1.3 CPU 乱序执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-保证-CPU-有序执行-内存屏障"><span class="toc-text">1.4 保证 CPU 有序执行-内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-解决处理器数据一致性问题"><span class="toc-text">1.5 解决处理器数据一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-L3-总线锁。"><span class="toc-text">1.5.1 L3 总线锁。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-缓存-一致性协议之-MESI"><span class="toc-text">1.5.2 缓存 一致性协议之 MESI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JMM"><span class="toc-text">2. JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-主内存与工作内存"><span class="toc-text">2.1 主内存与工作内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-主内存、工作内存交互"><span class="toc-text">2.2 主内存、工作内存交互</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM-定义了八大原子操作"><span class="toc-text">JMM 定义了八大原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-对于-volatile-变量的特殊规则"><span class="toc-text">2.3 对于 volatile 变量的特殊规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语义1：线程可见性"><span class="toc-text">语义1：线程可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语义2：禁止指令重排序"><span class="toc-text">语义2：禁止指令重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-原理"><span class="toc-text">volatile 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM-对-volatile-变量的特殊规则定义"><span class="toc-text">JMM 对 volatile 变量的特殊规则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#适合使用-volatile-的场景"><span class="toc-text">适合使用 volatile 的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-针对-long-和-double-型变量的特殊规则"><span class="toc-text">2.4 针对 long 和 double 型变量的特殊规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-原子性、可见性与有序性"><span class="toc-text">2.5 原子性、可见性与有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性（Atomicity）"><span class="toc-text">原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性（Visibility）"><span class="toc-text">可见性（Visibility）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性（Ordering）"><span class="toc-text">有序性（Ordering）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-hanppens-before-原则"><span class="toc-text">2.6 hanppens-before 原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-JVM-内存屏障"><span class="toc-text">2.7 JVM 内存屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-volatile-的实现细节"><span class="toc-text">3. volatile 的实现细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-synchronized-的实现细节"><span class="toc-text">4. synchronized 的实现细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-对象内存布局"><span class="toc-text">5. 对象内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-请解释一些下象的创建过程？"><span class="toc-text">1. 请解释一些下象的创建过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-对象在内存中的存储布局？"><span class="toc-text">2. 对象在内存中的存储布局？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-对象头包括什么？"><span class="toc-text">3. 对象头包括什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-对象怎么定位？"><span class="toc-text">4. 对象怎么定位？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-对象怎么分配？"><span class="toc-text">5. 对象怎么分配？</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>
<h2 id="1-CPU-内存模型"><a href="#1-CPU-内存模型" class="headerlink" title="1. CPU 内存模型"></a>1. CPU 内存模型</h2><p>硬件层的内存模型。</p>
<h3 id="1-1-存储器的层次结构"><a href="#1-1-存储器的层次结构" class="headerlink" title="1.1 存储器的层次结构"></a>1.1 存储器的层次结构</h3><p> 在一个典型操作系统中，可能会有几个缓存（<strong>在多核系统中，每个核心都会有自己的缓存</strong>）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了<strong>减少<code>CPU</code>读写共享主存的次数</strong>。 因为 CPU 和物理内存之间的通信速度远慢于 CPU 的处理速度 ，加入多级缓存就是为了解决<strong>处理器于内存速度之间的矛盾</strong>。</p>
<p><img src="../../images/jvm/03/存储器层次结构.png" alt=""></p>
<p>离 cpu 越近，容量更小，但是速度更快。</p>
<p>各个层次的速度对比：</p>
<p><img src="../../images/jvm/03/存储器速度.png" alt=""></p>
<h3 id="1-2-缓存一致性-Cache-Coherence-问题"><a href="#1-2-缓存一致性-Cache-Coherence-问题" class="headerlink" title="1.2 缓存一致性(Cache Coherence)问题"></a>1.2 缓存一致性(Cache Coherence)问题</h3><p>在多路处理器系统中，每个<strong>处理器内部(L1、L2)</strong>都有自己的高速缓存，而它们又共享同一<strong>主内存（Main Memory）</strong>，这种系统称为<strong>共享内存多核系统（Shared Memory Multiprocessors System）</strong>。</p>
<p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存时该以谁的缓存数据为准呢？从而引发缓存一致性问题。</p>
<p><img src="../../images/jvm/03/处理器_高速缓存_主内存关系.png" alt=""></p>
<p>为了解决缓存一致性问题，需要各个处理器读写高速缓存时都遵循一定的协议。这类协议有：MSI、<strong>MESI（Illinois Protocol）</strong>、MOSI、Synapse、Firefly 及 Dragon Protocol 等</p>
<p>Java虚拟机也有自己的内存模型，并且与这里介绍的硬件级别的内存模型有高度的可类比性。</p>
<h3 id="1-3-CPU-乱序执行"><a href="#1-3-CPU-乱序执行" class="headerlink" title="1.3 CPU 乱序执行"></a>1.3 CPU 乱序执行</h3><p>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，保证最终结果一样，但不保证执行顺序。</p>
<p>CPU 为了提高指令执行效率，会在一条指令执行过程中（比如去内存读取数据（慢100倍）），去同时执行另一条指令，前提是<strong>两条指令没有依赖关系</strong>。</p>
<p><img src="../../images/jvm/03/CPU指令重排序问题.png" alt=""></p>
<p>读可以乱序,写也可以合并。</p>
<p>合并写：CPU 有一个  WC cache，只有四个字节，速度比一级缓存更快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            System.out.println(i + <span class="string">" singleLoop duration (ns) ="</span> + runCaseOne());</div><div class="line">            System.out.println(i + <span class="string">" singleLoop duration (ns) ="</span> + runCaseTwo());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 直接一次写完速度反而更慢</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">int</span> i = ITERATIONS;</div><div class="line"></div><div class="line">        <span class="comment">// 写完四个字节后,剩下两个还要等待其他两个字节来填充后才提交</span></div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>)  &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</div><div class="line">            arrayA[slot] = b;</div><div class="line">            arrayB[slot] = b;</div><div class="line">            arrayC[slot] = b;</div><div class="line">            arrayD[slot] = b;</div><div class="line">            arrayE[slot] = b;</div><div class="line">            arrayF[slot] = b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.nanoTime() - start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 充分利用合并写技术,速度块一倍</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">int</span> i = ITERATIONS;</div><div class="line">        <span class="comment">// 每次四个字节,直接提交</span></div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</div><div class="line">            arrayA[slot] = b;</div><div class="line">            arrayB[slot] = b;</div><div class="line">            arrayC[slot] = b;</div><div class="line">        &#125;</div><div class="line">        i = ITERATIONS;</div><div class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</div><div class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</div><div class="line">            arrayD[slot] = b;</div><div class="line">            arrayE[slot] = b;</div><div class="line">            arrayF[slot] = b;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.nanoTime() - start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如何证明存在乱序执行？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        i++;</div><div class="line">        x = <span class="number">0</span>; y = <span class="number">0</span>;</div><div class="line">        a = <span class="number">0</span>; b = <span class="number">0</span>;</div><div class="line">        Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            shortWait(<span class="number">100000</span>);</div><div class="line">            a = <span class="number">1</span>;</div><div class="line">            x = b;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            b = <span class="number">1</span>;</div><div class="line">            y = a;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        one.start();other.start();</div><div class="line">        one.join();other.join();</div><div class="line">        String result = <span class="string">"第"</span> + i + <span class="string">"次("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>;</div><div class="line">        System.out.println(result);</div><div class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</div><div class="line">            System.err.println(result);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与处理器的乱序执行优化类似，Java虚拟机的<strong>即时编译器</strong>中也有<strong>指令重排序（Instruction Reorder）优化</strong>。</p>
<h3 id="1-4-保证-CPU-有序执行-内存屏障"><a href="#1-4-保证-CPU-有序执行-内存屏障" class="headerlink" title="1.4 保证 CPU 有序执行-内存屏障"></a>1.4 保证 CPU 有序执行-内存屏障</h3><p>​    sfence（读）：在 sfence（save fence） 指令前的写操作必须在 sfence 指令后的写操作前完成</p>
<p>​    lfence（写）：在 lfence(load fence) 指令前的读操作必须在 lfence 指令后的读操作前完成</p>
<p>​    mfence（读写）：在 mfence(mix fence) 指令前的读写操作必须在 mfence 指令后的读写操作前完成</p>
<p>intel lock 汇编指令(原子指令)</p>
<p>同样 JVM 也有定义自己的 JVM 内存屏障，但是底层还是靠硬件级别 CPU 内存屏障来实现的。</p>
<p><img src="../../images/jvm/03/数据不一致问题.png" alt=""></p>
<p>从上面模型看，<strong>L1、L2 是在 CPU 内部</strong>的，所以如果存在多个 CPU，就会有数据同步或者说数据不一致问题。比如：内存（主存）中有 x、y 两个变量，加入都被加载到 L1、L2，cpu1 修改了 x，在数据被写回主存之前，cpu2 是不知道数据改变了的。</p>
<h3 id="1-5-解决处理器数据一致性问题"><a href="#1-5-解决处理器数据一致性问题" class="headerlink" title="1.5 解决处理器数据一致性问题"></a>1.5 解决处理器数据一致性问题</h3><h4 id="1-5-1-L3-总线锁。"><a href="#1-5-1-L3-总线锁。" class="headerlink" title="1.5.1 L3 总线锁。"></a>1.5.1 L3 总线锁。</h4><p>但是这样子效率比较低，老的 CPU 才用这种方式。比如，CPU1 修改 x，就将整条总线锁住（ <strong>其他处理器就不能操作缓存了该共享变量内存地址的缓存</strong> ），导致另外一个 CPU 想访问 y 也只能等着。</p>
<h4 id="1-5-2-缓存-一致性协议之-MESI"><a href="#1-5-2-缓存-一致性协议之-MESI" class="headerlink" title="1.5.2 缓存 一致性协议之 MESI"></a>1.5.2 缓存 一致性协议之 MESI</h4><p>intel 使用的是 MESI，但是还有其他很多协议</p>
<ol>
<li><strong>M: 被修改（Modified)</strong> ：缓存行只被该 cpu 缓存，并且被修改过(<strong>dirty</strong>)，即与主存数据不一致。该缓存行需要在未来某个时间点<strong>写回（write back）</strong>主存。写回之前不允许其他 cpu 读取该缓存行。</li>
<li><strong>E: 独享的（Exclusive)</strong> ：缓存行只被该 cpu 缓存，并且数据和<strong>主存</strong>一致</li>
<li><strong>S: 共享的（Shared)</strong> ：缓存行被多个 cpu 缓存，并且数据都和<strong>主存</strong>一致</li>
<li><strong>I: 无效的（Invalid）</strong> :缓存行无效，可能被其他 cpu 修改了</li>
</ol>
<p><a href="https://www.cnblogs.com/z00377750/p/9180644.html" target="_blank" rel="external">https://www.cnblogs.com/z00377750/p/9180644.html</a> </p>
<p><img src="../../images/jvm/03/MESI缓存锁.png" alt=""></p>
<ol>
<li><p>现代 CPU 的缓存一致性实现是使用<strong>总线锁和缓存锁</strong>一起实现。因为有些无法被缓存的数据或者跨越多个缓存行的数据依然必须使用总线锁。</p>
</li>
<li><p>缓存行概念：cache line。cpu 读取缓存时，一般是读取一块内容，即以缓存行为基本单位，而不是申请读四个字节就只读四个字节。这一块内容就是一个基本读取单元也称为一个缓存行。现在大多数缓存行大小为 64 字节。这样会导致一个问题，CPU1 本来只想用 x，但是由于 x、y 在同一个缓存行，所以会一同读取进来；CPU2 本来只想用 y，也同样把 x、y 都读取进来了。所以当 CPU1 修改 x，会导致 CPU2 也要重新读取 x、y，这就是伪共享</p>
</li>
<li><p>伪共享：位于同一缓存行的两个不同数据，被两个不同 CPU 锁定，产生互相影响的<strong>伪共享</strong>问题。使用<strong>缓存行对齐</strong>来解决和提交效率。需要评估牺牲的空间是否值得。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_CacheLinePadding</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T[] arr= <span class="keyword">new</span> T[<span class="number">2</span>];</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</div><div class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">0</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">1</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();;</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">1000000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</div><div class="line">        <span class="comment">// 占用 56 字节,所以两个 T 对象肯定不在一个缓存行</span></div><div class="line">        <span class="comment">// 缓存行对齐</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1,p2,p3,p4,p5,p6,p7;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T[] arr= <span class="keyword">new</span> T[<span class="number">2</span>];</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</div><div class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">0</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</div><div class="line">                arr[<span class="number">1</span>].x = i;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();;</div><div class="line">        System.out.println((System.nanoTime() - start)/<span class="number">1000000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多开源软件中已经使用该方式来提高效率：</p>
<p><img src="../../images/jvm/03/缓存行对齐.png" alt=""></p>
<h2 id="2-JMM"><a href="#2-JMM" class="headerlink" title="2. JMM"></a>2. JMM</h2><h3 id="2-1-主内存与工作内存"><a href="#2-1-主内存与工作内存" class="headerlink" title="2.1 主内存与工作内存"></a>2.1 主内存与工作内存</h3><p>Java内存模型的主要目的是<strong>定义程序中各种变量的访问规则</strong>，即关注在虚拟机中把变量值存储到<br>内存和从内存中取出变量值这样的底层细节。</p>
<p>此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了<strong>实例字段、静态字段和构成数组对象的元素</strong>，但是<strong>不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p>
<ol>
<li><p>主内存</p>
<p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理<br>硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）</p>
</li>
<li><p>工作内存</p>
<p>每条<strong>线程</strong>还有自己的<strong>工作内存</strong>（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本。</p>
<p><strong>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行</strong>，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p>
</li>
</ol>
<p><img src="../../images/jvm/03/jmm.png" alt=""></p>
<h3 id="2-2-主内存、工作内存交互"><a href="#2-2-主内存、工作内存交互" class="headerlink" title="2.2 主内存、工作内存交互"></a>2.2 主内存、工作内存交互</h3><p>一个变量如何从主内存拷贝到工作内存？如何从工作内存同步回主内存？</p>
<h4 id="JMM-定义了八大原子操作"><a href="#JMM-定义了八大原子操作" class="headerlink" title="JMM 定义了八大原子操作"></a>JMM 定义了八大原子操作</h4><p>最新的 JSR-133 已经放弃这种描述，了解即可，但是 JMM 没有变化。</p>
<p>《深入理解 Java 虚拟机》P364</p>
<ul>
<li><strong>lock</strong>：主内存，标识变量为线程独占</li>
<li><strong>unlock</strong>：主内存，解锁线程独占变量</li>
<li><strong>read</strong>：主内存，把变量的值从主内存传输到线程的工作内存中，以备 load 使用</li>
<li>load：工作内存，read 后的值放入线程本地变量副本（工作内存的变量副本）</li>
<li>use：工作内存，传值给执行引擎</li>
<li>assign：工作内存，执行引擎结果赋值给工作内存变量</li>
<li>store：工作内存，存值到主内存给 write 备用</li>
<li><strong>write</strong>：主内存，写变量值</li>
</ul>
<h3 id="2-3-对于-volatile-变量的特殊规则"><a href="#2-3-对于-volatile-变量的特殊规则" class="headerlink" title="2.3 对于 volatile 变量的特殊规则"></a>2.3 对于 volatile 变量的特殊规则</h3><h4 id="语义1：线程可见性"><a href="#语义1：线程可见性" class="headerlink" title="语义1：线程可见性"></a>语义1：线程可见性</h4><p>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以<strong>立即得知</strong>的。</p>
<p>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<p><strong>错误的结论</strong>：基于volatile变量的运算在并发下是线程安全的</p>
<p>volatile 变量在工作内存中是不存在一致性问题的（从物理存储的角度看，可能存在不一致；但是从<strong>执行引擎</strong>角度看是不存在的，因为每次使用之前都要刷新）。但是 Java 里面的运算操作符<strong>并非原子操作</strong>，这导致 volatile 变量的运算在<strong>并发</strong>下一样是不安全的。例如 i++，可以分为三步：读取 i，i +1，写回 i，volatile 只能保证第一步是对的。</p>
<h4 id="语义2：禁止指令重排序"><a href="#语义2：禁止指令重排序" class="headerlink" title="语义2：禁止指令重排序"></a>语义2：禁止指令重排序</h4><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而<strong>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</strong>。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（<strong>Within-Thread As-If-Serial Semantics</strong>）。</p>
<p>典型的指令重排序可能导致的问题：DCL 单例。</p>
<h4 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h4><p>使用 HSDIS 查看 volatile 赋值操作的汇编码。</p>
<p>有 volatile 修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便是赋值操作）多执行了一个“<strong>lock</strong> addl$0x0，(%esp)”操作，这个操作的作用相当于一个<strong>内存屏障</strong>。</p>
<p>这里的关键在于 lock 前缀，查询<strong>IA32</strong>手册可知，它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核<strong>无效化（Invalidate）其缓存</strong>，这种操作相当于对缓存中的变量做了一次前面<br>介绍Java内存模式中所说的<strong>“store和write”</strong>（<strong>写回主内存</strong>）操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见。<strong>说白了就是 volatile 变量修改后立即写回主内存。</strong></p>
<p>lock addl$0x0，(%esp)指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“<strong>指令重排序无法越过内存屏障</strong>”的效果。</p>
<h4 id="JMM-对-volatile-变量的特殊规则定义"><a href="#JMM-对-volatile-变量的特殊规则定义" class="headerlink" title="JMM 对 volatile 变量的特殊规则定义"></a>JMM 对 volatile 变量的特殊规则定义</h4><p>假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：这里规则没必要细看了，理解就行。</p>
<ul>
<li>在工作内存中，每次使用V前都必须先<strong>从主内存刷新最新的值</strong>，用于保证能看见其他线程对变量V所做的修改。</li>
<li>在工作内存中，每次修改V后都必须<strong>立刻同步回主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。</li>
<li>要求volatile修饰的变量不会被指令<strong>重排序优化</strong>，从而保证代码的执行顺序与程序的顺序相同。</li>
</ul>
<h4 id="适合使用-volatile-的场景"><a href="#适合使用-volatile-的场景" class="headerlink" title="适合使用 volatile 的场景"></a>适合使用 volatile 的场景</h4><ul>
<li>运算结果不依赖变量的当前值，或者能保证只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<h3 id="2-4-针对-long-和-double-型变量的特殊规则"><a href="#2-4-针对-long-和-double-型变量的特殊规则" class="headerlink" title="2.4 针对 long 和 double 型变量的特殊规则"></a>2.4 针对 long 和 double 型变量的特殊规则</h3><p>JMM 要求 lock、unlock、read、load、assign、use、store、write 这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没<strong>有被 volatile 修饰</strong>的64 位数据的读写操作划分为<strong>两次 32 位的操作</strong>来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“<strong>long和double的非原子性协定</strong>”（Non-Atomic Treatment of double and long Variables）。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个<strong>既不是原值，也不是其他线程修改值</strong>的代表了“半个变量”的数值。不过这种读取到“半个变量”的情况是非常罕见的。</p>
<p><code>-XX：+AlwaysAtomicAccesses</code> JDK 9 开始，增加了这个实验性参数来约束虚拟机对所有数据类型进行原子性访问。</p>
<h3 id="2-5-原子性、可见性与有序性"><a href="#2-5-原子性、可见性与有序性" class="headerlink" title="2.5 原子性、可见性与有序性"></a>2.5 原子性、可见性与有序性</h3><p>JMM 是围绕着在<strong>并发</strong>过程中如何处理<strong>原子性、可见性和有序性</strong>这三个特征来建立的</p>
<h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>由 JMM 来直接保证的原子性变量操作包括 read、load、assign、use、store和write 这六个，<br>我们大致可以认为，<strong>基本数据类型的访问、读写都是具备原子性的</strong>（long、double 例外，知道就好）</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机<strong>未把 lock 和 unlock 操作直接开放给用户使用</strong>，但是却提供了更高层次的字节码指令 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块 <strong>synchronized</strong> 关键字，<strong>因此在synchronized块之间的操作也具备原子性</strong>。</p>
<h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>一个线程修改了共享变量，其他线程立即得知这个修改。</p>
<p>JMM 是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。</p>
<p>普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了<strong>新值能立即同步到主内存</strong>，以及每次使用前<strong>立即从主内存刷新</strong>。因此我们可以说 volatile 保证了<strong>多线程操作时变量的可见性</strong>，而普通变量则不能保证这一点。</p>
<p>除了 volatile 之外，<strong>synchronized 和 final</strong> 也能实现可见性。</p>
<ul>
<li>synchronized：对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li>
<li>final：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</li>
</ul>
<h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>如果在本线程内观察，所有的操作都是有序的；</p>
<p>如果在一个线程中观察另一个线程，所有的操作都是无序的。</p>
<p>前半句是指“<strong>线程内表现为串行的语义</strong>”（Within-Thread As-If-SerialSemantics）。</p>
<p>后半句是指“<strong>指令重排序</strong>”现象和“<strong>工作内存与主内存同步延迟</strong>”现象。</p>
<p>如何保证<strong>线程之间</strong>的操作有序性呢？</p>
<ul>
<li>volatile：本身有禁止指令重排序语义</li>
<li>synchronized：一个变量在同一个时刻只允许一条线程对其进行lock操作</li>
</ul>
<p>可以发现 上面三个特性都可以使用 synchronized 作为解决方案。</p>
<h3 id="2-6-hanppens-before-原则"><a href="#2-6-hanppens-before-原则" class="headerlink" title="2.6 hanppens-before 原则"></a>2.6 hanppens-before 原则</h3><p>操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>JMM 定义了一些“天然的”线性发生关系，他们无需任何同步器协助就已经存在。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，<strong>虚拟机可以对它们随意地进行重排序</strong>。</p>
<p>这只是 Java 的一个规范，具体由各个 JVM 实现。</p>
<p><img src="../../images/jvm/03/hanppens-before.png" alt=""></p>
<p><strong>时间先后顺序与先行发生原则之间基本没有因果关系</strong></p>
<ul>
<li>A 先行 B，但是时间上 A 不一定先于 B。典型的<strong>指令重排序</strong></li>
<li>A 时间顺序先于 B，A 不一定先行于 B。比如线程1时间上先 setValue，线程2紧接着 getValue。上面没有一个规则能证明线程1 set 操作先行于线程2 get 操作，所以如果不做手动同步处理，无法保证线程2 可以获取到正确的线程1 设置的值。</li>
</ul>
<h3 id="2-7-JVM-内存屏障"><a href="#2-7-JVM-内存屏障" class="headerlink" title="2.7 JVM 内存屏障"></a>2.7 JVM 内存屏障</h3><p>JVM 级别如何规范（JSR133）</p>
<p>JVM 只是一个规范，不同 CPU 的实现方式可能不同。比如龙芯、x86、arm 等 cpu 实现都不同。</p>
<p>LoadLoad 屏障：</p>
<ul>
<li>对于这样的语句 Load1; LoadLoad;Load2，在 Load2及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
</ul>
<p>StoreStore 屏障：</p>
<ul>
<li>对于这样的语句 Store1;StoreStore;Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其他处理器可见。</li>
</ul>
<p>LoadStore 屏障：</p>
<ul>
<li>对于这样的语句 Load1;StoreStore;Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据已经被读取完毕。</li>
</ul>
<p>StoreLoad 屏障：</p>
<ul>
<li>对于这样的语句 Store1;StoreStore;Load2，在 Load2 及后续读取操作执行前，保证 Store1 的写入对所有处理器可见。</li>
</ul>
<h2 id="3-volatile-的实现细节"><a href="#3-volatile-的实现细节" class="headerlink" title="3. volatile 的实现细节"></a>3. volatile 的实现细节</h2><ol>
<li><p>字节码层面</p>
<ol>
<li>只是增加 ACC_VOLATILE 标记</li>
</ol>
</li>
<li><p>JVM 层面</p>
<ol>
<li>StoreStoreBarrier;volatile 写操作;StoreLoadBarrier</li>
<li>LoadLoadBarrier;volatile 读操作;LoadStoreBarrier</li>
</ol>
</li>
<li><p>OS 和硬件层面</p>
<ol>
<li><p>使用 hsdis 观察汇编码</p>
</li>
<li><p>lock 指令 xxx 执行 xxx 指令的时候保证对内存区域加锁。</p>
<p>windows <strong>lock</strong> <strong>前缀</strong> 指令实现。</p>
<ol>
<li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存 </li>
<li>lock后的写操作会回写已修改的数据，同时让其它 CPU 相关缓存行失效，从而重新从主存中加载最新的数据 </li>
<li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两边的指令重排序 </li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/qq_26222859/article/details/52235930" target="_blank" rel="external">https://blog.csdn.net/qq_26222859/article/details/52235930</a></p>
</li>
</ol>
<h2 id="4-synchronized-的实现细节"><a href="#4-synchronized-的实现细节" class="headerlink" title="4. synchronized 的实现细节"></a>4. synchronized 的实现细节</h2><ol>
<li>字节码层面<ol>
<li>同步方法：ACC_SYNCHRONIZED</li>
<li>同步块：jvm monitorenter monitorexit 指令</li>
</ol>
</li>
<li>JVM 层面<ol>
<li>C C++ 调用了操作系统提供的同步机制</li>
</ol>
</li>
<li>OS 和硬件层面<ol>
<li>x86:<strong>处理器</strong> lock 指令实现(lock cmpxchg/xxx)，在指令前加 lock，表示在该只能执行过程中，锁定该指令要访问的内存区域，只有这条只能能修改，其他指令无法修改。</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/21aspnet/article/details/88571740" target="_blank" rel="external">https://blog.csdn.net/21aspnet/article/details/88571740</a></p>
<h2 id="5-对象内存布局"><a href="#5-对象内存布局" class="headerlink" title="5. 对象内存布局"></a>5. 对象内存布局</h2><h4 id="1-请解释一些下象的创建过程？"><a href="#1-请解释一些下象的创建过程？" class="headerlink" title="1. 请解释一些下象的创建过程？"></a>1. 请解释一些下象的创建过程？</h4><ol>
<li>class loading</li>
<li>class linking（verification,preparation,resolution）</li>
<li>class initializing</li>
<li>申请对象内存</li>
<li>成员变量赋默认值</li>
<li>调用构造方法<code>&lt;init&gt;</code><ol>
<li>成员变量顺序赋初始值</li>
<li>执行构造方法语句（先调用 super 构造方法）</li>
</ol>
</li>
</ol>
<h4 id="2-对象在内存中的存储布局？"><a href="#2-对象在内存中的存储布局？" class="headerlink" title="2. 对象在内存中的存储布局？"></a>2. 对象在内存中的存储布局？</h4><ol>
<li>观察虚拟机配置：java -XX:+PrintCommandLineFlags -version</li>
</ol>
<p><img src="../../images/jvm/03/JVM配置.png" alt=""></p>
<p>可以看出 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops 默认都是开启的。</p>
<ol>
<li><p>对象大小分析</p>
<p>普通对象：</p>
<ol>
<li>对象头：markword 8</li>
<li>ClassPointer 指针（指向 T.class 对象）：-XX:+UserCompressedClassPointers 为 4 字节，不开启为 8 字节</li>
<li>实例数据<ol>
<li>引用类型：-XX:+ UseCompressedOops 为 4 字节，不开启为 8 字节。Oops Ordinary Object Pointers</li>
</ol>
</li>
<li>Padding 对齐，8 的倍数（比如15个字节，实际上会读取 16 个字节）</li>
</ol>
<p>数组对象：</p>
<ol>
<li>对象头</li>
<li>ClassPointer 指针，同上</li>
<li><strong>数组长度：4 字节</strong></li>
<li>数组数据</li>
<li>Padding 对齐，8 的倍数</li>
</ol>
</li>
<li><p>验证分析</p>
</li>
</ol>
<p>新建 java agent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeAgent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation inst;</div><div class="line"></div><div class="line">    <span class="comment">// 格式固定和 main 方法一样, JVM 自动调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation _inst)</span> </span>&#123;</div><div class="line">        inst = _inst;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> inst.getObjectSize(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建 META-INF/MANIFEST.MF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Manifest-Version: 1.0</div><div class="line">Created-By: monkeykong.com</div><div class="line">Premain-Class: com.monkeykong.jvm.agent.ObjectSizeAgent</div></pre></td></tr></table></figure>
<p>使用 idea -&gt; project structor -&gt; artifacts -&gt; add jar -&gt; build artifacts 打成 jar 包</p>
<p>在需要使用该 Agent Jar 的项目中引入该 Jar 包<br>project structure - project settings - library 添加该jar包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> alvin</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-18 21:39</span></div><div class="line"><span class="comment"> * 运行时需要 Agent Jar 的类,加入参数:</span></div><div class="line"><span class="comment"> *   -javaagent:D:\01_code\01_javasebasic\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar</span></div><div class="line"><span class="comment"> * 关闭压缩 class pointer 压缩：-XX:-UseCompressedClassPointers</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SizeOfAnObject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 16:8(头 mark word)+4(class pointer 压缩)+4(padding)</span></div><div class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> Object()));</div><div class="line">        <span class="comment">// 32:8(头 mark word)+4(class pointer 压缩)+4(数组长度)+9(数组数据)+7(padding)</span></div><div class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;));</div><div class="line">        <span class="comment">// 32</span></div><div class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> P()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 一个 Object 占多少个字节</span></div><div class="line">    <span class="comment">//  -XX:+UseCompressedClassPointers -XX:+UseCompressedOops</span></div><div class="line">    <span class="comment">// Oops = ordinary object pointers 是否压缩普通对象指针</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</div><div class="line">                        <span class="comment">// 8 _markword</span></div><div class="line">                        <span class="comment">// 4 _class pointer</span></div><div class="line">        <span class="keyword">int</span> id;         <span class="comment">// 4</span></div><div class="line">        String name;    <span class="comment">// 4 因为是 64 位机器，默认为 8，但是 UseCompressedOops 开启了，所以为 4</span></div><div class="line">        <span class="keyword">int</span> age;        <span class="comment">// 4</span></div><div class="line"></div><div class="line">        <span class="keyword">byte</span> b1;        <span class="comment">// 1</span></div><div class="line">        <span class="keyword">byte</span> b2;        <span class="comment">// 1</span></div><div class="line"></div><div class="line">        Object o;       <span class="comment">// 4</span></div><div class="line">        <span class="keyword">byte</span> b3;        <span class="comment">// 1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-对象头包括什么？"><a href="#3-对象头包括什么？" class="headerlink" title="3. 对象头包括什么？"></a>3. 对象头包括什么？</h4><p>hosspot 源码，分为 32 位和 64 位。</p>
<p><img src="../../images/jvm/03/markword结构.png" alt=""></p>
<p>具体内容（32 位）：</p>
<p><img src="../../images/jvm/03/markword具体内容.png" alt=""></p>
<p>对象状态不同，大小分配也不同。主要记住三个锁标志位和 GC 标记和分代年龄。</p>
<p>当 Java 处在偏向锁、重量级锁状态时，hashcode 值存储在哪？</p>
<p><img src="../../images/jvm/03/markword相关问题.png" alt=""></p>
<h4 id="4-对象怎么定位？"><a href="#4-对象怎么定位？" class="headerlink" title="4. 对象怎么定位？"></a>4. 对象怎么定位？</h4><p>对象的引用怎么访问到 Java 堆中的对象的具体位置？</p>
<ol>
<li><p>句柄池</p>
<p> Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。 而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p>使用句柄方式最大的好处就是reference中存储的是<strong><em>稳定</em></strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时<strong>只会改变句柄中的实例数据指针</strong>，而 reference本身不需要被修改。 </p>
</li>
<li><p>直接指针</p>
<p> reference中直接存储的就是对象地址。使用直接指针方式最大的好处就是<strong><em>速度更快</em></strong>，他<strong><em>节省了一次指针定位的时间开销</em></strong>。 </p>
</li>
</ol>
<p>HotSpot 使用的是直接指针访问方式。</p>
<p><a href="https://blog.csdn.net/clover_lily/article/details/80095580" target="_blank" rel="external">https://blog.csdn.net/clover_lily/article/details/80095580</a></p>
<h4 id="5-对象怎么分配？"><a href="#5-对象怎么分配？" class="headerlink" title="5. 对象怎么分配？"></a>5. 对象怎么分配？</h4><p>GC 相关内容</p>
</div><div class="tags"><a href="/tags/JVM/">JVM</a></div><div class="post-nav"><a class="pre" href="/2020-07-19-jvm/jvm学习6_GC.html">JVM 学习（六）</a><a class="next" href="/2020-07-08-kafka/kafka学习2.html">Kafka学习(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/加解密技术/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/吉他/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/无关技术/">无关技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/疯狂-Java-讲义/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/计划/" style="font-size: 15px;">计划</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/吉他/" style="font-size: 15px;">吉他</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/无关技术/" style="font-size: 15px;">无关技术</a> <a href="/tags/疯狂-Java-讲义/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>