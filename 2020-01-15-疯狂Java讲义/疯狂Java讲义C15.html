<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="悟空的技术博客"><title>第 15 章 输入、输出 | 悟空</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第 15 章 输入、输出</h1><a id="logo" href="/.">悟空</a><p class="description">悟空的技术博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第 15 章 输入、输出</h1><div class="post-meta">2020-01-15<span> | </span><span class="category"><a href="/categories/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/">疯狂 Java 讲义</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-File-%E7%B1%BB"><span class="toc-text">15.1 File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">15.1.1 访问文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E5%90%8D%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">1. 访问文件名相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">2. 文件检测相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-text">3. 获取常规文件信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">4. 文件操作相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">5. 目录操作相关方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">15.1.2 文件过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E7%90%86%E8%A7%A3-Java-%E7%9A%84-IO-%E6%B5%81"><span class="toc-text">15.2 理解 Java 的 IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-1-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">15.2.1 流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">1. 输入流和输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">2. 字节流和字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-text">3. 节点流和处理流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-2-%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"><span class="toc-text">15.2.2 流的概念模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">输入流模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">输出流模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">处理流模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">15.3 字节流和字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-1-InputStream-%E5%92%8C-Reader"><span class="toc-text">15.3.1 InputStream 和 Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream"><span class="toc-text">InputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reader"><span class="toc-text">Reader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3"><span class="toc-text">指针相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-2-OutputStream-%E5%92%8C-Writer"><span class="toc-text">15.3.2 OutputStream 和 Writer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E4%BD%93%E7%B3%BB"><span class="toc-text">15.4 输入、输出体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-1-%E5%A4%84%E7%90%86%E6%B5%81%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">15.4.1 处理流的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-2-%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81%E4%BD%93%E7%B3%BB"><span class="toc-text">15.4.2 输入、输出流体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-3-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">15.4.3 转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-4-%E6%8E%A8%E5%9B%9E%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-text">15.4.4 推回输入流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA"><span class="toc-text">15.5 重定向标准输入、输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-6-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%BB%E5%86%99%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">15.6 Java 虚拟机读写其他进程的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-7-RandomAccessFile"><span class="toc-text">15.7 RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-8-Java-9-%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">15.8 Java 9 改进的对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-1-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-text">15.8.1 序列化的含义和意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-2-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">15.8.2 使用对象流实现序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-3-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">15.8.3 对象引用的序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-4-Java-9-%E5%A2%9E%E5%8A%A0%E7%9A%84%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-text">15.8.4 Java 9 增加的过滤功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">15.8.5 自定义序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-6-%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">15.8.6 另一种自定义序列化机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-7-%E7%89%88%E6%9C%AC"><span class="toc-text">15.8.7 版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-9-NIO"><span class="toc-text">15.9 NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-1-Java-%E6%96%B0-IO-%E6%A6%82%E8%BF%B0"><span class="toc-text">15.9.1 Java 新 IO 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-2-%E4%BD%BF%E7%94%A8-Buffer"><span class="toc-text">15.9.2 使用 Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-%E5%8E%9F%E7%90%86"><span class="toc-text">Buffer 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Buffer 常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-3-%E4%BD%BF%E7%94%A8-Channel"><span class="toc-text">15.9.3 使用 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-4-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C-Charset"><span class="toc-text">15.9.4 字符集和 Charset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-5-%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-text">15.9.5 文件锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-10-Java-7-%E7%9A%84-NIO-2"><span class="toc-text">15.10 Java 7 的 NIO.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-10-1-Path%E3%80%81Paths-%E5%92%8C-Files-%E6%A0%B8%E5%BF%83-API"><span class="toc-text">15.10.1 Path、Paths 和 Files 核心 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Path"><span class="toc-text">Path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Files"><span class="toc-text">Files</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-10-2-%E4%BD%BF%E7%94%A8-FileVisitor-%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">15.10.2 使用 FileVisitor 遍历文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-10-3-%E4%BD%BF%E7%94%A8-WatchService-%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96"><span class="toc-text">15.10.3 使用 WatchService 监控文件变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-10-4-%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">15.10.4 访问文件属性</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第 15 章 输入、输出</p>
<a id="more"></a>

<h2 id="15-1-File-类"><a href="#15-1-File-类" class="headerlink" title="15.1 File 类"></a>15.1 File 类</h2><p>File 类是 java.io 包下代表与平台无关的文件和目录。File 能新建、删除、重命名文件和目录，但是不能访问文件内容本身。如果要访问文件内容，需要用到输入、输出流。</p>
<h3 id="15-1-1-访问文件和目录"><a href="#15-1-1-访问文件和目录" class="headerlink" title="15.1.1 访问文件和目录"></a>15.1.1 访问文件和目录</h3><p>相对路径总是依据用户的工作路径（user.dir）来解释。</p>
<h4 id="1-访问文件名相关方法"><a href="#1-访问文件名相关方法" class="headerlink" title="1. 访问文件名相关方法"></a>1. 访问文件名相关方法</h4><ul>
<li>String getName()：返回此 File 对象所表示的文件名或路径名</li>
<li>String getPath()</li>
<li>File getAbsoluteFile()</li>
<li>String getAbsolutePath()</li>
<li>String getParent()：File 对象所对应目录的父目录名</li>
<li>boolean renameTo(File newName)</li>
</ul>
<h4 id="2-文件检测相关方法"><a href="#2-文件检测相关方法" class="headerlink" title="2. 文件检测相关方法"></a>2. 文件检测相关方法</h4><ul>
<li>boolean exists()</li>
<li>boolean canWrite()</li>
<li>boolean can Read()</li>
<li>boolean isFile()</li>
<li>boolean isDirectory()</li>
<li>boolean isAbsolute()</li>
</ul>
<h4 id="3-获取常规文件信息"><a href="#3-获取常规文件信息" class="headerlink" title="3. 获取常规文件信息"></a>3. 获取常规文件信息</h4><ul>
<li>long lastModified()</li>
<li>long length()：文件内容长度</li>
</ul>
<h4 id="4-文件操作相关方法"><a href="#4-文件操作相关方法" class="headerlink" title="4. 文件操作相关方法"></a>4. 文件操作相关方法</h4><ul>
<li>boolean createNewFile()：File 对象文件不存在时，创建指定的新文件</li>
<li>boolean delete()</li>
<li>static File createTempFile(String prefix, String suffix)：在默认的临时文件目录中创建一个临时空文件。</li>
<li>static File createTempFile(String prefix, String suffix, File directory)</li>
<li>void deleteOnExit()：虚拟机退出时，删除 File 对象所对应的文件和目录</li>
</ul>
<h4 id="5-目录操作相关方法"><a href="#5-目录操作相关方法" class="headerlink" title="5. 目录操作相关方法"></a>5. 目录操作相关方法</h4><ul>
<li>boolean mkdir()</li>
<li>String[] list()：列出 File 对象的所有子文件名和路径名</li>
<li>File[] listFiles()：列出 File 对象的所有子文件和路径</li>
<li>static File[] listRoots()：列出系统所有的根路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// Windows 路径分隔用反斜杠（\）表示，但反斜杠在Java 中表示转义，所以需要用双反斜杠(\\)；</span></span><br><span class="line">		<span class="comment">// 或者，Java 程序支持将斜线（/）当成平台无关的路径分隔符</span></span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">		System.out.println(file.createNewFile());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 访问文件名相关（对象所对应文件或目录名称、路径名、绝对路径、绝对路径名、父目录名、重命名）</span></span><br><span class="line">		System.out.println(<span class="string">&quot;访问文件名相关:&quot;</span>);</span><br><span class="line">		System.out.println(file.getName());</span><br><span class="line">		System.out.println(file.getPath());</span><br><span class="line">		System.out.println(file.getAbsoluteFile());</span><br><span class="line">		System.out.println(file.getAbsolutePath());</span><br><span class="line">		System.out.println(file.getParent());</span><br><span class="line">		System.out.println(file.getAbsoluteFile().getParent());</span><br><span class="line">		<span class="comment">//System.out.println(file.renameTo(new File(&quot;c&quot;)));</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 文件检测相关（对象所对应的文件或目录是否存在、是否可写、是否可读、是否可执行、是否文件、是否目录、是否绝对路径）</span></span><br><span class="line">		System.out.println(<span class="string">&quot;文件检测相关:&quot;</span>);</span><br><span class="line">		System.out.println(file.exists());</span><br><span class="line">		System.out.println(file.canWrite());</span><br><span class="line">		System.out.println(file.canRead());</span><br><span class="line">		System.out.println(file.canExecute());</span><br><span class="line">		System.out.println(file.isFile());</span><br><span class="line">		System.out.println(file.isDirectory());</span><br><span class="line">		System.out.println(file.isAbsolute());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 文件常规信息（最后修改时间、长度）</span></span><br><span class="line">		System.out.println(<span class="string">&quot;文件常规信息:&quot;</span>);</span><br><span class="line">		System.out.println(file.lastModified());</span><br><span class="line">		System.out.println(file.length());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 文件操作相关（新增、删除）</span></span><br><span class="line">		System.out.println(<span class="string">&quot;文件操作相关:&quot;</span>);</span><br><span class="line">		<span class="comment">//System.out.println(file.delete());</span></span><br><span class="line">		File tmpFile = File.createTempFile(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;.txt&quot;</span>, <span class="keyword">new</span> File(<span class="string">&quot;.//src&quot;</span>));</span><br><span class="line">		tmpFile.deleteOnExit();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;目录操作相关:&quot;</span>);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> File(<span class="string">&quot;aaa&quot;</span>).mkdir());</span><br><span class="line">		System.out.println(<span class="string">&quot;当期路径下的所有文件和路径如下:&quot;</span>);</span><br><span class="line">		String[] fileList = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>).list();</span><br><span class="line">		<span class="keyword">for</span> (String fileName : fileList) &#123;</span><br><span class="line">			System.out.println(fileName);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;系统所有根路径如下：&quot;</span>);</span><br><span class="line">		File[] roots = File.listRoots();</span><br><span class="line">		<span class="keyword">for</span> (File root : roots) &#123;</span><br><span class="line">			System.out.println(root);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-1-2-文件过滤器"><a href="#15-1-2-文件过滤器" class="headerlink" title="15.1.2 文件过滤器"></a>15.1.2 文件过滤器</h3><p>File 类的 list() 方法可以接受一个 FilenameFilter 参数，用于过滤符合条件的文件。</p>
<p>列出当前路径下所有的 *.java 文件和文件夹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileNameFileterTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">		String[] nameList = file.list((dir,name) -&gt; name.endsWith(<span class="string">&quot;.java&quot;</span>) || <span class="keyword">new</span> File(name).isDirectory());</span><br><span class="line">		<span class="keyword">for</span>(String name :nameList) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-理解-Java-的-IO-流"><a href="#15-2-理解-Java-的-IO-流" class="headerlink" title="15.2 理解 Java 的 IO 流"></a>15.2 理解 Java 的 IO 流</h2><h3 id="15-2-1-流的分类"><a href="#15-2-1-流的分类" class="headerlink" title="15.2.1 流的分类"></a>15.2.1 流的分类</h3><h4 id="1-输入流和输出流"><a href="#1-输入流和输出流" class="headerlink" title="1. 输入流和输出流"></a>1. 输入流和输出流</h4><ul>
<li>输入流：只能从中读取数据，不能写入。基类：InputStream、Reader</li>
<li>输出流：只能向其写入数据，不能读取。基类：OutputStream、Writer</li>
</ul>
<p>输入、输出都是站在<strong>程序运行所在内存</strong>的角度来看的。比如数据从程序内存到磁盘，就叫做输出流。</p>
<h4 id="2-字节流和字符流"><a href="#2-字节流和字符流" class="headerlink" title="2. 字节流和字符流"></a>2. 字节流和字符流</h4><p>用法几乎一样，区别在于操作的数据单元不同。</p>
<ul>
<li>字节流：操作的数据单元是 <strong>8 位</strong>的字节（<strong>一个字节 8 位</strong>）</li>
<li>字符流：<strong>16 位</strong>的字符（<strong>一个字符 2 个字节，所以是 16 位</strong>）</li>
</ul>
<h4 id="3-节点流和处理流"><a href="#3-节点流和处理流" class="headerlink" title="3. 节点流和处理流"></a>3. 节点流和处理流</h4><ul>
<li>节点流：从、向一个<strong>特定的 IO 设备</strong>（如磁盘、网络等）读写数据的流，称为节点流，节点流也称为低级流</li>
<li>处理流：对一个已存在的流进行连接和封装，通过封装后的流来实现数据读写功能，也称为高级流。好处是，<strong>只要使用相同的处理流，程序就可以采用完全相同的输入、输出代码来访问不同的数据源</strong>；<strong>以缓冲的方式来提高性能(@#1)；每次操作多个水滴。</strong></li>
</ul>
<p>Java 使用处理流来包装节点流是一种典型的<strong>装饰器模式(@#2)，</strong>通过使用处理流包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。因此处理流也被称为包装流。</p>
<p>InputStream、Reader；OutputStream、Writer；是节点流还是处理流？@#3</p>
<h3 id="15-2-2-流的概念模型"><a href="#15-2-2-流的概念模型" class="headerlink" title="15.2.2 流的概念模型"></a>15.2.2 流的概念模型</h3><ul>
<li>InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流 </li>
<li>OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流</li>
</ul>
<h4 id="输入流模型"><a href="#输入流模型" class="headerlink" title="输入流模型"></a>输入流模型</h4><p>装满水滴的水管，每读取一个指针向后移动一位。</p>
<p><img src="../../images/java/c15/%E8%BE%93%E5%85%A5%E6%B5%81%E6%A8%A1%E5%9E%8B.png"></p>
<h4 id="输出流模型"><a href="#输出流模型" class="headerlink" title="输出流模型"></a>输出流模型</h4><p>空水管，每次装入一滴水，指针向后移动一位</p>
<p><img src="../../images/java/c15/%E8%BE%93%E5%87%BA%E6%B5%81%E6%A8%A1%E5%9E%8B.png"></p>
<h4 id="处理流模型"><a href="#处理流模型" class="headerlink" title="处理流模型"></a>处理流模型</h4><p>处理流可以“嫁接”在任何已存在的流的基础之上。</p>
<p><img src="../../images/java/c15/%E5%A4%84%E7%90%86%E6%B5%81%E6%A8%A1%E5%9E%8B.png"></p>
<h2 id="15-3-字节流和字符流"><a href="#15-3-字节流和字符流" class="headerlink" title="15.3 字节流和字符流"></a>15.3 字节流和字符流</h2><h3 id="15-3-1-InputStream-和-Reader"><a href="#15-3-1-InputStream-和-Reader" class="headerlink" title="15.3.1 InputStream 和 Reader"></a>15.3.1 InputStream 和 Reader</h3><p>所有输入流的基类，<strong>本身并不能创建实例来执行输入</strong>，但他们将成为所有输入流的模板。</p>
<h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><ul>
<li>int read()：读取单个字节，返回读取的字节</li>
<li>int read(byte[] b)：读取最多 b.length 个字节，并存在 b 中，返回读取的字节个数</li>
<li>int read(byte[] b, int off, int len)：最多读取 len 字节，存在 b 中，从 off 开始存，返回读取的字节个数</li>
</ul>
<h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><ul>
<li>int read()</li>
<li>int read(char[] cbuf)</li>
<li>int read(char[], int off, int len)</li>
</ul>
<p>read() 方法返回 -1 表示输入流读取完毕。</p>
<p>InputStream 和 Reader 都是抽象类，本身不能创建实例。</p>
<p>他们分别有一个用于读取文件的输入流：FileInputStream 和 FileReader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./src/unit15_javaio/c3/FileInputStreamTest.java&quot;</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.print(<span class="keyword">new</span> String(bbuf, <span class="number">0</span>, hasRead));</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 自动关闭资源的 try 语句</span></span><br><span class="line">		<span class="keyword">try</span>(FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;./src/unit15_javaio/c3/FileReaderTest.java&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">			<span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((hasRead = fr.read(cbuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.print(<span class="keyword">new</span> String(cbuf, <span class="number">0</span>, hasRead));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="指针相关"><a href="#指针相关" class="headerlink" title="指针相关"></a>指针相关</h4><ul>
<li>void mark(int readAheadLimit)：在记录指针当前位置记录一个标记</li>
<li>boolean markSupported()：判断此输入流是否支持 mark 操作</li>
<li>void reset()：将此流的记录指针重新定位到上一次记录标记（mark）的位置</li>
<li>long skip(long n)：记录指针向前移动 n 个字节、字符</li>
</ul>
<h3 id="15-3-2-OutputStream-和-Writer"><a href="#15-3-2-OutputStream-和-Writer" class="headerlink" title="15.3.2 OutputStream 和 Writer"></a>15.3.2 OutputStream 和 Writer</h3><ul>
<li>void write(int c)</li>
<li>void write(byte[]/char[] buf)</li>
<li>void write(byte[]/char[] buf, int off, int len)</li>
</ul>
<p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来代替字符数组，即以 String 对象作为参数。</p>
<ul>
<li>void write(String str)</li>
<li>void write(String str, int off, int len)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./src/unit15_javaio/c3/FileOutputStreamTest.java&quot;</span>);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;newFile.txt&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">			<span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				fos.write(bbuf, <span class="number">0</span>, hasRead);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>使用 Java 的 IO 流时，要记得关闭输出流，一方面可以保证流的物理资源被回收，还可以保证输出流缓冲区中的数据 fulsh 到物理节点，因为执行 close 之前，会自动执行输出流的 flush() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;poem.txt&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// windos 换行符 \r\n；linux 换行符 \n</span></span><br><span class="line">			fw.write(<span class="string">&quot;锦瑟 - 李商隐\r\n&quot;</span>);</span><br><span class="line">			fw.write(<span class="string">&quot;锦瑟无端五十弦，一弦一柱思华年。\r\n&quot;</span>);</span><br><span class="line">			fw.write(<span class="string">&quot;庄生晓梦迷蝴蝶，望帝春心托杜鹃。\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="15-4-输入、输出体系"><a href="#15-4-输入、输出体系" class="headerlink" title="15.4 输入、输出体系"></a>15.4 输入、输出体系</h2><h3 id="15-4-1-处理流的用法"><a href="#15-4-1-处理流的用法" class="headerlink" title="15.4.1 处理流的用法"></a>15.4.1 处理流的用法</h3><p>使用处理流思路：包装节点流，程序通过处理流来执行输入、输出功能，让节点流与底层的 IO 设备、文件交互。</p>
<p>处理流构造器参数一般是已经存在的流；节点流构造器参数都是物理 IO 节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// 节点流</span></span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;text.txt&quot;</span>);</span><br><span class="line">			<span class="comment">// 包装为处理流</span></span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(fos))</span><br><span class="line">		&#123;</span><br><span class="line">			ps.println(<span class="string">&quot;普通字符串&quot;</span>);</span><br><span class="line">			ps.println(<span class="keyword">new</span> PrintStreamTest());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>关闭处理流会自动关闭该处理流包装的节点流。</p>
<h3 id="15-4-2-输入、输出流体系"><a href="#15-4-2-输入、输出流体系" class="headerlink" title="15.4.2 输入、输出流体系"></a>15.4.2 输入、输出流体系</h3><p><img src="../../images/java/c15/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E4%BD%93%E7%B3%BB.png"></p>
<p>通常来说，字节流功能比字符流强大，但问题是，如果使用字节流来处理文本，则需要使用合适的方式把这些字节转换成字符，这就增加了编程的复杂度。所以，如果处理的数据是<strong>文本内容，则应该考虑字符流</strong>；如果<strong>处理的数据是二进制内容，则应该考虑使用字节流</strong>。</p>
<p>计算机的文件常被分为文本文件和二进制文件两大类。所有可以使用记事本打开并看到其中字符内容的文件称为文本文件，反之则称为二进制文件。但实质是， 计算机里的所有文件都是二进制文件， 文本文件只是二进制文件的一种特例， 当二进制文件里的内容恰好能被正常解析成字符时，则该二进制文件就变成了文本文件。</p>
<p>宇符流还可以使用字符串作为物理节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNodeTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String src = <span class="string">&quot;从明天起，做一个幸福的人\n&quot;</span></span><br><span class="line">				+ <span class="string">&quot;喂马，劈柴，周游世界\n&quot;</span></span><br><span class="line">				+ <span class="string">&quot;从明天起，关心粮食和蔬菜\n&quot;</span></span><br><span class="line">				+ <span class="string">&quot;我有一所房子，面朝大海，春暖花开\n&quot;</span>;</span><br><span class="line">		<span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">		<span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span>(StringReader sr = <span class="keyword">new</span> StringReader(src))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 采用循环读取的方式读取字符串</span></span><br><span class="line">			<span class="keyword">while</span>((hasRead = sr.read(buffer)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, hasRead));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>(StringWriter sw = <span class="keyword">new</span> StringWriter())</span><br><span class="line">		&#123;</span><br><span class="line">			sw.write(<span class="string">&quot;有一个美丽的新世界，\n&quot;</span>);</span><br><span class="line">			sw.write(<span class="string">&quot;她在远方等我，\n&quot;</span>);</span><br><span class="line">			sw.write(<span class="string">&quot;那里有天真的孩子，\n&quot;</span>);</span><br><span class="line">			sw.write(<span class="string">&quot;还有姑娘的酒窝&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;----下面是 sw 字符串节点里的内容----&quot;</span>);</span><br><span class="line">			System.out.println(sw.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-3-转换流"><a href="#15-4-3-转换流" class="headerlink" title="15.4.3 转换流"></a>15.4.3 转换流</h3><ul>
<li>InputStreamReader：字节输入流转换成字符输入流</li>
<li>OutputStreamWriter：字节输出流转换成字符输出流</li>
</ul>
<p>Java 使用 System .in 代表标准输入， 即键盘输入，但这个标准输入流是 InputStream 类的实例， 使用不太方便， 而且键盘输入内容都是文本内容，所以可以使用 InputStreamReader 将其转换成字符输入流，。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyinTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">			BufferedReader br = <span class="keyword">new</span> BufferedReader(reader))</span><br><span class="line">		&#123;</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (line.equals(<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					System.exit(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;输入内容为：&quot;</span> + line);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-4-推回输入流"><a href="#15-4-4-推回输入流" class="headerlink" title="15.4.4 推回输入流"></a>15.4.4 推回输入流</h3><p>@#4为啥没有推回输出流？</p>
<p>读取到输入流中的数据后又推回去（unread）？有何应用场景？</p>
<p>PushbackInputStream、PushbackReader</p>
<ul>
<li>void unread(byte[]/char[] buf)</li>
<li>void unread(byte[]/char[] b, int off, int len)</li>
<li>void unread(int b)</li>
</ul>
<p>维护一个推回缓冲区，read 时总是先从推回缓冲区取“水滴”，当推回缓冲区水滴不够时才会到原输入流里去取。</p>
<p>如果程序中推回到缓冲区中的内容超出了推回缓冲区的大小，将会引发 Pushback buffer overflow 的 IOException。</p>
<p>下面程序试图找出程序中的 “new PushbackReader” 宇符串，当找到该字符串后，程序只是打印出目标宇符串之前的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="comment">// 创建一个 PushBackReader 对象,指定推回缓冲区长度为 64</span></span><br><span class="line">                PushbackReader pr = <span class="keyword">new</span> PushbackReader(</span><br><span class="line">                        <span class="keyword">new</span> FileReader(<span class="string">&quot;./src/unit15_javaio/c4/PushbackTest.java&quot;</span>), <span class="number">64</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">            <span class="comment">// 用以保存上次读取的字符串内容</span></span><br><span class="line">            String lastContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> hasRead =  <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环读取文件内容</span></span><br><span class="line">            <span class="keyword">while</span> ((hasRead = pr.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">                String content = <span class="keyword">new</span> String(buf, <span class="number">0</span>, hasRead);</span><br><span class="line">                <span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上次读取的字符串和本次读取的字符串拼接起来</span></span><br><span class="line">                <span class="comment">// 查看是否包含目标字符串,如果包含</span></span><br><span class="line">                <span class="keyword">if</span>((targetIndex = (lastContent + content)</span><br><span class="line">                        .indexOf(<span class="string">&quot;new PushbackReader&quot;</span>))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 将本次内容和上次内容一起推回缓冲区</span></span><br><span class="line">                    pr.unread((lastContent+content).toCharArray());</span><br><span class="line">                    <span class="comment">// 重新定义一个长度为 targetIndex 的 char 数组</span></span><br><span class="line">                    <span class="keyword">if</span>(targetIndex &gt; <span class="number">32</span>) &#123;</span><br><span class="line">                        buf = <span class="keyword">new</span> <span class="keyword">char</span>[targetIndex];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 再次读取指定长度的内容(就是目标字符串之前的内容)</span></span><br><span class="line">                    pr.read(buf, <span class="number">0</span>, targetIndex);</span><br><span class="line">                    <span class="comment">// 打印读取的内容</span></span><br><span class="line">                    System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, targetIndex));</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 打印上次读取的内容</span></span><br><span class="line">                    System.out.print(lastContent);</span><br><span class="line">                    <span class="comment">// 将本次内容设置为上次读取内容</span></span><br><span class="line">                    lastContent = content;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            ioe.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-5-重定向标准输入、输出"><a href="#15-5-重定向标准输入、输出" class="headerlink" title="15.5 重定向标准输入、输出"></a>15.5 重定向标准输入、输出</h2><p>System 类提供了三个重定向标准输入、输出的方法：</p>
<ul>
<li>static void setErr(PrintStream err)</li>
<li>static void setIn(InputStream in)</li>
<li>static void setOut(PrintStream out)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectOut</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			System.setOut(ps);</span><br><span class="line">			System.out.println(<span class="string">&quot;普通字符串&quot;</span>);</span><br><span class="line">			System.out.println(<span class="keyword">new</span> RedirectOut());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重定向标准输入，正常是键盘输入，现在重定向到一个文件作为输入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectIn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./src/unit15_javaio/c5/RedirectIn.java&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			System.setIn(fis);</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">			Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(sc.hasNext())</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) </span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-6-Java-虚拟机读写其他进程的数据"><a href="#15-6-Java-虚拟机读写其他进程的数据" class="headerlink" title="15.6 Java 虚拟机读写其他进程的数据"></a>15.6 Java 虚拟机读写其他进程的数据</h2><p>Runtime.exec()方法可以运行平台上的其他程序，返回一个 Process 对象。</p>
<ul>
<li>InputStream getErrorStream()：获取子进程的错误流</li>
<li>InputStream getInputStream()</li>
<li>OutputStream getOutputStream()</li>
</ul>
<p>读取其他进程数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFromProcess</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		Process p = Runtime.getRuntime().exec(<span class="string">&quot;javac&quot;</span>);</span><br><span class="line">		p.waitFor();</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream(),<span class="string">&quot;gbk&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			String buff = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span>((buff = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(buff);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送数据给其他进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteToProcess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Process p = Runtime.getRuntime().exec(<span class="string">&quot;java D:\\01_code\\01_javasebasic\\waojava\\src\\unit15_javaio\\c6\\ReadStandard&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// 以 p 进程的输出流创建 PrintStream</span></span><br><span class="line">			<span class="comment">// 这个 ps 对本程序是输出流,对p进程是输入流</span></span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(p.getOutputStream()))</span><br><span class="line">		&#123;</span><br><span class="line">			ps.println(<span class="string">&quot;啊啊啊啊啊啊&quot;</span>);</span><br><span class="line">			ps.println(<span class="keyword">new</span> WriteToProcess());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStandard</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;============&gt;main&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(sc.hasNext())</span><br><span class="line">			&#123;</span><br><span class="line">				ps.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-7-RandomAccessFile"><a href="#15-7-RandomAccessFile" class="headerlink" title="15.7 RandomAccessFile"></a>15.7 RandomAccessFile</h2><p>既可以读取文件内容也可以向文件输出数据。与普通输入、输出流不同的是，它支持随机访问的方式，程序可以直接跳转到文件的任意位置来读写数据。</p>
<p>如果只需要访问文件的部分内容；或者要向已存在的文件后追加内容，应该使用 RandomAccessFile</p>
<p>RandomAccessFile 最大的局限是只能读写文件，不能读写其他 IO 节点。</p>
<ul>
<li>long getFilePointer()</li>
<li>void seek(long pos)：将文件记录指针定位到 pos 位置</li>
</ul>
<p>因为既可以读也可以写所以同时包含 read 和 write 方法。</p>
<ul>
<li>r：只读</li>
<li>rw：读写</li>
<li>rws：读写，对文件的内容或元数据的每个更新都同步写入到底层存储设备</li>
<li>rwd：读写，对文件的内容的每个更新都同步写入到底层存储设备</li>
</ul>
<p>读取指定位置内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;./src/unit15_javaio/c7/RandomAccessFileTest.java&quot;</span>, <span class="string">&quot;r&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;RandomAccessFile 的文件指针的初始位置：&quot;</span> + raf.getFilePointer());</span><br><span class="line">			raf.seek(<span class="number">300</span>);</span><br><span class="line">			<span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((hasRead = raf.read(bbuf)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(<span class="keyword">new</span> String(bbuf, <span class="number">0</span>, hasRead));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追加内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppendContent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 指针定位到最后</span></span><br><span class="line">			raf.seek(raf.length());</span><br><span class="line">			raf.write(<span class="string">&quot;追加的内容\r\naaaaaaa\r\n&quot;</span>.getBytes());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) </span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定位置插入内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertContent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String fileName, <span class="keyword">long</span> pos, String insertContent)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		File tmp = File.createTempFile(<span class="string">&quot;tmp&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">		tmp.deleteOnExit();</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(fileName, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">			FileOutputStream tmpOut = <span class="keyword">new</span> FileOutputStream(tmp);</span><br><span class="line">			FileInputStream tmpIn = <span class="keyword">new</span> FileInputStream(tmp))</span><br><span class="line">		&#123;</span><br><span class="line">			raf.seek(pos);</span><br><span class="line">			<span class="comment">// 将插入点后的内容读入临时文件中保存</span></span><br><span class="line">			<span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>];</span><br><span class="line">			<span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((hasRead = raf.read(bbuf)) &gt; <span class="number">0</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				tmpOut.write(bbuf, <span class="number">0</span>, hasRead);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 追加需要插入的内容</span></span><br><span class="line">			raf.seek(pos);</span><br><span class="line">			raf.write(insertContent.getBytes());</span><br><span class="line">			<span class="keyword">while</span> ((hasRead = tmpIn.read(bbuf)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				raf.write(bbuf, <span class="number">0</span>, hasRead);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		insert(<span class="string">&quot;./src/unit15_javaio/c7/InsertContent.java&quot;</span>, <span class="number">45</span>, <span class="string">&quot;插入的内容\r\t&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-8-Java-9-改进的对象序列化"><a href="#15-8-Java-9-改进的对象序列化" class="headerlink" title="15.8 Java 9 改进的对象序列化"></a>15.8 Java 9 改进的对象序列化</h2><p>对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。</p>
<h3 id="15-8-1-序列化的含义和意义"><a href="#15-8-1-序列化的含义和意义" class="headerlink" title="15.8.1 序列化的含义和意义"></a>15.8.1 序列化的含义和意义</h3><p>对象的序列化( Serialize )指将一个Java 对象写入IO 流中，与此对应的是，对象的反序列化( Deserialize ) 则指从IO 流中恢复该 Java 对象。</p>
<p>为了让某个类是可序列化的：</p>
<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
<h3 id="15-8-2-使用对象流实现序列化"><a href="#15-8-2-使用对象流实现序列化" class="headerlink" title="15.8.2 使用对象流实现序列化"></a>15.8.2 使用对象流实现序列化</h3><p>序列化</p>
<ul>
<li>创建一个 ObjectOutputStream</li>
<li>writeObject()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// 创建对象流</span></span><br><span class="line">			ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 对象序列化</span></span><br><span class="line">			Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">			oos.writeObject(per);</span><br><span class="line"></span><br><span class="line">			Person per1 = <span class="keyword">new</span> Person(<span class="string">&quot;alvin&quot;</span>, <span class="number">500</span>);</span><br><span class="line">			oos.writeObject(per1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<ul>
<li>创建一个 ObjectInputStream</li>
<li>readObject()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// 创建对象流</span></span><br><span class="line">			ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 反序列化</span></span><br><span class="line">			Person p = (Person)ois.readObject();</span><br><span class="line">			System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName() + <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line"></span><br><span class="line">			Person p1 = (Person)ois.readObject();</span><br><span class="line">			System.out.println(<span class="string">&quot;名字为：&quot;</span> + p1.getName() + <span class="string">&quot;\n年龄为：&quot;</span> + p1.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>证明反序列化机制无须通过构造器来初始化Java 对象。</p>
<p>当一个可序列化类有多个父类时，这些父类<strong>要么有无参构造器要么也是可序列化</strong>的。如果父类是不可序列化只是有无参构造器，则该父类中定义的成员变量值不会序列化到二进制流中。</p>
<h3 id="15-8-3-对象引用的序列化"><a href="#15-8-3-对象引用的序列化" class="headerlink" title="15.8.3 对象引用的序列化"></a>15.8.3 对象引用的序列化</h3><p>某个类的成员变量的类型不是基本类型或 String 类型，而是另一个引用类型，那么这个引用类必须是可序列化的，否则拥有该类型成员变量的类也是不可序列化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialMachine</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">    Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;唐僧&quot;</span>, per);</span><br><span class="line">    Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">&quot;菩提老祖&quot;</span>, per);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想像一下，如果序列化 SerialMachine 后再反序列化，会得到几个 Person 对象。目前来看是不是会有三个？这样和序列化之前，该类不一致。</p>
<p>所以 Java 有一种特殊的序列化算法：</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号</li>
<li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过，只有未被序列化过，才会序列化该对象</li>
<li>如果已经序列化过，程序只是输出一个序列化编号，而不是再次重新序列化该对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建一个 ObjectOutputStream 输出流</span></span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;teacherr.txt&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;唐僧&quot;</span>, per);</span><br><span class="line">            Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">&quot;菩提老祖&quot;</span>, per);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一次将四个对象写入输出流</span></span><br><span class="line">            oos.writeObject(t1);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序实际上只序列化了三个对象，而且序列的两个 Teacher 对象的 student 引用实际是同一个Person 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建一个 ObjectInputStream 输入流</span></span><br><span class="line">            <span class="keyword">final</span> ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 依次读取 ObjectInputStream 输入流中的四个对象</span></span><br><span class="line">            Teacher t1 = (Teacher)ois.readObject();</span><br><span class="line">            Teacher t2 = (Teacher)ois.readObject();</span><br><span class="line">            Person p = (Person)ois.readObject();</span><br><span class="line">            Teacher t3 = (Teacher)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出 true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t1 的 student 引用是否和 p 相同:&quot;</span> +</span><br><span class="line">                    (t1.getStudent() == p));</span><br><span class="line">            <span class="comment">// 输出 true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2 的 student 引用是否和 p 相同:&quot;</span> +</span><br><span class="line">                    (t2.getStudent() == p));</span><br><span class="line">            <span class="comment">// 输出 true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2 和 t3 是否是同一个对象:&quot;</span> + (t2 == t3));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Java 对象序列化机制，同一个对象只会序列化一次，但是当序列化可变对象时，这就有问题了。@#4所以怎么解决呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeMutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建一个 ObjectOutputStream 输出流</span></span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;mutable.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 创建一个 ObjectInputStream 输入流</span></span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;mutable.txt&quot;</span>))</span><br><span class="line">            )</span><br><span class="line">        &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 系统将 per 对象转换成字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            <span class="comment">// 改变 per 对象的 name 实例变量值</span></span><br><span class="line">            per.setName(<span class="string">&quot;周八戒&quot;</span>);</span><br><span class="line">            <span class="comment">// 系统只是输出序列化编号,所以改变后的 name 不会被序列化</span></span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            Person p1 = (Person)ois.readObject();</span><br><span class="line">            Person p2 = (Person)ois.readObject();</span><br><span class="line">            <span class="comment">// true</span></span><br><span class="line">            System.out.println(p1 == p2);</span><br><span class="line">            <span class="comment">// 孙悟空</span></span><br><span class="line">            System.out.println(p2.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-8-4-Java-9-增加的过滤功能"><a href="#15-8-4-Java-9-增加的过滤功能" class="headerlink" title="15.8.4 Java 9 增加的过滤功能"></a>15.8.4 Java 9 增加的过滤功能</h3><p>ObjectInputStream 增加了 setObjectInputFilter()、getObjectInputFilter() 用于为对象输入流设置过滤器。当程序通过 ObjectInputStream 反序列化对象时，过滤器的 checkInput() 会被自动触发，用于检查序列化数据是否有效。</p>
<ul>
<li>Status.REJECT：拒绝恢复</li>
<li>Status.ALLOWED：允许恢复</li>
<li>Status.UNDECIDED：未决定状态，程序继续执行检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>))) &#123;</span><br><span class="line">            ois.setObjectInputFilter((info) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;===执行数据过滤===&quot;</span>);</span><br><span class="line">                ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">                <span class="keyword">if</span> (serialFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;serialFilter is not null&quot;</span>);</span><br><span class="line">                    <span class="comment">// 首先使用 ObjectInputFilter 执行默认的检查</span></span><br><span class="line">                    ObjectInputFilter.Status status = serialFilter.checkInput(info);</span><br><span class="line">                    <span class="comment">// 如果默认检查的结果不是 Status.UNDECIDED</span></span><br><span class="line">                    <span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;serialFilter result is not equals to UNDECIDED.&quot;</span>);</span><br><span class="line">                        <span class="comment">// 直接返回检查结果</span></span><br><span class="line">                        <span class="keyword">return</span> status;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果要恢复的对象不是一个</span></span><br><span class="line">                System.out.println(info.references());</span><br><span class="line">                <span class="keyword">if</span> (info.references() != <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The object is not the only one.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 不允许恢复对象</span></span><br><span class="line">                    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (info.serialClass() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    info.serialClass() != Person.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The object is not the Person class.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 不允许恢复对象</span></span><br><span class="line">                    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 从输入流中读取一个 Java 对象, 并强制转换为 Person 类</span></span><br><span class="line">            Person p = (Person)ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;名字为:&quot;</span> + p.getName() +</span><br><span class="line">                <span class="string">&quot;\n年龄为:&quot;</span> + p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没太说清楚啥意思。</p>
<h3 id="15-8-5-自定义序列化"><a href="#15-8-5-自定义序列化" class="headerlink" title="15.8.5 自定义序列化"></a>15.8.5 自定义序列化</h3><p>transient 关键字修饰实例变量，表明序列化时忽略该字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileInputStream(<span class="string">&quot;transient.txt&quot;</span>))) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;Alvin&quot;</span>, <span class="number">26</span>);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            Person p = (Person)ois.readObject();</span><br><span class="line">            System.out.println(p.getName());</span><br><span class="line">            System.out.println(p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有看到预期的效果，难道 Java 12 不支持了？</p>
<p>有时候不需要 transient 这么绝对的不序列化，那么我么可以自定序列化：</p>
<ul>
<li>private void writeObject(ObjectOutputStream out)  throw IOException</li>
<li>private void readObject(ObjectInputStream in)</li>
<li>private void readObjectNoData()</li>
<li>private Object writeReplace()</li>
<li>Object readResolve()：紧接着 readObject() 之后调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke wirteObject&quot;</span>);</span><br><span class="line">        <span class="comment">// 将 name 实例变量值反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke readObject&quot;</span>);</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋给 name 实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;custom.txt&quot;</span>));</span><br><span class="line">             ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                     <span class="keyword">new</span> FileInputStream(<span class="string">&quot;custom.txt&quot;</span>))) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;Alvin&quot;</span>, <span class="number">26</span>);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            Person p = (Person)ois.readObject();</span><br><span class="line">            System.out.println(p.getName());</span><br><span class="line">            System.out.println(p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的单例、枚举类在实现序列化时，都应该提供 readResolve() 方法，这样才可以保证反序列化的对象依然正常。</p>
<h3 id="15-8-6-另一种自定义序列化机制"><a href="#15-8-6-另一种自定义序列化机制" class="headerlink" title="15.8.6 另一种自定义序列化机制"></a>15.8.6 另一种自定义序列化机制</h3><p>通过实现 Externalizable 接口，完全控制存储和恢复对象数据。</p>
<ul>
<li>void readExternal(ObjectInput in)</li>
<li>void writeExternal(ObjectOutput out)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意必须提供无参构造器,否则反序列化时会失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 将 name 反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋值给 name 实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>实现 Serializable 接口</th>
<th>实现 Externalizable 接口</th>
</tr>
</thead>
<tbody><tr>
<td>系统自动存储必要信息</td>
<td>程序员决定存储哪些信息</td>
</tr>
<tr>
<td>Java 内建支持，实现接口即可</td>
<td>需要实现序列化方法</td>
</tr>
<tr>
<td>性能略差</td>
<td>性能略好</td>
</tr>
</tbody></table>
<ul>
<li>对象的类名、实例变量都会被序列化；方法、类变量、transient 实例变量都不会被序列化</li>
<li>实现 Serializable 为了让某个实例变量不序列化，应该用 transient 而不是 static</li>
<li>保证序列化对象的实例变量类型也是可序列化的，否则需要使用 transient 来修饰，要不然该类是不可序列化的。</li>
<li>反序列化对象时必须有该对象的 class 文件</li>
<li>当通过文件、网络来读取序列化后的对象时，必须按实际写入的顺序读取</li>
</ul>
<h3 id="15-8-7-版本"><a href="#15-8-7-版本" class="headerlink" title="15.8.7 版本"></a>15.8.7 版本</h3><p>反序列化 Java 对象时必须提供该对象的 class 文件，但是随着项目的升级，系统的 class 文件也会升级，Java 如何保证两个 class 文件的兼容性？</p>
<p>Java 序列化机制允许为序列化类提供一个 priate static final 的serialVersionUID 值，用于标识类的序列化版本，也就是说如果一个类升级后，只要它的 serialVersionUID 没变，序列化机制也会把他们当成同一个序列化版本。</p>
<p>通常建议每个序列化类都显示指定该值，如果不指定将由 JVM 根据类的相关信息计算，而修改后的类计算结果往往与修改前的不同，从而造成对象的反序列化因为类版本不兼容而失败。</p>
<p>JDK bin 目录下的 serialver.exe 工具可以获取类的 serialVersionUID 值。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialver Person</span><br></pre></td></tr></table></figure>

<p>如果类的修改确实会导致类实例的反序列化失败，则应该修改 serialVersionUID 的值。</p>
<ul>
<li>如果仅仅修改方法，反序列化不受影响，无需修改 serialVersionUID</li>
<li>如果仅仅修改静态变量或瞬态变量，同上</li>
<li>如果修改了非<strong>瞬态</strong>的实例变量<ul>
<li>类型修改：反序列失败，应该修改 serialVersionUID</li>
<li>删除变量：序列化版本可以兼容，可以不更新 serialVersionUID</li>
<li>新增变量：序列化版本可以兼容，可以不更新 serialVersionUID</li>
</ul>
</li>
</ul>
<h2 id="15-9-NIO"><a href="#15-9-NIO" class="headerlink" title="15.9 NIO"></a>15.9 NIO</h2><h3 id="15-9-1-Java-新-IO-概述"><a href="#15-9-1-Java-新-IO-概述" class="headerlink" title="15.9.1 Java 新 IO 概述"></a>15.9.1 Java 新 IO 概述</h3><p>新 IO 采用内存映射文件的方式来处理输入/输出，新 IO 将文件或文件的一段区域映射到内存中,这样就可以像访问内存一样来访问文件了(模拟了操作系统上虚拟内存的概念)，这样速度更快。</p>
<p>相关包：</p>
<ul>
<li>java.nio 包：各种与 Buffer 相关的类</li>
<li>java.nio.channels 包：Channel 和 Selector 相关的类</li>
<li>java.nio.charset 包：字符集相关的类</li>
<li>java.nio.channels.spi 包：Channel 相关的服务提供者</li>
<li>java.nio.charset.spi 包：字符集相关的服务提供者编程接口</li>
</ul>
<p>Channel（通道）：对传统的输入/输出系统的模拟。提供 map() 方法，直接将一块数据映射到内存中。</p>
<p>Buffer（容器）：类似于之前的竹筒</p>
<h3 id="15-9-2-使用-Buffer"><a href="#15-9-2-使用-Buffer" class="headerlink" title="15.9.2 使用 Buffer"></a>15.9.2 使用 Buffer</h3><h4 id="Buffer-原理"><a href="#Buffer-原理" class="headerlink" title="Buffer 原理"></a>Buffer 原理</h4><p>没有构造器。<code>static XxxBuffer allocate(int capacity)</code></p>
<p>Buffer 中三个重要的概念：</p>
<ul>
<li>容量（capacity）</li>
<li>界限（limit）：limit 后的数据既不可被读也不可被写</li>
<li>位置（position）</li>
<li>标记（mark）：允许直接将 position 定位到 mark 处</li>
</ul>
<p><img src="../../images/java/c15/buffer%E5%8E%9F%E7%90%86.png"></p>
<h4 id="Buffer-常用方法"><a href="#Buffer-常用方法" class="headerlink" title="Buffer 常用方法"></a>Buffer 常用方法</h4><ul>
<li>filp()：为读取 Buffer 中数据作准备 limit=position position=0</li>
<li>clear(): 为将数据写入 Buffer 做准备 limit=capacity position=0</li>
<li>int capacity()</li>
<li>boolean hasRemaining()</li>
<li>int limit()</li>
<li>Buffer limit(int newLimit)</li>
<li>Buffer mark()</li>
<li>int position()</li>
<li>Buffer position(int newPosition)</li>
<li>int remaining()</li>
<li>Buffer reset()</li>
<li>Buffer rewind()</li>
<li>put()</li>
<li>get()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 Buffer</span></span><br><span class="line">		CharBuffer buff = CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">		<span class="comment">// 8 8 0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;capacity：&quot;</span> + buff.capacity() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;limit：&quot;</span> + buff.limit() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;position：&quot;</span> + buff.position());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 放入元素</span></span><br><span class="line">		buff.put(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		buff.put(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">		buff.put(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;放入三个元素后：&quot;</span>);</span><br><span class="line">		<span class="comment">// 8 8 3</span></span><br><span class="line">		System.out.println(<span class="string">&quot;capacity：&quot;</span> + buff.capacity() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;limit：&quot;</span> + buff.limit() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;position：&quot;</span> + buff.position());</span><br><span class="line">		</span><br><span class="line">		buff.flip();</span><br><span class="line">		System.out.println(<span class="string">&quot;flip后：&quot;</span>);</span><br><span class="line">		<span class="comment">// 8 3 0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;capacity：&quot;</span> + buff.capacity() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;limit：&quot;</span> + buff.limit() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;position：&quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;第一个元素：&quot;</span> + buff.get());</span><br><span class="line">		System.out.println(<span class="string">&quot;取出一个元素后：&quot;</span>);</span><br><span class="line">		<span class="comment">// 8 3 1</span></span><br><span class="line">		System.out.println(<span class="string">&quot;capacity：&quot;</span> + buff.capacity() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;limit：&quot;</span> + buff.limit() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;position：&quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">		buff.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;clear后：&quot;</span>);</span><br><span class="line">		<span class="comment">// 8 8 0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;capacity：&quot;</span> + buff.capacity() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;limit：&quot;</span> + buff.limit() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;position：&quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;执行clear()后，缓冲区元素并没有被清除：例如还可以取到第三个元素：&quot;</span> + buff.get(<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;执行绝对取数后：position 不变&quot;</span>);</span><br><span class="line">		<span class="comment">// 8 8 0</span></span><br><span class="line">		System.out.println(<span class="string">&quot;capacity：&quot;</span> + buff.capacity() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;limit：&quot;</span> + buff.limit() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;position：&quot;</span> + buff.position());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ByteBuffer 提供了一个 allocateDirect() 方法来创建直接 Buffer。直接 Buffer 创建成本更高，但直接 Buffer 的读取效率更高。所以直接 Buffer 只适用于<strong>长生存期</strong>的 Buffer。</p>
<h3 id="15-9-3-使用-Channel"><a href="#15-9-3-使用-Channel" class="headerlink" title="15.9.3 使用 Channel"></a>15.9.3 使用 Channel</h3><ul>
<li>可直接将指定文件的部分或全部直接映射成 Buffer</li>
<li>程序不能直接访问 Channel 中的数据，包括读取、写入都不行 Channel 只能与 Buffer 进行交互。</li>
</ul>
<p>Channel 接口实现类：</p>
<ul>
<li>DatagramChannel：支持 UDP 通信的 Channel</li>
<li>FileChannel</li>
<li>Pipe.SinkChannel：支持线程间通信的管道</li>
<li>Pipe.SourceChannel：同上</li>
<li>SelectableChannel：</li>
<li>ServerSocketChannel、SocketChannel：TCP 通信</li>
</ul>
<p>通过传统的节点 InputStream、OutputStream 的 getChannel() 方法来返回对应的 Channel</p>
<ul>
<li>MappedByteBuffer map(MapMode mode, long pos, long size)：将 Channel 部分或全部数据映射成 ByteBuffer</li>
<li>read()：从 Buffer 中读取数据</li>
<li>write()：从 Buffer 中写入数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		File f = <span class="keyword">new</span> File(<span class="string">&quot;./src/unit15_javaio/c9/FileChannelTest.java&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">			<span class="comment">// 获取 Channel</span></span><br><span class="line">			FileChannel inChannel = fis.getChannel();</span><br><span class="line">			FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;1.txt&quot;</span>).getChannel())</span><br><span class="line">		&#123;</span><br><span class="line">			MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length());</span><br><span class="line">			outChannel.write(buffer);</span><br><span class="line">			buffer.clear();</span><br><span class="line">			<span class="comment">// 创建解码器对象</span></span><br><span class="line">			Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">			CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">			<span class="comment">// 使用解码器将 ByteBuffer 转换为 CharBuffer</span></span><br><span class="line">			CharBuffer charBuffer = decoder.decode(buffer);</span><br><span class="line">			System.out.println(charBuffer.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomFileChannelTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File f = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="comment">// a.txt 的 RandomAccessFile，可读可写</span></span><br><span class="line">			RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">			<span class="comment">// 获取 channel</span></span><br><span class="line">			FileChannel randomChannel = raf.getChannel())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 映射只读的 buffer</span></span><br><span class="line">			ByteBuffer buffer = randomChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length());</span><br><span class="line">			<span class="comment">// 设置 pos</span></span><br><span class="line">			randomChannel.position(f.length());</span><br><span class="line">			<span class="comment">// buffer 中的数据写入 channel</span></span><br><span class="line">			randomChannel.write(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果读者习惯了传统 IO 的” 用竹筒多次重复取水” 的过程，或者担心 Channel 对应的文件过大，使用mapO方法一次将所有的文件内容映射到内存中引起性能下降， 也可以使用 Channel 和 Buffer 传统的”用竹筒多次重复取水”的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建文件输入流</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\01_code\\01_javasebasic\\waojava\\src\\unit15_javaio\\c9\\ReadFile.java&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建一个 FileChannel</span></span><br><span class="line">            FileChannel fcin = fis.getChannel())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 定义一个 ByteBuffer 对象，用于重复取水</span></span><br><span class="line">            ByteBuffer bbuff = ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">            <span class="comment">// 将 FileChannel 中的数据放入 ByteBuffer 中</span></span><br><span class="line">            <span class="keyword">while</span> (fcin.read(bbuff) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 锁定 Buffer 的空白区</span></span><br><span class="line">                bbuff.flip();</span><br><span class="line">                <span class="comment">// 创建 Charset 对象</span></span><br><span class="line">                <span class="keyword">final</span> Charset gbk = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建解码器</span></span><br><span class="line">                <span class="keyword">final</span> CharsetDecoder decoder = gbk.newDecoder();</span><br><span class="line">                <span class="comment">// 转码</span></span><br><span class="line">                <span class="keyword">final</span> CharBuffer cbuff = decoder.decode(bbuff);</span><br><span class="line">                System.out.println(cbuff);</span><br><span class="line">                <span class="comment">// Buffer 初始化，为下一次读取数据做准备</span></span><br><span class="line">                bbuff.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-9-4-字符集和-Charset"><a href="#15-9-4-字符集和-Charset" class="headerlink" title="15.9.4 字符集和 Charset"></a>15.9.4 字符集和 Charset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharsetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取Java 支持的全部字符集</span></span><br><span class="line">		SortedMap&lt;String,Charset&gt; map = Charset.availableCharsets();</span><br><span class="line">		<span class="keyword">for</span> (String alias : map.keySet())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(alias + <span class="string">&quot;------&gt;&quot;</span> + map.get(alias));;</span><br><span class="line">		&#125;</span><br><span class="line">		Properties p = System.getProperties();</span><br><span class="line">		System.out.println(p.getProperty(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用字符集：</p>
<ul>
<li>GBK：简体中文</li>
<li>BIG5：繁体中文</li>
<li>ISO-8859-1</li>
<li>UTF-8：8位 UCS 转换格式</li>
<li>UTF-16BE：16 位 UCS 转换格式， Big-endian (最低地址存放高位字节) 字节顺序。</li>
<li>UTF-16LE：16 位 UCS 转换格式， Little-endian (最高地址存放低位字节)字节顺序。</li>
<li>UTF16：16 位 UCS 转换格式， 字节顺序由可选的字节顺序标记来标识。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharsetTransform</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Charset cn = Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> CharsetEncoder cnEncoder = cn.newEncoder();</span><br><span class="line">        <span class="keyword">final</span> CharsetDecoder cnDecoder = cn.newDecoder();</span><br><span class="line">        <span class="comment">// 创建一个 CharBuffer 对象</span></span><br><span class="line">        <span class="keyword">final</span> CharBuffer cbuff = CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        cbuff.put(<span class="string">&#x27;孙&#x27;</span>);</span><br><span class="line">        cbuff.put(<span class="string">&#x27;悟&#x27;</span>);</span><br><span class="line">        cbuff.put(<span class="string">&#x27;空&#x27;</span>);</span><br><span class="line">        cbuff.flip();</span><br><span class="line">        <span class="comment">// 将 CharBuffer 中的字符序列转换成字节序列</span></span><br><span class="line">        <span class="keyword">final</span> ByteBuffer bbuff = cnEncoder.encode(cbuff);</span><br><span class="line">        <span class="comment">// 循环访问 ByteBuffer 中的每个字节</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bbuff.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(bbuff.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 ByteBuffer 的数据解码成字符序列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + cnDecoder.decode(bbuff));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-9-5-文件锁"><a href="#15-9-5-文件锁" class="headerlink" title="15.9.5 文件锁"></a>15.9.5 文件锁</h3><p>用文件锁可以有效地阻止多个进程并发修改同一个文件，所以现在的大部分操作系统都提供了文件锁的功能。</p>
<p>JDK1.4 的 NIO 开始，Java 开始提供文件锁的支持。</p>
<p>提供 FileLock 来支持文件锁功能，在 Fi leChannel 中提供的lock()/tryLock() 方法可以获得文件锁FileLock 对象，从而锁定文件。lock 阻塞，tryLock 不阻塞。</p>
<ul>
<li>lock(long position, long size, boolean shared)</li>
</ul>
<p>shared 为 true：共享锁，允许多个进程读取该文件，但是阻止其他进程获得对该文件的排他锁。</p>
<p>shared 为 false：锁住该文件的读写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLockTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">			FileChannel channel = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>).getChannel())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 使用非阻塞的方式对指定文件加锁</span></span><br><span class="line">			FileLock lock = channel.tryLock();</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			lock.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件锁虽然可以用于控制并发访问，但对于高并发访问的情形，还是推荐使用数据库来保存程序信息， 而不是使用文件。</p>
<p>文件锁对象：</p>
<ul>
<li>在某些平台上， 文件锁仅仅是建议性的， 并不是强制性的。这意味着即使一个程序不能获得文件锁，它也可以对该文件进行读写。</li>
<li>在某些平台上，不能同步地锁定一个文件并把它映射到内存中。</li>
<li>文件锁是由 Java 虚拟机所持有的，如果两个Java 程序使用同一个Java 虚拟机运行，则它们不能对同一个文件进行加锁。</li>
<li>在某些平台上关闭 FileChannel 时， 会释放Java 虚拟机在该文件上的所有锁，因此应该避免对同一个被锁定的文件打开多个 FileChannel 。</li>
</ul>
<h2 id="15-10-Java-7-的-NIO-2"><a href="#15-10-Java-7-的-NIO-2" class="headerlink" title="15.10 Java 7 的 NIO.2"></a>15.10 Java 7 的 NIO.2</h2><p>主要有两个改进：</p>
<ul>
<li>提供了全面的文件 IO 和文件系统访问支持。</li>
<li>基于异步 Channel 的 IO</li>
</ul>
<h3 id="15-10-1-Path、Paths-和-Files-核心-API"><a href="#15-10-1-Path、Paths-和-Files-核心-API" class="headerlink" title="15.10.1 Path、Paths 和 Files 核心 API"></a>15.10.1 Path、Paths 和 Files 核心 API</h3><p>File 不能利用特定文件系统的特性，File 提供的方法的性能也不高。</p>
<p>所以 NIO.2 引入了 Path 接口，Path 接口代表一个平台无关的平台路径。</p>
<p>除此之外还提供了 Files、Paths 两个工具类。</p>
<h4 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 以当前路径来创建 Path 对象</span></span><br><span class="line">		Path path = Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;path 里包含的路径数量：&quot;</span> + path.getNameCount());</span><br><span class="line">		System.out.println(<span class="string">&quot;path 的根路径：&quot;</span> + path.getRoot());</span><br><span class="line">		Path absolutePath = path.toAbsolutePath();</span><br><span class="line">		<span class="comment">// D:\01_code\01_javasebasic\waojava\.</span></span><br><span class="line">		System.out.println(absolutePath);</span><br><span class="line">		System.out.println(<span class="string">&quot;absolutePath 的根路径：&quot;</span> + absolutePath.getRoot());</span><br><span class="line">		System.out.println(<span class="string">&quot;absolutePath 里包含的路径数量：&quot;</span> + absolutePath.getNameCount());</span><br><span class="line">		System.out.println(absolutePath.getName(<span class="number">2</span>));</span><br><span class="line">		Path path2 = Paths.get(<span class="string">&quot;g:&quot;</span>, <span class="string">&quot;publish&quot;</span>, <span class="string">&quot;codes&quot;</span>);</span><br><span class="line">		System.out.println(path2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">		Path p = Paths.get(<span class="string">&quot;./src/unit15_javaio/c10/FilesTest.java&quot;</span>);</span><br><span class="line">		Files.copy(p, <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		System.out.println(Files.isHidden(p));</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; lines = Files.readAllLines(p, StandardCharsets.UTF_8);</span><br><span class="line">		System.out.println(lines);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断指定文件的大小</span></span><br><span class="line">		System.out.println(Files.size(p));</span><br><span class="line">		List&lt;String&gt; poem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		poem.add(<span class="string">&quot;莫愁前路无知己&quot;</span>);</span><br><span class="line">		poem.add(<span class="string">&quot;天下谁人不识君&quot;</span>);</span><br><span class="line">		Files.write(Paths.get(<span class="string">&quot;poem.txt&quot;</span>), poem, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前目录下的所有文件和子目录</span></span><br><span class="line">		Files.list(Paths.get(<span class="string">&quot;.&quot;</span>)).forEach(System.out::println);</span><br><span class="line">		Files.lines(p, StandardCharsets.UTF_8).forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">		FileStore cStore = Files.getFileStore(Paths.get(<span class="string">&quot;C:&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;c:共有空间：&quot;</span> + cStore.getTotalSpace());</span><br><span class="line">		System.out.println(<span class="string">&quot;c:可用空间：&quot;</span> + cStore.getUsableSpace());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-10-2-使用-FileVisitor-遍历文件和目录"><a href="#15-10-2-使用-FileVisitor-遍历文件和目录" class="headerlink" title="15.10.2 使用 FileVisitor 遍历文件和目录"></a>15.10.2 使用 FileVisitor 遍历文件和目录</h3><ul>
<li>walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor)：遍历 start 路径下的所有文件和子目录。</li>
<li>walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth, FileVisitor&lt;? super Path&gt; visitor)：maxDepth 表示深度</li>
</ul>
<p>FileVisitor：</p>
<ul>
<li>FileVisitResult postVisitDirectory(T dir, IOException exc)：访问子目录后触发该方法</li>
<li>FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)：访问子目录之前触发该方法</li>
<li>FileVisitResult visitFile(T file, BasicFileAttributes attrs)：访问文件时</li>
<li>FileVisitResult visitFileFailed(T file, IOException exc)：访问文件失败时</li>
</ul>
<p>FileVisitResult：</p>
<ul>
<li>CONTINUE：继续访问</li>
<li>SKIP_SIBLINGS：继续访问，但不访问该文件或目录的兄弟文件或目录</li>
<li>SKIP_SUBTREE：继续访问，不访问子目录树</li>
<li>TERMINATE：终止访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileVisitorTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Files.walkFileTree(Paths.get(<span class="string">&quot;D:\\01_code\\01_javasebasic\\waojava&quot;</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;正在访问&quot;</span> + file + <span class="string">&quot;文件&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (file.endsWith(<span class="string">&quot;FileVisitorTest.java&quot;</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;已经找到目标文件&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;正在访问：&quot;</span> + dir + <span class="string">&quot;目录&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-10-3-使用-WatchService-监控文件变化"><a href="#15-10-3-使用-WatchService-监控文件变化" class="headerlink" title="15.10.3 使用 WatchService 监控文件变化"></a>15.10.3 使用 WatchService 监控文件变化</h3><p>注册监听：</p>
<ul>
<li>Path.register(WathService watcher, WatchEvent.Kind&lt;?&gt;… events)</li>
</ul>
<p>WatchService：</p>
<ul>
<li>WatchKey poll()：获取下一个 WatchKey，如果没有 WatchKey 发生立即返回 null</li>
<li>WatchKey poll(long timeout, TimeUnit unit)</li>
<li>WatchKey take()：阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		WatchService watchService = FileSystems.getDefault().newWatchService();</span><br><span class="line">		<span class="comment">// 为 C: 盘根路径注册监听</span></span><br><span class="line">		Paths.get(<span class="string">&quot;D:/&quot;</span>).register(watchService, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE,StandardWatchEventKinds.ENTRY_MODIFY);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;start======&gt;&quot;</span>);</span><br><span class="line">			<span class="comment">// 获取下一个文件变化事件</span></span><br><span class="line">			WatchKey key = watchService.take();</span><br><span class="line">			<span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents())</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(event.context() + <span class="string">&quot; 文件发生了 &quot;</span> + event.kind() + <span class="string">&quot;事件&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 重设 WatchKey</span></span><br><span class="line">			<span class="keyword">boolean</span> valid = key.reset();</span><br><span class="line">			<span class="keyword">if</span> (!valid)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;end======&gt;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-10-4-访问文件属性"><a href="#15-10-4-访问文件属性" class="headerlink" title="15.10.4 访问文件属性"></a>15.10.4 访问文件属性</h3><p>Java 7 的 NIO.2 在 java.nio.file.attribute 包下提供了大量的工具类：</p>
<ul>
<li>XxxAttributeView：某种文件属性的视图</li>
<li>XxxAttributes：某种文件属性的集合</li>
</ul>
<ol>
<li>AclFileAttributeView: 通过 AclFileAttributeView，开发者可以为特定文件设置 ACL (Access ControlList ) 及文件所有者属性。它的 getAcl() 方法返回 List<AclEntry> 对象，该返回值代表了该文件的权限集。通过 setAcl(List) 方法可以修改该文件的 ACL 。</li>
<li>BasicFileAttributeView: 它可以获取或修改文件的基本属性，包括文件的最后修改时间、最后访问时间、创建时间、大小、是否为目录、是否为符号链接等。它的 readAttributes() 方法返回一个BasicFileAttributes 对象，对文件夹基本属性的修改是通过 BasicFileAttributes 对象完成的。</li>
<li>DosFileAttributeView: 它主要用于获取或修改文件 DOS 相关属性，比如文件是否只读、是否隐藏、是否为系统文件、是否是存档文件等。它的 readAttributes() 方法返回一个 DosFileAttributes 对象， 对这些属性的修改其实是由 DosFileAttributes 对象来完成的。</li>
<li>FileOwnerAttributeView: 它主要用于获取或修改文件的所有者。它的 getOwner()方法返回一个UserPrincipal 对象来代表文件所有者；也可调用 setOwner(UserPrincipalowner) 方法来改变文件的所有者。</li>
<li>PosixFileAttributeView: 它主要用于获取或修改 POSIX(Portable Operating System Interface of INIX)属性，它的 readAttributes() 方法返回一个 PosixFileArtributes 对象， 该对象可用于获取或修改文件的所有者、组所有者、访问权限信息(就是UNIX 的chmod 命令负责干的事情)。这个View 只在UNIX 、Linux等系统上有用。</li>
<li>UserDefinedFileAttributeView: 它可以让开发者为文件设置一些自定义属性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeViewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取将要操作的文件</span></span><br><span class="line">        <span class="keyword">final</span> Path testPath = Paths.get(<span class="string">&quot;./src/unit15_javaio/c10/AttributeViewTest.java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问基本属性的 view</span></span><br><span class="line">        <span class="keyword">final</span> BasicFileAttributeView basicView = Files.getFileAttributeView(testPath, BasicFileAttributeView.class);</span><br><span class="line">        <span class="comment">// 获取访问基本属性的 attrs</span></span><br><span class="line">        <span class="keyword">final</span> BasicFileAttributes basicAttribs = basicView.readAttributes();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建时间：&quot;</span> + <span class="keyword">new</span> Date(basicAttribs.creationTime().toMillis()));</span><br><span class="line">        System.out.println(<span class="string">&quot;最后访问时间：&quot;</span> + <span class="keyword">new</span> Date(basicAttribs.lastAccessTime().toMillis()));</span><br><span class="line">        System.out.println(<span class="string">&quot;文件大小：&quot;</span> + basicAttribs.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问文件属性主信息的 view</span></span><br><span class="line">        <span class="keyword">final</span> FileOwnerAttributeView ownerView = Files.getFileAttributeView(testPath, FileOwnerAttributeView.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件所有者：&quot;</span> + ownerView.getOwner());</span><br><span class="line">        <span class="comment">// 获取系统中 guest 对应的用户</span></span><br><span class="line">        <span class="keyword">final</span> UserPrincipal user = FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改用户</span></span><br><span class="line">        <span class="comment">// ownerView.setOwner(user);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问自定义属性的 view</span></span><br><span class="line">        <span class="keyword">final</span> UserDefinedFileAttributeView userView = Files.getFileAttributeView(testPath, UserDefinedFileAttributeView.class);</span><br><span class="line">        <span class="comment">// 添加一个自定义属性</span></span><br><span class="line">        userView.write(<span class="string">&quot;发行者&quot;</span>, Charset.defaultCharset().encode(<span class="string">&quot;alvin&quot;</span>));</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; attrNames = userView.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : attrNames) &#123;</span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(userView.size(name));</span><br><span class="line">            userView.read(name, buf);</span><br><span class="line">            buf.flip();</span><br><span class="line">            String value = Charset.defaultCharset().decode(buf).toString();</span><br><span class="line">            System.out.println(name + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问 DOS 属性的 view</span></span><br><span class="line">        <span class="keyword">final</span> DosFileAttributeView dosView = Files.getFileAttributeView(testPath, DosFileAttributeView.class);</span><br><span class="line">        <span class="comment">// 将文件设置隐藏、只读</span></span><br><span class="line">        dosView.setHidden(<span class="keyword">true</span>);</span><br><span class="line">        dosView.setReadOnly(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/"><i class="fa fa-tag"></i>疯狂 Java 讲义</a></div><div class="post-nav"><a class="pre" href="/2020-01-16-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C16.html">第 16 章 多线程</a><a class="next" href="/2020-01-14-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C14.html">第 14 章 注解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Srping-Boot/">Srping Boot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF/">加解密技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%89%E4%BB%96/">吉他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E6%83%85/">心情</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/">无关技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/">疯狂 Java 讲义</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 15px;">心情</a> <a href="/tags/PGP/" style="font-size: 15px;">PGP</a> <a href="/tags/SFTP/" style="font-size: 15px;">SFTP</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Samba/" style="font-size: 15px;">Samba</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/Srping-Boot/" style="font-size: 15px;">Srping Boot</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/%E5%90%89%E4%BB%96/" style="font-size: 15px;">吉他</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/%E6%97%A0%E5%85%B3%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">无关技术</a> <a href="/tags/%E7%96%AF%E7%8B%82-Java-%E8%AE%B2%E4%B9%89/" style="font-size: 15px;">疯狂 Java 讲义</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/Observer/" style="font-size: 15px;">Observer</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Proxy/" style="font-size: 15px;">Proxy</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/LVS/" style="font-size: 15px;">LVS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/Eureka/" style="font-size: 15px;">Eureka</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.jamespan.me/" title="小鶸の道场" target="_blank">小鶸の道场</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a><ul></ul><a href="http://www.ruanyifeng.com/home.html" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://www.cnblogs.com/jingmoxukong/" title="静默虚空" target="_blank">静默虚空</a><ul></ul><a href="https://blog.hushhw.cn/" title="hushhw" target="_blank">hushhw</a><ul></ul><a href="https://hasaik.com/" title="hasaik" target="_blank">hasaik</a><ul></ul><a href="https://www.imalan.cn/" title="三无计划" target="_blank">三无计划</a><ul></ul><a href="https://i-meto.com/" title="meto" target="_blank">meto</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">悟空.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>