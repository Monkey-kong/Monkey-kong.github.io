<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>第 6 章 面向对象（下） | 悟空</title>
  <meta name="keywords" content=" Java讲义 ">
  <meta name="description" content="第 6 章 面向对象（下） | 悟空">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="悟空">
<meta property="og:url" content="http://yoursite.com/404.html">
<meta property="og:site_name" content="悟空">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-11-16T00:43:02.436Z">
<meta property="article:modified_time" content="2019-11-08T14:02:36.972Z">
<meta property="article:author" content="悟空">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

// 自定义内容
<script src="assets/js/aplayer.min.js"></script>
<script src="assets/js/meting.min.js"></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="悟空" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>悟空</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/Monkey-kong" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/wukong-16" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
        <a title="email" href="mailto:lixianfu1@outlook.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1109075867&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(121)</small></div></li>
    
        
            
            <li><div data-rel="Java基础">Java基础<small>(17)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="JVM">JVM<small>(11)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="多线程">多线程<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="OS">OS<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="IO">IO<small>(9)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="高并发">高并发<small>(9)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="MySQL">MySQL<small>(14)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="分布式">分布式<small>(20)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计模式">设计模式<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="其他">其他<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Spring基础">Spring基础<small>(5)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="121">
<input type="hidden" id="yelog_site_word_count" value="342.6k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://www.chenuon.cn/">程忧点滴</a></li>
            
            <li><a target="_blank" href="https://blog.jamespan.me/">小鶸の道场</a></li>
            
            <li><a target="_blank" href="http://www.ruanyifeng.com/home.html">阮一峰</a></li>
            
            <li><a target="_blank" href="https://www.haomwei.com/">屠城</a></li>
            
            <li><a target="_blank" href="https://hasaik.com/">hasaik</a></li>
            
            <li><a target="_blank" href="https://www.imalan.cn/">三无计划</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式会话</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>架构</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>内网穿透</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>其他</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>网络</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>远程连接</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Blog</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Eureka</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>flex</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>frp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>https</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java讲义</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LVS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Nginx</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NIO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Observer</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>OS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Proxy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RSC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sia</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Singleton</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring Cloud</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>TypeScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>uni-app</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>webpack</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ZooKeeper</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 分布式 "
           href="/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(6).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(六)">高并发架构(六)</span>
            <span class="post-date" title="2021-01-18 20:43:12">2021/01/18</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2021-01-18-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(7).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(七)">高并发架构(七)</span>
            <span class="post-date" title="2021-01-18 20:43:12">2021/01/18</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2021-01-17-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(4).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(四)">高并发架构(四)</span>
            <span class="post-date" title="2021-01-17 20:43:12">2021/01/17</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2021-01-17-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(5).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(五)">高并发架构(五)</span>
            <span class="post-date" title="2021-01-17 20:43:12">2021/01/17</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2021-01-16-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(3).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(三)">高并发架构(三)</span>
            <span class="post-date" title="2021-01-16 20:43:12">2021/01/16</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2021-01-08-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(2).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(二)">高并发架构(二)</span>
            <span class="post-date" title="2021-01-08 20:43:12">2021/01/08</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2021-01-07-08%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84(1).html"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="高并发架构(一)">高并发架构(一)</span>
            <span class="post-date" title="2021-01-07 20:43:12">2021/01/07</span>
        </a>
        
        <a  class="全部文章 Spring基础 "
           href="/2020-12-25-13Spring%E5%9F%BA%E7%A1%80/springmvc.html"
           data-tag="sia"
           data-author="" >
            <span class="post-title" title="第 5-9 章 Web 中的 Spring">第 5-9 章 Web 中的 Spring</span>
            <span class="post-date" title="2020-12-25 22:13:12">2020/12/25</span>
        </a>
        
        <a  class="全部文章 Spring基础 "
           href="/2020-12-24-13Spring%E5%9F%BA%E7%A1%80/20191026sia4.html"
           data-tag="sia"
           data-author="" >
            <span class="post-title" title="第 4 章 面向切面的 Spring">第 4 章 面向切面的 Spring</span>
            <span class="post-date" title="2020-12-24 22:13:12">2020/12/24</span>
        </a>
        
        <a  class="全部文章 Spring基础 "
           href="/2020-12-23-13Spring%E5%9F%BA%E7%A1%80/20191025sia3.html"
           data-tag="sia"
           data-author="" >
            <span class="post-title" title="第 3 章 高级装配">第 3 章 高级装配</span>
            <span class="post-date" title="2020-12-23 22:13:12">2020/12/23</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-12-22-12%E5%85%B6%E4%BB%96/Linux%E5%A4%87%E5%BF%98.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux 常用命令备忘">Linux 常用命令备忘</span>
            <span class="post-date" title="2020-12-22 22:13:12">2020/12/22</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-12-22-12%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85.html"
           data-tag="其他"
           data-author="" >
            <span class="post-title" title="组装电脑">组装电脑</span>
            <span class="post-date" title="2020-12-22 22:13:12">2020/12/22</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-12-22-12%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html"
           data-tag="frp,内网穿透,远程连接"
           data-author="" >
            <span class="post-title" title="使用 frp 实现远程连接和内网穿透">使用 frp 实现远程连接和内网穿透</span>
            <span class="post-date" title="2020-12-22 22:13:12">2020/12/22</span>
        </a>
        
        <a  class="全部文章 Spring基础 "
           href="/2020-12-22-13Spring%E5%9F%BA%E7%A1%80/20191022sia2.html"
           data-tag="sia"
           data-author="" >
            <span class="post-title" title="第 2 章 装配 Bean">第 2 章 装配 Bean</span>
            <span class="post-date" title="2020-12-22 22:13:12">2020/12/22</span>
        </a>
        
        <a  class="全部文章 Spring基础 "
           href="/2020-12-21-13Spring%E5%9F%BA%E7%A1%80/20191019sia1.html"
           data-tag="sia"
           data-author="" >
            <span class="post-title" title="第 1 章 构建 Spring 之旅">第 1 章 构建 Spring 之旅</span>
            <span class="post-date" title="2020-12-21 22:13:12">2020/12/21</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-12-21-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C21-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 21 章 函数式编程">第 21 章 函数式编程</span>
            <span class="post-date" title="2020-12-21 22:13:12">2020/12/21</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-11-30-11%E5%89%8D%E7%AB%AF/TypeScript.html"
           data-tag="TypeScript"
           data-author="" >
            <span class="post-title" title="TypeScript 学习(一)">TypeScript 学习(一)</span>
            <span class="post-date" title="2020-11-30 22:13:12">2020/11/30</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-11-15-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98.html"
           data-tag="flex"
           data-author="" >
            <span class="post-title" title="Flex 布局实战">Flex 布局实战</span>
            <span class="post-date" title="2020-11-15 22:13:12">2020/11/15</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%806-%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（六）">算法基础（六）</span>
            <span class="post-date" title="2020-11-08 23:13:12">2020/11/08</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-08-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%805-%E5%89%8D%E7%BC%80%E6%A0%91_%E6%A1%B6%E6%8E%92%E5%BA%8F_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（五）">算法基础（五）</span>
            <span class="post-date" title="2020-11-08 22:13:12">2020/11/08</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%803-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（三）">算法基础（三）</span>
            <span class="post-date" title="2020-11-02 22:13:12">2020/11/02</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-11-02-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%804-%E6%AF%94%E8%BE%83%E5%99%A8_%E5%A0%86%E6%8E%92%E5%BA%8F.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（四）">算法基础（四）</span>
            <span class="post-date" title="2020-11-02 22:13:12">2020/11/02</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-10-30-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%802.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（二）">算法基础（二）</span>
            <span class="post-date" title="2020-10-30 22:13:12">2020/10/30</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2020-10-28-10%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%801-%E5%A4%8D%E6%9D%82%E5%BA%A6_%E5%AF%B9%E6%95%B0%E5%99%A8_%E4%BA%8C%E5%88%86%E6%B3%95_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法基础（一）">算法基础（一）</span>
            <span class="post-date" title="2020-10-28 22:13:12">2020/10/28</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-11-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(8)-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(八)">Spring Cloud学习(八)</span>
            <span class="post-date" title="2020-10-11 23:43:12">2020/10/11</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-10-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(7)-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(七)">Spring Cloud学习(七)</span>
            <span class="post-date" title="2020-10-10 23:43:12">2020/10/10</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(6)-config.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(六)">Spring Cloud学习(六)</span>
            <span class="post-date" title="2020-10-04 23:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(1).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(一)">分布式会话管理(一)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(3).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(三)">分布式会话管理(三)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(4).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(四)">分布式会话管理(四)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-04-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86(2).html"
           data-tag="分布式会话"
           data-author="" >
            <span class="post-title" title="分布式会话管理(二)">分布式会话管理(二)</span>
            <span class="post-date" title="2020-10-04 20:43:12">2020/10/04</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(5)-zuul.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(五)">Spring Cloud学习(五)</span>
            <span class="post-date" title="2020-10-03 23:43:12">2020/10/03</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-03-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(4)-Hystrix.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(四)">Spring Cloud学习(四)</span>
            <span class="post-date" title="2020-10-03 23:33:12">2020/10/03</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-02-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(3)-Feign.html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="SpringCloud学习(三)">SpringCloud学习(三)</span>
            <span class="post-date" title="2020-10-02 23:33:12">2020/10/02</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-02-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(2).html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(二)">Spring Cloud学习(二)</span>
            <span class="post-date" title="2020-10-02 23:13:12">2020/10/02</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-10-01-08%E5%88%86%E5%B8%83%E5%BC%8F/SpringCloud(1).html"
           data-tag="Spring Cloud"
           data-author="" >
            <span class="post-title" title="Spring Cloud学习(一)">Spring Cloud学习(一)</span>
            <span class="post-date" title="2020-10-01 22:13:12">2020/10/01</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-20-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（五）">操作系统学习（五）</span>
            <span class="post-date" title="2020-09-20 22:13:12">2020/09/20</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-19-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（四）">操作系统学习（四）</span>
            <span class="post-date" title="2020-09-19 22:13:12">2020/09/19</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-18-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（三）">操作系统学习（三）</span>
            <span class="post-date" title="2020-09-18 22:13:12">2020/09/18</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-16-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（二）">操作系统学习（二）</span>
            <span class="post-date" title="2020-09-16 22:13:12">2020/09/16</span>
        </a>
        
        <a  class="全部文章 OS "
           href="/2020-09-15-04%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E8%AF%BE.html"
           data-tag="OS"
           data-author="" >
            <span class="post-title" title="操作系统学习（一）">操作系统学习（一）</span>
            <span class="post-date" title="2020-09-15 22:13:12">2020/09/15</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-09-10-07MySQL/mysql_14_%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十四) 经典面试题目">MySql 调优(十四) 经典面试题目</span>
            <span class="post-date" title="2020-09-10 23:13:12">2020/09/10</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_13_JavaSPI%E6%9C%BA%E5%88%B6.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十三) Java SPI 机制详解">MySql 调优(十三) Java SPI 机制详解</span>
            <span class="post-date" title="2020-08-29 23:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_12_%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十二) 经典笔试题">MySql 调优(十二) 经典笔试题</span>
            <span class="post-date" title="2020-08-29 22:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_11_%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十一) 读写分离">MySql 调优(十一) 读写分离</span>
            <span class="post-date" title="2020-08-29 21:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-29-07MySQL/mysql_10_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(十)">MySql 调优(十)</span>
            <span class="post-date" title="2020-08-29 20:13:12">2020/08/29</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-27-07MySQL/mysql_9_%E4%BA%8B%E5%8A%A1.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(九)">MySql 调优(九)</span>
            <span class="post-date" title="2020-08-27 22:13:12">2020/08/27</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-26-07MySQL/mysql_8_%E9%94%81%E6%9C%BA%E5%88%B6.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(八)">MySql 调优(八)</span>
            <span class="post-date" title="2020-08-26 22:13:12">2020/08/26</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-16-07MySQL/mysql_7_%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E5%92%8C%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(七)">MySql 调优(七)</span>
            <span class="post-date" title="2020-08-16 22:13:12">2020/08/16</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-14-07MySQL/mysql_6_%E5%88%86%E5%8C%BA.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(六)">MySql 调优(六)</span>
            <span class="post-date" title="2020-08-14 22:13:12">2020/08/14</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-13-07MySQL/mysql_5_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(五)">MySql 调优(五)</span>
            <span class="post-date" title="2020-08-13 22:13:12">2020/08/13</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-10-07MySQL/mysql_3_%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%9B%91%E6%8E%A7.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(三)">MySql 调优(三)</span>
            <span class="post-date" title="2020-08-10 22:13:12">2020/08/10</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-09-07MySQL/mysql_2_%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%92%8C%E5%85%B3%E9%94%AE%E5%90%8D%E8%AF%8D.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(二)">MySql 调优(二)</span>
            <span class="post-date" title="2020-08-09 22:13:12">2020/08/09</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-05-07MySQL/mysql_1_%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 调优(一)">MySql 调优(一)</span>
            <span class="post-date" title="2020-08-05 22:13:12">2020/08/05</span>
        </a>
        
        <a  class="全部文章 MySQL "
           href="/2020-08-04-07MySQL/mysql_0_%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD.html"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySql 安装">MySql 安装</span>
            <span class="post-date" title="2020-08-04 22:13:12">2020/08/04</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-24-02JVM/jvm%E5%AD%A6%E4%B9%A011_jvm%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（十一）">JVM 学习（十一）</span>
            <span class="post-date" title="2020-07-24 22:13:12">2020/07/24</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-24-02JVM/jvm%E5%AD%A6%E4%B9%A012_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（十二）">JVM 学习（十二）</span>
            <span class="post-date" title="2020-07-24 22:13:12">2020/07/24</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-23-02JVM/jvm%E5%AD%A6%E4%B9%A0%2010_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（十）">JVM 学习（十）</span>
            <span class="post-date" title="2020-07-23 22:13:12">2020/07/23</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-20-02JVM/jvm%E5%AD%A6%E4%B9%A07_xx.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（七）">JVM 学习（七）</span>
            <span class="post-date" title="2020-07-20 22:13:12">2020/07/20</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-20-02JVM/jvm%E5%AD%A6%E4%B9%A08_%E8%B0%83%E4%BC%982.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（八）">JVM 学习（八）</span>
            <span class="post-date" title="2020-07-20 22:13:12">2020/07/20</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-20-02JVM/jvm%E5%AD%A6%E4%B9%A09_%E8%B0%83%E4%BC%983.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（九）">JVM 学习（九）</span>
            <span class="post-date" title="2020-07-20 22:13:12">2020/07/20</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-19-02JVM/jvm%E5%AD%A6%E4%B9%A06_GC.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（六）">JVM 学习（六）</span>
            <span class="post-date" title="2020-07-19 22:13:12">2020/07/19</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-19-02JVM/jvm%E5%AD%A6%E4%B9%A05_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（五）">JVM 学习（五）</span>
            <span class="post-date" title="2020-07-19 22:13:12">2020/07/19</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-07-16-02JVM/jvm%E5%AD%A6%E4%B9%A03_4_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（三、四）">JVM 学习（三、四）</span>
            <span class="post-date" title="2020-07-16 22:13:12">2020/07/16</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-06-29-02JVM/jvm%E5%AD%A6%E4%B9%A02_class%E5%8A%A0%E8%BD%BD.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（二）">JVM 学习（二）</span>
            <span class="post-date" title="2020-06-29 22:13:12">2020/06/29</span>
        </a>
        
        <a  class="全部文章 JVM "
           href="/2020-06-28-02JVM/jvm%E5%AD%A6%E4%B9%A01_jvm%E5%9F%BA%E7%A1%80_jsf.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM 学习（一）">JVM 学习（一）</span>
            <span class="post-date" title="2020-06-28 22:13:12">2020/06/28</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-06-27-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%88%B0%20AOP.html"
           data-tag="Proxy"
           data-author="" >
            <span class="post-title" title="设计模式之 - 从代理模式到 Spring AOP">设计模式之 - 从代理模式到 Spring AOP</span>
            <span class="post-date" title="2020-06-27 22:13:12">2020/06/27</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-21-05IO/IO%E5%AD%A6%E4%B9%A07.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（七）">IO学习（七）</span>
            <span class="post-date" title="2020-06-21 22:13:12">2020/06/21</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-21-05IO/IO%E5%AD%A6%E4%B9%A08.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（八）">IO学习（八）</span>
            <span class="post-date" title="2020-06-21 22:13:12">2020/06/21</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-16-05IO/IO%E5%AD%A6%E4%B9%A05.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（五）">IO学习（五）</span>
            <span class="post-date" title="2020-06-16 22:13:12">2020/06/16</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-16-05IO/IO%E5%AD%A6%E4%B9%A06.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（六）">IO学习（六）</span>
            <span class="post-date" title="2020-06-16 22:13:12">2020/06/16</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-14-05IO/IO%E5%AD%A6%E4%B9%A03.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（三）">IO学习（三）</span>
            <span class="post-date" title="2020-06-14 22:13:12">2020/06/14</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-06-12-08%E5%88%86%E5%B8%83%E5%BC%8F/Https%E4%B9%8B%E5%AE%9E%E6%88%98.html"
           data-tag="https"
           data-author="" >
            <span class="post-title" title="Https 实战">Https 实战</span>
            <span class="post-date" title="2020-06-12 22:13:12">2020/06/12</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-10-05IO/IO%E5%AD%A6%E4%B9%A02.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（二）">IO学习（二）</span>
            <span class="post-date" title="2020-06-10 22:13:12">2020/06/10</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-08-05IO/IO%E5%AD%A6%E4%B9%A01.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（一）">IO学习（一）</span>
            <span class="post-date" title="2020-06-08 22:13:12">2020/06/08</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-06-06-08%E5%88%86%E5%B8%83%E5%BC%8F/Https%E4%B9%8BSSLTLS%20%E5%8D%8F%E8%AE%AE.html"
           data-tag="https"
           data-author="" >
            <span class="post-title" title="Https 之 SSL/TLS 协议">Https 之 SSL/TLS 协议</span>
            <span class="post-date" title="2020-06-06 22:13:12">2020/06/06</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-06-06-05IO/IO%E5%AD%A6%E4%B9%A04.html"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="IO学习（四）">IO学习（四）</span>
            <span class="post-date" title="2020-06-06 22:13:12">2020/06/06</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-05-25-11%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80.html"
           data-tag="flex"
           data-author="" >
            <span class="post-title" title="Flex 布局">Flex 布局</span>
            <span class="post-date" title="2020-05-25 22:13:12">2020/05/25</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-05-25-11%E5%89%8D%E7%AB%AF/vue-todo.html"
           data-tag="vue,webpack"
           data-author="" >
            <span class="post-title" title="vue 入门项目">vue 入门项目</span>
            <span class="post-date" title="2020-05-25 22:13:12">2020/05/25</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-04-10-11%E5%89%8D%E7%AB%AF/uniapp.html"
           data-tag="uni-app"
           data-author="" >
            <span class="post-title" title="uni-app">uni-app</span>
            <span class="post-date" title="2020-04-10 22:13:13">2020/04/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-04-10-11%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0(2).html"
           data-tag="vue"
           data-author="" >
            <span class="post-title" title="vue 学习(二)">vue 学习(二)</span>
            <span class="post-date" title="2020-04-10 22:13:12">2020/04/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2020-04-10-11%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0(1).html"
           data-tag="vue"
           data-author="" >
            <span class="post-title" title="vue 学习(一)">vue 学习(一)</span>
            <span class="post-date" title="2020-04-10 22:13:12">2020/04/10</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-07-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(7).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(七)">多线程高并发学习(七)</span>
            <span class="post-date" title="2020-04-07 22:13:12">2020/04/07</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-06-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(6).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(六)">多线程高并发学习(六)</span>
            <span class="post-date" title="2020-04-06 22:13:12">2020/04/06</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-05-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(5).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(五)">多线程高并发学习(五)</span>
            <span class="post-date" title="2020-04-05 22:13:12">2020/04/05</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-04-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(4).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(四)">多线程高并发学习(四)</span>
            <span class="post-date" title="2020-04-04 22:13:12">2020/04/04</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-03-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(3).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(三)">多线程高并发学习(三)</span>
            <span class="post-date" title="2020-04-03 22:13:12">2020/04/03</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-02-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(2).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(二)">多线程高并发学习(二)</span>
            <span class="post-date" title="2020-04-02 22:13:12">2020/04/02</span>
        </a>
        
        <a  class="全部文章 多线程 "
           href="/2020-04-01-03%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0(1).html"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程高并发学习(一)">多线程高并发学习(一)</span>
            <span class="post-date" title="2020-04-01 22:13:12">2020/04/01</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-03-20-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Observer.html"
           data-tag="Observer"
           data-author="" >
            <span class="post-title" title="设计模式之 - Observer">设计模式之 - Observer</span>
            <span class="post-date" title="2020-03-20 22:13:12">2020/03/20</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-03-20-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-ResponsibilityChain.html"
           data-tag="RSC"
           data-author="" >
            <span class="post-title" title="设计模式之 - Responsibility Chain">设计模式之 - Responsibility Chain</span>
            <span class="post-date" title="2020-03-20 22:13:12">2020/03/20</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020-03-20-09%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-singleton.html"
           data-tag="Singleton"
           data-author="" >
            <span class="post-title" title="设计模式之 - Singleton">设计模式之 - Singleton</span>
            <span class="post-date" title="2020-03-20 22:13:12">2020/03/20</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-05-06%E9%AB%98%E5%B9%B6%E5%8F%91/zookeeper%E5%AD%A6%E4%B9%A0(%E4%B8%89).html"
           data-tag="ZooKeeper"
           data-author="" >
            <span class="post-title" title="ZooKeeper学习(三)">ZooKeeper学习(三)</span>
            <span class="post-date" title="2020-03-05 22:13:12">2020/03/05</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-02-06%E9%AB%98%E5%B9%B6%E5%8F%91/zookeeper%E5%AD%A6%E4%B9%A0(%E4%B8%80).html"
           data-tag="ZooKeeper"
           data-author="" >
            <span class="post-title" title="ZooKeeper学习(一)">ZooKeeper学习(一)</span>
            <span class="post-date" title="2020-03-02 22:13:12">2020/03/02</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-02-06%E9%AB%98%E5%B9%B6%E5%8F%91/zookeeper%E5%AD%A6%E4%B9%A0(%E4%BA%8C).html"
           data-tag="ZooKeeper"
           data-author="" >
            <span class="post-title" title="ZooKeeper学习(二)">ZooKeeper学习(二)</span>
            <span class="post-date" title="2020-03-02 22:13:12">2020/03/02</span>
        </a>
        
        <a  class="全部文章 分布式 "
           href="/2020-03-02-08%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98C3_%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86.html"
           data-tag="Eureka"
           data-author="" >
            <span class="post-title" title="第三章 服务治理">第三章 服务治理</span>
            <span class="post-date" title="2020-03-02 22:13:12">2020/03/02</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-03-01-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%94)-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(五)-面试常见问题">Redis 学习(五)-面试常见问题</span>
            <span class="post-date" title="2020-03-01 22:13:12">2020/03/01</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-02-28-06%E9%AB%98%E5%B9%B6%E5%8F%91/Linux%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%AE%80%E8%A6%81%E6%AD%A5%E9%AA%A4.html"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux 系统安装简要步骤">Linux 系统安装简要步骤</span>
            <span class="post-date" title="2020-02-28 22:13:12">2020/02/28</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2020-02-28-06%E9%AB%98%E5%B9%B6%E5%8F%91/Typecho+Tengine%E5%BB%BA%E7%AB%99.html"
           data-tag="Nginx,Blog"
           data-author="" >
            <span class="post-title" title="Typecho+Tengine 搭建个人主页">Typecho+Tengine 搭建个人主页</span>
            <span class="post-date" title="2020-02-28 22:13:12">2020/02/28</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-28-06%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"
           data-tag="LVS,网络"
           data-author="" >
            <span class="post-title" title="高并发负载均衡">高并发负载均衡</span>
            <span class="post-date" title="2020-02-28 22:13:12">2020/02/28</span>
        </a>
        
        <a  class="全部文章 IO "
           href="/2020-02-22-05IO/IO%E5%AD%A6%E4%B9%A09.html"
           data-tag="NIO"
           data-author="" >
            <span class="post-title" title="NIO 原理">NIO 原理</span>
            <span class="post-date" title="2020-02-22 22:13:12">2020/02/22</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-21-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E5%9B%9B)-%E9%9B%86%E7%BE%A4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(四)-主从复制、高可用、集群">Redis 学习(四)-主从复制、高可用、集群</span>
            <span class="post-date" title="2020-02-21 22:13:12">2020/02/21</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-20-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%B8%89)-%E6%8C%81%E4%B9%85%E5%8C%96.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(三)-持久化">Redis 学习(三)-持久化</span>
            <span class="post-date" title="2020-02-20 22:13:12">2020/02/20</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-19-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(二)-管道、发布/订阅、事务、modules、过期">Redis 学习(二)-管道、发布/订阅、事务、modules、过期</span>
            <span class="post-date" title="2020-02-19 22:13:12">2020/02/19</span>
        </a>
        
        <a  class="全部文章 高并发 "
           href="/2020-02-18-06%E9%AB%98%E5%B9%B6%E5%8F%91/Redis%20%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4.html"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 学习(一)-概述、安装、类型、指令">Redis 学习(一)-概述、安装、类型、指令</span>
            <span class="post-date" title="2020-02-18 22:13:12">2020/02/18</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-18-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C18.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 18 章 类加载机制与反射">第 18 章 类加载机制与反射</span>
            <span class="post-date" title="2020-01-18 22:13:12">2020/01/18</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-17-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C17.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 17 章 网络编程">第 17 章 网络编程</span>
            <span class="post-date" title="2020-01-17 23:13:12">2020/01/17</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-16-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C16.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 16 章 多线程">第 16 章 多线程</span>
            <span class="post-date" title="2020-01-16 22:13:12">2020/01/16</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-15-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C15.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 15 章 输入、输出">第 15 章 输入、输出</span>
            <span class="post-date" title="2020-01-15 22:13:12">2020/01/15</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-14-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C14.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 14 章 注解">第 14 章 注解</span>
            <span class="post-date" title="2020-01-14 22:13:12">2020/01/14</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-13-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C13.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 13 章 MySQL 数据库与 JDBC 编程">第 13 章 MySQL 数据库与 JDBC 编程</span>
            <span class="post-date" title="2020-01-13 22:13:12">2020/01/13</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-10-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C10.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 10 章 异常处理">第 10 章 异常处理</span>
            <span class="post-date" title="2020-01-10 22:13:12">2020/01/10</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-09-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C9.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 9 章 泛型">第 9 章 泛型</span>
            <span class="post-date" title="2020-01-09 22:13:12">2020/01/09</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-08-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C8.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 8 章 Java 集合">第 8 章 Java 集合</span>
            <span class="post-date" title="2020-01-08 22:13:12">2020/01/08</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-07-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C7.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 7 章 Java 基础类库">第 7 章 Java 基础类库</span>
            <span class="post-date" title="2020-01-07 22:13:12">2020/01/07</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-06-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C6.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 6 章 面向对象（下）">第 6 章 面向对象（下）</span>
            <span class="post-date" title="2020-01-06 22:13:12">2020/01/06</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-05-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C5.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 5 章 面向对象（上）">第 5 章 面向对象（上）</span>
            <span class="post-date" title="2020-01-05 22:13:12">2020/01/05</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-04-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C4.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 4 章 流程控制与数组">第 4 章 流程控制与数组</span>
            <span class="post-date" title="2020-01-04 22:13:12">2020/01/04</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-03-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C3.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 3 章 数据类型和运算符">第 3 章 数据类型和运算符</span>
            <span class="post-date" title="2020-01-03 22:13:12">2020/01/03</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-02-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C2.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 2 章 理解面向对象">第 2 章 理解面向对象</span>
            <span class="post-date" title="2020-01-02 22:13:12">2020/01/02</span>
        </a>
        
        <a  class="全部文章 Java基础 "
           href="/2020-01-01-01%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89/%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89C1.html"
           data-tag="Java讲义"
           data-author="" >
            <span class="post-title" title="第 1 章 Java 语言概述与开发环境">第 1 章 Java 语言概述与开发环境</span>
            <span class="post-date" title="2020-01-01 22:13:12">2020/01/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-01疯狂Java讲义/疯狂Java讲义C6" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">第 6 章 面向对象（下）</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java基础">Java基础</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">Java讲义</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2020-11-24 23:14:20'>2020-01-06 22:13</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:15.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Java-8-%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">6.1 Java 8 增强的包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.2 处理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E7%9A%84-toString-%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.1 打印对象的 toString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%92%8C-equals-%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.2 &#x3D;&#x3D;和 equals 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">6.3 类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E7%90%86%E8%A7%A3%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">6.3.1 理解类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-text">6.3.2 单例类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-final-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">6.4 final 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-final-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">6.4.1 final 成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-final-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">6.4.2 final 局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-final-%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB"><span class="toc-text">6.4.3  final 修饰基本类型变量和引用类型变量区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4-%E5%8F%AF%E6%89%A7%E8%A1%8C-%E2%80%9C%E5%AE%8F%E6%9B%BF%E6%8D%A2%E2%80%9D-%E7%9A%84-final-%E5%8F%98%E9%87%8F"><span class="toc-text">6.4.4 可执行 “宏替换” 的 final 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5-final-%E6%96%B9%E6%B3%95"><span class="toc-text">6.4.5 final 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-6-final-%E7%B1%BB"><span class="toc-text">6.4.6 final 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-7-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="toc-text">6.4.7 不可变类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-8-%E7%BC%93%E5%AD%98%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="toc-text">6.4.8 缓存实例的不可变类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">6.5 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">6.5.1 抽象方法和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">6.5.2 抽象类的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Java-9-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.6 Java 9 改进的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">6.6.1 接口的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-Java-9-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">6.6.2 Java 9 中接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">6.6.3 接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.6.4 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">6.6.5 接口和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-6-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-text">6.6.6 面向接口编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. 简单工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. 命令模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.7 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.7.1 非静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.7.2 静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-3-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.7.3 使用内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">1. 在外部类内部使用内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BB%A5%E5%A4%96%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">2. 在外部类以外使用非静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BB%A5%E5%A4%96%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3. 在外部类以外使用静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-4-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.7.4 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-5-Java-8-%E6%94%B9%E8%BF%9B%E7%9A%84%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.7.5 Java 8 改进的匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-Java-8-%E6%96%B0%E5%A2%9E%E7%9A%84-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">6.8 Java 8 新增的 Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8"><span class="toc-text">6.8.1  Lambda 表达式入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-2-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.8.2 Lambda 表达式与函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">6.8.3 方法引用与构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">1. 引用类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%89%B9%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">2. 引用特定对象的实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%95%E7%94%A8%E6%9F%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">3. 引用某类对象的实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">4. 引用构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-4-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">6.8.4 Lambda 表达式与匿名内部类的联系和区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%83%E7%94%A8-Arrays-%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">使用 Lambda 表达式调用 Arrays 的类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">6.9 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-1-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">6.9.1 手动实现枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%85%A5%E9%97%A8"><span class="toc-text">6.9.2 枚举类入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">6.9.3 枚举类的成员变量、方法和构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-4-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">6.9.4 实现接口的枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-5-%E5%8C%85%E5%90%AB%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">6.9.5 包含抽象方法的枚举类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">6.10 对象与垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">6.10.1 对象在内存中的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-%E5%BC%BA%E5%88%B6%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">6.10.2 强制垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-3-finalize-%E6%96%B9%E6%B3%95"><span class="toc-text">6.10.3 finalize 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AF%E3%80%81%E5%BC%B1%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-text">6.10.4 对象的软、弱和虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">6.11 修饰符的适用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-Java-9-%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC-JAR-%E5%8C%85"><span class="toc-text">6.12 Java 9 的多版本 JAR 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-1-jar-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">6.12.1 jar 命令详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-2-%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84-jar-%E5%8C%85"><span class="toc-text">6.12.2 创建可执行的 jar 包</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第 6 章 面向对象（下）</p>
<a id="more"></a>

<h2 id="6-1-Java-8-增强的包装类"><a href="#6-1-Java-8-增强的包装类" class="headerlink" title="6.1 Java 8 增强的包装类"></a>6.1 Java 8 增强的包装类</h2><p>Java 是面向对象的编程语言，但它包含 8 种基本数据类型，他们不具备“对象”的特征：没有成员变量、方法可以被调用。所有引用类型的变量都继承了 Object 类，都可当成 Object 类型变量使用。但基本数据类型的变量不可以，如果有个方法需要 Object 类型的参数，但实际需要的值却是 2、3 等数值，这可能比较难处理。</p>
<p>为了解决 8 种基本数据类型的变量不能当成 Object 类型变量使用的问题，Java 提供了包装类的概念，为 8 种基本数据类型分别定义了相应的引用类型。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>JDK 1.5 以前，基本类型和包装类之间的转换：</p>
<p><img src="../../images/java/c6/c61_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E8%BD%AC%E6%8D%A2.png"></p>
<p>JDK 1.5 开始，提供<strong>自动装箱</strong>和<strong>自动拆箱</strong>功能。</p>
<p><strong>自动装箱</strong>， 就是可以把一个基本类型变量直接赋给对应的包装类变量， 或者赋给 Object 变量。</p>
<p>自动拆箱则与之相反，允许直接把包装类对象直接赋给一个对应的基本类型变量。</p>
<pre><code class="java">public class AutoBoxingUnboxing
&#123;
    public static void main(String[] args)
    &#123;
        // 自动装箱，直接把一个基本类型变量赋值给 Integer 对象
        Integer inObj = 5;
        // 自动装箱，直接把一个 boolean 类型变量赋值给一个 Object 类型变量
        Object boolObj = true;
        // 自动拆箱，直接把一个 Integer 对象赋给 int 类型的变量
        int it = inObj;
        if(boolObj instanceof Boolean)
        &#123;
            boolean b = (Boolean)boolObj;
            System.out.println(b);
        &#125;
    &#125;
&#125;</code></pre>
<p>基本类和字符串转换</p>
<p><img src="../../images/java/c6/c61_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2.png"></p>
<pre><code class="java">public class Primitive2String &#123;
    public static void main(String[] args) &#123;
        String intStr = &quot;123&quot;;
        // 字符串转int
        int it1 = Integer.parseInt(intStr);
        int it2 = Integer.valueOf(intStr);
        System.out.println(it2);
        String floatStr = &quot;4.56&quot;;
        // 字符串转float
        float ft1 = Float.parseFloat(floatStr);
        float ft2 = Float.valueOf(floatStr);
        System.out.println(ft2);

        // float转string
        String ftStr = String.valueOf(2.345f);
        // double转string
        String dbStr = String.valueOf(3.345);
        // boolean转String
        String boolStr = String.valueOf(true);
        System.out.println(boolStr.toUpperCase());
    &#125;
&#125;</code></pre>
<pre><code class="java">public class WrapperClassCompare &#123;
    public static void main(String[] args) &#123;
        // 虽然包装类型变量是引用数据类型，但包装类的实例可以与数值类型的值进行比较
        Integer a = Integer.valueOf(6);
        System.out.println(&quot;6的包装类实例是否大于5.0：&quot; + (a &gt; 5.0));

        // 两个包装类的实例进行比较的情况比较复杂，因为包装类的实例实际上是引用类型，只有两个包装类的引用
        // 指向同一个对象时才会返回 true
        System.out.println(&quot;比较两个包装类的实例是否想等：&quot; + (Integer.valueOf(2) == Integer.valueOf(2)));

        System.out.println(&quot;比较两个包装类的实例是否想等(127)：&quot; + (Integer.valueOf(127) == Integer.valueOf(127)));
        System.out.println(&quot;比较两个包装类的实例是否想等(128)：&quot; + (Integer.valueOf(128) == Integer.valueOf(128)));
        // 结果不同和 Integer 的设计有关，Integer 把 -128~127 之间的整数自动装箱成 Integer 实例， 并放入了一个名为 cache 的数组中缓存起来
        // 不在 -128~127之间的整数自动装箱为Integer时，系统会新建一个Integer实例

        // Java7 为所有的包装类都提供了一个静态的 compare 方法，用于比较两个基本类型的大小
        System.out.println(&quot;========================包装类静态compare方法========================&quot;);
        System.out.println(Boolean.compare(true, false));
        System.out.println(Boolean.compare(false, false));

        System.out.println(Double.compare(3.14, 3.15));
        System.out.println(Double.compare(3.14, 3.14));

        // Character 提供了很多字符相关的工具方法，详见 API

    &#125;
&#125;</code></pre>
<pre><code class="java">public class UnsignedTest &#123;
    public static void main(String[] args) &#123;
        byte b = -3;
        System.out.println(&quot;byte 类型的 -3 对应的无符号整数：&quot; + Byte.toUnsignedInt(b));
        System.out.println(&quot;指定使用 16 进制解析无符号整数：&quot; + Integer.parseUnsignedInt(&quot;ab&quot;, 16));
        // 将 -12 转换为无符号 int 型，然后转换为十六进制的字符串
        System.out.println(Integer.toUnsignedString(-12, 16));
        System.out.println(Integer.divideUnsigned(-2, 3));
        System.out.println(Integer.remainderUnsigned(-2, 7));
    &#125;
&#125;</code></pre>
<h2 id="6-2-处理对象"><a href="#6-2-处理对象" class="headerlink" title="6.2 处理对象"></a>6.2 处理对象</h2><h3 id="6-2-1-打印对象的-toString-方法"><a href="#6-2-1-打印对象的-toString-方法" class="headerlink" title="6.2.1 打印对象的 toString 方法"></a>6.2.1 打印对象的 toString 方法</h3><p>Object 类提供的 toString() 方法总是返回该对象实现类的”类名+@+ hashCode “ 值，这个返回值并不能真正实现”自我描述”的功能，因此如果用户需要自定义类能实现”自我描述”的功能，就必须重写 Object 类的toString() 方法。</p>
<h3 id="6-2-2-和-equals-方法"><a href="#6-2-2-和-equals-方法" class="headerlink" title="6.2.2 ==和 equals 方法"></a>6.2.2 ==和 equals 方法</h3><p>​    <code>==</code> 用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不一定要求数据类型严格相同) ，则只要两个变量的值相等，就将返回 true 。</p>
<p>但对于两个引用类型变量，只有它们指向同一个对象时，<code>==</code> 判断才会返回 true，<code>==</code> 不可用于比较类型上没有父子关系的两个对象。</p>
<pre><code class="java">public class EqualTest &#123;
    public static void main(String[] args) &#123;
        int it = 65;
        float fl = 65.0f;
        // true
        System.out.println(&quot;65和65.0f是否相等？&quot; + (it == fl));
        char ch = &#39;A&#39;;
        // true
        System.out.println(&quot;65和&#39;A是否相等？&quot; + (it == ch));
        String str1 = new String(&quot;hello&quot;);
        String str2 = new String(&quot;hello&quot;);
        // false
        System.out.println(&quot;str1 和 str2 是否相等？&quot;
            + (str1 == str2));
        // true
        System.out.println(&quot;str1 是否 equals str2？&quot;
            + (str1.equals(str2)));
        // String 与 EqualTest 类没有继承关系，编译报错
        // System.out.println(&quot;hello&quot; == new EqualTest());
    &#125;
&#125;</code></pre>
<p>“hello” 直接量和 new Sting(“hello”) 有什么区别呢？当 Java 程序直接使用形如 “hello” 的字符串直接量( 包括可以在编译时就计算出来的字符串值)时， JVM 将会使用常量池来管理这些字符串；当使用new String(“hello”) 时， JVM 会先使用常量池来管理”hello”直接量，再调用 String 类的构造器来创建一个新的String 对象，新创建的 String 对象被保存在堆内存中。换句话说， new String(“hello”)一共产生了两个字符串对象。</p>
<pre><code class="java">public class StringCompareTest &#123;
    public static void main(String[] args) &#123;
        // s1 直接引用常量池中的&quot;疯狂Java&quot;
        String s1 = &quot;疯狂Java&quot;;
        String s2 = &quot;疯狂&quot;;
        String s3 = &quot;Java&quot;;
        // s4 可以在编译时就确定下来，直接引用常量池
        String s4 = &quot;疯狂&quot; + &quot;Java&quot;;
        // 同上
        String s5 = &quot;疯&quot; + &quot;狂&quot; + &quot;Java&quot;;
        // 编译时无法确定，不能引用常量池
        String s6 = s2 + s3;
        // 使用new调用构造器会创建一个新的String对象
        // s7引用堆内存中新创建的String对象
        String s7 = new String(&quot;疯狂Java&quot;);
        System.out.println(s1 == s4);
        System.out.println(s1 == s5);
        System.out.println(s1 == s6);
        System.out.println(s1 == s7);
    &#125;
&#125;</code></pre>
<h2 id="6-3-类成员"><a href="#6-3-类成员" class="headerlink" title="6.3 类成员"></a>6.3 类成员</h2><h3 id="6-3-1-理解类成员"><a href="#6-3-1-理解类成员" class="headerlink" title="6.3.1 理解类成员"></a>6.3.1 理解类成员</h3><p>类方法也是类成员的一种，类方法也是属于类的，通常直接使用类作为调用者来调用类方法，但也可以使用对象来调用类方法。与类变量类似，即使使用对象来调用类方法，其效果也与采用类来调用类方法完全一样。</p>
<pre><code class="java">public class NullAccessStatic &#123;
    private static void test()
    &#123;
        System.out.println(&quot;static 修饰的类方法&quot;);
    &#125;

    public static void main(String[] args) &#123;
        NullAccessStatic nas = null;
        nas.test();
    &#125;
&#125;</code></pre>
<p>编译、运行上面程序， 一切正常，程序将打印出” static 修饰的类方法”宇符串，这表明 null 对象可以访问它所属类的类成员。</p>
<p>对 static 关键宇而言，有一条非常重要的规则：类成员( 包括方法、初始化块、内部类和枚举类)不能访问实例成员(包括成员变量、方法、初始化块、内部类和枚举类) 。</p>
<h3 id="6-3-2-单例类"><a href="#6-3-2-单例类" class="headerlink" title="6.3.2 单例类"></a>6.3.2 单例类</h3><p>如果一个类始终只能创建一个实例，则会个类被成为单例类。</p>
<pre><code class="java">class Singleton &#123;
    // 使用一个类变量来缓存曾经创建的实例
    private static Singleton instance;
    // 隐藏构造器
    private Singleton()&#123;&#125;
    // 提供一个静态方法，返回Singleton对象
    public static Singleton getInstance()
    &#123;
        if(instance == null)
        &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
public class SingletonTest
&#123;
    public static void main(String[] args) &#123;
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        System.out.println(s1 == s2);
    &#125;
&#125;</code></pre>
<h2 id="6-4-final-修饰符"><a href="#6-4-final-修饰符" class="headerlink" title="6.4 final 修饰符"></a>6.4 final 修饰符</h2><p>final 关键字可用于修饰类、变量和方法。</p>
<p>final 修饰变量时，表示该变量一旦获得了初始值就不可被改变， final 既可以修饰成员变量( 包括类变量和实例变量)， 也可以修饰局部变量、形参。有的书上介绍说 final 修饰的变量不能被赋值，这种说法是错误的。严格的说法是， final 修饰的变量<strong>不可被改变</strong>， 一旦获得了初始值， 该 final 变量的值就不能被重新赋值。</p>
<h3 id="6-4-1-final-成员变量"><a href="#6-4-1-final-成员变量" class="headerlink" title="6.4.1 final 成员变量"></a>6.4.1 final 成员变量</h3><p>理解成员变量：</p>
<p>成员变量是随类初始化或对象初始化而初始化的。当类初始化时，系统会为该类的类变量分配内存，<strong>并分配默认值</strong>；当创建对象时，系统会为该对象的实例变量分配内存，<strong>并分配默认值</strong>。</p>
<p>也就是说，当执行<strong>静态初始化块</strong>时可以对<strong>类变量</strong>赋初始值；当执行<strong>普通初始化块、构造器</strong>时可对<strong>实例变量</strong>赋初始值。</p>
<p>类变量（static）和实例变量理解 ：</p>
<p><a href="https://blog.csdn.net/caigen0001/article/details/89676253">https://blog.csdn.net/caigen0001/article/details/89676253</a></p>
<p>简单的说，有 static 修饰的就是类变量（静态变量）。使用时直接用类调用即可，不用创建对象。</p>
<p>理解 final 修饰的成员变量：</p>
<p>对于 final 修饰的成员变量而言，一旦有了初始值，就不能被重新赋值，如果既没有在定义成员变量时指定初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值将一直是系统默认分配的 0 、’\u0000’ 、false 或 null ， 这些成员变量也就完全失去了存在的意义。因此 Java 语法规定: <strong>final 修饰的成员变量必须由程序员显式地指定初始值。并且不能重新赋值。</strong></p>
<p>例如：如果在初始化块中初始化了 final 的值，那么就不能在构造器中初始化了。</p>
<p>类变量和实例变量赋值：</p>
<ul>
<li>类变量：只能在静态初始化块或者声明该类时指定值</li>
<li>实例变量：只能在非静态初始化块、声明该类或者构造器中指定初始值</li>
</ul>
<pre><code class="java">// 实例变量，声明时分配了初始值，合法
final int a = 6;
// 实例变量，在普通初始化块中分配了初始值，合法
final String str;
&#123;
    str = &quot;Hello&quot;;
    // 实例变量 a 已经分配初始值，不可重新赋值，不合法
    // a = 9;
&#125;
// 实例变量，在构造器中分配了初始值，合法
final int c;
public FinalVariableTest()
&#123;
    // str 已经分配初始值，不可重新赋值，不合法
    // str = &quot;java&quot;;
    c = 5;
&#125;
// 类变量，在静态初始化块中分配了初始值，合法
final static double d;
static
&#123;
    d = 5.6;
&#125;
// 实例变量，在声明时、初始化块中、构造器中均没有分配初始值，不合法
// final char ch;
public void changeFinal()
&#123;
    // 普通方法不能为 final 修饰的成员变量（实例变量、类变量）赋值
    // d = 1.2;
    // ch = &#39;a&#39;;
&#125;</code></pre>
<p>总结：</p>
<ol>
<li>成员变量包含：实例变量、类变量</li>
<li>成员变量赋值的位置：声明变量时、初始化块（普通、静态块）、构造函数（仅实例变量）</li>
<li>普通成员变量：如果没有赋初始值，系统会给默认值</li>
<li>final 成员变量：Java 规定必须显示指定初始值</li>
</ol>
<p>如果打算在构造器、初始化块中对 final 成员变量进行初始化，则不要在初始化之前直接访问 final 成员变量;但 Java 又允许通过方法来访问 final 成员变量，此时会看到系统将 final 成员变量默认初始化为0(或’\u0000’ 、false 或 null) 。基本上可断定是 Java 设计的一个缺陷，应该避免在 final 变量初始化之前访问它。</p>
<pre><code class="java">public class FinaIErrorTest &#123;
    // 定义 final 修饰的实例变量 age
    final int age;
    // 定义普通初始化块，用来初始化 age 的值
    &#123;
        // 此时 age 还没有初始化，不可以直接访问成员变量
        // System.out.println(age);
        // 此时 age 还没有初始化，但是可以通过方法访问成员变量，值为0
        printAge();
        age = 6;
        System.out.println(age);
    &#125;
    public void printAge()&#123;
        System.out.println(age);
    &#125;
&#125;</code></pre>
<p>如果去掉 final 修饰，那么上面代码完全没问题。否则会报错。</p>
<h3 id="6-4-2-final-局部变量"><a href="#6-4-2-final-局部变量" class="headerlink" title="6.4.2 final 局部变量"></a>6.4.2 final 局部变量</h3><p>系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。因此使用 final 修饰局部变量时， <strong>既可以在定义时指定默认值，也可以不指定默认值。</strong></p>
<p>如果 final 修饰的局部变量在定义时没有指定默认值，则可以在后面代码中对该 final 变量赋初始值，但只能一次，不能重复赋值; </p>
<p>如果 final 修饰的局部变量在定义时己经指定默认值，则后面代码中不能再对该变量赋值。</p>
<p>因为形参在调用该方法时，由系统根据传入的参数来完成初始化，因此使用 final 修饰的形参不能被赋值。</p>
<pre><code class="java">public class FinalLocalVariableTest
&#123;
    public void test(final int a)
    &#123;
        // 不能对 final 形参赋值，非法
        // a = 5;
    &#125;
    public static void main(String[] args)
    &#123;
        // 局部变量，定义时赋初始值
        final String str = &quot;hello&quot;;
        // 局部变量，str 已经赋值，非法
        // str = &quot;Java&quot;;
        // 局部变量，定义没有赋初始值
        final double d;
        // 局部变量，可以赋值一次
        d = 5.6;
        // 局部变量，d 已经赋值，非法
        // d = 3.4;
        // 普通局部变量，可以多次赋值
        double e;
        e = 1;
        e = 3;
    &#125;
&#125;</code></pre>
<p>总结：</p>
<ol>
<li>系统不会对局部变量赋初始值，所以局部变量必须赋初始值，不管是否有 final</li>
<li>局部变量赋值位置：定义局部变量时、定义之后赋值</li>
<li>final 局部变量和普通局部变量区别：final 局部变量只可以赋值一次</li>
</ol>
<h3 id="6-4-3-final-修饰基本类型变量和引用类型变量区别"><a href="#6-4-3-final-修饰基本类型变量和引用类型变量区别" class="headerlink" title="6.4.3  final 修饰基本类型变量和引用类型变量区别"></a>6.4.3  final 修饰基本类型变量和引用类型变量区别</h3><p>当使用 final 修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用， final 只保证这个引用类型变量所引用的<strong>地址不会改变</strong>， 即一直引用同一个对象，但这个对象完全可以发生改变。</p>
<p><strong>简单的说，final 修饰的应用变量可以改变应用变量的内容，但是不可以重新赋值，改变引用的地址。</strong></p>
<h3 id="6-4-4-可执行-“宏替换”-的-final-变量"><a href="#6-4-4-可执行-“宏替换”-的-final-变量" class="headerlink" title="6.4.4 可执行 “宏替换” 的 final 变量"></a>6.4.4 可执行 “宏替换” 的 final 变量</h3><p>final 修饰符的一个重要用途就是定义”宏变量”。</p>
<p>对一个final 变量来说，不管它是类变量、实例变量，还是局部变量，只要该变量满足三个条件，这个final 变量就不再是一个变量，而是相当于一个直接量。</p>
<ul>
<li>使用 final 修饰符修饰</li>
<li>在<strong>定义</strong>该 final 变量时指定了初始值</li>
<li>该初始值在编译时就被确定下来</li>
</ul>
<pre><code class="java">public static void main(String[] args)
&#123;
    // 宏变量
    final int a = 5 + 2;
    // 宏变量
    final double b = 1.2/5;
    // 宏变量
    final String str = &quot;疯狂&quot; + &quot;Java&quot;;
    // 宏变量
    final String book = &quot;疯狂 Java 讲义：&quot; + 99.0;
    // 调用了方法，无法在编译时确定，所以不是宏变量
    final String book2 = &quot;疯狂 Java 讲义：&quot; + String.valueOf(99.0);
    System.out.println(book == &quot;疯狂 Java 讲义：99.0&quot;); // true
    System.out.println(book2 == &quot;疯狂 Java 讲义：99.0&quot;);// false

    final int c = 5;
    // 对于程序来说，变量 c 其实根本不存在。实际执行的代码被转换为 println(5)
    System.out.println(a);
&#125;</code></pre>
<p>Java 会使用<strong>常量池</strong>来管理曾经用过的字符串直接量，例如执行 String a = “java”；语句之后，常量池中就会缓存一个字符串”java”；如果程序再次执行String b = “java”；系统将会让 b 直接指向常量池中的”java”字符串，因此 a == b 将会返回 true。</p>
<p>进一步理解 final 宏替换</p>
<pre><code class="java">public static void main(String[] args)
&#123;
    String s1 = &quot;疯狂Java&quot;;
    // 编译时就可以确认，所以 s2 直接引用常量池中已有的&quot;疯狂Java&quot;字符串
    String s2 = &quot;疯狂&quot; + &quot;Java&quot;;
    System.out.println(s1 == s2); // true
    String str1 = &quot;疯狂&quot;;
    String str2 = &quot;Java&quot;;
    // str1、str2 只是两个普通变量，编译器不会进行“宏替换”，因此编译器无法在编译时确定 s3 的值
    String s3 = str1 + str2;
    System.out.println(s1 == s3); // false
    // 所以要使得 s1 == s3 只需，str1、str2 用 final 修饰即可
&#125;</code></pre>
<p>注意：对于实例变量，三个地方赋初始值效果一样。但对于 final 实例变量而言，只有在<strong>定义</strong>该变量时指定初始值才会有”宏变量”的效果。final 局部变量也是一样。</p>
<h3 id="6-4-5-final-方法"><a href="#6-4-5-final-方法" class="headerlink" title="6.4.5 final 方法"></a>6.4.5 final 方法</h3><p>final 修饰的方法不可被重写，如果出于某些原因，<strong>不希望子类重写父类的某个方法</strong>，则可以使用 final 修饰该方法。</p>
<pre><code class="java">public class PrivateFinalMethodTest
&#123;
    private final void test1()&#123;&#125;

    public final void test2()&#123;&#125;
&#125;
class Sub extends  PrivateFinalMethodTest
&#123;
    // 合法，只是定义了一个新方法，不是重写父类方法
    public void test1()&#123;&#125;;
    // 非法
    // public void test2()&#123;&#125;;
&#125;</code></pre>
<p>对于一个 private 方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法。所以如果子类中定义一个与父类 private 方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。</p>
<p>final 修饰发方法，只是不能被重写，但是可以重载</p>
<pre><code class="java">class FinalOverload
&#123;
    public final void test() &#123;&#125;
    // final 修饰的方法，只是不能被重写，而不是不能被重载。合法
    public final void test(String org) &#123;&#125;
&#125;</code></pre>
<h3 id="6-4-6-final-类"><a href="#6-4-6-final-类" class="headerlink" title="6.4.6 final 类"></a>6.4.6 final 类</h3><p>final 修饰的类不可以有子类， 例如 java.1ang.Math 类就是一个 final 类，它不可以有子类。如 Math 类。</p>
<p>当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用 final 修饰这个类。</p>
<h3 id="6-4-7-不可变类"><a href="#6-4-7-不可变类" class="headerlink" title="6.4.7 不可变类"></a>6.4.7 不可变类</h3><p>不可变( immutable ) 类的意思是创建该<strong>类的实例</strong>后， 该实例的实例变量是不可改变的。</p>
<p>Java 提供的8 个包装类和 java.lang.String 类都是不可变类。</p>
<p>创建自定义的不可变类规则：</p>
<ul>
<li>使用 private 和 final 修饰符来修饰该类的成员变量。</li>
<li>提供带参数构造器，用于根据传入参数来初始化类里的成员变量。</li>
<li>仅为该类的成员变量提供 getter 方法，不要为该类的成员变量提供 setter 方法，因为普通方法无法修改final 修饰的成员变量。</li>
<li>如果有必要，重写 Object 类的 hashCode() 和 equals() 方法</li>
</ul>
<pre><code class="java">public class Address
&#123;
    // 使用 private 和 final 修饰符来修饰该类的成员变量
    private final String detail;
    private final String postCode;
    public Address()
    &#123;
        this.detail = &quot;&quot;;
        this.postCode = &quot;&quot;;
    &#125;
    // 提供带参数构造器，用于根据传入参数来初始化类里的成员变量
    public Address(String detail, String postCode)
    &#123;
        this.detail = detail;
        this.postCode = postCode;
    &#125;
    // 仅为该类的成员变量提供 getter 方法
    public String getDetail()
    &#123;
        return detail;
    &#125;
    public String getPostCode()
    &#123;
        return postCode;
    &#125;
    // 重写 equals() 方法，判断两个对象是否相等
    @Override
    public boolean equals(Object obj)
    &#123;
        if(this == obj)
        &#123;
            return true;
        &#125;
        if(obj != null &amp;&amp; obj.getClass() == Address.class)
        &#123;
            Address address = (Address)obj;
            if(this.getDetail().equals(address.getDetail())
                &amp;&amp; this.getPostCode().equals(address.getPostCode()))
            &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
    @Override
    public int hashCode()
    &#123;
        return detail.hashCode() + postCode.hashCode() * 31;
    &#125;
&#125;</code></pre>
<p>注意：当使用 final 修饰引用类型变量时，仅表示这个引用类型变量不可被重新赋值，但<strong>引用类型变量所指向的对象</strong>依然可改变。所以成员变量和 get 方法需要特殊处理。</p>
<pre><code class="java">public class Person
&#123;
    private final Address address;
    public Person(Address address)
    &#123;
        // 设置新对象，防止 Person 类的 address 成员变量被改
        this.address = new Address(address.getDetail(), address.getPostCode());
    &#125;
    public Address getAddress()
    &#123;
        // 返回新对象
        return new Address(address.getDetail(), address.getPostCode());
    &#125;
&#125;</code></pre>
<h3 id="6-4-8-缓存实例的不可变类"><a href="#6-4-8-缓存实例的不可变类" class="headerlink" title="6.4.8 缓存实例的不可变类"></a>6.4.8 缓存实例的不可变类</h3><p>不可变类的实例状态不可改变，可以很方便地被多个对象所共享。如果程序经常需要使用相同的不可变类实例，则应该考虑缓存这种不可变类的实例。</p>
<pre><code class="java">class Cachelmmutale
&#123;
    private static int MAX_SIZE=10;
    private static Cachelmmutale[] cache = new Cachelmmutale[MAX_SIZE];
    private static int pos = 0;
    private final String name;
    // 隐藏构造器，使得只能使用 valueOf 方法来创建实例
    private Cachelmmutale(String name)
    &#123;
        this.name = name;
    &#125;
    public String getName()
    &#123;
        return name;
    &#125;
    public static Cachelmmutale valueOf(String name)
    &#123;
        for (int i = 0; i &lt; MAX_SIZE; i++)
        &#123;
            if(cache[i] != null &amp;&amp; cache[i].getName().equals(name))
            &#123;
                return cache[i];
            &#125;
        &#125;
        if(pos == MAX_SIZE)
        &#123;
            cache[0] = new Cachelmmutale(name);
            pos = 1;
        &#125;
        else
        &#123;
            cache[pos++] = new Cachelmmutale(name);
        &#125;
        // 走到这里，肯定是新对象，存到了缓存，然后pos+1
        return cache[pos - 1];
    &#125;
    @Override
    public boolean equals(Object obj)
    &#123;
        if(this == obj)
        &#123;
            return true;
        &#125;
        if(obj != null &amp;&amp; obj.getClass() == Cachelmmutale.class)
        &#123;
            Cachelmmutale ci = (Cachelmmutale)obj;
            return name.equals(ci.getName());
        &#125;
        return false;
    &#125;
    @Override
    public int hashCode()
    &#123;
        return name.hashCode();
    &#125;
&#125;
public class CachelmmutaleTest
&#123;
    public static void main(String[] args)
    &#123;
        Cachelmmutale c1 = Cachelmmutale.valueOf(&quot;hello&quot;);
        Cachelmmutale c2 = Cachelmmutale.valueOf(&quot;hello&quot;);
        System.out.println(c1 == c2); // true
    &#125;
&#125;</code></pre>
<p>Java 提供的 java.lang .lnteger 类，采用了与 Cachelmmutale 类相同的处理策略。</p>
<h2 id="6-5-抽象类"><a href="#6-5-抽象类" class="headerlink" title="6.5 抽象类"></a>6.5 抽象类</h2><h3 id="6-5-1-抽象方法和抽象类"><a href="#6-5-1-抽象方法和抽象类" class="headerlink" title="6.5.1 抽象方法和抽象类"></a>6.5.1 抽象方法和抽象类</h3><ul>
<li>抽象方法、抽象类使用 abstract 修饰符来修饰，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，无法 new 出实例。</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接口、枚举）5 种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</li>
<li>含有抽象方法的类（直接定义了一个抽象方法；继承了一个抽象父类，但没有完全实现父类包含的抽象方法；实现了一个接口，但没有完全实现接口包含的抽象方法）只能被定义为抽象类。</li>
</ul>
<pre><code class="java">public abstract class Shape &#123;
    &#123;
        System.out.println(&quot;执行 Shape 的初始化块...&quot;);
    &#125;
    private String color;
    // 定义一个计算周长的抽象方法
    public abstract double calPerimeter();
    // 定义一个返回形状的抽象方法
    public abstract String getType();
    // 定义构造器，用于被子类调用
    public Shape()&#123;&#125;
    public Shape(String color)
    &#123;
        System.out.println(&quot;执行 Shape 的构造器...&quot;);
        this.color = color;
    &#125;

    public String getColor() &#123;
        return color;
    &#125;

    public void setColor(String color) &#123;
        this.color = color;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Triangle extends Shape &#123;
    // 定义三角形三边
    private double a;
    private double b;
    private double c;
    public Triangle(String color, double a, double b, double c)
    &#123;
        // 调用父类构造器
        super(color);
        this.setSides(a,b,c);
    &#125;
    public void setSides(double a, double b, double c)
    &#123;
        if(a &gt;= b+c || b &gt;= a+c || c &gt;= a+b)
        &#123;
            System.out.println(&quot;三角形两边之和必须大于第三边&quot;);
            return;
        &#125;
        this.a = a;
        this.b = b;
        this.c = c;
    &#125;
    @Override
    public double calPerimeter() &#123;
        return a + b + c;
    &#125;
    @Override
    public String getType() &#123;
        return &quot;三角形&quot;;
    &#125;
    public static void main(String[] args) &#123;
        Shape s1 = new Triangle(&quot;黑色&quot;,3,4,5);
        System.out.println(s1.getType());
        System.out.println(s1.calPerimeter());
    &#125;
&#125;
</code></pre>
<p>上面的 Triangle 类继承了 Shape 抽象类，并实现了 Shape 类中两个抽象方法，是一个普通类，因此可以创建Triangle 类的实例，可以让一个 Shape 类型的引用变量指向 Triangle 对象。</p>
<p>利用抽象类和抽象方法的优势，可以更好地发挥多态的优势，使得程序更加灵活。</p>
<p>final 和 abstract 永远不能同时使用。static 和 abstract 不能同时修饰某个方法，即没有所谓的类抽象方法。private 和 abstract 不能同时修饰方法。</p>
<h3 id="6-5-2-抽象类的作用"><a href="#6-5-2-抽象类的作用" class="headerlink" title="6.5.2 抽象类的作用"></a>6.5.2 抽象类的作用</h3><p>模板模式：父类的普通方法依赖于一个抽象方法，而抽象方法则推迟到子类中提供实现。</p>
<pre><code class="java">public abstract class SpeedMeter &#123;
    // 转速
    private double turnRate;
    public SpeedMeter()&#123;&#125;
    // 把计算车轮周长的方法定义成抽象方法
    public abstract double calGirth();
    public void setTurnRate(double turnRate)
    &#123;
        this.turnRate = turnRate;
    &#125;
    // 定义计算速度的通用算法
    public double getSpeed()
    &#123;
        // 速度等于 周长 * 转速
        return calGirth() * turnRate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class CarSpeedMeter extends SpeedMeter &#123;
    private double radius;
    public CarSpeedMeter(double radius)
    &#123;
        this.radius = radius;
    &#125;
    public double calGirth()
    &#123;
        return  radius * 2 * Math.PI;
    &#125;
    public static void main(String[] args) &#123;
        CarSpeedMeter csm = new CarSpeedMeter(0.34);
        csm.setTurnRate(15);
        System.out.println(csm.getSpeed());
    &#125;
&#125;
</code></pre>
<p>SpeedMeter 类里提供了速度表的通用算法，但一些具体的实现细节则推迟到其子类 CarSpeedMeter 类中实现。这也是一种典型的模板模式。</p>
<p>模板模式规则：</p>
<ul>
<li>抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给子类实现。</li>
<li>父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而必须依赖于其子类的辅助。</li>
</ul>
<h2 id="6-6-Java-9-改进的接口"><a href="#6-6-Java-9-改进的接口" class="headerlink" title="6.6 Java 9 改进的接口"></a>6.6 Java 9 改进的接口</h2><h3 id="6-6-1-接口的概念"><a href="#6-6-1-接口的概念" class="headerlink" title="6.6.1 接口的概念"></a>6.6.1 接口的概念</h3><p>接口是从多个相似类中抽象出来的规范，接口不提供任何实现。接口体现的是规范和实现分离的设计哲学。</p>
<p>让规范和实现分离正是接口的好处，让软件系统的各组件之间面向接口搞合，是一种松藕合的设计。</p>
<h3 id="6-6-2-Java-9-中接口的定义"><a href="#6-6-2-Java-9-中接口的定义" class="headerlink" title="6.6.2 Java 9 中接口的定义"></a>6.6.2 Java 9 中接口的定义</h3><pre><code class="java">[修饰符] interface 接口名 extends 父接口1，父接口2...
&#123;
    零个到多个常量定义...
    零个到多个抽象方法定义...
    零个到多个内部类、接口、枚举定义...
    零个到多个私有方法（java9）、默认方法（java8）或类方法（java8）定义...
&#125;</code></pre>
<ul>
<li>修饰符可以是 public 或者省略，如果省略则默认采用包权限访问控制符</li>
</ul>
<p>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量(只能是<strong>静态常量</strong>)、方法(只能是抽象实例方法、类方法、默认方法或私有方法)、内部类(包括内部接口、枚举)定义。</p>
<p>私有方法可以使用 static 修饰，也就是说，私有方法既可是类方法，也可是实例方法。</p>
<p>对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static 和 final 两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用 <strong>public static final</strong> 修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。</p>
<p>定义接口里的普通方法时不管是否使用 <strong>public abstract</strong> 修饰符，接口里的普通方法总是使用 public abstract 来修饰。接口里的普通方法不能有方法实现(方法体)；但类方法、默认方法、私有方法都必须有方法实现(方法体〉。</p>
<pre><code class="java">public interface Output &#123;
    // 接口里定义的成员变量只能是常量
    int MAX_CACHE_LINE = 50;
    // 接口里定义的普通方法只能是 public 的抽象方法
    void out();
    void getData(String msg);
    // 接口中定义默认方法，需要使用 default 修饰
    default void print(String... msgs)
    &#123;
        for(String msg : msgs)
        &#123;
            System.out.println(msg);
        &#125;
    &#125;
    default void test()
    &#123;
        System.out.println(&quot;默认的test方法&quot;);
    &#125;
    // 接口中定义类方法，需要使用 static 修饰
    static String staticTest()
    &#123;
        return &quot;接口里的类方法&quot;;
    &#125;
    // 接口中定义私有方法
    private void foo()
    &#123;
        System.out.println(&quot;foo 私有方法&quot;);
    &#125;
    // 接口中定义私有静态方法
    private static void bar()
    &#123;
        System.out.println(&quot;bar 私有静态方法&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class OutputFieldTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(Output.MAX_CACHE_LINE);
        // final 变量不可重新赋值
        // Output.MAX_CACHE_LINE = 20;
        // 使用接口调用类方法
        System.out.println(Output.staticTest());
    &#125;
&#125;
</code></pre>
<h3 id="6-6-3-接口的继承"><a href="#6-6-3-接口的继承" class="headerlink" title="6.6.3 接口的继承"></a>6.6.3 接口的继承</h3><p>接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。</p>
<h3 id="6-6-4-使用接口"><a href="#6-6-4-使用接口" class="headerlink" title="6.6.4 使用接口"></a>6.6.4 使用接口</h3><ul>
<li>定义变量，也可用于进行强制类型转换</li>
<li>调用接口中定义的常量</li>
<li>被其他类实现</li>
</ul>
<p>实现接口和继承父类类似，一样可以获得所实现接口里定义的常量（成员变量）、方法（包括抽象方法和默认方法）</p>
<pre><code class="java">[修饰符] class 类名 extends 父类 implements 接口1，接口2
&#123;
    类体部分
&#125;
</code></pre>
<p>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法(也就是重写这些抽象方法)；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</p>
<pre><code class="java">interface Product
&#123;
    int getProduceTime();
&#125;
public class Printer implements Output, Product&#123;
    private String[] printData = new String[MAX_CACHE_LINE];
    // 用于记录当前需打印的作业数
    private int dataNum = 0;
    @Override
    public void out()
    &#123;
        // 只要还有作业，就继续打印
        while (dataNum &gt; 0)
        &#123;
            System.out.println(&quot;打印机打印：&quot;+printData[0]);
            // 把作业队列整体前移一位，并将剩下的作业数减一
            System.arraycopy(printData,1,printData,0,--dataNum);
        &#125;
    &#125;
    @Override
    public void getData(String msg)
    &#123;
        if (dataNum &gt;= MAX_CACHE_LINE)
        &#123;
            System.out.println(&quot;输出队列已满，添加失败&quot;);
        &#125;
        else
        &#123;
            // 把打印数据添加到队列里，已保存数据的数量加1
            printData[dataNum++] = msg;
        &#125;
    &#125;
    @Override
    public int getProduceTime()
    &#123;
        return 45;
    &#125;
    public static void main(String[] args) &#123;
        // 创建一个Printer对象，当成Output使用
        Output o = new Printer();
        o.getData(&quot;轻量级Java EE企业应用实战&quot;);
        o.getData(&quot;疯狂Java讲义&quot;);
        o.out();
        o.getData(&quot;疯狂Android讲义&quot;);
        o.getData(&quot;疯狂Ajax讲义&quot;);
        o.out();
        // 调用Output接口中定义的默认方法
        o.print(&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;白骨精&quot;);
        o.test();
        // 创建一个Printer对象，当成Product使用
        Product p = new Printer();
        System.out.println(p.getProduceTime());
        // 所有接口类型的引用变量都可以直接赋值给Object类型变量
        Object obj = p;
    &#125;
&#125;</code></pre>
<h3 id="6-6-5-接口和抽象类"><a href="#6-6-5-接口和抽象类" class="headerlink" title="6.6.5 接口和抽象类"></a>6.6.5 接口和抽象类</h3><ul>
<li>接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</li>
<li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li>
<li>接口里不包含构造器；抽象类里可以包含构造器</li>
<li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li>
<li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。</li>
</ul>
<h3 id="6-6-6-面向接口编程"><a href="#6-6-6-面向接口编程" class="headerlink" title="6.6.6 面向接口编程"></a>6.6.6 面向接口编程</h3><h4 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h4><p>有一个场景：假设程序中有个 Computer 类需要组合一个输出设备，现在有两个选择: 直接让 Computer 类组合一个 Printer ， 或者让 Computer 类组合一个 Output ，那么到底采用哪种方式更好呢？</p>
<pre><code class="java">public class Computer &#123;
    private Output out;
    public Computer(Output out)
    &#123;
        this.out = out;
    &#125;
    // 定义一个模拟获取字符串输入的方法
    public void keyIn(String msg)
    &#123;
        out.getData(msg);
    &#125;
    // 定义一个模拟打印的方法
    public void print()
    &#123;
        out.out();
    &#125;
&#125;
</code></pre>
<p>上面的 Computer 类己经完全与 Printer 类分离，只是与 Output 接口稠合。Computer 不再负责创建 Output 对象，系统提供一个 Output 工厂来负责生成 Output 对象。</p>
<pre><code class="java">public class OutputFactory &#123;
    public Output getOutput()
    &#123;
        return new Printer();
    &#125;

    public static void main(String[] args) &#123;
        OutputFactory of = new OutputFactory();
        Computer c = new Computer(of.getOutput());
        c.keyIn(&quot;轻量级Java EE企业应用实战&quot;);
        c.keyIn(&quot;疯狂Java讲义&quot;);
        c.print();
    &#125;
&#125;</code></pre>
<h4 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2. 命令模式"></a>2. 命令模式</h4><p>场景: 某个方法需要完成某一个行为， 但这个行为的具体实现无法确定，必须等到执行该方法时才可以确定。具体一点: 假设有个方法需要遍历某个数组的数组元素， 但无法确定在遍历数组元素时如何处理这些元素， 需要在调用该方法时指定具体的处理行为。</p>
<pre><code class="java">public interface Command &#123;
    // 接口里定义的process方法用于封装&quot;处理行为&quot;
    void process(int[] target);
&#125;</code></pre>
<pre><code class="java">public class ProcessArray &#123;
    public void process(int[] target, Command cmd)
    &#123;
        cmd.process(target);
    &#125;
&#125;</code></pre>
<pre><code class="java">public class CommandTest &#123;
    public static void main(String[] args) &#123;
        ProcessArray pa = new ProcessArray();
        int[] target = &#123;3, -4, 6, 4&#125;;
        // 第一次处理数组，具体行为取决于PrintCommand
        pa.process(target, new PrintCommand());
        System.out.println(&quot;=================&quot;);
        pa.process(target, new AddCommand());
    &#125;
&#125;</code></pre>
<pre><code class="java">public class PrintCommand implements Command&#123;
    public void process(int[] target)
    &#123;
        for(int tmp : target)
        &#123;
            System.out.println(&quot;迭代输出：&quot; + tmp);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="6-7-内部类"><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2><p>内部类作用：</p>
<ul>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内。</li>
<li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员。</li>
<li>匿名内部类适合用于创建那些仅需要使用一次的类。</li>
<li>内部类比外部类可以多使用单个修饰符：private、protected、static</li>
<li>非静态内部类不能拥有静态成员</li>
</ul>
<h3 id="6-7-1-非静态内部类"><a href="#6-7-1-非静态内部类" class="headerlink" title="6.7.1 非静态内部类"></a>6.7.1 非静态内部类</h3><p>外部类的上一级程序单元是包，所以它只有 2 个作用域；同一个包内和任何位置。因此只需2 种访问权限:包访问权限和公开访问权限，正好对应省略访问控制符和public访问控制符</p>
<pre><code class="java">public class Cow &#123;
    private double weight;
    public Cow()&#123;&#125;
    public Cow(double weight)
    &#123;
        this.weight = weight;
    &#125;
    // 定义一个非静态内部类
    private class CowLeg
    &#123;
        // 非静态内部类的两个实例变量
        private double length;
        private String color;
        // 非静态内部类的两个重载的构造器
        public CowLeg()&#123;&#125;
        public CowLeg(double length, String color)
        &#123;
            this.length = length;
            this.color = color;
        &#125;
        // 非静态内部类的实例方法
        public void info()
        &#123;
            System.out.println(&quot;当前牛的颜色是：&quot; + color
                + &quot;,高：&quot; + length);
            // 直接访问外部类private成员变量
            System.out.println(&quot;本牛腿所在的奶牛重：&quot; + weight);
        &#125;
        public double getLength() &#123;
            return length;
        &#125;
        public void setLength(double length) &#123;
            this.length = length;
        &#125;
        public String getColor() &#123;
            return color;
        &#125;
        public void setColor(String color) &#123;
            this.color = color;
        &#125;
    &#125;
    public void test()
    &#123;
        CowLeg cl = new CowLeg(1.12, &quot;黑白相间&quot;);
        cl.info();
    &#125;
    public static void main(String[] args) &#123;
        Cow cow = new Cow(378.9);
        cow.test();
    &#125;
&#125;
</code></pre>
<p>外部类、内部类实例变量和局部变量的访问</p>
<pre><code class="java">public class DiscernVariable &#123;
    private String prop = &quot;外部类的实例变量&quot;;
    private class InClass
    &#123;
        private String prop = &quot;内部类的实例变量&quot;;
        public void info()
        &#123;
            String prop = &quot;局部变量&quot;;
            System.out.println(&quot;外部类实例变量值：&quot; + DiscernVariable.this.prop);
            System.out.println(&quot;内部类实例变量值：&quot; + this.prop);
            System.out.println(&quot;局部变量值：&quot; + prop);
        &#125;
    &#125;
    public void test()
    &#123;
        InClass in = new InClass();
        in.info();
    &#125;
    public static void main(String[] args) &#123;
        new DiscernVariable().test();
    &#125;
&#125;
</code></pre>
<p>根据静态成员不能访问非静态成员的规则， 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例等。</p>
<pre><code class="java">public class StaticTest &#123;
    public class In&#123;&#125;
    public static void main(String[] args) &#123;
        // 静态成员无法访问非静态成员
        // new In();
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class InnerNoStatic &#123;
    private class InnerClass
    &#123;
        // 非静态成员不能使用静态成员
//        static
//        &#123;
//            System.out.println(&quot;========&quot;);
//        &#125;
//        private static int inProp;
//        private static void test()&#123;&#125;
    &#125;
&#125;
</code></pre>
<h3 id="6-7-2-静态内部类"><a href="#6-7-2-静态内部类" class="headerlink" title="6.7.2 静态内部类"></a>6.7.2 静态内部类</h3><p>静态内部类可以包含静态成员， 也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。</p>
<pre><code class="java">public class StaticlnnerClassTest &#123;
    private int prop1 = 5;
    private static int prop2 = 9;
    static class StaticInnerClass
    &#123;
        // 静态内部类里可以包含静态成员
        private static int age;
        // 也可以包含非静态成员
        private double money;
        public void accessOuterProp()
        &#123;
            // 静态内部类不可访问外部类实例变量
            // System.out.println(prop1);
            System.out.println(prop2);
        &#125;
    &#125;
&#125;
</code></pre>
<p>Java 还允许在接口里定义内部类，接口里定义的内部类默认使用public static 修饰，也就是说， 接口内部类只能是静态内部类。</p>
<h3 id="6-7-3-使用内部类"><a href="#6-7-3-使用内部类" class="headerlink" title="6.7.3 使用内部类"></a>6.7.3 使用内部类</h3><h4 id="1-在外部类内部使用内部类"><a href="#1-在外部类内部使用内部类" class="headerlink" title="1. 在外部类内部使用内部类"></a>1. 在外部类内部使用内部类</h4><p>与平常使用普通类没有太大的区别。只需注意不要在外部类的静态成员中使用非静态内部类。</p>
<h4 id="2-在外部类以外使用非静态内部类"><a href="#2-在外部类以外使用非静态内部类" class="headerlink" title="2. 在外部类以外使用非静态内部类"></a>2. 在外部类以外使用非静态内部类</h4><p>定义内部类时不可用 private，定义格式：OuterClass.InnerClass varName</p>
<p>创建内部类对象：OuterInstance.new InnerConstructor()</p>
<pre><code class="java">class Out
&#123;
    class In
    &#123;
        public In(String msg)
        &#123;
            System.out.println(msg);
        &#125;
    &#125;
&#125;
public class Createlnnerlnstance &#123;
    public static void main(String[] args) &#123;
        Out.In in = new Out().new In(&quot;测试信息&quot;);
    &#125;
&#125;</code></pre>
<p>当创建一个子类时，子类构造器总会调用父类的构造器，因此在创建非静态内部类的子类时，必须保证让子类构造器可以调用非静态内部类的构造器，调用非静态内部类的构造器时，必须存在一个外部类对象。</p>
<pre><code class="java">public class SubClass extends Out.In &#123;
    public SubClass(Out out) &#123;
        out.super(&quot;hello&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="3-在外部类以外使用静态内部类"><a href="#3-在外部类以外使用静态内部类" class="headerlink" title="3. 在外部类以外使用静态内部类"></a>3. 在外部类以外使用静态内部类</h4><p>因为静态内部类是外部类类相关的，因此创建静态内部类对象时无须创建外部类对象。在外部类以外的地方创建静态内部类实例的语法如下:</p>
<p><code>new OuterClass.InnerConstructor()</code></p>
<pre><code class="java">class StaticOut
&#123;
    static class StaticIn
    &#123;
        public StaticIn()
        &#123;
            System.out.println(&quot;静态内部类的构造器&quot;);
        &#125;
    &#125;
&#125;
public class CreateStaticInnerInstance &#123;
    public static void main(String[] args) &#123;
        StaticOut.StaticIn in = new StaticOut.StaticIn();
    &#125;
&#125;
</code></pre>
<p>相比之下，使用静态内部类比使用非静态内部类要简单很多，只要把外部类当成静态内部类的包空间即可。因此当程序需要使用内部类时， 应该优先考虑使用静态内部类。</p>
<h3 id="6-7-4-局部内部类"><a href="#6-7-4-局部内部类" class="headerlink" title="6.7.4 局部内部类"></a>6.7.4 局部内部类</h3><p>如果把一个内部类放在方法里定义，则这个内部类就是一个局部内部类， 局部内部类仅在该方法里有效。由于局部内部类不能在外部类的方法以外的地方使用，因此局部内部类也不能使用访问控制符和 static 修饰符修饰。</p>
<pre><code class="java">public class LocalInnerClass &#123;
    public static void main(String[] args) &#123;
        // 定义局部内部类
        class InnerBase
        &#123;
            int a;
        &#125;
        // 定义局部内部类的子类
        class InnerSub extends InnerBase
        &#123;
            int b;
        &#125;
        // 创建局部内部类的对象
        InnerSub is = new InnerSub();
        is.a = 5;
        is.b = 8;
        System.out.println(&quot;a:&quot; + is.a +&quot;,b:&quot; + is.b);
    &#125;
&#125;
</code></pre>
<p>局部内部类走一个非常”鸡肋” 的语法，在实际开发中很少定义局部内部类，这是因为局部内部类的作用域太小了：只能在当前方法中使用。大部分时候，定义一个类之后，当然希望多次复用这个类，但局部内部类无法离开它所在的方法， 因此在实际开发中很少使用局部内部类。</p>
<h3 id="6-7-5-Java-8-改进的匿名内部类"><a href="#6-7-5-Java-8-改进的匿名内部类" class="headerlink" title="6.7.5 Java 8 改进的匿名内部类"></a>6.7.5 Java 8 改进的匿名内部类</h3><p>匿名内部类适合创建那种只需要一次使用的类，例如前面介绍命令模式时所需要的Command 对象。匿名内部类的语法有点奇怪，创建匿名内部类时会立即创建一个该类的实例， 这个类定义立即消失， 匿名内部类不能重复使用。</p>
<p>定义格式：</p>
<pre><code class="java">new 实现接口() | 父类构造器（实参列表）
&#123;
    // 匿名内部类的类体部分
&#125;
</code></pre>
<p>匿名内部类必须继承一个父类，或实现一个接口， 但最多只能继承一个父类，或实现一个接口。</p>
<p>匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。</p>
<p>匿名内部类不能定义构造器。可以定义初始化块</p>
<pre><code class="java">interface Product
&#123;
    public double getPrice();
    public String getName();
&#125;
public class AnonymousTest &#123;
    public void test(Product p)
    &#123;
        System.out.println(&quot;购买一个&quot; + p.getName()
            + &quot;，花掉了&quot; + p.getPrice());
    &#125;

    public static void main(String[] args) &#123;
        AnonymousTest ta = new AnonymousTest();
        // 调用 test 方法时，需要传入一个 Product 参数
        // 此处传入其匿名实现类的实例
        ta.test(new Product() &#123;
            @Override
            public double getPrice() &#123;
                return 567.8;
            &#125;
            @Override
            public String getName() &#123;
                return &quot;AGP显卡&quot;;
            &#125;
        &#125;);
    &#125;
&#125;</code></pre>
<p>如果这个 Product 接口<strong>实现类</strong>需要重复使用， 则应该将该实现类定义成一个独立类；如果这个Product 接口实现类只需一次使用，则可采用上面程序中的方式，定义一个匿名内部类。</p>
<p>如果通过继承父类来创建匿名内部类时， 匿名内部类将拥有和父类相似的构造器，此处的相似指的是拥有相同的形参列表。</p>
<pre><code class="java">abstract class Device
&#123;
    private String name;
    public abstract double getPrice();
    public Device()&#123;&#125;
    public Device(String name)
    &#123;
        this.name = name;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
public class Anonymouslnner &#123;
    public void test(Device d)
    &#123;
        System.out.println(&quot;购买了一个&quot; + d.getName()
            + &quot;，花掉了&quot; + d.getPrice());
    &#125;

    public static void main(String[] args) &#123;
        Anonymouslnner ai = new Anonymouslnner();
        // 调用有参数的构造器创建Device匿名实现类的对象
        ai.test(new Device(&quot;电子示波器&quot;) &#123;
            @Override
            public double getPrice() &#123;
                return 67.8;
            &#125;
        &#125;);
        // 调用无参数的构造器创建 Device 匿名实现类的对象
        Device d = new Device() &#123;
            // 初始化块
            &#123;
                System.out.println(&quot;匿名内部类的初始化块...&quot;);
            &#125;
            @Override
            public double getPrice() &#123;
                return 56.2;
            &#125;
            // 重写父类的实例方法
            public String getName()
            &#123;
                return &quot;键盘&quot;;
            &#125;
        &#125;;
        ai.test(d);
    &#125;
&#125;</code></pre>
<p>被匿名内部类访问的局部变量必须使用 final 修饰。</p>
<pre><code class="java">interface A
&#123;
    void test();
&#125;
public class ATest &#123;
    public static void main(String[] args) &#123;
        int age = 8;
        A a = new A()
        &#123;
            public void test()
            &#123;
                // 在Java 8 以前下面语句将提示错误: age 必须使用final 修饰
                // Java 8开始，自动添加了 final 修饰
                System.out.println(age);
            &#125;
        &#125;;
        a.test();
    &#125;
&#125;</code></pre>
<h2 id="6-8-Java-8-新增的-Lambda-表达式"><a href="#6-8-Java-8-新增的-Lambda-表达式" class="headerlink" title="6.8 Java 8 新增的 Lambda 表达式"></a>6.8 Java 8 新增的 Lambda 表达式</h2><p>Lambda 表达式支持将代码块作为方法参数， Lambda 表达式允许使用更简洁的代码来创建只有一个抽象方法的接口(这种接口被称为函数式接口)的实例。</p>
<h3 id="6-8-1-Lambda-表达式入门"><a href="#6-8-1-Lambda-表达式入门" class="headerlink" title="6.8.1  Lambda 表达式入门"></a>6.8.1  Lambda 表达式入门</h3><p>使用匿名内部类来改写前面的command 表达式的例子</p>
<pre><code class="java">public class CommandTest &#123;
    public static void main(String[] args) &#123;
        ProcessArray pa = new ProcessArray();
        int[] target = &#123;3, -4, 6, 4&#125;;
        // 处理数组，具体处理行为取决于匿名内部类
        pa.process(target, new Command() &#123;
            @Override
            public void process(int[] target) &#123;
                int sum = 0;
                for(int tmp : target)
                &#123;
                    sum += tmp;
                &#125;
                System.out.println(&quot;数组元素之和：&quot;+sum);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>使用 Lambda 改写后</p>
<pre><code class="java">public class CommandTest2 &#123;
    public static void main(String[] args) &#123;
        ProcessArray pa = new ProcessArray();
        int[] array = &#123;3, -4, 6, 4&#125;;
        pa.process(array, (int[] target)-&gt;&#123;
            int sum = 0;
            for(int tmp : target)
            &#123;
                sum += tmp;
            &#125;
            System.out.println(&quot;数组元素之和：&quot; + sum);
        &#125;);
    &#125;
&#125;</code></pre>
<p>Lambda 表达式的几种简化写法</p>
<pre><code class="java">interface Eatable
&#123;
    void taste();
&#125;
interface Flyable
&#123;
    void fly(String weather);
&#125;
interface Addable
&#123;
    int add(int a, int b);
&#125;
public class LambdaQs &#123;
    public void eat(Eatable e)
    &#123;
        //System.out.println(e);
        e.taste();
    &#125;
    public void drive(Flyable f)
    &#123;
        //System.out.println(&quot;我正在驾驶：&quot; + f);
        f.fly(&quot;[碧空如洗的晴日]&quot;);
    &#125;
    public void test(Addable add)
    &#123;
        System.out.println(&quot;5与3的和为:&quot; + add.add(5, 3));
    &#125;
    public static void main(String[] args) &#123;
        LambdaQs lq = new LambdaQs();
        // Lambda 代码块只有一条语句，可以省略花括号
        lq.eat(() -&gt; System.out.println(&quot;苹果的味道不错！&quot;));
        // Lambda 形参只有一个，可以省略圆括号
        lq.drive(weather -&gt; &#123;
            System.out.println(&quot;今天天气是：&quot; + weather);
            System.out.println(&quot;直升机飞行平稳&quot;);
        &#125;);
        lq.test((a, b)-&gt; a+b);
    &#125;
&#125;</code></pre>
<p>eat()方法，调用该方法需要一个Eatable 类型的参数，但实际传入的是Lambda 表达式</p>
<p>这说明Lambda 表达式实际上将会被当成一个”任意类型”的对象，到底需要当成何种类型的对象， 这取决于运行环境的需要</p>
<h3 id="6-8-2-Lambda-表达式与函数式接口"><a href="#6-8-2-Lambda-表达式与函数式接口" class="headerlink" title="6.8.2 Lambda 表达式与函数式接口"></a>6.8.2 Lambda 表达式与函数式接口</h3><p>函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法。</p>
<p>由于Lambda 表达式的结果就是被当成对象， 因此程序中完全可以使用Lambda 表达式进行赋值。</p>
<pre><code class="java">public class LambdaTest &#123;
    // Runnable 接口中只包含一个无参数的方法
    // 下面的Lambda表达式创建了一个Runnable对象
    Runnable r = () -&gt;&#123;
        for(int i=0;i&lt;100;i++)
        &#123;
            System.out.println();
        &#125;
    &#125;;

    // Object 不是函数接口
//    Object obj = () -&gt;&#123;
//        for(int i=0;i&lt;100;i++)
//        &#123;
//            System.out.println();
//        &#125;
//    &#125;;

    // 强转
        Object obj = (Runnable)() -&gt;&#123;
        for(int i=0;i&lt;100;i++)
        &#123;
            System.out.println();
        &#125;
    &#125;;
&#125;</code></pre>
<p>综上所述，不难发现Lambda 表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例-这种语法避免了匿名内部类的烦琐。</p>
<h3 id="6-8-3-方法引用与构造器引用"><a href="#6-8-3-方法引用与构造器引用" class="headerlink" title="6.8.3 方法引用与构造器引用"></a>6.8.3 方法引用与构造器引用</h3><h4 id="1-引用类方法"><a href="#1-引用类方法" class="headerlink" title="1. 引用类方法"></a>1. 引用类方法</h4><pre><code class="java">Converter converter1 = from -&gt; Integer.valueOf(from);
// 方法引用代替 Lambda 表达式
Converter converter2 = Integer::valueOf;</code></pre>
<h4 id="2-引用特定对象的实例方法"><a href="#2-引用特定对象的实例方法" class="headerlink" title="2. 引用特定对象的实例方法"></a>2. 引用特定对象的实例方法</h4><pre><code class="java">Converter converter3 = from -&gt; &quot;fkit.org&quot;.indexOf(from);
Converter converter4 = &quot;fkit.org&quot;::indexOf;
</code></pre>
<h4 id="3-引用某类对象的实例方法"><a href="#3-引用某类对象的实例方法" class="headerlink" title="3. 引用某类对象的实例方法"></a>3. 引用某类对象的实例方法</h4><pre><code class="java">    MyTest mt = (a,b,c)-&gt; a.substring(b,c);
    MyTest mt1 = String :: substring;
</code></pre>
<h4 id="4-引用构造器"><a href="#4-引用构造器" class="headerlink" title="4. 引用构造器"></a>4. 引用构造器</h4><pre><code class="java">YoutTest yt = (String a) -&gt; new JFrame(a);
YoutTest yt1 = JFrame::new;</code></pre>
<h3 id="6-8-4-Lambda-表达式与匿名内部类的联系和区别"><a href="#6-8-4-Lambda-表达式与匿名内部类的联系和区别" class="headerlink" title="6.8.4 Lambda 表达式与匿名内部类的联系和区别"></a>6.8.4 Lambda 表达式与匿名内部类的联系和区别</h3><ul>
<li>Lambda 表达式与匿名内部类都可以直接访问”effectively final” 的局部变量，以及外部类的成员变量(包括实例变量和类变量〉。</li>
<li>Lambda 表达式创建的对象与匿名内部类生成的对象 都可以直接调用从接口中继承的默认方法。</li>
</ul>
<pre><code class="java">@FunctionalInterface
interface Displayable
&#123;
    // 定义一个抽象方法和默认方法
    void display();
    default int add(int a, int b)
    &#123;
        return a + b;
    &#125;
&#125;
public class LambdaAndlnner &#123;
    private int age = 12;
    private static String name = &quot;疯狂软件教育中心&quot;;
    public void test()
    &#123;
        String book = &quot;疯狂Java讲义&quot;;
        Displayable dis = ()-&gt;&#123;
            // 访问“effectively final”的局部变量
            System.out.println(&quot;book 局部变量为：&quot; + book);
            System.out.println(&quot;外部类的age实例变量为：&quot;+age);
            System.out.println(&quot;外部类的name类变量为：&quot; + name);
        &#125;;
        dis.display();
        System.out.println(dis.add(3,5));
    &#125;
    public static void main(String[] args) &#123;
        LambdaAndlnner lambda = new LambdaAndlnner();
        lambda.test();
    &#125;
&#125;</code></pre>
<p>主要区别：</p>
<ul>
<li>匿名内部类可以为任意接口创建实例一一不管接口包含多少个抽象方法，只要匿名内部类实现所有的抽象方法即可;但Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例;但Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法;但Lambda 表达式的代码块不允许调用接口中定义的默认方法。</li>
</ul>
<h3 id="使用-Lambda-表达式调用-Arrays-的类方法"><a href="#使用-Lambda-表达式调用-Arrays-的类方法" class="headerlink" title="使用 Lambda 表达式调用 Arrays 的类方法"></a>使用 Lambda 表达式调用 Arrays 的类方法</h3><pre><code class="java">public class LambdaArrays &#123;
    public static void main(String[] args) &#123;
        String[] arr1 = new String[]&#123;&quot;java&quot;,&quot;fkava&quot;,&quot;fkit&quot;,&quot;ios&quot;,&quot;android&quot;&#125;;
        Arrays.parallelSort(arr1, (o1,o2) -&gt; o1.length() - o2.length());
        System.out.println(Arrays.toString(arr1));
        int[] arr2 = new int[]&#123;3,-4,25,16,30,18&#125;;
        Arrays.parallelPrefix(arr2, (left,right)-&gt; left * right);
        System.out.println(Arrays.toString(arr2));
        long[] arr3 = new long[5];
        Arrays.parallelSetAll(arr3, operand -&gt; operand * 5);
        System.out.println(arr3);
    &#125;
&#125;</code></pre>
<h2 id="6-9-枚举类"><a href="#6-9-枚举类" class="headerlink" title="6.9 枚举类"></a>6.9 枚举类</h2><p>一个类的对象是有限而且固定的，比如季节类，它只有4 个对象:再比如行星类，<br>目前只有8 个对象。这种实例有限而且固定的类，在Java 里被称为枚举类。</p>
<h3 id="6-9-1-手动实现枚举类"><a href="#6-9-1-手动实现枚举类" class="headerlink" title="6.9.1 手动实现枚举类"></a>6.9.1 手动实现枚举类</h3><p>在早期代码中，可能会直接使用简单的静态常量来表示枚举。</p>
<pre><code class="java">public static final int SEASON_SPRING = 1;
public static final int SEASON_SUMMER = 2;
public static final int SEASON_FALL = 3;
public static final int SEASON_WINTER = 4;</code></pre>
<p>这样写有如下问题：</p>
<ol>
<li>类型不安全。例如，完全可以把季节当成int来操作</li>
<li> 没有命名空间。必须要有 SEASON_ 前缀</li>
<li>打印输出意义不明确</li>
</ol>
<h3 id="6-9-2-枚举类入门"><a href="#6-9-2-枚举类入门" class="headerlink" title="6.9.2 枚举类入门"></a>6.9.2 枚举类入门</h3><p>Java 5 新增 enum 关键字，用于定义枚举类。</p>
<p>枚举类和普通类区别：</p>
<ul>
<li>枚举类可以实现一个或多个接口。枚举类默认继承 Enum 类，而不是 Object 类，因此<strong>枚举类不能显示继承其他父类</strong>。</li>
<li>非抽象的枚举类默认使用 final 修饰，因此枚举类不能派生子类。</li>
<li>枚举类构造器只能使用 private 修饰，如省略系统模式使用 private</li>
<li>枚举类所有实例必须在第一行显示列出，系统自动加 public static final</li>
</ul>
<pre><code class="java">public enum SeasonEnum &#123;
    // 在第一行列出 4 个枚举实例
    SPRING,
    SUMMER,
    FALL,
    WINTER;
&#125;</code></pre>
<pre><code class="java">public class EnumTest &#123;
    public void judge(SeasonEnum s)
    &#123;
        // switch 语句里可以是枚举值
        switch (s)
        &#123;
            case SPRING:
                System.out.println(&quot;春天&quot;);
                break;
            case SUMMER:
                System.out.println(&quot;夏天&quot;);
                break;
            case FALL:
                System.out.println(&quot;秋天&quot;);
                break;
            case WINTER:
                System.out.println(&quot;冬天&quot;);
                break;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        // 枚举类默认有 values() 方法，返回所有实例
        for (SeasonEnum s : SeasonEnum.values())
        &#123;
            System.out.println(s);
        &#125;
        // 使用枚举类时，EnumClass.variable
        new EnumTest().judge(SeasonEnum.SUMMER);
    &#125;
&#125;</code></pre>
<h3 id="6-9-3-枚举类的成员变量、方法和构造器"><a href="#6-9-3-枚举类的成员变量、方法和构造器" class="headerlink" title="6.9.3 枚举类的成员变量、方法和构造器"></a>6.9.3 枚举类的成员变量、方法和构造器</h3><p>枚举类通常应该设计成不可变类，也就是说，它的成员变量值不应该允许改变，这样会更安全，而且代码更加简洁。因此建议将枚举类的成员变量都使用private final 修饰。</p>
<p>如此，则应该在构造器里为这些成员变量指定初始值（或者定义成员变量、初始化块，这两种不常见）。</p>
<p>一旦为枚举类显示定义了带参数构造器，列出枚举值时，必须传入该参数。</p>
<pre><code class="java">public enum Gender &#123;
    // 此处枚举值必须调用对应构造器创建
    MALE(&quot;男&quot;),
    FEMALE(&quot;女&quot;);
    private final String name;
    // 枚举类构造器只能用 private 修饰
    private Gender(String name)
    &#123;
        this.name = name;
    &#125;
    public String getName()
    &#123;
        return this.name;
    &#125;
&#125;</code></pre>
<h3 id="6-9-4-实现接口的枚举类"><a href="#6-9-4-实现接口的枚举类" class="headerlink" title="6.9.4 实现接口的枚举类"></a>6.9.4 实现接口的枚举类</h3><pre><code class="java">public interface GenderDesc &#123;
    void info();
&#125;</code></pre>
<pre><code class="java">public enum Gender implements GenderDesc&#123;
    // 此处枚举值必须调用对应构造器创建
    // 花括号部分实际上是一个类体部分
    MALE(&quot;男&quot;)
    &#123;
        @Override
        public void info() &#123;
            System.out.println(&quot;这个枚举值代表男性&quot;);
        &#125;
    &#125;,
    FEMALE(&quot;女&quot;)
    &#123;
        @Override
        public void info() &#123;
            System.out.println(&quot;这个枚举值代表女性&quot;);
        &#125;
    &#125;;
    private final String name;
    // 枚举类构造器只能用 private 修饰
    private Gender(String name)
    &#123;
        this.name = name;
    &#125;
    public String getName()
    &#123;
        return this.name;
    &#125;

    // 这样写，所有枚举实例行为全部一样
//    @Override
//    public void info() &#123;
//        System.out.println(&quot;这是一个用于定义性别的枚举类&quot;);
//    &#125;
&#125;</code></pre>
<p>花括号部分实际上就是一个类体部分，在这种情况下，当创建MALE 、FEMALE 枚举值时， 并不是直接创建Gender 枚举类的实例， 而是相当于创建G ender 的匿名子类的实例。因为粗体字括号部分实际上是匿名内部类的类体部分， 所以这个部分的代码语法与前面介绍的匿名内部类语法大致相似，只是它依然是枚举类的匿名内部子类。</p>
<p>问题：枚举类不是用 final 修饰了吗？怎么还能派生子类呢？</p>
<p>回答：并不是所有的枚举类都使用了 final 修饰。非抽象的枚举类才默认使用 final。对于抽象枚举类（只要它包含抽象方法），系统默认使用 abstract 修饰。</p>
<p>编译上面程序，生产了 Gender.class、Gender$1.class和Gender$2.class 三个文件，正好证明 MALE 和 FEMALE 实际上是 Gender 匿名子类的实例，而不是 Gender 类的实例。</p>
<h3 id="6-9-5-包含抽象方法的枚举类"><a href="#6-9-5-包含抽象方法的枚举类" class="headerlink" title="6.9.5 包含抽象方法的枚举类"></a>6.9.5 包含抽象方法的枚举类</h3><p>定义一个枚举类，表示加减乘除，定义一个方法来完成计算。</p>
<pre><code class="java">public enum Operation &#123;
    PLUS
    &#123;
        public double eval(double x, double y)
        &#123;
            return x + y;
        &#125;
    &#125;,
    MINUS
    &#123;
        public double eval(double x, double y)
        &#123;
            return x - y;
        &#125;
    &#125;,
    TIMES
    &#123;
        public double eval(double x, double y)
        &#123;
            return x * y;
        &#125;
    &#125;,
    DIVIDE
    &#123;
        public double eval(double x, double y)
        &#123;
            return x / y;
        &#125;
    &#125;;
    // 为枚举类定义一个抽象方法
    // 这个抽象方法由不同的枚举值提供不同的实现
    public abstract double eval(double x, double y);

    public static void main(String[] args) &#123;
        System.out.println(Operation.PLUS.eval(3, 4));
        System.out.println(Operation.MINUS.eval(3, 4));
    &#125;
&#125;</code></pre>
<p>编译上面程序会生产 5 个 class 文件。</p>
<p>枚举类里定义抽象方法时，不能用 abstract 定义枚举类（系统会自动添加）。</p>
<p>枚举类需要显示创建枚举值，不是作为父类，所以定义每个枚举值时，必须为抽象方法提供实现，否则出先编译错误。</p>
<h2 id="6-10-对象与垃圾回收"><a href="#6-10-对象与垃圾回收" class="headerlink" title="6.10 对象与垃圾回收"></a>6.10 对象与垃圾回收</h2><p>当程序创建对象、数组等引用类型实体时，系统都会在堆内存中为之分配一块内存区，对象就保存在这块内存区中，当这块内存不再被任何引用变量引用时，这块内存就变成垃圾，等待垃圾回收机制进行回收。</p>
<ul>
<li>垃圾回收机制只负责回收堆内存中对象，不会回收任何物理资源（例如数据库连接、网络 IO 等资源）。</li>
<li>程序无法精确控制垃圾回收的运行，垃圾回收会在何时的时候进行。</li>
<li><strong>回收任何对象之前，总会先调用它的 finalize() 方法</strong>，该方法可能使对象重新复活（让一个引用变量重新引用该对象）,从而导致取消回收。</li>
</ul>
<h3 id="6-10-1-对象在内存中的状态"><a href="#6-10-1-对象在内存中的状态" class="headerlink" title="6.10.1 对象在内存中的状态"></a>6.10.1 对象在内存中的状态</h3><p>当一个对象在堆内存中运行时，根据他被引用变量所引用的状态，可以把它所处的状态分为如下三种：</p>
<ul>
<li><strong>可达状态</strong>：一个对象被创建后，有一个以上的引用变量引用它。程序可通过引用变量来调用该对象的实例变量和方法。</li>
<li><strong>可恢复状态</strong>：程序中某个对象不再有任何引用变量引用他。通过 finalize()方法可能变回可达状态</li>
<li><strong>不可达状态</strong>：对象与所有引用变量的关联都被切断。且调用 finalize() 方法后依然没有使该对象变成可达状态，那么这个对象将永久性失去引用，变成不可达状态</li>
</ul>
<h3 id="6-10-2-强制垃圾回收"><a href="#6-10-2-强制垃圾回收" class="headerlink" title="6.10.2 强制垃圾回收"></a>6.10.2 强制垃圾回收</h3><p>程序只能控制一个对象何时不再被任何引用变量引用，绝不能控制它何时被回收。</p>
<p>程序无法精确控制 Java 垃圾回收的时机，但依然可以强制系统进行垃圾回收，这种强制只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。</p>
<pre><code class="java">public class GcTest &#123;
    public static void main(String[] args)
    &#123;
        for (int i = 0; i&lt;4; i++)
        &#123;
            new GcTest();
            //System.gc();
            Runtime.getRuntime().gc();
        &#125;
    &#125;
    @Override
    public void finalize()
    &#123;
        System.out.println(&quot;系统正在清理 GcTest 对象的资源...&quot;);
    &#125;
&#125;</code></pre>
<p>指定 <code>-verbose:gc</code> 选项，可以看到每次垃圾回收后的提示信息。</p>
<h3 id="6-10-3-finalize-方法"><a href="#6-10-3-finalize-方法" class="headerlink" title="6.10.3 finalize 方法"></a>6.10.3 finalize 方法</h3><p>特点：</p>
<ol>
<li>永远不要主动调用某个对象的 finalize() 方法</li>
<li>该方法何时被调用具有不确定性</li>
<li>JVM 执行可恢复对象的 finalize() 方法时，可能使该对象或者系统中其他对象重新变成可达状态</li>
<li>执行该方法时出现异常，垃圾回收机制不会报告异常，程序继续执行</li>
</ol>
<h3 id="6-10-4-对象的软、弱和虚引用"><a href="#6-10-4-对象的软、弱和虚引用" class="headerlink" title="6.10.4 对象的软、弱和虚引用"></a>6.10.4 对象的软、弱和虚引用</h3><ol>
<li><p>强引用</p>
</li>
<li><p>软引用</p>
<p>通过 SoftReference 类实现。当一个对象只有软引用时，可能被回收，是否回收得<strong>看系统内存</strong></p>
</li>
<li><p>弱引用</p>
<p>通过 WeakReference 类实现。当一个对象只有弱引用时，<strong>执行垃圾回收时，肯定会被回收</strong></p>
</li>
<li><p>虚引用</p>
<p>通过 PhantomReference 类实现。虚引用完全类似于没有引用。主要用于跟踪对象被垃圾回收的状态。必须和引用队列联合使用</p>
</li>
</ol>
<pre><code class="java">public class ReferenceTest &#123;
    public static void main(String[] args) throws Exception&#123;
        String str = new String(&quot;疯狂 Java 讲义&quot;);
        WeakReference wr = new WeakReference(str);
        str = null;
        // 取出弱引用所引用的对象
        System.out.println(wr.get());
        // 强制垃圾回收
        System.gc();
        System.runFinalization();
        System.out.println(wr.get());
    &#125;
&#125;</code></pre>
<pre><code class="java">public class PhantomReferenceTest &#123;
    public static void main(String[] args) &#123;
        String str = new String(&quot;疯狂 Java 讲义&quot;);
        // 创建一个引用队列
        ReferenceQueue rq = new ReferenceQueue();
        // 创建一个虚引用
        PhantomReference pr = new PhantomReference(str, rq);
        str = null;
        // 并不能通过虚引用获取被引用的对象，输出 null
        System.out.println(pr.get());
        System.gc();
        System.runFinalization();
        // 垃圾回收后，虚引用将被放入引用队列中
        System.out.println(rq.poll() == pr);
    &#125;
&#125;</code></pre>
<p>要使用这些特殊的引用类，就不能保留对对象的强引用:如果保留了对对象的强引用，就会浪费这些引用类所提供的任何好处。</p>
<p>由于垃圾回收的不确定性，当程序希望从软、弱引用中取出被引用的对象时，可能这个对象已经被回收了。如果程序需要使用那个被引用的对象，则必须判断，如果为 null，则必须重新创建该对象。</p>
<h2 id="6-11-修饰符的适用范围"><a href="#6-11-修饰符的适用范围" class="headerlink" title="6.11 修饰符的适用范围"></a>6.11 修饰符的适用范围</h2><table>
<thead>
<tr>
<th></th>
<th>外部类/接口</th>
<th>成员</th>
<th>方法</th>
<th>构造器</th>
<th>初始化</th>
<th>成员</th>
<th>局部</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>protect</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>包访问控制符</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>⚪</td>
<td>√</td>
<td>⚪</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>abstract</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>final</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>static</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>strictfp</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>synchronized</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>native</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transient</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>volatile</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>strictfp 关键宇的含义是 FP-strict ，也就是精确浮点的意思。</p>
<p>native 方法通常采用C 语言来实现。如果某个方法需要利用平台相关特性，或者访问系统硬件等，则可以使用native 修饰该方法，再把该方法交给C 去实现。一旦Java 程序中包含了native 方法，这个程序将失去跨平台的功能。</p>
<p>4 个访问控制符是互斥的，最多只能出现其中之一。</p>
<p>abstract 和 final 永远不能用时使用；</p>
<p>abstract 和 static 不能同时修饰方法，可以同时修饰内部类；</p>
<p>abstract 和 private 不能同时修饰方法，可以同时修饰内部类</p>
<p>private 和 final 同时修饰方法语法是合法的，但是没有意义。</p>
<h2 id="6-12-Java-9-的多版本-JAR-包"><a href="#6-12-Java-9-的多版本-JAR-包" class="headerlink" title="6.12 Java 9 的多版本 JAR 包"></a>6.12 Java 9 的多版本 JAR 包</h2><p>JAR 文件与 ZIP  文件的区别就是在 JAR 文件中默认包含了一个名为META-INF/MANIFEST.MF 的清单文件，这个清单文件是在生成 JAR 文件时由系统自动创建的。</p>
<h3 id="6-12-1-jar-命令详解"><a href="#6-12-1-jar-命令详解" class="headerlink" title="6.12.1 jar 命令详解"></a>6.12.1 jar 命令详解</h3><ol>
<li>创建 jar 文件 jar cvf test.jar -C dist/ .</li>
</ol>
<p>当前路径下的 dist 路径下的全部内容生成一个 test.jar 文件。</p>
<ol start="2">
<li>不适用清单文件 jar cvfM test.jar -C dist/ .</li>
<li>自定义清单文件内容 jar cvfm test.jar a.txt -C dist/ .</li>
<li>查看 jar 包内容 jar tf test.jar &gt; a.txt</li>
<li>查看 jar 包详细内容 jar tvf test.jar</li>
<li>解压缩 jar xvf test.jar</li>
<li>更新 jar 文件 jar uvf test.jar Hello.class</li>
</ol>
<p>更新 test.jar 中的 Hello.class 文件</p>
<ol start="8">
<li>创建多版本 jar 包 jar cvf test.jar -C dist7/ . –release 9 -C dist/ .</li>
</ol>
<p>针对 Java7 编译的所有 class 文件放在 dist7 目录下，9则方法 dist </p>
<h3 id="6-12-2-创建可执行的-jar-包"><a href="#6-12-2-创建可执行的-jar-包" class="headerlink" title="6.12.2 创建可执行的 jar 包"></a>6.12.2 创建可执行的 jar 包</h3><p>对于一个可执行的JAR 包，用户只需要双击它就可以运行程序了。</p>
<p>创建可执行的JAR 包的关键在于:让Javaw 命令知道JAR 包中哪个类是主类。</p>
<p>java cvfe test.jar test.Test test</p>
<p>上面命令把 test 目录下所有文件都压缩到 test.jar 包中，并指定使用 test.Test 类作为程序入口。</p>
<p>java -jar test.jar</p>
<p>javaw test.jar</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 lixianfu1@outlook.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '8b4bf9e725fa9e5652a9',
            clientSecret: 'bfc996b7a7d84a81599a9af4ca153637bd05b9f3',
            repo: 'gitalk',
            owner: 'Monkey-kong',
            admin: ['Monkey-kong'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry"><span class="miit">
                <img src="/img/gov.png" title="中华人民共和国工业和信息化部">
                <a href="http://beian.miit.gov.cn/">粤ICP备2020135752号</a>
        </span>
    
    ©2019-2020 悟空
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 562px;
    }
    .nav.fullscreen {
        margin-left: -562px;
    }
    .nav-left {
        width: 140px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>






</html>
